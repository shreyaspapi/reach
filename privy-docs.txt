# Authorization signatures
Source: https://docs.privy.io/api-reference/authorization-signatures

Securing Privy API requests with authorization signatures

## Overview

[Owners](/controls/overview) provide an additional layer of security for actions taken by your app’s wallets. This primitive helps ensure that only actions explicitly authorized by your server are executed on user wallets.

When you specify an owner of a resource, all requests to update that resource must be signed with the associated key (user, authorization key, or key quorum). Requests to take actions with a wallet must also be signed by the wallet’s owner. This security measure verifies that each request comes from your authorized backend systems and helps prevent unauthorized operations.

<Tip>
  Authorization signatures are an important security measure and we strongly recommend registering
  authorization keys for all production resources.
</Tip>

<Info>
  Learn more about [owners](/controls/authorization-keys/owners/overview) and [authorization
  signatures](/controls/authorization-keys/keys/overview).
</Info>

### When are they necessary?

Authorization signatures are necessary in the following cases.

#### Updating wallets and policies

All critical resources, such as wallets and policies, have an `owner_id` field, which indicates the authorization key or quorum whose signatures are required in order to modify the given resource.

This means, if the `owner_id` is set, authorization signatures are required for all `PATCH` and `DELETE` requests to the resource. This includes:

* `PATCH /v1/wallets/[wallet_id]`
* `DELETE /v1/wallets/[wallet_id]`
* `PATCH /v1/policies/[policy_id]`
* `DELETE /v1/policies/[policy_id]`

Signatures from the wallet's owner are required to take actions on a wallet by default. If an `owner_id` is set, authorization signatures are required for:

* `POST /v1/wallets/<wallet_id>/rpc`

#### Executing actions with wallets

Executing actions with wallets requires authorization signature(s) from the wallet's owner, if the wallet has an owner. This includes:

* `POST /v1/wallets/[wallet_id]/rpc`

#### Updating key quorums

Though key quorums do not have owners, updating or deleting a key quorum requires a satisfying set of signatures from the *existing* key quorum that meet the authorization threshold. This includes:

* `PATCH /v1/key_quorums/[key_quorum_id]`
* `DELETE /v1/key_quorum/[key_quorum_id]`

Signatures from the wallet's owner are required to take actions on a wallet by default. If an `owner_id` is set, authorization signatures are required for:

## Usage

At a high-level, the flow of using authorization signatures is as follows:

<Steps>
  <Step title="Get your private keys">
    Get the private keys that you will use to sign your request. This might be retrieved from the
    private keys you saved locally (app owners and key quorum owners) or requested from the Privy
    API using a user JWT (user owners).
  </Step>

  <Step title="Construct your request">
    Construct the request that you intend to make to Privy. This might be updating or deleting
    wallets, updating or deleting policies, updating or deleting key quorums, or taking actions with
    wallets.
  </Step>

  <Step title="Sign the request">Format and sign the request with your private key(s).</Step>

  <Step title="Include the signature as a request header">
    Finally, when making your request to Privy, include the authorization signature(s) as a string
    in the `privy-authorization-signature` header.
  </Step>
</Steps>

### Getting authorization keys

To start, get the private keys for the authorization key(s) that owner your resource.

If the owner of your resource is an authorization key, get the private key(s) that you saved locally when creating your owner in the Privy API or Dashboard. Privy does not save these private key(s) and cannot help you recover them.

If the owner of your resource is a user, request a time-bound user key to take actions with or update the resource. Follow the guide below to learn how to request user keys given a user's access token.

<CardGroup cols={1}>
  <Card title="Using user owners" href="/controls/authorization-keys/keys/create/user/overview">
    Request keys for user owners.
  </Card>
</CardGroup>

<CardGroup cols={1}>
  <Card title="Get user keys" href="/controls/authorization-keys/keys/create/user/overview">
    Request a user key with a user's access token to sign requests to the Privy API.
  </Card>
</CardGroup>

### Signing requests

Next, sign the request with your authorization key(s). Make sure to correctly format your request before signing the request.

If the owner of your resource is a key quorum, make sure to sign the request with enough authorization keys to meet the authorization threshold.

Follow this guide for instructions on how to correctly sign your request:

<CardGroup cols={1}>
  <Card title="Sign requests" href="/controls/authorization-keys/using-owners/sign">
    Learn how to sign requests to the Privy API.
  </Card>
</CardGroup>

### Setting required headers

Once you have collected your authorization signature(s), set the following header on your request to the Privy API.

<ParamField header="privy-authorization-signature" type="string">
  The authorization signature. If multiple signatures are required, include them as a
  comma-delimited string.
</ParamField>

<Tip>
  If you are using Privy's SDKs, the appropriate authorization signature header is added
  automatically to your requests.
</Tip>


# Add items to a condition set
Source: https://docs.privy.io/api-reference/condition-sets/condition-set-items/create

post /v1/condition_sets/{condition_set_id}/condition_set_items
Add new items to a condition set. Can add up to 100 items at once.



# Delete an item from a condition set
Source: https://docs.privy.io/api-reference/condition-sets/condition-set-items/delete

delete /v1/condition_sets/{condition_set_id}/condition_set_items/{condition_set_item_id}
Delete an item from a condition set by condition set ID and item ID.



# Get an item from a condition set
Source: https://docs.privy.io/api-reference/condition-sets/condition-set-items/get

get /v1/condition_sets/{condition_set_id}/condition_set_items/{condition_set_item_id}
Get an item from a condition set by condition set ID and item ID.



# Get all items from a condition set
Source: https://docs.privy.io/api-reference/condition-sets/condition-set-items/get-all

get /v1/condition_sets/{condition_set_id}/condition_set_items
Get all items in a condition set with pagination support.



# Update items in a condition set
Source: https://docs.privy.io/api-reference/condition-sets/condition-set-items/update

put /v1/condition_sets/{condition_set_id}/condition_set_items
Replace all items in a condition set by condition set ID. Can add up to 100 items at once.



# Create condition set
Source: https://docs.privy.io/api-reference/condition-sets/create

post /v1/condition_sets
Create a new condition set. You must provide either "owner" or "owner_id" (but not both) to specify ownership.



# Delete condition set
Source: https://docs.privy.io/api-reference/condition-sets/delete

delete /v1/condition_sets/{condition_set_id}
Delete a condition set by condition set ID.



# Get condition set
Source: https://docs.privy.io/api-reference/condition-sets/get

get /v1/condition_sets/{condition_set_id}
Get a condition set by condition set ID.



# Update condition set
Source: https://docs.privy.io/api-reference/condition-sets/update

patch /v1/condition_sets/{condition_set_id}
Update a condition set by condition set ID.



# Create fiat account
Source: https://docs.privy.io/api-reference/fiat/accounts/create

post /v1/users/{user_id}/fiat/accounts
Sets up external bank account object for the user through the configured default provider. Requires the user to already be KYC'ed.



# Get fiat accounts
Source: https://docs.privy.io/api-reference/fiat/accounts/get

get /v1/users/{user_id}/fiat/accounts
Returns the IDs of all external fiat accounts (used for offramping) for the user



# Configure app for native onramp
Source: https://docs.privy.io/api-reference/fiat/configure-app

post /v1/apps/{app_id}/fiat
Updates the app configuration for the specified onramp provider. This is used to set up the app for fiat onramping and offramping.



# Start KYC process
Source: https://docs.privy.io/api-reference/fiat/kyc/create

post /v1/users/{user_id}/fiat/kyc
Initiates KYC verification process for a user with the configured provider



# Get KYC process status
Source: https://docs.privy.io/api-reference/fiat/kyc/get

get /v1/users/{user_id}/fiat/kyc
Get the current KYC verification status for a user from the configured provider



# Update KYC details
Source: https://docs.privy.io/api-reference/fiat/kyc/update

patch /v1/users/{user_id}/fiat/kyc
Update the KYC verification status for a user from the configured provider



# Initiate offramp
Source: https://docs.privy.io/api-reference/fiat/offramp/create

post /v1/users/{user_id}/fiat/offramp
Triggers the offramp flow and gets the on-chain address to send funds to



# Initiate onramp
Source: https://docs.privy.io/api-reference/fiat/onramp/create

post /v1/users/{user_id}/fiat/onramp
Triggers an onramp to the specified recipient blockchain address, returns the bank deposit instructions



# Get transactions
Source: https://docs.privy.io/api-reference/fiat/status

post /v1/users/{user_id}/fiat/status
Returns a list of fiat transactions and their statuses



# Create a terms of service agreement
Source: https://docs.privy.io/api-reference/fiat/tos/create

post /v1/users/{user_id}/fiat/tos
Creates a terms of service agreement for a user



# Idempotency keys
Source: https://docs.privy.io/api-reference/idempotency-keys

Making Privy API requests idempotent with idempotency keys

Idempotency keys ensure your API requests to Privy aren't executed multiple times, preventing duplicated transactions. When provided, Privy guarantees that a request with the same idempotency key will only be processed once within a 24-hour window.

## Required headers

When using idempotency keys with the REST API, include the following header with your request:

<ParamField header="privy-idempotency-key" type="string" required>
  A unique identifier for the request, up to 256 characters. We recommend using a V4 UUID.
</ParamField>

## When are they necessary?

Idempotency keys are recommended for:

* Any `POST` request that triggers state changes or transactions
* Scenarios where network issues might cause request retries
* Critical operations where duplicate execution would be problematic

While optional, idempotency keys are strongly recommended for all non-idempotent operations in production environments to prevent double-spends and duplicate transactions.

## How idempotency works

<Steps>
  <Step title="First Request">
    When Privy receives a request with a new idempotency key, it processes the request normally and
    stores both the request details and response for 24 hours.
  </Step>

  <Step title="Subsequent Requests">
    If the same idempotency key is used again within 24 hours:

    * If the request body matches the original request: Privy returns the stored response without re-executing the operation
    * If the request body differs: Privy returns a 400 error indicating invalid use of the key
  </Step>

  <Step title="Key Expiration">
    After 24 hours, idempotency keys expire. Using an expired key will result in normal request
    processing.
  </Step>
</Steps>

<Warning>
  Changing any part of the request body while reusing an idempotency key will result in an error.
  Each unique operation should have its own idempotency key.
</Warning>

## Generating idempotency keys

Generate a unique, random string for each distinct operation. V4 UUIDs are recommended for their uniqueness properties.

<CodeGroup>
  ```ts JavaScript/TypeScript theme={"system"}
  import {v4 as uuidv4} from 'uuid';

  // Generate a unique idempotency key
  const idempotencyKey = uuidv4();
  ```

  ```python Python theme={"system"}
  import uuid

  # Generate a unique idempotency key
  idempotency_key = str(uuid.uuid4())
  ```
</CodeGroup>

## Examples

<CodeGroup>
  ```ts @privy-io/node theme={"system"}
  import {PrivyClient} from '@privy-io/node';
  import {v4 as uuidv4} from 'uuid';

  const client = new PrivyClient({appId: '$PRIVY_APP_ID', appSecret: '$PRIVY_APP_SECRET'});

  // Generate a unique idempotency key
  const idempotencyKey = uuidv4();

  const res = await client
    .wallets()
    .ethereum()
    .sendTransaction('$WALLET_ID', {
      idempotency_key: idempotencyKey, // Pass the idempotency key to prevent duplicate transactions
      caip2: 'eip155:8453',
      params: {
        transaction: {
          to: '0xE3070d3e4309afA3bC9a6b057685743CF42da77C',
          value: '0x2386F26FC10000',
          chain_id: 8453
        }
      }
    });
  ```

  ```ts @privy-io/server-auth theme={"system"}
  import {PrivyClient} from '@privy-io/server-auth';
  import {v4 as uuidv4} from 'uuid';

  const client = new PrivyClient('$PRIVY_APP_ID', '$PRIVY_APP_SECRET');

  // Generate a unique idempotency key
  const idempotencyKey = uuidv4();

  const res = await client.walletApi.ethereum.sendTransaction({
    walletId: '$WALLET_ID',
    idempotencyKey, // Pass the idempotency key to prevent duplicate transactions
    caip2: 'eip155:8453',
    transaction: {
      to: '0xE3070d3e4309afA3bC9a6b057685743CF42da77C',
      value: '0x2386F26FC10000',
      chainId: 8453
    }
  });
  ```

  ```ts TypeScript/JavaScript theme={"system"}
  import axios from 'axios';
  import {v4 as uuidv4} from 'uuid';

  // Generate a unique idempotency key
  const idempotencyKey = uuidv4();

  const response = await axios.post(
    'https://api.privy.io/api/v1/wallets/y5ofctvacjiv53u4hmnqi0e5/rpc',
    {
      caip2: 'eip155:8453',
      method: 'eth_sendTransaction',
      params: {
        transaction: {
          to: '0xE3070d3e4309afA3bC9a6b057685743CF42da77C',
          value: '0x2386F26FC10000',
          chainId: 8453
        }
      }
    },
    {
      headers: {
        'privy-app-id': 'insert-your-app-id',
        'privy-idempotency-key': idempotencyKey,
        Authorization: 'Bearer insert-your-api-key'
      }
    }
  );
  ```
</CodeGroup>

<Tip>
  For critical operations, store the idempotency key alongside your transaction records. This allows
  you to safely retry failed operations with the same key.
</Tip>


# Introduction
Source: https://docs.privy.io/api-reference/introduction

Getting started with the Privy REST API

Privy offers low-level APIs you can use to interact with wallets and user objects directly. This means APIs to interface with the following resources:

* **Users**: create user objects with appropriate linked accounts and pregenerate wallets for them.
* **Wallets**: create, update and use wallets across blockchains.
* **Authorization keys**: create and manage authorization keys to manage wallets.
* **Policies**: create and manage policies tied to wallets.

Read more about direct API access below.

## Base URL

All requests to the Privy API must be made to the following base URL:

```
https://api.privy.io
```

HTTPS is required for all requests. HTTP requests will be rejected.

## Authentication

All API endpoints require authentication using Basic Auth and a Privy App ID header. Include the following headers with every request:

<ParamField header="Authorization" type="string" example="Basic ouihv9248hosd9020oihj0v10d=" required>
  Basic Auth header with your app ID as the username and your app secret as the password.
</ParamField>

<ParamField header="privy-app-id" type="string" example="cla06f34x0001mh08l8nsr496" required>
  Your Privy app ID as a string.
</ParamField>

Requests missing either of these headers will be rejected by Privy's middleware.

<Info>
  Your Privy app ID and app secret can be found in the [**App settings** >
  **Basics**](https://dashboard.privy.io/apps?page=settings\&tab=basics) tab for your app.
</Info>

## Examples

<Tabs>
  <Tab title="JavaScript">
    ```javascript  theme={"system"}
    fetch('https://api.privy.io/v1/wallets', {
      method: 'GET',
      headers: {
        'Authorization': `Basic ${btoa('insert-your-app-id' + ':' + 'insert-your-app-secret')}`,
        'privy-app-id': 'insert-your-app-id',
        'Content-Type': 'application/json'
      }
    })
    .then(response => response.json())
    .then(data => console.log(data));
    ```
  </Tab>

  <Tab title="cURL">
    ```bash  theme={"system"}
    curl -X GET "https://api.privy.io/v1/wallets" \
      --user "insert-your-app-id:insert-your-app-secret" \
      -H "privy-app-id: insert-your-app-id" \
      -H "Content-Type: application/json"
    ```
  </Tab>

  <Tab title="Python">
    ```python  theme={"system"}
    import requests
    import base64

    app_id = "insert-your-app-id"
    app_secret = "insert-your-app-secret"

    auth_string = f"{app_id}:{app_secret}"
    encoded_auth = base64.b64encode(auth_string.encode()).decode()

    headers = {
        "Authorization": f"Basic {encoded_auth}",
        "privy-app-id": app_id,
        "Content-Type": "application/json"
    }

    response = requests.get("https://api.privy.io/v1/wallets", headers=headers)
    data = response.json()
    ```
  </Tab>
</Tabs>


# Create key quorum
Source: https://docs.privy.io/api-reference/key-quorums/create

post /v1/key_quorums
Create a new key quorum.



# Delete key quorum
Source: https://docs.privy.io/api-reference/key-quorums/delete

delete /v1/key_quorums/{key_quorum_id}
Delete a key quorum by key quorum ID.



# Get key quorum
Source: https://docs.privy.io/api-reference/key-quorums/get

get /v1/key_quorums/{key_quorum_id}
Get a key quorum by ID.



# Update key quorum
Source: https://docs.privy.io/api-reference/key-quorums/update

patch /v1/key_quorums/{key_quorum_id}
Update a key quorum by key quorum ID.



# Create policy
Source: https://docs.privy.io/api-reference/policies/create

post /v1/policies
Create a new policy.



# Delete policy
Source: https://docs.privy.io/api-reference/policies/delete

delete /v1/policies/{policy_id}
Delete a policy by policy ID.



# Get policy
Source: https://docs.privy.io/api-reference/policies/get

get /v1/policies/{policy_id}
Get a policy by policy ID.



# Add a rule to a policy
Source: https://docs.privy.io/api-reference/policies/rules/create

post /v1/policies/{policy_id}/rules
Create a new rule for a policy.



# Delete a rule from a policy
Source: https://docs.privy.io/api-reference/policies/rules/delete

delete /v1/policies/{policy_id}/rules/{rule_id}
Delete a rule by policy ID and rule ID.



# Get a rule from a policy
Source: https://docs.privy.io/api-reference/policies/rules/get

get /v1/policies/{policy_id}/rules/{rule_id}
Get a rule by policy ID and rule ID.



# Update a rule in a policy
Source: https://docs.privy.io/api-reference/policies/rules/update

patch /v1/policies/{policy_id}/rules/{rule_id}
Update a rule by policy ID and rule ID.



# Update policy
Source: https://docs.privy.io/api-reference/policies/update

patch /v1/policies/{policy_id}
Update a policy by policy ID.



# Get transaction
Source: https://docs.privy.io/api-reference/transactions/get

get /v1/transactions/{transaction_id}
Get a transaction by transaction ID.

<Note>
  In August 2025 we migrated transactions to a new data store. As part of this migration, we changed
  the format of transaction IDs from CUID2 to UUIDv4. You may continue using the CUID2 for your
  existing transactions, but we encourage migration to the new UUID, as it will avoid a very slight
  latency increase due to an extra lookup for mapping from the legacy ID to the new ID.
</Note>


# Create user
Source: https://docs.privy.io/api-reference/users/create

post /v1/users
Create a new user with linked accounts. Optionally pre-generate embedded wallets for the user.



# Add custom metadata
Source: https://docs.privy.io/api-reference/users/custom-metadata/create

post /v1/users/{user_id}/custom_metadata
Adds custom metadata to a user by user ID.



# Delete user
Source: https://docs.privy.io/api-reference/users/delete

delete /v1/users/{user_id}
Delete a user by user ID.



# Get user by ID
Source: https://docs.privy.io/api-reference/users/get

get /v1/users/{user_id}
Get a user by user ID.

<Warning>
  This endpoint is heavily rate limited. If you're looking to get information about an authenticated
  user, consider using [identity tokens](/user-management/users/identity-tokens) as a more efficient
  way to access user data.
</Warning>


# Get users
Source: https://docs.privy.io/api-reference/users/get-all

get /v1/users
Get all users in your app.



# Get user by custom auth ID
Source: https://docs.privy.io/api-reference/users/get-by-custom-auth

post /v1/users/custom_auth/id
Looks up a user by their custom auth ID.



# Get user by Discord username
Source: https://docs.privy.io/api-reference/users/get-by-discord-username

post /v1/users/discord/username
Looks up a user by their Discord username.



# Get user by email address
Source: https://docs.privy.io/api-reference/users/get-by-email-address

post /v1/users/email/address
Looks up a user by their email address.



# Get user by Farcaster ID
Source: https://docs.privy.io/api-reference/users/get-by-farcaster-id

post /v1/users/farcaster/fid
Looks up a user by their Farcaster ID.



# Get user by GitHub username
Source: https://docs.privy.io/api-reference/users/get-by-github-username

post /v1/users/github/username
Looks up a user by their Github username.



# Get user by Instagram username
Source: https://docs.privy.io/api-reference/users/get-by-instagram-username

post /v1/users/instagram/username
Looks up a user by their Instagram username.



# Get user by phone number
Source: https://docs.privy.io/api-reference/users/get-by-phone-number

post /v1/users/phone/number
Looks up a user by their phone number.



# Get user by smart wallet address
Source: https://docs.privy.io/api-reference/users/get-by-smart-wallet-address

post /v1/users/smart_wallet/address
Looks up a user by their smart wallet address.



# Get user by Spotify subject
Source: https://docs.privy.io/api-reference/users/get-by-spotify-subject

post /v1/users/spotify/subject
Looks up a user by their Spotify subject (user ID).



# Get user by Telegram user ID
Source: https://docs.privy.io/api-reference/users/get-by-telegram-user-id

post /v1/users/telegram/telegram_user_id
Looks up a user by their Telegram user ID.



# Get user by Telegram username
Source: https://docs.privy.io/api-reference/users/get-by-telegram-username

post /v1/users/telegram/username
Looks up a user by their Telegram username.



# Get user by Twitch username
Source: https://docs.privy.io/api-reference/users/get-by-twitch-username

post /v1/users/twitch/username
Looks up a user by their Twitch username.



# Get user by Twitter subject
Source: https://docs.privy.io/api-reference/users/get-by-twitter-subject

post /v1/users/twitter/subject
Looks up a user by their Twitter subject.



# Get user by Twitter username
Source: https://docs.privy.io/api-reference/users/get-by-twitter-username

post /v1/users/twitter/username
Looks up a user by their Twitter username.



# Get user by wallet address
Source: https://docs.privy.io/api-reference/users/get-by-wallet-address

post /v1/users/wallet/address
Looks up a user by their wallet address.



# Pregenerate wallets
Source: https://docs.privy.io/api-reference/users/pregenerate-wallets

post /v1/users/{user_id}/wallets
Creates an embedded wallet for an existing user.



# Search users
Source: https://docs.privy.io/api-reference/users/search

post /v1/users/search
Search users by search term, emails, phone numbers, or wallet addresses.



# Authenticate
Source: https://docs.privy.io/api-reference/wallets/authenticate

post /v1/wallets/authenticate
Obtain a session key to enable wallet access.

<Info>
  Directly managing user authorization keys via the API is an advanced setting. We recommend using
  Privy's SDKs, which internally manage user authorization keys if applicable.
</Info>

This endpoint is used to create an ephemeral signing key for signing requests to [take actions](/api-reference/wallets/ethereum/eth-send-transaction) with a user's wallet.

The returned key is encrypted using Hybrid Public Key Encryption (HPKE), with the following configuration:

<ul>
  <li>KEM (Key Encapsulation Mechanism): DHKEM\_P256\_HKDF\_SHA256</li>
  <li>KDF (Key Derivation Function): HKDF\_SHA256</li>
  <li>AEAD (Authenticated Encryption with Associated Data): CHACHA20\_POLY1305</li>
  <li>Mode: BASE</li>
</ul>

The response `authorization_key` is ciphertext and must be decrypted.


# Create wallet
Source: https://docs.privy.io/api-reference/wallets/create

post /v1/wallets
Create a new wallet.



# eth_sendTransaction
Source: https://docs.privy.io/api-reference/wallets/ethereum/eth-send-transaction

post /v1/wallets/{wallet_id}/rpc
Sign and send a transaction using the eth_sendTransaction method.

<RequestExample>
  ```sh cURL theme={"system"}
  curl --request POST \
    --url https://api.privy.io/v1/wallets/{wallet_id}/rpc \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "method": "eth_sendTransaction",
    "caip2": "eip155:11155111",
    "chain_type": "ethereum",
    "sponsor": true,
    "params": {
      "transaction": {
        "to": "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045",
        "value": "0x2386F26FC10000",
      }
    }
  }'
  ```
</RequestExample>

<ResponseExample>
  ```json 200 theme={"system"}
  {
    "method": "eth_sendTransaction",
    "data": {
      "hash": "0xfc3a736ab2e34e13be2b0b11b39dbc0232a2e755a11aa5a9219890d3b2c6c7d8",
      "caip2": "eip155:11155111",
      "transaction_id": "y90vpg3bnkjxhw541c2zc6a9"
    }
  }
  ```
</ResponseExample>

<Warning>
  A successful response indicates that the transaction has been broadcasted to the network.
  Transactions may get broadcasted but still fail to be confirmed by the network. To handle these
  scenarios, see our guide on [speeding up transactions](/recipes/speeding-up-transactions).
</Warning>

### Headers

<ParamField header="privy-app-id" type="string" required>
  ID of your Privy app.
</ParamField>

<ParamField header="privy-authorization-signature" type="string">
  Request authorization signature. If multiple signatures are required, they should be comma
  separated.
</ParamField>

### Path Parameters

<ParamField path="wallet_id" type="string" required>
  ID of the wallet to get.
</ParamField>

### Body

<ParamField body="method" type="string" defaultValue="eth_sendTransaction" required>
  Available options: `eth_sendTransaction`
</ParamField>

<ParamField body="caip2" type="string" initialValue="eip155:11155111" required />

<ParamField body="params" type="object" required>
  <Expandable title="child attributes" defaultOpen="true">
    <ParamField body="transaction" type="object" required>
      <Expandable title="child attributes" defaultOpen="true">
        <ParamField body="from" type="string" />

        <ParamField body="to" type="string" />

        <ParamField body="chain_id" type="string" />

        <ParamField body="nonce" type="string" />

        <ParamField body="data" type="string" />

        <ParamField body="value" type="string">
          The value to send in the transaction in wei as a hexadecimal string.
        </ParamField>

        <ParamField body="type" type="number">
          Available options: `0`, `1`, `2`
        </ParamField>

        <ParamField body="gas_limit" type="string" />

        <ParamField body="gas_price" type="string" />
      </Expandable>
    </ParamField>
  </Expandable>
</ParamField>

<ParamField body="sponsor" type="boolean">
  Optional parameter to enable gas sponsorship for this transaction. [Learn
  more.](/wallets/gas-and-asset-management/gas/overview)
</ParamField>

<ParamField body="address" type="string" />

<ParamField body="chain_type" type="string">
  Available options: `ethereum`
</ParamField>

### Returns

<ResponseField name="method" type="enum<string>" required>
  Available options: `eth_sendTransaction`
</ResponseField>

<ResponseField name="data" type="object" required>
  <Expandable title="child attributes" defaultOpen="true">
    <ResponseField name="hash" type="string" required />

    <ResponseField name="caip2" type="string" required />

    <ResponseField name="transaction_id" type="string" />
  </Expandable>
</ResponseField>


# eth_sign7702Authorization
Source: https://docs.privy.io/api-reference/wallets/ethereum/eth-sign-7702-authorization

post /v1/wallets/{wallet_id}/rpc
Signs an EIP-7702 authorization struct using the wallet's private key.

<RequestExample>
  ```sh cURL theme={"system"}
  curl --request POST \
    --url https://api.privy.io/v1/wallets/{wallet_id}/rpc \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
      "method": "eth_sign7702Authorization",
      "params": {
        "contract": "0x1234567890abcdef1234567890abcdef12345678",
        "chain_id": 1,
        "nonce": 0
      }
  }'
  ```
</RequestExample>

<ResponseExample>
  ```json 200 theme={"system"}
  {
    "method": "eth_sign7702Authorization",
    "data": {
      "authorization": {
        "contract": "0x1234567890abcdef1234567890abcdef12345678",
        "chain_id": 1,
        "nonce": 0,
        "r": "0x0db9c7bd881045cbba28c347de6cc32a653e15d7f6f2f1cec21d645f402a6419",
        "s": "0x6e877eb45d3041f8d2ab1a76f57f408b63894cfc6f339d8f584bd26efceae308",
        "y_parity": 1
      }
    }
  }
  ```
</ResponseExample>

### Headers

<ParamField header="privy-app-id" type="string" required>
  ID of your Privy app.
</ParamField>

<ParamField header="privy-authorization-signature" type="string">
  Request authorization signature. If multiple signatures are required, they should be comma
  separated.
</ParamField>

### Path Parameters

<ParamField path="wallet_id" type="string" required>
  ID of the wallet to get.
</ParamField>

### Body

<ParamField body="method" type="string" defaultValue="eth_sign7702Authorization" required>
  The RPC method to execute. Must be `eth_sign7702Authorization`.
</ParamField>

<ParamField body="params" type="object" required>
  The parameters for signing the EIP-7702 authorization.

  <Expandable title="child properties" defaultOpen="true">
    <ParamField body="contract" type="string" required>
      The address of the smart contract that the EOA will delegate to. Must be a valid Ethereum
      address in hex format.
    </ParamField>

    <ParamField body="chain_id" type="number" required>
      The chain ID where this authorization will be valid.
    </ParamField>

    <ParamField body="nonce" type="number">
      The nonce for the authorization. If not provided, defaults to 0.
    </ParamField>
  </Expandable>
</ParamField>

### Response

<ResponseField name="method" type="string" required>
  The RPC method that was executed. Will be `eth_sign7702Authorization`.
</ResponseField>

<ResponseField name="data" type="object" required>
  The response data containing the signed authorization.

  <Expandable title="child properties" defaultOpen="true">
    <ResponseField name="authorization" type="object" required>
      The signed EIP-7702 authorization object.

      <Expandable title="authorization properties">
        <ResponseField name="contract" type="string" required>
          The address of the smart contract that the EOA delegates to.
        </ResponseField>

        <ResponseField name="chain_id" type="number" required>
          The chain ID where this authorization is valid.
        </ResponseField>

        <ResponseField name="nonce" type="number" required>
          The nonce for the authorization.
        </ResponseField>

        <ResponseField name="r" type="string" required>
          The r component of the ECDSA signature.
        </ResponseField>

        <ResponseField name="s" type="string" required>
          The s component of the ECDSA signature.
        </ResponseField>

        <ResponseField name="y_parity" type="number" required>
          The recovery parameter (0 or 1) for the signature.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Expandable>
</ResponseField>


# eth_signTransaction
Source: https://docs.privy.io/api-reference/wallets/ethereum/eth-sign-transaction

post /v1/wallets/{wallet_id}/rpc
Sign a transaction using the eth_signTransaction method.

<RequestExample>
  ```sh cURL theme={"system"}
  curl --request POST \
    --url https://api.privy.io/v1/wallets/{wallet_id}/rpc \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "method": "eth_signTransaction",
    "params": {
      "transaction": {
        "to": "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045",
        "value": "0x2386F26FC10000",
        "chain_id": 11155111,
        "data": "0x",
        "gas_limit": 50000,
        "nonce": 0,
        "max_fee_per_gas": 1000308,
        "max_priority_fee_per_gas": "1000000"
      }
    }
  }'
  ```
</RequestExample>

<ResponseExample>
  ```json 200 theme={"system"}
  {
    "method": "eth_signTransaction",
    "data": {
      "signed_transaction": "0x02f870830138de80830f4240830f437480940b81418147df37155d643b5cb65ba6c8cb7aba76872000000000000480c080a05c11a2166ec56189d993dec477477d962ce0d4c466ab7ed8982110621ec87a57a003c796590c0c62eac30acd412f2aa0e8ad740c4ded86fb64d3326ee4c0ea804c",
      "encoding": "rlp"
    }
  }
  ```
</ResponseExample>

### Headers

<ParamField header="privy-app-id" type="string" required>
  ID of your Privy app.
</ParamField>

<ParamField header="privy-authorization-signature" type="string">
  Request authorization signature. If multiple signatures are required, they should be comma
  separated.
</ParamField>

### Path Parameters

<ParamField path="wallet_id" type="string" required>
  ID of the wallet to get.
</ParamField>

### Body

<ParamField body="method" type="string" defaultValue="eth_signTransaction" required>
  Available options: `eth_signTransaction`
</ParamField>

<ParamField body="params" type="object" required>
  <Expandable title="child attributes" defaultOpen="true">
    <ParamField body="transaction" type="object" required>
      <Expandable title="child attributes" defaultOpen="true">
        <ParamField body="from" type="string" />

        <ParamField body="to" type="string" />

        <ParamField body="chain_id" type="string" />

        <ParamField body="nonce" type="string" />

        <ParamField body="data" type="string" />

        <ParamField body="value" type="string">
          The value to send in the transaction in wei as a hexadecimal string.
        </ParamField>

        <ParamField body="type" type="number">
          Available options: `0`, `1`, `2`
        </ParamField>

        <ParamField body="gas_limit" type="string" />

        <ParamField body="gas_price" type="string" />
      </Expandable>
    </ParamField>
  </Expandable>
</ParamField>

### Response

<ResponseField name="method" type="enum<string>" required>
  Available options: `eth_signTransaction`
</ResponseField>

<ResponseField name="data" type="object" required>
  <Expandable title="child properties" defaultOpen="true">
    <ResponseField name="signed_transaction" type="string" required />

    <ResponseField name="encoding" type="enum<string>">
      Available options: `rlp`
    </ResponseField>
  </Expandable>
</ResponseField>


# eth_signUserOperation
Source: https://docs.privy.io/api-reference/wallets/ethereum/eth-sign-user-operation

post /v1/wallets/{wallet_id}/rpc
Sign a user operation using the eth_signUserOperation method.

<Info>
  This method is currently only supported for the Alchemy smart contract address
  `0x69007702764179f14F51cdce752f4f775d74E139`.
</Info>

<RequestExample>
  ```sh cURL theme={"system"}
  curl --request POST \
    --url https://api.privy.io/v1/wallets/{wallet_id}/rpc \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "method": "eth_signUserOperation",
    "params": {
      "contract": "0x69007702764179f14F51cdce752f4f775d74E139",
      "user_operation": {
        "sender": "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045",
        "nonce": "0x0",
        "call_data": "0x",
        "call_gas_limit": "0x30d40",
        "verification_gas_limit": "0x30d40",
        "pre_verification_gas": "0x5208",
        "max_fee_per_gas": "0xf4240",
        "max_priority_fee_per_gas": "0xf4240",
        "paymaster": "0x0000000000000000000000000000000000000000",
        "paymaster_data": "0x",
        "paymaster_verification_gas_limit": "0x0",
        "paymaster_post_op_gas_limit": "0x0"
      },
      "chain_id": "11155111"
    }
  }'
  ```
</RequestExample>

<ResponseExample>
  ```json 200 theme={"system"}
  {
    "method": "eth_signUserOperation",
    "data": {
      "signature": "0x1754782aea15e96189c3a85a7b7ac2f6339f6f4f3b29b1d3200a4c9907ef53e4776a84387583896b0a074cbc6de1a1c2a1eb53aba199da6ada8c99b0266171c41b",
      "encoding": "hex"
    }
  }
  ```
</ResponseExample>

### Headers

<ParamField header="privy-app-id" type="string" required>
  ID of your Privy app.
</ParamField>

<ParamField header="privy-authorization-signature" type="string">
  Request authorization signature. If multiple signatures are required, they should be comma
  separated.
</ParamField>

### Path Parameters

<ParamField path="wallet_id" type="string" required>
  ID of the wallet to get.
</ParamField>

### Body

<ParamField body="method" type="string" defaultValue="eth_signUserOperation" required>
  Available options: `eth_signUserOperation`
</ParamField>

<ParamField body="params" type="object" required>
  <Expandable title="child attributes" defaultOpen="true">
    <ParamField body="contract" type="string" required>
      The smart contract address for the user operation. Currently only supports the Alchemy smart
      contract: `0x69007702764179f14F51cdce752f4f775d74E139`.
    </ParamField>

    <ParamField body="user_operation" type="object" required>
      <Expandable title="child attributes" defaultOpen="true">
        <ParamField body="sender" type="string" required>
          The account making the operation.
        </ParamField>

        <ParamField body="nonce" type="string" required>
          Anti-replay parameter; also used as the salt for first-time account creation.
        </ParamField>

        <ParamField body="call_data" type="string" required>
          The data to pass to the sender during the main execution call.
        </ParamField>

        <ParamField body="call_gas_limit" type="string" required>
          The amount of gas to allocate the main execution call.
        </ParamField>

        <ParamField body="verification_gas_limit" type="string" required>
          The amount of gas to allocate for the verification step.
        </ParamField>

        <ParamField body="pre_verification_gas" type="string" required>
          Extra gas to pay the bundler.
        </ParamField>

        <ParamField body="max_fee_per_gas" type="string" required>
          Maximum fee per gas (similar to EIP-1559 max\_fee\_per\_gas).
        </ParamField>

        <ParamField body="max_priority_fee_per_gas" type="string" required>
          Maximum priority fee per gas (similar to EIP-1559 max\_priority\_fee\_per\_gas).
        </ParamField>

        <ParamField body="paymaster" type="string" required>
          Address of paymaster sponsoring the transaction, zero for self-sponsored.
        </ParamField>

        <ParamField body="paymaster_data" type="string" required>
          Extra data to send to the paymaster.
        </ParamField>

        <ParamField body="paymaster_verification_gas_limit" type="string" required>
          The amount of gas to allocate for the paymaster validation code.
        </ParamField>

        <ParamField body="paymaster_post_op_gas_limit" type="string" required>
          The amount of gas to allocate for the paymaster post-operation code.
        </ParamField>
      </Expandable>
    </ParamField>

    <ParamField body="chain_id" type="string" required>
      The chain ID for the user operation.
    </ParamField>
  </Expandable>
</ParamField>

### Response

<ResponseField name="method" type="enum<string>" required>
  Available options: `eth_signUserOperation`
</ResponseField>

<ResponseField name="data" type="object" required>
  <Expandable title="child properties" defaultOpen="true">
    <ResponseField name="signature" type="string" required>
      The hex-encoded signature of the user operation.
    </ResponseField>

    <ResponseField name="encoding" type="enum<string>">
      Available options: `hex`
    </ResponseField>
  </Expandable>
</ResponseField>


# eth_signTypedData_v4
Source: https://docs.privy.io/api-reference/wallets/ethereum/eth-signtypeddata-v4

post /v1/wallets/{wallet_id}/rpc
Sign a message using the eth_signTypedData_v4 method.

<RequestExample>
  ```sh cURL theme={"system"}
  curl --request POST \
    --url https://api.privy.io/v1/wallets/{wallet_id}/rpc \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "method": "eth_signTypedData_v4",
    "params": {
      "typed_data": {
        "types": {
          "EIP712Domain": [
            { "name": "name", "type": "string" },
            { "name": "version", "type": "string" },
            { "name": "chainId", "type": "uint160" },
            { "name": "verifyingContract", "type": "address" }
          ],
          "Person": [
            { "name": "name", "type": "string" },
            { "name": "wallet", "type": "address" }
          ],
          "Mail": [
            { "name": "from", "type": "Person" },
            { "name": "to", "type": "Person" },
            { "name": "contents", "type": "string" }
          ]
        },
        "message": {
          "from": {
            "name": "Alice",
            "wallet": "0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826"
          },
          "to": {
            "name": "Bob",
            "wallet": "0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB"
          },
          "contents": "Hello, Bob!"
        },
        "primary_type": "Mail",
        "domain": {
          "name": "DApp Mail",
          "version": "1",
          "chainId": "0x3e8",
          "verifyingContract": "0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC"
        }
      }
    }
  }'
  ```
</RequestExample>

<ResponseExample>
  ```json 200 theme={"system"}
  {
    "method": "eth_signTypedData_v4",
    "data": {
      "signature": "0x1754782aea15e96189c3a85a7b7ac2f6339f6f4f3b29b1d3200a4c9907ef53e4776a84387583896b0a074cbc6de1a1c2a1eb53aba199da6ada8c99b0266171c41b",
      "encoding": "hex"
    }
  }
  ```
</ResponseExample>

### Headers

<ParamField header="privy-app-id" type="string" required>
  ID of your Privy app.
</ParamField>

<ParamField header="privy-authorization-signature" type="string">
  Request authorization signature. If multiple signatures are required, they should be comma
  separated.
</ParamField>

### Path Parameters

<ParamField path="wallet_id" type="string" required>
  ID of the wallet to get.
</ParamField>

### Body

<ParamField body="method" type="string" defaultValue="eth_signTypedData_v4" required>
  Available options: `eth_signTypedData_v4`
</ParamField>

<ParamField body="params" type="object" required>
  <Expandable title="child attributes" defaultOpen="true">
    <ParamField body="typed_data" type="object" required>
      <Expandable title="child attributes" defaultOpen="true">
        <ParamField body="domain" type="object" required />

        <ParamField body="types" type="object" required />

        <ParamField body="message" type="object" required />

        <ParamField body="primary_type" type="string" required />
      </Expandable>
    </ParamField>
  </Expandable>
</ParamField>

### Response

<ResponseField name="method" type="enum<string>" required>
  Available options: `eth_signTypedData_v4`
</ResponseField>

<ResponseField name="data" type="object" required>
  <Expandable title="child attributes" defaultOpen="true">
    <ResponseField name="signature" type="string" required />

    <ResponseField name="encoding" type="enum<string>">
      Available options: `utf-8`, `hex`
    </ResponseField>
  </Expandable>
</ResponseField>


# personal_sign
Source: https://docs.privy.io/api-reference/wallets/ethereum/personal-sign

post /v1/wallets/{wallet_id}/rpc
Sign a message using the personal_sign method.

<RequestExample>
  ```sh cURL theme={"system"}
  curl --request POST \
    --url https://api.privy.io/v1/wallets/{wallet_id}/rpc \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "method": "personal_sign",
    "params": {
      "message": "Hello from Privy!",
      "encoding": "utf-8"
    }
  }'
  ```
</RequestExample>

<ResponseExample>
  ```json 200 theme={"system"}
  {
    "method": "personal_sign",
    "data": {
      "signature": "0x0db9c7bd881045cbba28c347de6cc32a653e15d7f6f2f1cec21d645f402a64196e877eb45d3041f8d2ab1a76f57f408b63894cfc6f339d8f584bd26efceae3081c",
      "encoding": "hex"
    }
  }
  ```
</ResponseExample>

### Headers

<ParamField header="privy-app-id" type="string" required>
  ID of your Privy app.
</ParamField>

<ParamField header="privy-authorization-signature" type="string">
  Request authorization signature. If multiple signatures are required, they should be comma
  separated.
</ParamField>

### Path Parameters

<ParamField path="wallet_id" type="string" required>
  ID of the wallet to get.
</ParamField>

### Body

<ParamField body="method" type="string" defaultValue="personal_sign" required>
  Available options: `personal_sign`
</ParamField>

<ParamField body="params" type="object" required>
  <Expandable title="child properties" defaultOpen="true">
    <ParamField body="message" type="string" />

    <ParamField body="encoding" type="string" initialValue="utf-8">
      Available options: `utf-8`, `hex`
    </ParamField>
  </Expandable>
</ParamField>

### Response

<ResponseField name="method" type="enum<string>" required>
  Available options: `personal_sign`
</ResponseField>

<ResponseField name="data" type="object" required>
  <Expandable title="child properties" defaultOpen="true">
    <ResponseField name="signature" type="string" required />

    <ResponseField name="encoding" type="enum<string>">
      Available options: `utf-8`, `hex`
    </ResponseField>
  </Expandable>
</ResponseField>


# secp256k1_sign
Source: https://docs.privy.io/api-reference/wallets/ethereum/secp256k1-sign

post /v1/wallets/{wallet_id}/rpc
Sign a hash using the secp256k1 method.

<RequestExample>
  ```sh cURL theme={"system"}
  curl --request POST \
    --url https://api.privy.io/v1/wallets/{wallet_id}/rpc \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "method": "secp256k1_sign",
    "params": {
      "hash": "0x12345678",
    }
  }'
  ```
</RequestExample>

<ResponseExample>
  ```json 200 theme={"system"}
  {
    "method": "secp256k1_sign",
    "data": {
      "signature": "0x0db9c7bd881045cbba28c347de6cc32a653e15d7f6f2f1cec21d645f402a64196e877eb45d3041f8d2ab1a76f57f408b63894cfc6f339d8f584bd26efceae3081c",
      "encoding": "hex"
    }
  }
  ```
</ResponseExample>

### Headers

<ParamField header="privy-app-id" type="string" required>
  ID of your Privy app.
</ParamField>

<ParamField header="privy-authorization-signature" type="string">
  Request authorization signature. If multiple signatures are required, they should be comma
  separated.
</ParamField>

### Path Parameters

<ParamField path="wallet_id" type="string" required>
  ID of the wallet to get.
</ParamField>

### Body

<ParamField body="method" type="string" defaultValue="secp256k1_sign" required>
  Available options: `secp256k1_sign`
</ParamField>

<ParamField body="params" type="object" required>
  <Expandable title="child properties" defaultOpen="true">
    <ParamField body="hash" type="string" />
  </Expandable>
</ParamField>

### Response

<ResponseField name="method" type="enum<string>" required>
  Available options: `secp256k1_sign`
</ResponseField>

<ResponseField name="data" type="object" required>
  <Expandable title="child properties" defaultOpen="true">
    <ResponseField name="signature" type="string" required />

    <ResponseField name="encoding" type="enum<string>">
      Available options: `hex`
    </ResponseField>
  </Expandable>
</ResponseField>


# Export wallet
Source: https://docs.privy.io/api-reference/wallets/export

post /v1/wallets/{wallet_id}/export
Export a wallet's private key.

This endpoint exports a wallet's private key using Hybrid Public Key Encryption (HPKE). The following HPKE configuration is supported:

* KEM (Key Encapsulation Mechanism): DHKEM\_P256\_HKDF\_SHA256
* KDF (Key Derivation Function): HKDF\_SHA256
* AEAD (Authenticated Encryption with Associated Data): CHACHA20\_POLY1305
* Mode: BASE

<RequestExample>
  ```sh cURL theme={"system"}
  curl --request POST \
    --url https://api.privy.io/v1/wallets/{wallet_id}/export \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "encryption_type": "HPKE",
    "recipient_public_key": "<base64-encoded-recipient-public-key>"
  }'
  ```
</RequestExample>

<ResponseExample>
  ```json 200 theme={"system"}
  {
    "encryption_type": "HPKE",
    "ciphertext": "N3rWFx85foeomDu8054VcwNBIwPkVNt4i5m2av1sXsXeWrIicVGwutFist12MmnI",
    "encapsulated_key": "BECqbgIAcs3TpP5GadS6F8mXkSktR2DR8WNtd3e0Qcy7PpoRHEygpzjFWttntS+SEM3VSr4Thewh18ZP9chseLE="
  }
  ```
</ResponseExample>

### Headers

<ParamField header="privy-app-id" type="string" required>
  ID of your Privy app.
</ParamField>

<ParamField header="privy-authorization-signature" type="string">
  Request authorization signature. If multiple signatures are required, they should be comma
  separated.
</ParamField>

### Path Parameters

<ParamField path="wallet_id" type="string" required>
  ID of the wallet to export.
</ParamField>

### Body

<ParamField body="encryption_type" type="string" defaultValue="HPKE" required>
  Currently only supports `HPKE` (Hybrid Public Key Encryption).
</ParamField>

<ParamField body="recipient_public_key" type="string" required>
  Base64-encoded public key of the recipient who will decrypt the private key. This key must be
  generated securely and kept confidential. The public key sent should be in base64-encoded DER
  format.
</ParamField>

### Response

<ResponseField name="encryption_type" type="string" required>
  Will be `HPKE` to indicate Hybrid Public Key Encryption was used.
</ResponseField>

<ResponseField name="ciphertext" type="string" required>
  Base64-encoded encrypted private key. The private key format depends on the wallet type: base58
  for Solana wallets, hex for EVM wallets.
</ResponseField>

<ResponseField name="encapsulated_key" type="string" required>
  Base64-encoded ephemeral public key used in the HPKE encryption process. Required for decryption.
</ResponseField>


# Get wallet
Source: https://docs.privy.io/api-reference/wallets/get

get /v1/wallets/{wallet_id}
Get a wallet by wallet ID.



# Get wallets
Source: https://docs.privy.io/api-reference/wallets/get-all

get /v1/wallets
Get all wallets in your app.



# Get balance
Source: https://docs.privy.io/api-reference/wallets/get-balance

get /v1/wallets/{wallet_id}/balance
Get the balance of a wallet by wallet ID.



# Get transactions
Source: https://docs.privy.io/api-reference/wallets/get-transactions

get /v1/wallets/{wallet_id}/transactions
Get incoming and outgoing transactions of a wallet by wallet ID.



# Initialize import
Source: https://docs.privy.io/api-reference/wallets/import/init

post /v1/wallets/import/init
Initialize a wallet import. Complete by submitting the import.

See the [Import a wallet](/wallets/wallets/import-a-wallet) guide for a walkthrough of the full flow and architecture.


# Submit import
Source: https://docs.privy.io/api-reference/wallets/import/submit

post /v1/wallets/import/submit
Submit a wallet import request.

See the [Import a wallet](/wallets/wallets/import-a-wallet) guide for a walkthrough of the full flow and architecture.


# Raw sign
Source: https://docs.privy.io/api-reference/wallets/raw-sign

post /v1/wallets/{wallet_id}/raw_sign
Sign a raw hash along the blockchain's cryptographic curve using the wallet's private key.

<Info>
  To see how to use raw sign for chains with Tier 2 support, see [this recipe](/recipes/use-tier-2).
</Info>


# signAndSendTransaction
Source: https://docs.privy.io/api-reference/wallets/solana/sign-and-send-transaction

post /v1/wallets/{wallet_id}/rpc
Sign and send transaction with a Solana wallet using the signAndSendTransaction method.

<RequestExample>
  ```sh cURL theme={"system"}
  curl --request POST \
    --url https://api.privy.io/v1/wallets/{wallet_id}/rpc \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "method": "signAndSendTransaction",
    "caip2": "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
    "sponsor": true,
    "params": {
      "transaction": "AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEDRpb0mdmKftapwzzqUtlcDnuWbw8vwlyiyuWyyieQFKESezu52HWNss0SAcb60ftz7DSpgTwUmfUSl1CYHJ91GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAScgJ7J0AXFr1azCEvB1Y5zpiF4eXR+yTW0UB7am+E/MBAgIAAQwCAAAAQEIPAAAAAAA=",
      "encoding": "base64"
    }
  }
  '
  ```
</RequestExample>

<ResponseExample>
  ```json 200 theme={"system"}
  {
    "method": "signAndSendTransaction",
    "data": {
      "hash": "22VS6wqrbeaN21ku3pjEjfnrWgk1deiFBSB1kZzS8ivr2G8wYmpdnV3W7oxpjFPGkt5bhvZvK1QBzuCfUPUYYFQq",
      "caip2": "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
      "transaction_id": "nyorsf87s9d08jimesv3n8yq"
    }
  }
  ```
</ResponseExample>

### Headers

<ParamField header="privy-app-id" type="string" required>
  ID of your Privy app.
</ParamField>

<ParamField header="privy-authorization-signature" type="string">
  Request authorization signature. If multiple signatures are required, they should be comma
  separated.
</ParamField>

### Path Parameters

<ParamField path="wallet_id" type="string" required>
  ID of the wallet to get.
</ParamField>

### Body

<ParamField body="method" type="string" defaultValue="signAndSendTransaction" required>
  Available options: `signAndSendTransaction`
</ParamField>

<ParamField body="caip2" type="string" initialValue="eip155:11155111" required>
  Available options: `solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp` (Solana Mainnet),
  `solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1` (Solana Devnet),
  `solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z` (Solana Testnet)
</ParamField>

<ParamField body="params" type="object" required>
  <Expandable title="child attributes" defaultOpen="true">
    <ParamField body="transaction" type="string">
      Base64 encoded serialized transaction to sign.
    </ParamField>

    <ParamField body="encoding" type="string">
      Available options: `base64`
    </ParamField>
  </Expandable>
</ParamField>

<ParamField body="sponsor" type="boolean">
  Optional parameter to enable gas sponsorship for this transaction. [Learn
  more.](/wallets/gas-and-asset-management/gas/overview)
</ParamField>

### Returns

<ResponseField name="method" type="enum<string>" required>
  Available options: `signAndSendTransaction`
</ResponseField>

<ResponseField name="data" type="object" required>
  <Expandable title="child attributes" defaultOpen="true">
    <ResponseField name="hash" type="string" required>
      Transaction hash of the signed and sent transaction.
    </ResponseField>

    <ResponseField name="caip2" type="string" required>
      CAIP-2 chain ID of the network where the transaction was sent.
    </ResponseField>

    <ResponseField name="transaction_id" type="string">
      Optional Privy-assigned transaction ID.
    </ResponseField>
  </Expandable>
</ResponseField>


# signMessage
Source: https://docs.privy.io/api-reference/wallets/solana/sign-message

post /v1/wallets/{wallet_id}/rpc
Sign a message with a Solana wallet using the signMessage method.

<RequestExample>
  ```sh cURL theme={"system"}
  curl --request POST \
    --url https://api.privy.io/v1/wallets/{wallet_id}/rpc \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "method": "signMessage",
    "params": {
      "message": "aGVsbG8sIFByaXZ5IQ=",
      "encoding": "base64"
    }
  }
  '
  ```
</RequestExample>

<ResponseExample>
  ```json 200 theme={"system"}
  {
    "method": "signMessage",
    "data": {
      "signature": "76wpEsq9FS4QOInePQUY3b4GCXdVwLv+nNp4NnI+EPTAPVwvXCjzjUW/gD6Vuh4KaD+7p2X4MaTu6xYu0rMTAA==",
      "encoding": "base64"
    }
  }
  ```
</ResponseExample>

### Headers

<ParamField header="privy-app-id" type="string" required>
  ID of your Privy app.
</ParamField>

<ParamField header="privy-authorization-signature" type="string">
  Request authorization signature. If multiple signatures are required, they should be comma
  separated.
</ParamField>

### Path Parameters

<ParamField path="wallet_id" type="string" required>
  ID of the wallet to get.
</ParamField>

### Body

<ParamField body="method" type="string" defaultValue="signMessage" required>
  Available options: `signMessage`
</ParamField>

<ParamField body="params" type="object" required>
  <Expandable title="child properties">
    <ParamField body="message" type="string">
      Base64 encoded message to sign.
    </ParamField>

    <ParamField body="encoding" type="string">
      Available options: `base64`
    </ParamField>
  </Expandable>
</ParamField>

### Response

<ResponseField name="method" type="enum<string>" required>
  Available options: `signMessage`
</ResponseField>

<ResponseField name="data" type="object" required>
  <Expandable title="child properties">
    <ResponseField name="signature" type="string" required />

    <ResponseField name="encoding" type="enum<string>">
      Available options: `base64`
    </ResponseField>
  </Expandable>
</ResponseField>


# signTransaction
Source: https://docs.privy.io/api-reference/wallets/solana/sign-transaction

post /v1/wallets/{wallet_id}/rpc
Sign a transaction with a Solana wallet using the signTransaction method.

<RequestExample>
  ```sh cURL theme={"system"}
  curl --request POST \
    --url https://api.privy.io/v1/wallets/{wallet_id}/rpc \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "method": "signTransaction",
    "params": {
      "transaction": "AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEDRpb0mdmKftapwzzqUtlcDnuWbw8vwlyiyuWyyieQFKESezu52HWNss0SAcb60ftz7DSpgTwUmfUSl1CYHJ91GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAScgJ7J0AXFr1azCEvB1Y5zpiF4eXR+yTW0UB7am+E/MBAgIAAQwCAAAAQEIPAAAAAAA=",
      "encoding": "base64"
    }
  }
  '
  ```
</RequestExample>

<ResponseExample>
  ```json 200 theme={"system"}
  {
    "method": "signTransaction",
    "data": {
      "signed_transaction": "AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEDRpb0mdmKftapwzzqUtlcDnuWbw8vwlyiyuWyyieQFKESezu52HWNss0SAcb60ftz7DSpgTwUmfUSl1CYHJ91GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAScgJ7J0AXFr1azCEvB1Y5zpiF4eXR",
      "encoding": "base64"
    }
  }
  ```
</ResponseExample>

### Headers

<ParamField header="privy-app-id" type="string" required>
  ID of your Privy app.
</ParamField>

<ParamField header="privy-authorization-signature" type="string">
  Request authorization signature. If multiple signatures are required, they should be comma
  separated.
</ParamField>

### Path Parameters

<ParamField path="wallet_id" type="string" required>
  ID of the wallet to get.
</ParamField>

### Body

<ParamField body="method" type="string" defaultValue="signTransaction" required>
  Available options: `signTransaction`
</ParamField>

<ParamField body="params" type="object" required>
  <Expandable title="child attributes" defaultOpen="true">
    <ParamField body="transaction" type="string">
      Base64 encoded serialized transaction to sign.
    </ParamField>

    <ParamField body="encoding" type="string">
      Available options: `base64`
    </ParamField>
  </Expandable>
</ParamField>

### Response

<ResponseField name="method" type="enum<string>" required>
  Available options: `signTransaction`
</ResponseField>

<ResponseField name="data" type="object" required>
  <Expandable title="child attributes" defaultOpen="true">
    <ResponseField name="signed_transaction" type="string" required />

    <ResponseField name="encoding" type="enum<string>">
      Available options: `base64`
    </ResponseField>
  </Expandable>
</ResponseField>


# claimStaticDeposit
Source: https://docs.privy.io/api-reference/wallets/spark/claim-static-deposit

post /v1/wallets/{wallet_id}/rpc
Claims funds sent to the static BTC deposit address.

<RequestExample>
  ```sh  theme={"system"}
  curl --request POST \
    --url https://api.privy.io/v1/wallets/{wallet_id}/rpc \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "method": "claimStaticDeposit",
    "network": "MAINNET",
    "params": {
      "credit_amount_sats": 9901,
      "signature": "3045022100c4b5c728cdaf2ca0d9ffa2a5689eefa51d286bf32fbfb678071735a44e83132f0220173e59115579e705689dd0d3e819b87255e86ed4629637c85f761c0960869c7a",
      "transaction_id": "cff576f1ebebda2ddf812f06f656a6668f08f13d56290b4468327607f4d68acb",
      "output_index": 0
    }
  }'
  ```
</RequestExample>

<ResponseExample>
  ```json 200 theme={"system"}
  {
    "method": "claimStaticDeposit",
    "data": {
      "transfer_id": "22a62e0b-6eae-4d84-8f15-2a69a6440b74"
    }
  }
  ```
</ResponseExample>

### Headers

<ParamField header="privy-app-id" type="string" required>
  ID of your Privy app.
</ParamField>

<ParamField header="privy-authorization-signature" type="string">
  Request authorization signature. If multiple signatures are required, they should be comma
  separated.
</ParamField>

### Path Parameters

<ParamField path="wallet_id" type="string" required>
  ID of the wallet to get.
</ParamField>

<Info>
  These wallet methods are modeled after the [Spark Wallet
  SDK](https://github.com/buildonspark/spark/tree/main/sdks/js/packages/spark-sdk). For more
  information about this wallet method, check out the [Spark Wallet
  documentation](https://docs.spark.money/wallet/introduction).
</Info>

### Body

<ParamField body="method" type="string" defaultValue="claimStaticDeposit" required>
  Available options: `claimStaticDeposit`
</ParamField>

<ParamField body="network" type="string" required>
  Available options: `MAINNET`, `REGTEST`
</ParamField>

<ParamField body="params" type="object" required>
  Required parameters to claim the deposit.

  <Expandable title="child attributes" defaultOpen="true">
    <ParamField body="credit_amount_sats" type="number" required>
      Amount of native tokens (in satoshis) being claimed from the UTXO.
    </ParamField>

    <ParamField body="signature" type="string" required>
      A signature authorizing the claim, signed by the address that received the deposit.
    </ParamField>

    <ParamField body="transaction_id" type="string" required>
      The transaction ID (hash) of the deposit transaction containing the UTXO.
    </ParamField>

    <ParamField body="output_index" type="number" required>
      The index of the UTXO output in the transaction.
    </ParamField>
  </Expandable>
</ParamField>

### Returns

<ResponseField name="method" type="enum<string>" required>
  Always `"claimStaticDeposit"`
</ResponseField>

<ResponseField name="data" type="object" required>
  Information about the claimed deposit.

  <Expandable title="child attributes" defaultOpen="true">
    <ResponseField name="transfer_id" type="string" required>
      A unique identifier representing the successful internal transfer of claimed funds to the
      wallet.
    </ResponseField>
  </Expandable>
</ResponseField>


# createLightningInvoice
Source: https://docs.privy.io/api-reference/wallets/spark/create-lightning-invoice

post /v1/wallets/{wallet_id}/rpc
Creates a Lightning invoice for the given wallet, allowing funds to be received via the Lightning Network.

<RequestExample>
  ```sh  theme={"system"}
  curl --request POST \
    --url https://api.privy.io/v1/wallets/{wallet_id}/rpc \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "method": "createLightningInvoice",
    "network": "MAINNET",
    "params": {
      "amount_sats": 20
    }
  }'
  ```
</RequestExample>

<ResponseExample>
  ```json 200 theme={"system"}
  {
    "method": "createLightningInvoice",
    "data": {
      "id": "SparkLightningReceiveRequest:019842c4-c50f-cd96-0000-612d71a61547",
      "created_at": "2025-07-25T18:07:28.527107+00:00",
      "updated_at": "2025-07-25T18:07:28.527107+00:00",
      "network": "MAINNET",
      "invoice": {
        "encodedInvoice": "lnbc...",
        "bitcoinNetwork": "MAINNET",
        "paymentHash": "f59c86aaafa9920f410d1567d9ee38bf526c932691c23c7bac6d8519682a6d76",
        "amount": {
          "originalValue": 20000,
          "originalUnit": "MILLISATOSHI",
          "preferredCurrencyUnit": "USD",
          "preferredCurrencyValueRounded": 2,
          "preferredCurrencyValueApprox": 2.3228803716608595
        },
        "createdAt": "2025-07-25T18:07:28.484042+00:00",
        "expiresAt": "2025-08-24T18:07:28.484042+00:00",
        "memo": null
      },
      "status": "INVOICE_CREATED",
      "typename": "LightningReceiveRequest",
      "payment_preimage": null,
      "receiver_identity_public_key": null
    }
  }
  ```
</ResponseExample>

### Headers

<ParamField header="privy-app-id" type="string" required>
  ID of your Privy app.
</ParamField>

<ParamField header="privy-authorization-signature" type="string">
  Request authorization signature. If multiple signatures are required, they should be comma
  separated.
</ParamField>

### Path Parameters

<ParamField path="wallet_id" type="string" required>
  ID of the wallet to get.
</ParamField>

<Info>
  These wallet methods are modeled after the [Spark Wallet
  SDK](https://github.com/buildonspark/spark/tree/main/sdks/js/packages/spark-sdk). For more
  information about this wallet method, check out the [Spark Wallet
  documentation](https://docs.spark.money/wallet/introduction).
</Info>

### Body

<ParamField body="method" type="string" defaultValue="createLightningInvoice" required>
  Available options: `createLightningInvoice`
</ParamField>

<ParamField body="network" type="string" required>
  Available options: `MAINNET`, `REGTEST`
</ParamField>

<ParamField body="params" type="object" required>
  Parameters for the invoice to be created.

  <Expandable title="child attributes" defaultOpen="true">
    <ParamField body="amount_sats" type="number" required>
      The amount of sats to be received.
    </ParamField>
  </Expandable>
</ParamField>

### Returns

<ResponseField name="method" type="enum<string>" required>
  Always `"createLightningInvoice"`
</ResponseField>

<ResponseField name="data" type="object" required>
  Details about the created Lightning invoice.

  <Expandable title="child attributes" defaultOpen="true">
    <ResponseField name="id" type="string" required>
      Unique ID of the Lightning receive request.
    </ResponseField>

    <ResponseField name="created_at" type="string" required>
      Timestamp of invoice creation.
    </ResponseField>

    <ResponseField name="updated_at" type="string" required>
      Timestamp of last update.
    </ResponseField>

    <ResponseField name="network" type="string" required>
      The Bitcoin network this invoice is valid for.
    </ResponseField>

    <ResponseField name="invoice" type="object" required>
      Encoded invoice details.

      <Expandable title="child attributes" defaultOpen="true">
        <ResponseField name="encodedInvoice" type="string" required>
          Bolt11-encoded Lightning invoice string.
        </ResponseField>

        <ResponseField name="bitcoinNetwork" type="string" required>
          The Bitcoin network.
        </ResponseField>

        <ResponseField name="paymentHash" type="string" required>
          The hash of the preimage for this payment request.
        </ResponseField>

        <ResponseField name="amount" type="object" required>
          Amount details.

          <Expandable title="child attributes" defaultOpen="true">
            <ResponseField name="originalValue" type="number" required />

            <ResponseField name="originalUnit" type="string" required />

            <ResponseField name="preferredCurrencyUnit" type="string" required />

            <ResponseField name="preferredCurrencyValueRounded" type="number" required />

            <ResponseField name="preferredCurrencyValueApprox" type="number" required />
          </Expandable>
        </ResponseField>

        <ResponseField name="createdAt" type="string" required>
          Timestamp of invoice creation.
        </ResponseField>

        <ResponseField name="expiresAt" type="string" required>
          Timestamp of invoice expiration.
        </ResponseField>

        <ResponseField name="memo" type="string" nullable>
          Optional memo included with the invoice.
        </ResponseField>
      </Expandable>
    </ResponseField>

    <ResponseField name="status" type="string" required>
      Current status of the invoice. Possible value: `"INVOICE_CREATED"`.
    </ResponseField>

    <ResponseField name="typename" type="string" required />

    <ResponseField name="payment_preimage" type="string" nullable />

    <ResponseField name="receiver_identity_public_key" type="string">
      Public key of the receiving node.
    </ResponseField>
  </Expandable>
</ResponseField>


# getBalance
Source: https://docs.privy.io/api-reference/wallets/spark/get-balance

post /v1/wallets/{wallet_id}/rpc
Retrieve the balance and token holdings of a Spark wallet. Claims any pending transfers.

<RequestExample>
  ```sh  theme={"system"}
  curl --request POST \
    --url https://api.privy.io/v1/wallets/{wallet_id}/rpc \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "method": "getBalance",
    "network": "MAINNET"
  }'
  ```
</RequestExample>

<ResponseExample>
  ```json 200 theme={"system"}
  {
    "method": "getBalance",
    "data": {
      "balance": "239170",
      "token_balances": {
        "btknrt1x9helfvakyz8y53lzwt2wjen7d30ft6skpu69eydvndqt5uxsr4q0zvugn": {
          "balance": "999999910",
          "token_metadata": {
            "raw_token_identifier": "316f9fa59db10472523f1396a74b33f362f4af50b079a2e48d64da05d38680ea",
            "token_public_key": "025bd027cd332a40e21f16cb6e9c6aee9ac11e3dff9508081b64fa8b27658b18b6",
            "token_name": "Merica",
            "token_ticker": "USA",
            "decimals": 6,
            "max_supply": "21000000000000"
          }
        }
      },
      "encoding": "hex"
    }
  }
  ```
</ResponseExample>

### Headers

<ParamField header="privy-app-id" type="string" required>
  ID of your Privy app.
</ParamField>

<ParamField header="privy-authorization-signature" type="string">
  Request authorization signature. If multiple signatures are required, they should be comma
  separated.
</ParamField>

### Path Parameters

<ParamField path="wallet_id" type="string" required>
  ID of the wallet to get.
</ParamField>

<Info>
  These wallet methods are modeled after the [Spark Wallet
  SDK](https://github.com/buildonspark/spark/tree/main/sdks/js/packages/spark-sdk). For more
  information about this wallet method, check out the [Spark Wallet
  documentation](https://docs.spark.money/wallet/introduction).
</Info>

### Body

<ParamField body="method" type="string" defaultValue="getBalance" required>
  Available options: `getBalance`
</ParamField>

<ParamField body="network" type="string" required>
  Available options: `MAINNET`, `REGTEST`
</ParamField>

### Returns

<ResponseField name="method" type="enum<string>" required>
  Available options: `getBalance`
</ResponseField>

<ResponseField name="data" type="object" required>
  The balance and token holdings of the wallet.

  <Expandable title="child attributes" defaultOpen="true">
    <ResponseField name="balance" type="string" required>
      Native Spark balance in satoshis.
    </ResponseField>

    <ResponseField name="token_balances" type="object" required>
      A mapping of token Spark addresses to token data.

      <Expandable title="child attributes" defaultOpen="true">
        <ResponseField name="[token_spark_address]" type="object" required>
          <Expandable title="child attributes" defaultOpen="true">
            <ResponseField name="balance" type="string" required />

            <ResponseField name="token_metadata" type="object" required>
              <Expandable title="child attributes" defaultOpen="true">
                <ResponseField name="raw_token_identifier" type="string" required />

                <ResponseField name="token_public_key" type="string" required />

                <ResponseField name="token_name" type="string" required />

                <ResponseField name="token_ticker" type="string" required />

                <ResponseField name="decimals" type="number" required />

                <ResponseField name="max_supply" type="string" required />
              </Expandable>
            </ResponseField>
          </Expandable>
        </ResponseField>
      </Expandable>
    </ResponseField>

    <ResponseField name="encoding" type="string" required />
  </Expandable>
</ResponseField>

```
```


# getStaticDepositAddress
Source: https://docs.privy.io/api-reference/wallets/spark/get-static-deposit-address

post /v1/wallets/{wallet_id}/rpc
Returns a static deposit address that can be used to deposit tokens from BTC into Spark.

<RequestExample>
  ```sh  theme={"system"}
  curl --request POST \
    --url https://api.privy.io/v1/wallets/{wallet_id}/rpc \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "method": "getStaticDepositAddress",
    "network": "MAINNET"
  }'
  ```
</RequestExample>

<ResponseExample>
  ```json 200 theme={"system"}
  {
    "method": "getStaticDepositAddress",
    "data": {
      "address": "bcrt1ppvq36yzcycqfcgcl34samllm75zkqjgdkfsqj8hkgdh9pnse5czqj0zh9r"
    }
  }
  ```
</ResponseExample>

### Headers

<ParamField header="privy-app-id" type="string" required>
  ID of your Privy app.
</ParamField>

<ParamField header="privy-authorization-signature" type="string">
  Request authorization signature. If multiple signatures are required, they should be comma
  separated.
</ParamField>

### Path Parameters

<ParamField path="wallet_id" type="string" required>
  ID of the wallet to get.
</ParamField>

<Info>
  These wallet methods are modeled after the [Spark Wallet
  SDK](https://github.com/buildonspark/spark/tree/main/sdks/js/packages/spark-sdk). For more
  information about this wallet method, check out the [Spark Wallet
  documentation](https://docs.spark.money/wallet/introduction).
</Info>

### Body

<ParamField body="method" type="string" defaultValue="getStaticDepositAddress" required>
  Available options: `getStaticDepositAddress`
</ParamField>

<ParamField body="network" type="string" required>
  Available options: `MAINNET`, `REGTEST`
</ParamField>

### Returns

<ResponseField name="method" type="enum<string>" required>
  Always `"getStaticDepositAddress"`
</ResponseField>

<ResponseField name="data" type="object" required>
  The static deposit address for the wallet.

  <Expandable title="child attributes" defaultOpen="true">
    <ResponseField name="address" type="string" required>
      A BTC address for depositing native tokens.
    </ResponseField>
  </Expandable>
</ResponseField>


# getClaimStaticDepositQuote
Source: https://docs.privy.io/api-reference/wallets/spark/get-static-deposit-quote

post /v1/wallets/{wallet_id}/rpc
Retrieve the quote needed to claim BTC sent to a static deposit address.

<RequestExample>
  ```sh  theme={"system"}
  curl --request POST \
    --url https://api.privy.io/v1/wallets/{wallet_id}/rpc \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "method": "getClaimStaticDepositQuote",
    "network": "REGTEST",
    "params": {
      "transaction_id": "448f305caf15ec10b2a8286fde6c31ebe2eb30e2018b22a8f7630d3fa2753e49"
    }
  }'
  ```
</RequestExample>

<ResponseExample>
  ```json 200 theme={"system"}
  {
    "method": "getClaimStaticDepositQuote",
    "data": {
      "credit_amount_sats": 9901,
      "signature": "304402206e61d688bc498b8cd95f798c82c6f087c71d56ef822b04bc268240dba7be8705022077609ae2349b5233455821cd8db7dc36ac9e123b62f983bd1da371034e786dfd",
      "transaction_id": "448f305caf15ec10b2a8286fde6c31ebe2eb30e2018b22a8f7630d3fa2753e49",
      "output_index": 1,
      "network": "REGTEST"
    }
  }
  ```
</ResponseExample>

### Headers

<ParamField header="privy-app-id" type="string" required>
  ID of your Privy app.
</ParamField>

<ParamField header="privy-authorization-signature" type="string">
  Request authorization signature. If multiple signatures are required, they should be comma
  separated.
</ParamField>

### Path Parameters

<ParamField path="wallet_id" type="string" required>
  ID of the wallet to get.
</ParamField>

<Info>
  These wallet methods are modeled after the [Spark Wallet
  SDK](https://github.com/buildonspark/spark/tree/main/sdks/js/packages/spark-sdk). For more
  information about this wallet method, check out the [Spark Wallet
  documentation](https://docs.spark.money/wallet/introduction).
</Info>

### Body

<ParamField body="method" type="string" defaultValue="getClaimStaticDepositQuote" required>
  Must be set to getClaimStaticDepositQuote.
</ParamField>

<ParamField body="network" type="string" required>
  Blockchain network to use. Options: `MAINNET`, `REGTEST`.
</ParamField>

<ParamField body="params" type="object" required>
  <Expandable title="child attributes" defaultOpen="true">
    <ParamField body="transaction_id" type="string" required>
      The transaction hash of the BTC sent to the static deposit address.
    </ParamField>
  </Expandable>
</ParamField>

### Returns

<ResponseField name="method" type="enum<string>" defaultValue="getClaimStaticDepositQuote" required />

<ResponseField name="data" type="object" required>
  Contains the BTC claim quote.

  <Expandable title="child attributes" defaultOpen="true">
    <ResponseField name="credit_amount_sats" type="number" required>
      The amount of sats credited to the wallet after claiming.
    </ResponseField>

    <ResponseField name="signature" type="string" required />

    <ResponseField name="transaction_id" type="string" required>
      The hash of the Bitcoin transaction containing the deposit.
    </ResponseField>

    <ResponseField name="output_index" type="number" required>
      The index of the output within the transaction that is being claimed.
    </ResponseField>

    <ResponseField name="network" type="string" required>
      The network used (e.g. `REGTEST` or `MAINNET`).
    </ResponseField>
  </Expandable>
</ResponseField>


# payLightningInvoice
Source: https://docs.privy.io/api-reference/wallets/spark/pay-lightning-invoice

post /v1/wallets/{wallet_id}/rpc
Pay a Lightning Network invoice from a Spark wallet.

<RequestExample>
  ```sh curl --request POST \ theme={"system"}
    --url https://api.privy.io/v1/wallets/{wallet_id}/rpc \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "method": "payLightningInvoice",
    "network": "MAINNET",
    "params": {
      "invoice": "lnbc1230n1p...",
      "max_fee_sats": 5,
      "prefer_spark": true,
      "amount_sats_to_send": 5000
    }
  }'
  ```
</RequestExample>

<ResponseExample>
  ```json 200 theme={"system"}
  {
    "method": "payLightningInvoice",
    "data": {
      "id": "2fb0b49e-0aef-4726-a348-2dd0a9432c12",
      "created_at": "2025-07-24T16:43:12.509Z",
      "updated_at": "2025-07-24T16:43:12.509Z",
      "network": "MAINNET",
      "encoded_invoice": "lnbc1230n1p...",
      "fee": {
        "original_value": 3,
        "original_unit": "SATOSHI",
        "preferred_currency_unit": "USD",
        "preferred_currency_value_rounded": 0.01,
        "preferred_currency_value_approx": 0.012
      },
      "status": "SUCCESS",
      "typename": "LightningSendRequest"
    }
  }
  ```
</ResponseExample>

### Headers

<ParamField header="privy-app-id" type="string" required>
  ID of your Privy app.
</ParamField>

<ParamField header="privy-authorization-signature" type="string">
  Request authorization signature. If multiple signatures are required, they should be comma
  separated.
</ParamField>

### Path Parameters

<ParamField path="wallet_id" type="string" required>
  ID of the wallet to get.
</ParamField>

<Info>
  These wallet methods are modeled after the [Spark Wallet
  SDK](https://github.com/buildonspark/spark/tree/main/sdks/js/packages/spark-sdk). For more
  information about this wallet method, check out the [Spark Wallet
  documentation](https://docs.spark.money/wallet/introduction).
</Info>

### Body

<ParamField body="method" type="string" defaultValue="payLightningInvoice" required>
  Available options: `payLightningInvoice`
</ParamField>

<ParamField body="network" type="string" required>
  Available options: `MAINNET`, `REGTEST`
</ParamField>

<ParamField body="params" type="object" required>
  <Expandable title="child attributes" defaultOpen="true">
    <ParamField body="invoice" type="string" required>
      The BOLT11 Lightning invoice to pay.
    </ParamField>

    <ParamField body="max_fee_sats" type="number" required>
      Maximum fee (in sats) the payer is willing to pay.
    </ParamField>

    <ParamField body="prefer_spark" type="boolean">
      Whether to prefer paying on Spark. If true, will return a Transfer object. Defaults to false.
    </ParamField>

    <ParamField body="amount_sats_to_send" type="number">
      Amount to pay in sats. Required only for zero-amount invoices.
    </ParamField>
  </Expandable>
</ParamField>

### Returns

<ResponseField name="method" type="enum<string>" required>
  Available options: `payLightningInvoice`
</ResponseField>

<ResponseField name="data" type="object" required>
  If `prefer_spark` is false, a `LightningSendRequest` object with the following fields:

  <Expandable title="child attributes" defaultOpen="true">
    <ResponseField name="id" type="string" required />

    <ResponseField name="created_at" type="string" required />

    <ResponseField name="updated_at" type="string" required />

    <ResponseField name="network" type="string" required />

    <ResponseField name="encoded_invoice" type="string" required />

    <ResponseField name="fee" type="object" required>
      <Expandable title="child attributes" defaultOpen="true">
        <ResponseField name="original_value" type="number" />

        <ResponseField name="original_unit" type="string" />

        <ResponseField name="preferred_currency_unit" type="string" />

        <ResponseField name="preferred_currency_value_rounded" type="number" />

        <ResponseField name="preferred_currency_value_approx" type="number" />
      </Expandable>
    </ResponseField>

    <ResponseField name="status" type="string" required />

    <ResponseField name="typename" type="string" required />
  </Expandable>

  If `prefer_spark` is true, the response will be a `Transfer` object with the following fields:

  <Expandable title="child attributes" defaultOpen="true">
    <ResponseField name="id" type="string" required />

    <ResponseField name="sender_identity_public_key" type="string" required />

    <ResponseField name="receiver_identity_public_key" type="string" required />

    <ResponseField name="status" type="string" required />

    <ResponseField name="total_value" type="number" required />

    <ResponseField name="expiry_time" type="string" />

    <ResponseField name="leaves" type="array<object>" required>
      Each item contains transfer metadata and encrypted leaf information.

      <Expandable title="child attributes" defaultOpen="true">
        <ResponseField name="leaf" type="object" required>
          <Expandable title="child attributes" defaultOpen="true">
            <ResponseField name="id" type="string" required />

            <ResponseField name="tree_id" type="string" required />

            <ResponseField name="value" type="number" required />

            <ResponseField name="parent_node_id" type="string" required />

            <ResponseField name="node_tx" type="string" required />

            <ResponseField name="refund_tx" type="string" required />

            <ResponseField name="vout" type="number" required />

            <ResponseField name="verifying_public_key" type="string" required />

            <ResponseField name="owner_identity_public_key" type="string" required />

            <ResponseField name="signing_keyshare" type="object" required>
              <Expandable title="child attributes" defaultOpen="true">
                <ResponseField name="owner_identifiers" type="array<string>" required />

                <ResponseField name="threshold" type="number" required />

                <ResponseField name="public_key" type="string" required />

                <ResponseField name="public_shares" type="object" required>
                  A mapping from signer identifier to public share
                </ResponseField>

                <ResponseField name="updated_time" type="string" required />
              </Expandable>
            </ResponseField>

            <ResponseField name="status" type="string" required />

            <ResponseField name="network" type="string" required />
          </Expandable>
        </ResponseField>

        <ResponseField name="secret_cipher" type="string" required />

        <ResponseField name="signature" type="string" required />

        <ResponseField name="intermediate_refund_tx" type="string" required />
      </Expandable>
    </ResponseField>

    <ResponseField name="created_time" type="string" />

    <ResponseField name="updated_time" type="string" />

    <ResponseField name="type" type="string" />

    <ResponseField name="transfer_direction" type="string" />

    <ResponseField name="encoding" type="string" />
  </Expandable>
</ResponseField>


# signMessageWithIdentityKey
Source: https://docs.privy.io/api-reference/wallets/spark/sign-message-with-identity-key

post /v1/wallets/{wallet_id}/rpc
Sign a message using the Spark wallet's identity key.

<RequestExample>
  ```sh curl --request POST \ theme={"system"}
    --url https://api.privy.io/v1/wallets/{wallet_id}/rpc \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "method": "signMessageWithIdentityKey",
    "network": "MAINNET",
    "params": {
      "message": "Hello, Spark!",
      "compact": true
    }
  }'
  ```
</RequestExample>

<ResponseExample>
  ```json 200 theme={"system"}
  {
    "method": "signMessageWithIdentityKey",
    "data": {
      "signature": "304402201a2b3c4d5e6f708192a3b4c5d6e7f8091a2b3c4d5e6f708192a3b4c5d6e7f80902201a2b3c4d5e6f708192a3b4c5d6e7f8091a2b3c4d5e6f708192a3b4c5d6e7f809"
    }
  }
  ```
</ResponseExample>

### Headers

<ParamField header="privy-app-id" type="string" required>
  ID of your Privy app.
</ParamField>

<ParamField header="privy-authorization-signature" type="string">
  Request authorization signature. If multiple signatures are required, they should be comma
  separated.
</ParamField>

### Path Parameters

<ParamField path="wallet_id" type="string" required>
  ID of the wallet to get.
</ParamField>

<Info>
  These wallet methods are modeled after the [Spark Wallet
  SDK](https://github.com/buildonspark/spark/tree/main/sdks/js/packages/spark-sdk). For more
  information about this wallet method, check out the [Spark Wallet
  documentation](https://docs.spark.money/wallet/introduction).
</Info>

### Body

<ParamField body="method" type="string" defaultValue="signMessageWithIdentityKey" required>
  Available options: `signMessageWithIdentityKey`
</ParamField>

<ParamField body="network" type="string" required>
  Available options: `MAINNET`, `REGTEST`
</ParamField>

<ParamField body="params" type="object" required>
  <Expandable title="child attributes" defaultOpen="true">
    <ParamField body="message" type="string" required>
      The message to sign with the identity key.
    </ParamField>

    <ParamField body="compact" type="boolean">
      Whether to use compact signature format. Defaults to false.
    </ParamField>
  </Expandable>
</ParamField>

### Returns

<ResponseField name="method" type="enum<string>" required>
  Available options: `signMessageWithIdentityKey`
</ResponseField>

<ResponseField name="data" type="object" required>
  The signature response object

  <Expandable title="child attributes" defaultOpen="true">
    <ResponseField name="signature" type="string" required>
      The signature of the message from the wallet's identity key.
    </ResponseField>
  </Expandable>
</ResponseField>


# transfer
Source: https://docs.privy.io/api-reference/wallets/spark/transfer

post /v1/wallets/{wallet_id}/rpc
Transfer satoshis from a Spark wallet to another Spark address.

<RequestExample>
  ```sh curl --request POST \ theme={"system"}
    --url https://api.privy.io/v1/wallets/{wallet_id}/rpc \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "method": "transfer",
    "network": "MAINNET",
    "params": {
      "receiver_spark_address": "sprt1pgss8z35rpycv4duqdk5u3sclhjnztjunv5yajlwk69tyv5fsvwwe9mg8n4d49",
      "amount_sats": 16
    }
  }'
  ```
</RequestExample>

<ResponseExample>
  ```json 200 theme={"system"}
  {
    "method": "transfer",
    "data": {
      "id": "01983eb7-4008-7b73-b269-c0bd86955a1b",
      "sender_identity_public_key": "027bca218b2853d5ff2e9b174370f58107a23df98a759e968c523253c1702dd485",
      "receiver_identity_public_key": "038a3418498655bc036d4e4618fde5312e5c9b284ecbeeb68ab23289831cec9768",
      "status": "TRANSFER_STATUS_SENDER_KEY_TWEAKED",
      "total_value": 16,
      "expiry_time": "1970-01-01T00:00:00.000Z",
      "leaves": [
        {
          "leaf": {
            "id": "01983e38-b2f8-7649-a910-b2be1424de1d",
            "tree_id": "01983e36-e645-7a34-ab95-a6faec210992",
            "value": 16,
            "parent_node_id": "01983e38-b2e2-7edd-9b6b-a784545aa28c",
            "node_tx": "<hex-encoded-tx>",
            "refund_tx": "<hex-encoded-refund>",
            "vout": 0,
            "verifying_public_key": "<pubkey>",
            "owner_identity_public_key": "<pubkey>",
            "signing_keyshare": {
              "owner_identifiers": ["...", "..."],
              "threshold": 2,
              "public_key": "<pubkey>",
              "public_shares": {
                "...": "<pubkey>",
                "...": "<pubkey>"
              },
              "updated_time": "2025-07-24T23:14:14.598Z"
            },
            "status": "TRANSFER_LOCKED",
            "network": "MAINNET"
          },
          "secret_cipher": "<ciphertext>",
          "signature": "<hex>",
          "intermediate_refund_tx": "<hex>"
        }
      ],
      "created_time": "2025-07-24T23:14:14.276Z",
      "updated_time": "2025-07-24T23:14:14.618Z",
      "type": "TRANSFER",
      "transfer_direction": "OUTGOING",
      "encoding": "hex"
    }
  }
  ```
</ResponseExample>

### Headers

<ParamField header="privy-app-id" type="string" required>
  ID of your Privy app.
</ParamField>

<ParamField header="privy-authorization-signature" type="string">
  Request authorization signature. If multiple signatures are required, they should be comma
  separated.
</ParamField>

### Path Parameters

<ParamField path="wallet_id" type="string" required>
  ID of the wallet to get.
</ParamField>

<Info>
  These wallet methods are modeled after the [Spark Wallet
  SDK](https://github.com/buildonspark/spark/tree/main/sdks/js/packages/spark-sdk). For more
  information about this wallet method, check out the [Spark Wallet
  documentation](https://docs.spark.money/wallet/introduction).
</Info>

### Body

<ParamField body="method" type="string" defaultValue="transfer" required>
  Available options: `transfer`
</ParamField>

<ParamField body="network" type="string" required>
  Available options: `MAINNET`, `REGTEST`
</ParamField>

<ParamField body="params" type="object" required>
  <Expandable title="child attributes" defaultOpen="true">
    <ParamField body="receiver_spark_address" type="string" required>
      The Spark address of the recipient.
    </ParamField>

    <ParamField body="amount_sats" type="number" required>
      The amount to send in satoshis.
    </ParamField>
  </Expandable>
</ParamField>

### Returns

<ResponseField name="method" type="enum<string>" required>
  Available options: `transfer`
</ResponseField>

<ResponseField name="data" type="object" required>
  The returned Transfer object

  <Expandable title="child attributes" defaultOpen="true">
    <ResponseField name="id" type="string" required />

    <ResponseField name="sender_identity_public_key" type="string" required />

    <ResponseField name="receiver_identity_public_key" type="string" required />

    <ResponseField name="status" type="string" required />

    <ResponseField name="total_value" type="number" required />

    <ResponseField name="expiry_time" type="string" />

    <ResponseField name="leaves" type="array<object>" required>
      Each item contains transfer metadata and encrypted leaf information.

      <Expandable title="child attributes" defaultOpen="true">
        <ResponseField name="leaf" type="object" required>
          <Expandable title="child attributes" defaultOpen="true">
            <ResponseField name="id" type="string" required />

            <ResponseField name="tree_id" type="string" required />

            <ResponseField name="value" type="number" required />

            <ResponseField name="parent_node_id" type="string" required />

            <ResponseField name="node_tx" type="string" required />

            <ResponseField name="refund_tx" type="string" required />

            <ResponseField name="vout" type="number" required />

            <ResponseField name="verifying_public_key" type="string" required />

            <ResponseField name="owner_identity_public_key" type="string" required />

            <ResponseField name="signing_keyshare" type="object" required>
              <Expandable title="child attributes" defaultOpen="true">
                <ResponseField name="owner_identifiers" type="array<string>" required />

                <ResponseField name="threshold" type="number" required />

                <ResponseField name="public_key" type="string" required />

                <ResponseField name="public_shares" type="object" required>
                  A mapping from signer identifier to public share
                </ResponseField>

                <ResponseField name="updated_time" type="string" required />
              </Expandable>
            </ResponseField>

            <ResponseField name="status" type="string" required />

            <ResponseField name="network" type="string" required />
          </Expandable>
        </ResponseField>

        <ResponseField name="secret_cipher" type="string" required />

        <ResponseField name="signature" type="string" required />

        <ResponseField name="intermediate_refund_tx" type="string" required />
      </Expandable>
    </ResponseField>

    <ResponseField name="created_time" type="string" />

    <ResponseField name="updated_time" type="string" />

    <ResponseField name="type" type="string" />

    <ResponseField name="transfer_direction" type="string" />

    <ResponseField name="encoding" type="string" />
  </Expandable>
</ResponseField>


# transferTokens
Source: https://docs.privy.io/api-reference/wallets/spark/transfer-tokens

post /v1/wallets/{wallet_id}/rpc
Transfer a specified amount of Spark tokens to another Spark address.

<RequestExample>
  ```sh  theme={"system"}
  curl --request POST \
    --url https://api.privy.io/v1/wallets/{wallet_id}/rpc \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "method": "transferTokens",
    "network": "MAINNET",
    "params": {
      "token_identifier": "btknrt1x9helfvakyz8y53lzwt2wjen7d30ft6skpu69eydvndqt5uxsr4q0zvugn",
      "token_amount": 10,
      "receiver_spark_address": "sprt1pgss8z35rpycv4duqdk5u3sclhjnztjunv5yajlwk69tyv5fsvwwe9mg8n4d49"
    }
  }'
  ```
</RequestExample>

<ResponseExample>
  ```json 200 theme={"system"}
  {
    "method": "transferTokens",
    "data": {
      "id": "22c469d0a956b188f7dc058e43515a2c4e675d75edc302b75805d9c5dccaeb6b",
    }
  }
  ```
</ResponseExample>

### Headers

<ParamField header="privy-app-id" type="string" required>
  ID of your Privy app.
</ParamField>

<ParamField header="privy-authorization-signature" type="string">
  Request authorization signature. If multiple signatures are required, they should be comma
  separated.
</ParamField>

### Path Parameters

<ParamField path="wallet_id" type="string" required>
  ID of the wallet to get.
</ParamField>

<Info>
  These wallet methods are modeled after the [Spark Wallet
  SDK](https://github.com/buildonspark/spark/tree/main/sdks/js/packages/spark-sdk). For more
  information about this wallet method, check out the [Spark Wallet
  documentation](https://docs.spark.money/wallet/introduction).
</Info>

### Body

<ParamField body="method" type="string" defaultValue="transferTokens" required>
  Available options: `transferTokens`
</ParamField>

<ParamField body="network" type="string" required>
  Available options: `MAINNET`, `REGTEST`
</ParamField>

<ParamField body="params" type="object" required>
  Parameters for the token transfer.

  <Expandable title="child attributes" defaultOpen="true">
    <ParamField body="token_identifier" type="string" required>
      Spark token address (starts with `btkn`).
    </ParamField>

    <ParamField body="token_amount" type="number" required>
      Number of tokens to send
    </ParamField>

    <ParamField body="receiver_spark_address" type="string" required>
      Spark address to send the tokens to.
    </ParamField>
  </Expandable>
</ParamField>

### Returns

<ResponseField name="method" type="enum<string>" required>
  Always `"transferTokens"`
</ResponseField>

<ResponseField name="data" type="object" required>
  The result of the token transfer.

  <Expandable title="child attributes" defaultOpen="true">
    <ResponseField name="id" type="string" required>
      Transaction hash of the token transfer.
    </ResponseField>
  </Expandable>
</ResponseField>

```
```


# Update wallet
Source: https://docs.privy.io/api-reference/wallets/update

patch /v1/wallets/{wallet_id}
Update a wallet's policies or authorization key configuration.



# Overview
Source: https://docs.privy.io/authentication/overview



Privy's wallet system supports granular controls on who can access wallets and what actions different users can perform.

To enforce these controls, Privy's API must verify the identity of the party requesting a wallet action, ensuring that only authorized actions are executed by the system. This process is known as **authentication**.

Privy supports both **user authentication** and **API authentication** for authenticating access to wallets.

***

## User authentication

Privy is a powerful toolkit for progressive authentication of users. With fine-grained control over onboarding flows and wallet connections, you can improve conversion and craft better UX.

Your app can authenticate users across web2 and web3 accounts, using either your existing authentication provider or Privy's authentication system.

### Using Privy as your authentication provider

If your app doesn't have an existing authentication provider, or would like a single provider for authentication and embedded wallets, you can use Privy's authentication system, which supports both web2 and web3 accounts.

Privy's client-side SDKs offers a variety of authentication methods, including email, SMS, passkey, socials (Google, Apple, Twitter, Farcaster, etc.), any OAuth system, and Ethereum and Solana wallets.

You can also associate multiple authentication methods with a user, allowing them to login to the same account and access the same wallet with whichever method they choose.

### Using your own authentication provider

If your app already has an authentication provider, Privy integrates with your app's [existing authentication system](/authentication/user-authentication/jwt-based-auth/overview). This includes any OIDC compliant authentication system , including OAuth 2.0, Auth0, Firebase, AWS Cognito, and more.

You can integrate your existing authentication provider with Privy via the REST API or any of Privy's client-side SDKs.

***

## API authentication

With **API authentication**, Privy authenticates a request from your server directly using an **API secret**. This ensures that Privy only executes requests sent by your servers alone, and no other party.

In addition to the API secret, you can also configure **authorization keys** that control specific wallets, policies, and other resources. Any requests to use or update these resources require a signature from the corresponding authorization key. This allows you to enforce granular controls on all Privy resources.

***

## Get started

<CardGroup>
  <Card title="Login users with their email" icon="envelope" href="/authentication/user-authentication/login-methods/email">
    Authenticate users using just their email address and a one-time passcode.
  </Card>

  <Card title="Login with metamask" icon="wallet" href="/authentication/user-authentication/login-methods/wallet">
    Authenticate users with their externally owned Ethereum or Solana wallets.
  </Card>

  <Card title="Enable MFA" icon="key" href="/authentication/user-authentication/mfa">
    Add an extra layer of security to user accounts with multi-factor authentication.
  </Card>

  <Card title="Seamless Farcaster Mini App login" icon="frame" href="/recipes/farcaster/mini-apps">
    Allow your users to sign into your Farcaster Mini App seamlessly with Privy.
  </Card>
</CardGroup>


# Access tokens
Source: https://docs.privy.io/authentication/user-authentication/access-tokens



When a user logs in to your app and becomes **authenticated**, Privy issues the user an app **access token**. This token is signed by Privy and cannot be spoofed.

When your frontend makes a request to your backend, you should include the current user's access token in the request. This allows your server to determine whether the requesting user is truly authenticated or not.

<Note>
  Looking to access user data? Check out our [Identity
  tokens](/user-management/users/identity-tokens#identity-tokens).
</Note>

***

## Access token format

Privy access tokens are [JSON Web Tokens (JWT)](https://jwt.io/introduction), signed with the ES256 algorithm. These JWTs include certain information about the user in their claims, namely:

<Expandable title="properties">
  <ResponseField name="sid" type="string">
    The user's current session ID
  </ResponseField>

  <ResponseField name="sub" type="string">
    The user's Privy DID
  </ResponseField>

  <ResponseField name="iss" type="string">
    The token issuer, which should always be [privy.io](https://privy.io)
  </ResponseField>

  <ResponseField name="aud" type="string">
    Your Privy app ID
  </ResponseField>

  <ResponseField name="iat" type="number">
    The timestamp of when the JWT was issued
  </ResponseField>

  <ResponseField name="exp" type="number">
    The timestamp of when the JWT will expire and is no longer valid. This is generally 1 hour after
    the JWT was issued.
  </ResponseField>
</Expandable>

<Info>
  Read more about Privy's tokens and their security in our [security
  guide](/security/authentication/user-authentication).
</Info>

***

## Sending the access token

### Accessing the token from your client

To include the current user's access token in requests from your frontend to your backend, you'll first need to retrieve it, then send it appropriately.

<Tabs>
  <Tab title="React">
    You can get the current user's Privy token as a string using the **`getAccessToken`** method from the **`usePrivy`** hook. This method will also automatically refresh the user's access token if it is nearing expiration or has expired.

    ```tsx  theme={"system"}
    const { getAccessToken } = usePrivy();
    const accessToken = await getAccessToken();
    ```

    If you need to get a user's Privy token *outside* of Privy's React context, you can directly import the **`getAccessToken`** method:

    ```tsx  theme={"system"}
    import { getAccessToken } from '@privy-io/react-auth';

    const authToken = await getAccessToken();
    ```

    <Warning>
      When using direct imports, you must ensure **`PrivyProvider`** has rendered before invoking the method.
      Whenever possible, you should retrieve **`getAccessToken`** from the **`usePrivy`** hook.
    </Warning>
  </Tab>

  <Tab title="React Native">
    In React Native, you can use the `getAccessToken` method from the `PrivyClient` instance to retrieve the user's access token.

    ```tsx  theme={"system"}
    const privy = createPrivyClient({
      appId: '<your-privy-app-id>',
      clientId: '<your-privy-app-client-id>'
    });
    const accessToken = await privy.getAccessToken();
    ```
  </Tab>

  <Tab title="Swift">
    In Swift, you can use the `getAccessToken` method on the PrivyUser object to retrieve the user's access token.

    ```swift  theme={"system"}
    // Check if user is authenticated
    guard let user = privy.user else {
      // If user is nil, user is not authenticated
      return
    }

    // Get the access token
    do {
      let accessToken = try await user.getAccessToken()
      print("Access token: \(accessToken)")
    } catch {
      // Handle error appropriately
    }
    ```
  </Tab>

  <Tab title="Android">
    In Android, you can use the `getAccessToken` method on the PrivyUser object to retrieve the user's access token.

    ```kotlin  theme={"system"}
    // Check if user is authenticated
    val user = privy.user
    if (user != null) {

      // Get the access token
      val result: Result<String> = user.getAccessToken()

      // Handle the result with fold method
      result.fold(
          onSuccess = { accessToken ->
              println("Access token: $accessToken")
          },
          onFailure = { error ->
              // Handle error appropriately
          },
      )
    }
    ```
  </Tab>

  <Tab title="Flutter">
    In Flutter, you can use the `getAccessToken` method on the PrivyUser object to retrieve the user's access token.

    ```dart  theme={"system"}
    // Check if user is authenticated
    final user = privy.user;
    if (user != null) {

      // Get the access token
      final result = await privy.user.getAccessToken();

      // Handle the result with fold method
      result.fold(
        onSuccess: (accessToken) {
          print('Access token: $accessToken');
        },
        onError: (error) {
          // Handle error appropriately
        },
      );
    }
    ```
  </Tab>

  <Tab title="Unity">
    In Unity, you can use the `GetAccessToken` method on the `PrivyUser` instance to retrieve the user's access token.

    ```csharp  theme={"system"}
    // User will be null if no user is authenticated
    PrivyUser user = PrivyManager.Instance.User;
    if (user != null) {
      string accessToken = await user.GetAccessToken();
      Debug.Log(accessToken);
    }
    ```
  </Tab>
</Tabs>

<Info>
  If your app is configured to use HTTP-only cookies (instead of the default local storage), the
  access token will automatically be included in the cookies for requests to the same domain. In
  this case, you don't need to manually include the token in the request headers.
</Info>

### Using the access token with popular libraries

When sending requests to your backend, here's how you can include the access token with different HTTP client libraries:

<Tabs>
  <Tab title="fetch">
    ```tsx  theme={"system"}
    // For bearer token approach (when using local storage)
    const accessToken = await getAccessToken();
    const response = await fetch('<your-api-endpoint>', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(data)
    });

    // For HTTP-only cookies approach
    const response = await fetch('<your-api-endpoint>', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      credentials: 'include', // This includes cookies automatically
      body: JSON.stringify(data)
    });
    ```
  </Tab>

  <Tab title="axios">
    ```tsx  theme={"system"}
    import axios from 'axios';

    // For bearer token approach (when using local storage)
    const accessToken = await getAccessToken();
    const response = await axios({
      method: 'post',
      url: '<your-api-endpoint>',
      headers: {
        'Authorization': `Bearer ${accessToken}`
      },
      data: data
    });

    // For HTTP-only cookies approach
    const response = await axios({
      method: 'post',
      url: '<your-api-endpoint>',
      withCredentials: true, // This includes cookies automatically
      data: data
    });
    ```
  </Tab>

  <Tab title="ofetch">
    ```tsx  theme={"system"}
    import { ofetch } from 'ofetch';

    // For bearer token approach (when using local storage)
    const accessToken = await getAccessToken();
    const response = await ofetch('<your-api-endpoint>', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${accessToken}`
      },
      body: data
    });

    // For HTTP-only cookies approach
    const response = await ofetch('<your-api-endpoint>', {
      method: 'POST',
      credentials: 'include', // This includes cookies automatically
      body: data
    });
    ```
  </Tab>
</Tabs>

***

## Getting the access token

### Accessing the token from your server

When your server receives a request, the location of the user's access token depends on whether your app uses **local storage** (the default) or **cookies** to manage user sessions.

<Expandable title="local storage setup">
  If you're using local storage for session management, the access token will be passed in the `Authorization` header of the request with the `Bearer` prefix. You can extract it like this:

  <Tabs>
    <Tab title="NodeJS">
      ```tsx  theme={"system"}
      // Example for Express.js
      const accessToken = req.headers.authorization?.replace('Bearer ', '');

      // Example for Next.js API route
      const accessToken = req.headers.authorization?.replace('Bearer ', '');

      // Example for Next.js App Router
      const accessToken = headers().get('authorization')?.replace('Bearer ', '');
      ```
    </Tab>

    <Tab title="Go">
      ```go  theme={"system"}
      // Example for Go
      accessToken := r.Header.Get("Authorization")
      accessToken = strings.Replace(accessToken, "Bearer ", "", 1)
      ```
    </Tab>

    <Tab title="Python">
      ```python  theme={"system"}
      # Example for Python
      accessToken = request.headers.get("Authorization")
      accessToken = accessToken.replace("Bearer ", "")
      ```
    </Tab>
  </Tabs>
</Expandable>

<Expandable title="cookie setup">
  If you're using HTTP-only cookies for session management, the access token will be automatically included in the `privy-token` cookie. You can extract it like this:

  <Tabs>
    <Tab title="NodeJS">
      ```tsx  theme={"system"}
      // Example for Express.js
      const accessToken = req.cookies['privy-token'];

      // Example for Next.js API route
      const accessToken = req.cookies['privy-token'];

      // Example for Next.js App Router
      const cookieStore = cookies();
      const accessToken = cookieStore.get('privy-token')?.value;
      ```
    </Tab>

    <Tab title="Go">
      ```go  theme={"system"}
      // Example for Go
      accessToken := r.Cookies["privy-token"]
      ```
    </Tab>

    <Tab title="Python">
      ```python  theme={"system"}
      # Example for Python
      accessToken = request.cookies.get("privy-token")
      ```
    </Tab>
  </Tabs>
</Expandable>

## Verifying the access token

Once you've obtained the user's access token from a request, you should verify the token against Privy's **verification key** for your app to confirm that the token was issued by Privy and the user referenced by the DID in the token is truly authenticated.

The access token is a standard [ES256](https://datatracker.ietf.org/doc/html/rfc7518#section-3.1) [JWT](https://jwt.io) and the verification key is a standard [Ed25519](https://en.wikipedia.org/wiki/EdDSA#Ed25519) public key. You can verify the access token against the public key using the **`@privy-io/node`** or **`@privy-io/server-auth`** libraries or using a third-party library for managing tokens.

<Tabs>
  <Tab title="NodeJS">
    ### Using Privy SDK

    Pass the user's access token as a `string` to the **`PrivyClient`**'s **`verifyAuthToken`** method:

    <CodeGroup>
      ```ts @privy-io/node theme={"system"}
      // `privy` refers to an instance of the `PrivyClient`
      try {
        const verifiedClaims = await privy.utils().auth().verifyAuthToken(authToken);
      } catch (error) {
        console.log(`Token verification failed with error ${error}.`);
      }
      ```

      ```ts @privy-io/server-auth theme={"system"}
      // `privy` refers to an instance of the `PrivyClient`
      try {
        const verifiedClaims = await privy.verifyAuthToken(authToken);
      } catch (error) {
        console.log(`Token verification failed with error ${error}.`);
      }
      ```
    </CodeGroup>

    If the token is valid, **`verifyAuthToken`** will return an object with additional information about the request, with the fields below:

    | Parameter    | Type     | Description                                                                   |
    | ------------ | -------- | ----------------------------------------------------------------------------- |
    | `appId`      | `string` | Your Privy app ID.                                                            |
    | `userId`     | `string` | The authenticated user's Privy DID. Use this to identify the requesting user. |
    | `issuer`     | `string` | This will always be `'privy.io'`.                                             |
    | `issuedAt`   | `number` | Unix timestamp for when the access token was signed by Privy.                 |
    | `expiration` | `number` | Unix timestamp for when the access token will expire.                         |
    | `sessionId`  | `string` | Unique identifier for the user's session.                                     |

    If the token is invalid, **`verifyAuthToken`** will throw an error and you should **not** consider the requesting user authorized. This generally occurs if the token has expired or is invalid (e.g. corresponds to a different app ID).

    <Tip>
      The Privy Client's `verifyAuthToken` method will make a request to Privy's API to fetch the verification key for your app.
      You can avoid this API request by copying your verification key from the **Configuration > App settings** page of the [**Dashboard**](https://dashboard.privy.io).

      <CodeGroup>
        ```ts @privy-io/node theme={"system"}
        const privy = new PrivyClient({
          appId: 'your-privy-app-id',
          apiKey: 'your-privy-api-key',
          // Set the copied verification key to use when creating the `PrivyClient`
          jwtVerificationKey: 'paste-your-verification-key-from-the-dashboard'
        });

        const verifiedClaims = await privy.utils().auth().verifyAuthToken(
          authToken
        );
        ```

        ```ts @privy-io/server-auth theme={"system"}
        const verifiedClaims = await privy.verifyAuthToken(
          authToken,
          // Pass the copied verification key as the second parameter here.
          'paste-your-verification-key-from-the-dashboard'
        );
        ```
      </CodeGroup>
    </Tip>

    ### Using JavaScript libraries

    You can also use common JavaScript libraries to verify tokens:

    <Tabs>
      <Tab title="jose">
        To start, install `jose`:

        ```sh  theme={"system"}
        npm i jose
        ```

        Then, load your Privy public key using [`jose.importSPKI`](https://github.com/panva/jose/blob/main/docs/functions/key_import.importSPKI.md):

        ```tsx  theme={"system"}
        const verificationKey = await jose.importSPKI(
          "insert-your-privy-verification-key",
          "ES256"
        );
        ```

        Lastly, using [`jose.jwtVerify`](https://github.com/panva/jose/blob/main/docs/functions/jwt_verify.jwtVerify.md), verify that the JWT is valid and was issued by Privy!

        ```tsx  theme={"system"}
        const accessToken = "insert-the-users-access-token";
        try {
          const payload = await jose.jwtVerify(accessToken, verificationKey, {
            issuer: "privy.io",
            audience: "insert-your-privy-app-id",
          });
          console.log(payload);
        } catch (error) {
          console.error(error);
        }
        ```

        If the JWT is valid, you can extract the JWT's claims from the [`payload`](https://github.com/panva/jose/blob/main/docs/interfaces/types.JWTPayload.md). For example, you can use `payload.sub` to get the user's Privy DID.

        If the JWT is invalid, this method will throw an error.
      </Tab>

      <Tab title="jsonwebtoken">
        To start, install `jsonwebtoken`:

        ```sh  theme={"system"}
        npm i jsonwebtoken
        ```

        Then, load your Privy public key as a string.

        ```tsx  theme={"system"}
        const verificationKey = "insert-your-privy-verification-key".replace(
          /\\n/g,
          "\n"
        );
        ```

        The `replace` operation above ensures that any instances of `'\n'` in the stringified public key are replaced with actual newlines, per the PEM-encoded format.

        Lastly, verify the JWT using [`jwt.verify`](https://github.com/auth0/node-jsonwebtoken#jwtverifytoken-secretorpublickey-options-callback):

        ```tsx  theme={"system"}
        const accessToken = 'insert-the-user-access-token-from-request';
        try {
          const decoded = jwt.verify(accessToken, verificationKey, {
            issuer: 'privy.io',
            audience: /* your Privy App ID */
          });
          console.log(decoded);
        } catch (error) {
          console.error(error);
        }
        ```

        If the JWT is valid, you can extract the JWT's claims from `decoded`. For example, you can use `decoded.sub` to get the user's Privy DID.

        If the JWT is invalid, this method will throw an error.
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Go">
    For Go, the [`golang-jwt`](https://github.com/golang-jwt/jwt) library is a popular choice for token verification. To start, install the library:

    ```sh  theme={"system"}
    go get -u github.com/golang-jwt/jwt/v5
    ```

    Next, load your Privy verification key and app ID as strings:

    ```go  theme={"system"}
    verificationKey := "insert-your-privy-verification-key"
    appId := "insert-your-privy-app-id"
    ```

    Then, parse the claims from the JWT and verify that they are valid:

    ```go  theme={"system"}
    accessToken := "insert-the-users-access-token"

    // Defining a Go type for Privy JWTs
    type PrivyClaims struct {
      AppId      string `json:"aud,omitempty"`
      Expiration uint64 `json:"exp,omitempty"`
      Issuer     string `json:"iss,omitempty"`
      UserId     string `json:"sub,omitempty"`
    }

    // This method will be used to check the token's claims later
    func (c *PrivyClaims) Valid() error {
      if c.AppId != appId {
        return errors.New("aud claim must be your Privy App ID.")
      }
      if c.Issuer != "privy.io" {
        return errors.New("iss claim must be 'privy.io'")
      }
      if c.Expiration < uint64(time.Now().Unix()) {
        return errors.New("Token is expired.");
      }

      return nil
    }

    // This method will be used to load the verification key in the required format later
    func keyFunc(token *jwt.Token) (interface{}, error) {
      if token.Method.Alg() != "ES256" {
        return nil, fmt.Errorf("Unexpected JWT signing method=%v", token.Header["alg"])
      }
        // https://pkg.go.dev/github.com/dgrijalva/jwt-go#ParseECPublicKeyFromPEM
      return jwt.ParseECPublicKeyFromPEM([]byte(verificationKey)), nil
    }

    // Check the JWT signature and decode claims
    // https://pkg.go.dev/github.com/dgrijalva/jwt-go#ParseWithClaims
    token, err := jwt.ParseWithClaims(accessToken, &PrivyClaims{}, keyFunc)
    if err != nil {
        fmt.Println("JWT signature is invalid.")
    }

    // Parse the JWT claims into your custom struct
    privyClaim, ok := token.Claims.(*PrivyClaims)
    if !ok {
        fmt.Println("JWT does not have all the necessary claims.")
    }

    // Check the JWT claims
    err = Valid(privyClaim);
    if err {
        fmt.Printf("JWT claims are invalid, with error=%v.", err);
        fmt.Println();
    } else {
        fmt.Println("JWT is valid.")
        fmt.Printf("%v", privyClaim)
    }
    ```

    If the JWT is valid, you can access its claims, including the user's DID, from the `privyClaim` struct above.

    If the JWT is invalid, an error will be thrown.
  </Tab>

  <Tab title="Rust">
    For Rust, the [`jsonwebtoken`](https://github.com/Keats/jsonwebtoken) crate is a popular choice for token verification. To start, add it to your dependencies:

    ```toml  theme={"system"}
    [dependencies]
    jsonwebtoken = "9"
    serde = { version = "1.0", features = ["derive"] }
    ```

    Next, load your Privy verification key and app ID as strings:

    ```rust  theme={"system"}
    let verification_key = "insert-your-privy-verification-key";
    let app_id = "insert-your-privy-app-id";
    ```

    Then, parse the claims from the JWT and verify that they are valid:

    ```rust  theme={"system"}
    use jsonwebtoken::{decode, DecodingKey, Validation, Algorithm};
    use serde::{Deserialize, Serialize};

    let access_token = "insert-the-users-access-token";

    // Defining a Rust struct for Privy JWTs
    #[derive(Debug, Serialize, Deserialize)]
    struct PrivyClaims {
        aud: String, // App ID
        exp: u64,    // Expiration timestamp
        iss: String, // Issuer
        sub: String, // User ID (Privy DID)
        sid: String, // Session ID
        iat: u64,    // Issued at timestamp
    }

    // Configure validation settings
    let mut validation = Validation::new(Algorithm::ES256);
    validation.set_issuer(&["privy.io"]);
    validation.set_audience(&[app_id]);

    // Parse the verification key
    let decoding_key = DecodingKey::from_ec_pem(verification_key.as_bytes())?;

    // Verify the JWT and decode claims
    match decode::<PrivyClaims>(&access_token, &decoding_key, &validation) {
        Ok(token_data) => {
            let claims = token_data.claims;
            println!("JWT is valid");
            println!("User ID: {}", claims.sub);
            println!("App ID: {}", claims.aud);
            println!("Session ID: {}", claims.sid);

            // Use the claims for your application logic
        }
        Err(err) => {
            eprintln!("JWT verification failed: {}", err);
            // Handle invalid token
        }
    }
    ```

    If the JWT is valid, you can access its claims, including the user's DID, from the `claims` struct above.

    If the JWT is invalid, an error will be returned with details about what went wrong.
  </Tab>

  <Tab title="Python">
    For Python, use the `verify_access_token` method to verify the access token and get the user's claims.

    ```python  theme={"system"}
    from privy import PrivyAPI

    client = PrivyAPI(app_id="your-privy-app-id", app_secret="your-privy-api-key")
    try:
        user = client.users.verify_access_token(access_token)
        print(user)
    except Exception as e:
        print(e)
    ```

    If the token is valid, **`verify_access_token`** will return an **`AccessTokenClaims`** object with additional information about the request, with the fields below:

    | Parameter    | Type     | Description                                                                   |
    | ------------ | -------- | ----------------------------------------------------------------------------- |
    | `app_id`     | `string` | Your Privy app ID.                                                            |
    | `user_id`    | `string` | The authenticated user's Privy DID. Use this to identify the requesting user. |
    | `issuer`     | `string` | This will always be `'privy.io'`.                                             |
    | `issued_at`  | `string` | Timestamp for when the access token was signed by Privy.                      |
    | `expiration` | `string` | Timestamp for when the access token will expire.                              |
    | `session_id` | `string` | Unique identifier for the user's session.                                     |

    If the token is invalid, **`verify_access_token`** will throw an exception and you should **not** consider the requesting user authorized. This generally occurs if the token has expired or is invalid (e.g. corresponds to a different app ID).

    <Tip>
      The Privy Client's `verify_access_token` method will make a request to Privy's API to fetch the verification key for your app. You can avoid this API request by copying your verification key from the **Configuration > App settings** page of the [**Dashboard**](https://dashboard.privy.io) and passing it as a second parameter to `verify_access_token`:

      ```python  theme={"system"}
      user = client.users.verify_access_token(
        access_token,
        'paste-your-verification-key-from-the-dashboard'
      )
      ```
    </Tip>
  </Tab>
</Tabs>

## Managing expired access tokens

A user's access token might expire while they are actively using your app. For example, if a user does not take action on an application for an extended period of time, the access token can become expired.

* **Handle invalid token errors**: In these scenarios, if a method returns with an **`'invalid auth token'`** error, we recommend calling the **`getAccessToken`** method with a time-based backoff until the user's access token is refreshed with an updated expiration time.
* **Return errors from backend**: If you receive an expired access token in your backend, return an error to your client, and as above, trigger **`getAccessToken`** in your client.
* **Handle failed refreshes**: If the user's access token cannot be refreshed, the user will be logged out.


# Authentication state
Source: https://docs.privy.io/authentication/user-authentication/authentication-state



Throughout your app, you may want to gate certain user experiences based on whether the current user is authenticated or not. Privy makes it easy to check your user's authentication status and handle it appropriately.

<Tabs>
  <Tab title="React">
    You can use the boolean `authenticated` from the `usePrivy` hook to determine if your user is authenticated or not.

    ```tsx  theme={"system"}
    authenticated: boolean;
    ```

    <Tip>
      Before determining a user's auth status from Privy, you should verify that
      Privy has fully initialized and is **`ready`**
    </Tip>

    ### Usage

    ```tsx  theme={"system"}
    import { useRouter } from "next/router";

    import { usePrivy } from "@privy-io/react-auth";

    export default function MyComponent() {
    const { ready, authenticated, user } = usePrivy();
    const router = useRouter();

    if (!ready) {
        // Do nothing while the PrivyProvider initializes with updated user state
        return <></>;
    }

    if (ready && !authenticated) {
        // Replace this code with however you'd like to handle an unauthenticated user
        // As an example, you might redirect them to a login page
        router.push("/login");
    }

    if (ready && authenticated) {
        // Replace this code with however you'd like to handle an authenticated user
        return <p>User {user?.id} is logged in.</p>;
    }
    }
    ```
  </Tab>

  <Tab title="React Native">
    You can use the `user` object from the `usePrivy` hook to determine if your user is authenticated or not.

    ```tsx  theme={"system"}
    user: User | null;
    ```

    ### Usage

    ```tsx  theme={"system"}
    import { useRouter } from "expo-router";
    import { usePrivy } from "@privy-io/expo";
    import { useEffect } from "react";
    import { Text, View } from "react-native";

    export default function MyComponent() {
      const { isReady, user } = usePrivy();
      const router = useRouter();

      useEffect(() => {
        if (isReady && !user) {
          // Replace this code with however you'd like to handle an unauthenticated user
          // As an example, you might redirect them to a login page
          router.replace("/login");
        }
      }, [isReady, user, router]);

      if (!isReady) {
        // Do nothing while the PrivyProvider initializes with updated user state
        return null;
      }

      if (isReady && !user) {
        // You could show a loading state or handle this differently
        return <Text>Not authenticated</Text>;
      }

      if (isReady && user) {
        // Replace this code with however you'd like to handle an authenticated user
        return (
          <View>
            <Text>User {user.id} is logged in.</Text>
          </View>
        );
      }
    }
    ```
  </Tab>

  <Tab title="Swift">
    The `AuthState` enum is used to describe the user's authenticated state.

    ```swift  theme={"system"}
    public enum AuthState {
      /// AuthState has not been determined yet, show loading
      case notReady

      /// User is unauthenticated
      case unauthenticated

      /// Auth state cannot be determined while no network connectivity is available, but session tokens exist in cache
      case authenticatedUnverified(AuthenticatedUnverifiedContext)

      /// User is authenticated and has an associated PrivyUser object
      case authenticated(PrivyUser)
    }
    ```

    ### Handling no network connectivity at SDK initialization:

    When the Privy SDK is initialized while there is no network connectivity, Privy will first check if a prior user session is persisted.

    If there is not, the auth state will be set to  `AuthState.unauthenticated`.

    If there is, Privy can't verify that validity of the prior session without network connectivity. Thus, the auth state will be set to  `AuthState.authenticatedUnverified`.

    Privy will automatically attempt to confirm the user's authenticated state when network connectivity is restored. Alternatively, you may explicitly call
    `Privy.onNetworkRestored()` once you determine network is restored.

    ### Usage

    There are various ways to determine user's auth state, outlined below:

    #### 1. Grab the user's current auth state

    ```swift  theme={"system"}
    public protocol Privy {
      /// Get the user's current auth state.
      func getAuthState() async -> AuthState
    }
    ```

    ```swift  theme={"system"}
    // Grab current auth state
    if case .authenticated(let user) = await privy.getAuthState() {
      // User is authenticated. Grab the user's linked accounts
      let linkedAccounts = user.linkedAccounts
    }
    ```

    #### 2. Subscribe to auth state updates

    Auth state is exposed as an AsyncStream on the Privy object:

    ```swift  theme={"system"}
    public protocol Privy {
      /// An AsyncStream that emits auth state changes.
      var authStateStream: AsyncStream<AuthState> { get }
    }
    ```

    ```swift  theme={"system"}
      let task = Task {
        for await authState in privy.authStateStream {
          switch authState {
            case .authenticated(let user):
              // User is authenticated. Grab the user's linked accounts
              let linkedAccounts = user.linkedAccounts
            case .notReady:
              // Privy was just initialized and has not determined auth state yet
            case .authenticatedUnverified:
              // Prior user session exists, but can't be refreshed / verified. Likely due to network connectivity.
            case .unauthenticated:
              // User in not authenticated. Perhaps show login screen.
          }
        }
      }
    ```

    #### 3. Directly grab the User

    As a convenience, you can grab the user object directly from the Privy instance. If the user is not null, there is an authenticated user.

    ```swift  theme={"system"}
    let privyUser = await privy.getUser()

    if (privyUser != null) {
      // User is authenticated
      let linkedAccounts = privyUser.linkedAccounts
    }
    ```
  </Tab>

  <Tab title="Android">
    The `AuthState` sealed type is used to describe the user's authenticated state.

    ```kotlin  theme={"system"}
    public sealed interface AuthState {
      // AuthState has not been determined yet, show loading
      public data object NotReady : AuthState

      // User is unauthenticated
      public data object Unauthenticated : AuthState

      // Auth state cannot be determined while no network connectivity is available, but session tokens exist in cache
      public data class AuthenticatedUnverified(/* */) : AuthState

      // User is authenticated and has an associated PrivyUser object
      public data class Authenticated(val user: PrivyUser) : AuthState
    }
    ```

    ### Handling no network connectivity at SDK initialization:

    When the Privy SDK is initialized while there is no network connectivity, Privy will first check if a prior user session is persisted.

    If there is not, auth state will be set to  `AuthState.Unauthenticated`.

    If there is, Privy can't verify that validity of the prior session without network connectivity. Thus, auth state will be set to  `AuthState.AuthenticatedUnverified`.

    Privy will automatically attempt to confirm the user's authenticated state when network connectivity is restored. Alternatively, you may explicitly call
    `Privy.onNetworkRestored()` once you determine network is restored.

    ### Usage

    There are various ways to determine a user's auth state:

    #### 1. Grab the user's current auth state

    ```kotlin  theme={"system"}
    coroutineScope.launch {
      val authState = privy.getAuthState()

      if (authState is AuthState.Authenticated) {
        // User is authenticated. Grab the user's linked accounts
        val privyUser = currentAuthState.user
        val linkedAccount = privyUser.linkedAccounts
      }
    }
    ```

    #### 2. Subscribe to auth state updates

    Auth state is exposed as a StateFlow on the Privy object:

    ```kotlin  theme={"system"}
    public interface Privy {
     // A state flow that can be subscribed to for auth state updates
     public val authState: StateFlow<AuthState>
    }
    ```

    ```kotlin  theme={"system"}
    coroutineScope.launch {
        privy.authState.collectLatest { authState ->
            when(authState) {
                is AuthState.Authenticated -> {
                    // User is authenticated. Grab the user's linked accounts
                    val privyUser = authState.user
                    val linkedAccounts = privyUser.linkedAccounts
                }
                AuthState.NotReady -> {
                    // Privy was just initialized and has not determined auth state yet
                }
                is AuthState.AuthenticatedUnverified -> {
                    // Prior user session exists, but can't be verified due to no network connectivity.
                }
                AuthState.Unauthenticated -> {
                    // User in not authenticated. Perhaps show login screen.
                }
            }
        }
    }
    ```

    #### 3. Directly grab the User

    As a convenience, you can grab the user object directly from the Privy instance. If the user is not null, there is an authenticated user.

    ```kotlin  theme={"system"}
    coroutineScope.launch {
      val privyUser = privy.getUser()

      if (privyUser != null) {
        // User is authenticated
        val linkedAccounts = privyUser.linkedAccounts
      }
    }
    ```
  </Tab>

  <Tab title="Unity">
    The `AuthState` enum is used to describe the user's authenticated state.

    ```csharp  theme={"system"}
    public enum AuthState
    {
        NotReady, // Privy has not yet finished initializing
        Unauthenticated, // User is unauthenticated
        Authenticated // User is authenticated
    }
    ```

    ### Usage

    There are various ways to determine a user's auth state, outlined below:

    #### 1. Grab the user's current auth state

    ```csharp  theme={"system"}
    public interface IPrivy {
      // Get the user's current authentication state.
      Task<AuthState> GetAuthState();
    }
    ```

    ```csharp  theme={"system"}
    var authState = await PrivyManager.Instance.GetAuthState();
    Debug.Log(authState);
    ```

    #### 2. Subscribe to auth state updates

    You can also subscribe to `AuthState` updates via the `SetAuthStateChangeCallback` listener.

    ```csharp  theme={"system"}
    public interface IPrivy {
      // Sets a callback method to be invoked when the authentication state changes.
      void SetAuthStateChangeCallback(Action<AuthState> callback);
    }
    ```

    ```csharp  theme={"system"}
    PrivyManager.Instance.SetAuthStateChangeCallback(authState =>
    {
        // User's authentication state has updated
        Debug.Log(authState);
    });
    ```

    #### 3. Directly grab the User

    As a convenience, you can grab the user object directly from the Privy instance.
    If the user is not null, there is an authenticated user.

    ```csharp  theme={"system"}
    public interface IPrivy {
      // Get the current user.
      Task<PrivyUser> GetUser();
    }
    ```

    ```csharp  theme={"system"}
    var privyUser = await PrivyManager.Instance.GetUser();

    if (privyUser != null)
    {
      var linkedAccounts = privyUser.LinkedAccounts;
    }
    ```
  </Tab>

  <Tab title="Flutter">
    A user's authentication state is described by the AuthState sealed class.

    ```dart  theme={"system"}
    /// Base class representing different authentication states.
    sealed class AuthState {
      const AuthState();
    }

    /// Represents the initial state before authentication status is determined.
    class NotReady extends AuthState {
      const NotReady();
    }

    /// Represents the state when the user is not authenticated.
    class Unauthenticated extends AuthState {
      const Unauthenticated();
    }

    /// Represents the state when the user is authenticated.
    class Authenticated extends AuthState {
      final PrivyUser user;

      /// Constructor accepting the authenticated user's details.
      const Authenticated(this.user);
    }
    ```

    The current auth state and an auth state stream are accessible directly on the Privy object.

    ```dart  theme={"system"}
    abstract interface class Privy {
      // Get the current authentication state.
      AuthState get currentAuthState;

      // A stream for auth state updates.
      Stream<AuthState> get authStateStream;
    }
    ```

    ### Accessing authentication state

    There are various ways to determine user's auth state, outlined below. Mix and match to fit the needs of your application.

    #### 1. Directly retrieve the user

    As a convenience, you can grab the user object directly from the Privy instance. If the user is not null, there is an authenticated user.

    ```dart  theme={"system"}
    final privyUser = privy.user;

    if (privyUser != null) {
      // User is authenticated
      final linkedAccounts = privyUser.linkedAccounts;
    }
    ```

    #### 2. Retrieve the current auth state

    ```dart  theme={"system"}
    // Grab current auth state
    final currentAuthState = privy.currentAuthState;

    if (currentAuthState is Authenticated) {
      // User is authenticated. Retrieve the associated user from the auth state.
      final privyUser = currentAuthState.user;
      final linkedAccounts = privyUser.linkedAccounts;
    }
    ```

    #### 3. Subscribe to auth state updates

    ```dart  theme={"system"}
    privy.authStateStream.listen((authState) {
      switch (authState) {
        case Authenticated():
          // User is authenticated. Retrieve the user.
          final privyUser = authState.user;
          final userId = privyUser.linkedAccounts;
          break;
        case NotReady():
          // Privy is not yet ready. Ensure Privy is initialized first.
          break;
        case Unauthenticated():
          // User is not authenticated. You may want to show the login screen.
          break;
      }
    });
    ```
  </Tab>
</Tabs>


# Captcha on login
Source: https://docs.privy.io/authentication/user-authentication/captcha



Privy supports adding CAPTCHA to your login flow to prevent botting.

<Tip>
  Enable CAPTCHA in the [Privy
  Dashboard](https://dashboard.privy.io/apps?page=settings\&setting=advanced) before implementing
  this feature.
</Tip>

Once CAPTCHA is enabled, import the `Captcha` component and place it as a peer to your login form: *(When this component mounts, it will execute the invisible Captcha.)*

<Tabs>
  <Tab title="React">
    ```tsx  theme={"system"}
    import {Captcha, useLoginWithEmail} from '@privy-io/react-auth';

    const MyLoginForm = () => {
      const [email, setEmail] = useState('');
      const {sendCode, loginWithCode} = useLoginWithEmail();

      const handleSendCode = async () => {
        try {
          await sendCode(email);
        } catch (err) {
          // Captcha failures due to timeout or otherwise will show up here
          // in addition to possible network errors from the sendCode request
          //
          // The `sendCode` method from `useLoginWithSms` and `initOAuth` method
          // from `useLoginWithOAuth` work exactly the same way.
        }
      };

      return (
        <>
          <input type="text" onChange={(e) => setEmail(e.target.value)} />
          <button onClick={handleSendCode}>Send Code</button>
          <Captcha />
        </>
      );
    };
    ```
  </Tab>
</Tabs>

**That's it! Whenever a user tries to log into your app, Privy will pre-validate the attempt with an invisible captcha.** 🎉

<Info>
  Currently only Cloudflare's [Turnstile](https://www.cloudflare.com/products/turnstile/) is
  supported as a Captcha provider.
</Info>


# Using your own authentication provider
Source: https://docs.privy.io/authentication/user-authentication/jwt-based-auth/overview



Privy supports all JWT-based authentication providers. This includes any OIDC compliant authentication system, including OAuth 2.0, Auth0, Firebase, AWS Cognito, and more.

Using JWT-based authentication integration, you can use your existing authentication system with Privy's services. This approach allows users to maintain their existing login experience while giving them access to embedded wallets.

Privy's authentication is fully compatible with any authentication provider that supports [JWT-based](https://jwt.io/), [stateless](https://auth0.com/blog/stateless-auth-for-stateful-minds/) authentication. When a user logs into your app, your auth provider issues them an access and/or identity token to represent their auth status. Privy validates this token to authenticate your user.

<img src="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/jwt-based-auth-splash.png?fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=ac522c8b8c19e1983d064c042db39936" alt="JWT-based auth splash" data-og-width="5529" width="5529" data-og-height="3949" height="3949" data-path="images/jwt-based-auth-splash.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/jwt-based-auth-splash.png?w=280&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=4a1cb0e1fb927c57346fb3e774993e92 280w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/jwt-based-auth-splash.png?w=560&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=4917411ef3002a86a24c845b7e13bf6e 560w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/jwt-based-auth-splash.png?w=840&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=64ef25ceb73aef7e0ce753a83ce53ae1 840w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/jwt-based-auth-splash.png?w=1100&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=ddf26e5294ad69d4026aec1ebc3cf673 1100w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/jwt-based-auth-splash.png?w=1650&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=71d8ba5c985dac39f6164ff65e425d0a 1650w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/jwt-based-auth-splash.png?w=2500&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=5603353b36d739523f9f11cc55317b16 2500w" />


# Configuring your authentication provider
Source: https://docs.privy.io/authentication/user-authentication/jwt-based-auth/setup



To integrate your authentication provider with Privy:

1. Go to the [**Privy Dashboard**](https://dashboard.privy.io)
2. Select your app from the **App Dropdown** in the left sidebar
3. Request access to **Custom Auth Support** in the [Integrations > Plugins](https://dashboard.privy.io/apps?page=integrations) tab of the Privy dashboard
4. Navigate to the [JWT Dashboard](https://dashboard.privy.io/apps?logins=basics\&page=login-methods) via User management > Authentication > JWT-based auth

<img src="https://mintcdn.com/privy-c2af3412/zSwkF5-adOBDSGL-/images/jwt.png?fit=max&auto=format&n=zSwkF5-adOBDSGL-&q=85&s=41c879569e14361b74ab0f68ad32f777" alt="JWT-based auth" data-og-width="5529" width="5529" data-og-height="3949" height="3949" data-path="images/jwt.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/zSwkF5-adOBDSGL-/images/jwt.png?w=280&fit=max&auto=format&n=zSwkF5-adOBDSGL-&q=85&s=12e419ba6574798506b373937267bce5 280w, https://mintcdn.com/privy-c2af3412/zSwkF5-adOBDSGL-/images/jwt.png?w=560&fit=max&auto=format&n=zSwkF5-adOBDSGL-&q=85&s=059f17bc8f3dbcb0fa6ef05e5fe7de10 560w, https://mintcdn.com/privy-c2af3412/zSwkF5-adOBDSGL-/images/jwt.png?w=840&fit=max&auto=format&n=zSwkF5-adOBDSGL-&q=85&s=0a30638c9190a10327c599c55a3882b9 840w, https://mintcdn.com/privy-c2af3412/zSwkF5-adOBDSGL-/images/jwt.png?w=1100&fit=max&auto=format&n=zSwkF5-adOBDSGL-&q=85&s=c706485d075e4fa41f736395c29a2d0b 1100w, https://mintcdn.com/privy-c2af3412/zSwkF5-adOBDSGL-/images/jwt.png?w=1650&fit=max&auto=format&n=zSwkF5-adOBDSGL-&q=85&s=0c942f3ef85c52d9f21af685e572c7bf 1650w, https://mintcdn.com/privy-c2af3412/zSwkF5-adOBDSGL-/images/jwt.png?w=2500&fit=max&auto=format&n=zSwkF5-adOBDSGL-&q=85&s=7d62b221b0a5431bec9a41ffb505a5eb 2500w" />

You'll need to provide the following information:

<ParamField path="Authentication environment">
  Select which environment JWT-authenticated requests will originate from. Client side will only
  allow requests from end user devices, while server side will only allow requests from your own
  backend servers.

  <Tip>
    If you do not use one of Privy's client-side SDKs, we recommended you enable "Server side".
  </Tip>
</ParamField>

<ParamField path="JWT Verification Details" required>
  Privy requires a verification key to ensure the JWTs received are valid. Both the token's signature and its expiration time ([claim](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.4)) are verified to ensure secure access. This verification process helps protect user data and prevents unauthorized access to Privy services.

  You can provide the verification key in one of two ways:

  <AccordionGroup>
    <Accordion title="JWKS Endpoint">
      If your provider uses [JWKS](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets) to sign JWTs, provide a JWKS endpoint URL where Privy can retrieve your auth provider's JWT public key.

      ```json  theme={"system"}
      {
          "keys": [
              {
                "kty": "XXX",
                "n": "XXX",
                "e": "XXX",
                "alg": "XXX", // "RS256" or "ES256"
                "kid": "XXX"
                // ...
              }
          ]
      }
      ```
    </Accordion>

    <Accordion title="Public Verification Key">
      If your provider uses a single key to sign JWTs, provide the corresponding public key certificate used for verification.

      ```json  theme={"system"}
      -----BEGIN CERTIFICATE-----
      // Public key
      -----END CERTIFICATE-----
      ```
    </Accordion>
  </AccordionGroup>
</ParamField>

<ParamField path="JWT ID Claim" default="sub">
  Enter the claim from your user's JWT that contains the user's unique ID. In most access tokens and
  identity tokens, this is the claim.
</ParamField>


# Integrating your authentication provider with Privy
Source: https://docs.privy.io/authentication/user-authentication/jwt-based-auth/usage



Follow the guide below to integrate your authentication provider with Privy.

<Tabs>
  <Tab title="React">
    ### Implementation

    To integrate JWT-based authentication with Privy in your React application, you'll need to use
    the `useSubscribeToJwtAuthWithFlag` hook to subscribe the Privy SDK to your auth provider's
    state.

    #### Getting the state from your auth provider

    To get the state from your auth provider, import the provider's hook.

    ```tsx  theme={"system"}
    // Import your auth provider's hook or state management
    import { useAuth } from 'your-auth-provider';

    // Get auth details from your provider
    const { getToken, isLoading, isAuthenticated } = useAuth();
    ```

    #### Subscribing to the auth provider's state

    In a component that lives below both `PrivyProvider`, and your custom auth provider, call the
    `useSubscribeToJwtAuthWithFlag` hook to subscribe the Privy SDK to your auth provider's state.

    ```tsx  theme={"system"}
    import { useAuth } from 'your-auth-provider';
    import { useSubscribeToJwtAuthWithFlag } from '@privy-io/react-auth';

    const MyStateSyncComponent = () => {
        const { getToken, isLoading, isAuthenticated } = useAuth();

        useSubscribeToJwtAuthWithFlag({
            isAuthenticated,
            isLoading,
            getExternalJwt: async () => {
                if (isAuthenticated) {
                    const token = await getToken();
                    return token;
                }
            }
        })

        return null;
    }
    ```

    This hook will observe state from your auth provider and update the Privy SDK's authentication
    state accordingly.
    The hook itself (and the `MyStateSyncComponent` component) should be mounted throughout the
    lifetime of your app to ensure state is kept in sync.

    #### Integrate the provider with your app

    Make sure to nest your custom provider inside your auth provider in your app structure:

    ```tsx App.tsx theme={"system"}
    import { AuthProvider } from 'your-auth-provider';
    import PrivyAuthProvider from './PrivyAuthProvider';

    function App() {
        return (
            <AuthProvider>
                <PrivyAuthProvider>
                    {/* Invocation of `useSubscribeToJwtAuthWithFlag` must be below both providers */}
                    <MyStateSyncComponent />
                    <MainContent />
                </PrivyAuthProvider>
            </AuthProvider>
        );
    }

    export default App;
    ```

    #### Disabling the external auth provider

    If you want to disable the external auth provider, you can set the `enabled` flag to `false` in
    the hook configuration.

    ```tsx  theme={"system"}
    useSubscribeToJwtAuthWithFlag({
        enabled: false,
        isAuthenticated,
        // ...
    });
    ```

    Setting the `enabled` flag to `false` will disable the external auth provider and will stop
    Privy from attempting to synchronize its state with the external auth provider regardless of the
    value of the `isAuthenticated` flag, until `enabled` is set to `true` again.

    ### Advanced Usage

    <Warning>
      This approach is **not recommended for most use cases**, as it increases the complexity of setup significantly and
      can result in state synchronization issues if used incorrectly.

      Always prefer the flag-based approach when possible if your auth provider offers an `isAuthenticated` flag.
    </Warning>

    For more advanced usage, or in cases where your auth provider lives outside React or otherwise
    offers no `isAuthenticated` flag, you can use the `useSyncJwtBasedAuthState` hook to subscribe to
    the auth provider's state via state listeners.

    Let's say the library for your auth provider exports an `authStore` object that holds state.

    ```ts  theme={"system"}
    import { authStore } from 'your-auth-provider';
    ```

    This object has a `subscribe` method that takes a callback, and invokes it every time the
    auth state changes, most importantly when the user either logs in or out.

    ```ts  theme={"system"}
    authStore.subscribe(() => {
        console.log('Auth state changed');
    });
    ```

    The store object also has a `getState` method that returns the current state, which we can use to
    get the current JWT token whenever necessary.

    ```ts  theme={"system"}
    const authState = authStore.getState();
    console.log('Is authenticated:', authState.isAuthenticated);
    console.log('JWT token:', authState.token);
    ```

    By using the `useSyncJwtBasedAuthState` hook, we can link Privy to the auth provider's state store
    by using those two methods.

    ```ts  theme={"system"}
    import { useSyncJwtBasedAuthState } from '@privy-io/react-auth';
    import { authStore } from 'your-auth-provider';

    useSyncJwtBasedAuthState({
        subscribe: (onAuthStateChange) => {
            const unsubscribe = authStore.subscribe((state) => {
                onAuthStateChange(); // Notify Privy of the auth state change.
            });

            return unsubscribe; // Return the `unsubscribe` to avoid memory leaks.
        },
        getExternalJwt: () => {
            const authState = authStore.getState();
            if (authState.isAuthenticated) {
                return authState.token;
            }
        }
    })
    ```

    ### Accessing User Authentication Status

    Once configured, you can access the user's authentication status through the Privy SDK:

    ```tsx  theme={"system"}
    import { usePrivy } from '@privy-io/react-auth';

    function MainContent() {
        const { user, ready, authenticated } = usePrivy();

        if (!ready) {
            return <div>Loading...</div>;
        }

        if (!authenticated) {
            return <div>Please log in through your authentication provider</div>;
        }

        return (
            <div>
                <p>Welcome, authenticated user!</p>
                <p>User ID: {user.id}</p>
            </div>
        );
    }
    ```

    <Info>
      When using a custom authentication provider, you should not use the Privy `login` method (from `useLogin` or `usePrivy`). Instead, call the login method of your custom provider, and the Privy SDK will automatically synchronize its state.
    </Info>
  </Tab>

  <Tab title="React Native">
    ### Implementation

    To integrate JWT-based authentication with Privy in your React Native application, you'll need to create a custom `PrivyProvider` wrapper that supplies your auth token to Privy.

    #### Create a custom `PrivyProvider` wrapper

    Create a component that wraps the `PrivyProvider` with your custom auth configuration:

    ```tsx PrivyAuthProvider.tsx theme={"system"}
    import { useCallback, PropsWithChildren } from 'react';
    import { PrivyProvider } from '@privy-io/expo';

    // Import your auth provider's hook or state management
    import { useAuth0 } from 'react-native-auth0';

    const PrivyAuthProvider: React.FC<PropsWithChildren> = ({ children }) => {
        // Get auth details from your auth provider
        const { user: auth0User, isLoading, getCredentials } = useAuth0();

        // Create a callback to get the token
        const getCustomToken = useCallback(async () => {
            // Your logic to retrieve the JWT token from your auth provider
            try {
                const creds = await getCredentials();
                return creds?.idToken;
            } catch (error) {
                // If there's an error, the user is likely not authenticated
                return undefined;
            }
        }, [isLoading, auth0User, getCredentials]); // Re-create when auth state changes

        return (
            <PrivyProvider
                appId='your-privy-app-id'
                config={{
                    customAuth: {
                        enabled: true,
                        // Indicates if your auth provider is currently updating auth state
                        isLoading: isLoading,
                        // Callback to get the user's JWT token
                        getCustomAccessToken: getCustomToken,
                    }
                }}
            >
                {children}
            </PrivyProvider>
        );
    };

    export default PrivyAuthProvider;
    ```

    #### Integrate the provider with your app

    Make sure to nest your custom provider inside your auth provider in your app structure:

    ```tsx App.tsx theme={"system"}
    import { Auth0Provider } from 'react-native-auth0';
    import PrivyAuthProvider from './PrivyAuthProvider';

    function App() {
        return (
            <Auth0Provider
                domain="your-domain.auth0.com"
                clientId="your-client-id"
            >
                {/* Our custom wrapper must be nested inside your AuthProvider */}
                <PrivyAuthProvider>
                    {/* Your app content */}
                    <MainContent />
                </PrivyAuthProvider>
            </Auth0Provider>
        );
    }

    export default App;
    ```

    ### Accessing User Authentication Status

    Once configured, you can access the user's authentication status through the Privy SDK:

    ```tsx  theme={"system"}
    import { usePrivy } from '@privy-io/expo';
    import { View, Text } from 'react-native';

    function MainContent() {
        const { user, ready } = usePrivy();

        if (!ready) {
            return <Text>Loading...</Text>;
        }

        if (!user) {
            return <Text>Please log in through your authentication provider</Text>;
        }

        return (
            <View>
                <Text>Welcome, authenticated user!</Text>
                <Text>User ID: {user.id}</Text>
            </View>
        );
    }
    ```

    <Info>
      When using a custom authentication provider in React Native, you should let your auth provider handle the authentication flow. Privy will automatically synchronize its state based on the token provided by your `getCustomAccessToken` callback.
    </Info>
  </Tab>

  <Tab title="Swift">
    ### Implementation

    To integrate JWT-based authentication with Privy in your Swift application, you'll need to initialize the Privy SDK with a token provider callback and handle authentication.

    #### Initialize Privy with a token provider callback

    First, initialize the Privy SDK with a `tokenProvider` callback that will provide the JWT from your custom auth provider:

    ```swift Privy initialization with custom auth theme={"system"}
    let privy = PrivyConfig(
        appId: "YOUR_APP_ID",
        appClientId: "YOUR_APP_CLIENT_ID",
        customAuthConfig: PrivyLoginWithCustomAuthConfig {
            // Client logic to provide the JWT
            // This might involve network requests or accessing secure storage
            return await fetchAccessTokenFromAuthProvider()
        }
    )
    ```

    ```swift Example token provider implementation theme={"system"}
    private func fetchAccessTokenFromAuthProvider() async throws -> String? {
        // Your custom logic to retrieve the JWT token
        // This might be from shared preferences, secure storage, or an API call
        try await yourAuthManager.getAccessToken()
    }
    ```

    This `tokenProvider` callback should:

    * Return the current user's access token as a `String` when authenticated
    * Return `nil` when the user is not authenticated

    #### Authenticate your user

    Once you have defined a `tokenProvider` callback, authenticate your user with Privy using the `loginWithCustomAccessToken` method:

    ```swift Authenticating with Privy theme={"system"}
    do {
        try await privy.customJwt.loginWithCustomAccessToken()
        // User is now authenticated with Privy
    } catch {
        // Handle authentication errors
        print("Failed to authenticate with Privy: \(error)")
    }
    ```

    If the provided token is valid, Privy will successfully authenticate your user. If the token is invalid, this method will throw an error.

    #### Example with Auth0

    Here's an example using Auth0's Swift SDK for authentication:

    ```swift Auth0 Integration Example theme={"system"}
    // Store the Auth0 token
    var auth0Token: String? = nil

    // Set up the token provider to return the stored token
    let config = PrivyConfig(
        appId: "YOUR_APP_ID",
        appClientId: "YOUR_APP_CLIENT_ID",
        customAuthConfig: PrivyLoginWithCustomAuthConfig {
            return auth0Token
        }
    )

    // Handle Auth0 authentication
    Auth0.webAuth().start { result in
        if case .success(let credentials) = result {
            auth0Token = credentials.accessToken

            Task {
                do {
                    // Authenticate with Privy using the token
                    try await privy.customJwt.loginWithCustomAccessToken()

                    // Now the user is authenticated with Privy
                    // You can access their wallet and other features
                } catch {
                    print("Privy authentication failed: \(error)")
                }
            }
        } else {
            print("Auth0 authentication failed")
        }
    }
    ```

    ### Authentication Flow

    When using custom authentication with the Swift SDK:

    1. When the Privy SDK is first initialized, it attempts to restore any prior session
    2. If a prior session exists, Privy automatically tries to reauthenticate using your `tokenProvider`
    3. You can manually trigger authentication by calling `loginWithCustomAccessToken`
    4. After successful authentication, you have access to the `PrivyUser` object and wallet functionality

    <Info>
      When your app starts up, as soon as you determine your user is authenticated via your custom auth provider, you should call Privy's `loginWithCustomAccessToken` method to synchronize the authentication state.
    </Info>

    ### Accessing User Data

    Once authenticated, you can access the user's data and embedded wallets:

    ```swift  theme={"system"}
    // Check if user is authenticated
    if let user = privy.user {
        // Access user information
        let userId = user.id

        // Access embedded wallets
        if let wallet = user.embeddedEthereumWallets.first {
            let walletAddress = wallet.address
            print("User has Ethereum wallet with address: \(walletAddress)")
        }
    }
    ```

    Privy identifies users based on the unique ID assigned by your auth provider (stored in the `sub` claim of their access token). You can view all users in the **Users** section of the Privy Developer Dashboard.
  </Tab>

  <Tab title="Android">
    ### Implementation

    To integrate JWT-based authentication with Privy in your Android application, you'll need to initialize the Privy SDK with a token provider callback and handle authentication.

    #### Initialize Privy with a token provider callback

    First, initialize the Privy SDK with a `tokenProvider` callback that will provide the JWT from your custom auth provider:

    ```kotlin Privy initialization with custom auth theme={"system"}
    private val privy: Privy = Privy.init(
        context = applicationContext, // Be sure to only pass in Application context
        config = PrivyConfig(
            appId = "YOUR_APP_ID",
            appClientId = "YOUR_APP_CLIENT_ID",
            logLevel = PrivyLogLevel.NONE,
            customAuthConfig = LoginWithCustomAuthConfig(
                tokenProvider = {
                    // Return the user's access token if they're authenticated
                    // Or return null if they're not authenticated
                    fetchTokenFromAuthProvider()
                }
            )
        )
    )

    // Example token provider implementation
    private suspend fun fetchTokenFromAuthProvider(): String? {
        return try {
            // Your custom logic to retrieve the JWT token
            // This might be from shared preferences, secure storage, or an API call
            yourAuthManager.getAccessToken()
        } catch (e: Exception) {
            // If there's an error, the user is likely not authenticated
            null
        }
    }
    ```

    The `tokenProvider` callback should:

    * Return the current user's access token as a `String` when authenticated
    * Return `null` when the user is not authenticated
    * Be implemented as a suspending function that can perform asynchronous operations

    #### Authenticate your user

    Once you've initialized Privy with a `tokenProvider` callback, authenticate your user with Privy using the `loginWithCustomAccessToken` method:

    ```kotlin Authenticating with Privy theme={"system"}
    // Make sure to call this in a coroutine scope
    val privyLoginResult = privy.customAuth.loginWithCustomAccessToken()

    privyLoginResult.fold(
        onSuccess = { user ->
            Log.d("Privy", "Privy login success! User: ${user}")
            // Now you can access user information and wallet functionality
        },
        onFailure = { error ->
            Log.d("Privy", "Privy login failure! $error")
            // Handle authentication error
        }
    )
    ```

    If the provided access or identity token is valid, Privy will authenticate your user and return a `Result.success` with the `PrivyUser` object. If the token is invalid, it will return a `Result.failure`.

    #### Example integration with Auth0

    Here's an example of integrating with Auth0 for Android:

    ```kotlin Auth0 Integration Example theme={"system"}
    private val auth0 = Auth0(
        clientId = "YOUR_AUTH0_CLIENT_ID",
        domain = "YOUR_AUTH0_DOMAIN"
    )

    // Store the Auth0 token
    private var auth0Token: String? = null

    // Initialize Privy with token provider that returns the Auth0 token
    private val privy = Privy.init(
        context = applicationContext,
        config = PrivyConfig(
            appId = "YOUR_PRIVY_APP_ID",
            appClientId = "YOUR_PRIVY_APP_CLIENT_ID",
            customAuthConfig = LoginWithCustomAuthConfig(
                tokenProvider = { auth0Token }
            )
        )
    )

    // Authenticate with Auth0, then with Privy
    private fun authenticateUser() {
        val callback = object : Callback<Credentials, AuthenticationException> {
            override fun onSuccess(credentials: Credentials) {
                // Store the token
                auth0Token = credentials.accessToken

                // Authenticate with Privy
                lifecycleScope.launch {
                    val privyResult = privy.customAuth.loginWithCustomAccessToken()
                    privyResult.fold(
                        onSuccess = { user ->
                            Log.d("Auth", "Successfully authenticated with Privy")
                            // Proceed with authenticated user
                        },
                        onFailure = { error ->
                            Log.e("Auth", "Failed to authenticate with Privy", error)
                        }
                    )
                }
            }

            override fun onFailure(error: AuthenticationException) {
                Log.e("Auth", "Auth0 authentication failed", error)
            }
        }

        // Start Auth0 authentication
        WebAuthProvider.login(auth0)
            .withScheme("demo")
            .start(this, callback)
    }
    ```

    ### Authentication flow

    When using custom authentication with the Android SDK:

    1. When the Privy SDK is first initialized, it attempts to restore any prior session
    2. If a prior session exists, Privy automatically tries to reauthenticate using your `tokenProvider`
    3. You can manually trigger authentication by calling `loginWithCustomAccessToken`
    4. After successful authentication, you have access to the `PrivyUser` object and wallet functionality

    <Info>
      It's important to await the `privy.awaitReady()` call before triggering any other Privy flows to ensure the SDK has completed initialization and attempted session restoration.
    </Info>

    ### Accessing user data and wallets

    Once authenticated, you can access the user's data and embedded wallets:

    ```kotlin  theme={"system"}
    // Check if user is authenticated
    val user = privy.user
    if (user != null) {
        // Access user information
        val userId = user.id

        // Access embedded Ethereum wallets
        val ethereumWallets = user.embeddedEthereumWallets
        if (ethereumWallets.isNotEmpty()) {
            val walletAddress = ethereumWallets.first().address
            Log.d("Wallet", "User has Ethereum wallet with address: $walletAddress")
        }
    }
    ```

    Privy identifies users based on the unique ID that your auth provider has assigned (stored in the `sub` claim of their access token). You can view all users in the **Users** section of the Privy Developer Dashboard.
  </Tab>

  <Tab title="Flutter">
    ### Implementation

    To integrate JWT-based authentication with Privy in your Flutter application, you'll need to initialize the Privy SDK with a token provider callback and handle authentication.

    #### Initialize Privy with a token provider callback

    First, initialize the Privy SDK with a `tokenProvider` callback that will provide the JWT from your custom auth provider:

    ```dart Privy initialization with custom auth theme={"system"}
    // Define a function to retrieve the token from your auth provider
    Future<String?> _retrieveCustomAuthAccessToken() async {
      // Implement logic to fetch the access token from your auth provider
      // Return the token if the user is authenticated, or null if not
      try {
        // Your custom logic to retrieve the JWT token
        // This might be from secure storage or an API call
        final token = await yourAuthService.getAccessToken();
        return token;
      } catch (e) {
        // If there's an error, the user is likely not authenticated
        return null;
      }
    }

    // Initialize Privy with the token provider
    final privyConfig = PrivyConfig(
      appId: "YOUR_APP_ID",
      appClientId: "YOUR_APP_CLIENT_ID",
      logLevel: PrivyLogLevel.NONE,
      customAuthConfig: LoginWithCustomAuthConfig(
        tokenProvider: _retrieveCustomAuthAccessToken,
      ),
    );

    final privy = Privy(config: privyConfig);
    ```

    The `tokenProvider` callback should:

    * Return the current user's access token as a `String` when authenticated
    * Return `null` when the user is not authenticated
    * Be implemented as an async function that can perform asynchronous operations

    #### Await SDK readiness

    Before performing any operations with the SDK, make sure to await its readiness:

    ```dart Awaiting SDK readiness theme={"system"}
    // Wait for the SDK to be ready before proceeding
    await privy.awaitReady();
    ```

    This ensures that the SDK has completed initialization and attempted session restoration if a prior session exists.

    #### Authenticate your user

    Once you've initialized Privy with a `tokenProvider` callback, authenticate your user with Privy using the `loginWithCustomAccessToken` method:

    ```dart Authenticating with Privy theme={"system"}
    // Authenticate with Privy
    final result = await privy.customAuth.loginWithCustomAccessToken();

    result.fold(
      onSuccess: (user) {
        print("Privy login success! User: ${user}");
        // Now you can access user information and wallet functionality
      },
      onFailure: (error) {
        print("Privy login failure! ${error.message}");
        // Handle authentication error
      },
    );
    ```

    If the provided access or identity token is valid, Privy will authenticate your user and return `Success()` with an encapsulated `PrivyUser`. If the token is invalid, it will return a `Failure()` with a PrivyException.

    #### Example integration with Firebase Auth

    Here's an example of integrating with Firebase Authentication:

    ```dart Firebase Auth Integration Example theme={"system"}
    import 'package:firebase_auth/firebase_auth.dart';
    import 'package:privy_flutter/privy_flutter.dart';

    class AuthService {
      final FirebaseAuth _auth = FirebaseAuth.instance;
      late final Privy _privy;

      // Initialize Privy with Firebase token provider
      Future<void> initPrivy() async {
        final privyConfig = PrivyConfig(
          appId: "YOUR_PRIVY_APP_ID",
          appClientId: "YOUR_PRIVY_APP_CLIENT_ID",
          logLevel: PrivyLogLevel.NONE,
          customAuthConfig: LoginWithCustomAuthConfig(
            tokenProvider: _getFirebaseIdToken,
          ),
        );

        _privy = Privy(config: privyConfig);

        // Wait for Privy to be ready
        await _privy.awaitReady();
      }

      // Firebase token provider function
      Future<String?> _getFirebaseIdToken() async {
        try {
          final user = _auth.currentUser;
          if (user == null) return null;

          // Get the ID token
          return await user.getIdToken();
        } catch (e) {
          print("Error getting Firebase ID token: $e");
          return null;
        }
      }

      // Sign in with Firebase, then with Privy
      Future<Result<PrivyUser>> signInWithEmailAndPassword(String email, String password) async {
        try {
          // Sign in with Firebase
          await _auth.signInWithEmailAndPassword(
            email: email,
            password: password,
          );

          // After Firebase auth succeeds, authenticate with Privy
          return await _privy.customAuth.loginWithCustomAccessToken();
        } catch (e) {
          return Result.failure(AuthError("Firebase authentication failed: $e"));
        }
      }
    }
    ```

    ### Authentication flow

    When using custom authentication with the Flutter SDK:

    1. When the Privy SDK is first initialized, it attempts to restore any prior session
    2. If a prior session exists, Privy automatically tries to reauthenticate using your `tokenProvider`
    3. You can manually trigger authentication by calling `loginWithCustomAccessToken`
    4. After successful authentication, you have access to the `PrivyUser` object and wallet functionality

    <Info>
      It's important to `await privy.awaitReady()` before triggering any other Privy flows to ensure the SDK has completed initialization and attempted session restoration.
    </Info>

    ### Accessing user data and wallets

    Once authenticated, you can access the user's data and embedded wallets:

    ```dart  theme={"system"}
    // Check if user is authenticated
    final user = privy.user;
    if (user != null) {
      // Access user information
      final userId = user.id;

      // Access embedded Ethereum wallets
      final ethereumWallets = user.embeddedEthereumWallets;
      if (ethereumWallets.isNotEmpty) {
        final walletAddress = ethereumWallets.first.address;
        print("User has Ethereum wallet with address: $walletAddress");
      }
    }
    ```

    Privy identifies users based on the unique ID that your auth provider has assigned (stored in the `sub` claim of their access token). You can view all users in the **Users** section of the Privy Developer Dashboard.
  </Tab>
</Tabs>


# Additional OAuth providers
Source: https://docs.privy.io/authentication/user-authentication/login-methods/custom-oauth



This guide demonstrates how to integrate any custom [OAuth 2.0 provider](https://oauth.net/2/) that is not natively supported by Privy.

<Warning>
  This is an advanced feature. We recommend understanding the basics of OAuth 2.0 before proceeding.
  Misconfiguring this feature can lead to security vulnerabilities.
</Warning>

## Overview

Privy's custom OAuth feature allows you to:

* **Integrate any OAuth 2.0 provider** - Add authentication for services like YouTube, Kraken, or Reddit not natively supported by Privy
* **Maintain unified user experience** - Custom providers work seamlessly with Privy's existing authentication flows
* **Customize branding** - Upload custom provider icons and display names for your login UI
* **Advanced configuration** - Support for PKCE, custom scopes, and flexible user data mapping

## Step 1: Configure your OAuth provider

First, you'll need to set up your OAuth application with the provider you want to integrate.

### Register your application

1. Navigate to your OAuth provider's developer console
2. Create a new OAuth application
3. Configure the redirect URI to point to Privy:
   ```
   https://auth.privy.io/api/v1/oauth/callback
   ```
4. Note your client ID and client secret
5. Review the provider's documentation for:
   * Authorization endpoint URL
   * Token endpoint URL
   * User info endpoint URL (if needed)
   * Available scopes
   * User data structure

### Example: Setting up Twitch OAuth

Here's how to configure Twitch as an example:

1. Go to the [Twitch Developer Console](https://dev.twitch.tv/console)
2. Create a new application with these settings:
   * **Name**: Your app name
   * **OAuth Redirect URLs**: `https://auth.privy.io/api/v1/oauth/callback`
   * **Category**: Choose appropriate category
3. Note the **Client ID** and generate a **Client Secret**
4. Review Twitch's OAuth endpoints:
   * Authorization URL: `https://id.twitch.tv/oauth2/authorize`
   * Token URL: `https://id.twitch.tv/oauth2/token`
   * User Info: `https://id.twitch.tv/oauth2/userinfo`

## Step 2: Configure custom OAuth in Privy Dashboard

Navigate to your Privy Dashboard and configure the custom OAuth provider.

<Warning>
  Once set, custom OAuth provider fields cannot be changed. Be sure to double check your
  configuration before saving. Once users are created under a custom OAuth provider, the
  configuration cannot be deleted.
</Warning>

### Basic configuration

1. Go to **Settings > Login methods** in your Privy Dashboard
2. Click **Add Custom Provider**
3. Fill in the basic configuration:

**Display name** (required)

* How the provider appears in your login UI
* Example: "Twitch", "Kraken", "Reddit"

**Provider icon**

* Upload a icon for your login button
* Will be displayed alongside other social login options

**Client ID** (required)

* The client ID from your OAuth provider
* Used to identify your application during OAuth flow

**Client secret** (required)

* The client secret from your OAuth provider
* Securely stored and used for token exchange

### OAuth endpoints

Configure the OAuth flow endpoints:

**Authorization URL** (required)

* Where users are redirected to grant permissions
* Example: `https://provider.com/oauth/authorize`

**Token URL** (required)

* Endpoint for exchanging authorization code for access token
* Also known as the refresh URL
* Example: `https://provider.com/oauth/token`

**Profile URL** (optional)

* Endpoint to fetch user information
* Only needed if using "Profile Endpoint" user info source
* Example: `https://api.provider.com/user`

### Advanced configuration

**Scopes**

* List of OAuth scopes to request
* Common scopes: `openid`, `profile`, `email`
* Provider-specific examples:
  * Twitch: `user:read:email`, `openid`
  * Discord: `identify`, `email`

**Scopes delimiter**

* Character used to separate multiple scopes
* Default: space (` `)
* Some providers use comma (`,`) or plus (`+`)

**PKCE enabled**

* Enable Proof Key for Code Exchange for enhanced security
* Recommended for public clients and mobile apps
* Check if your OAuth provider supports PKCE before enabling this setting

**Use cookie domain for redirect**

* Advanced setting for custom domain configurations
* Leave disabled unless specifically needed

### User information configuration

Configure how Privy extracts user data from your OAuth provider. Review your authentication provider's documentation to determine which method is needed for your use case.

**ID Token**

* Extract user info from OpenID Connect ID token
* Works with providers that return ID tokens

**Profile endpoint**

* Fetch user info from a dedicated API endpoint
* Requires additional HTTP request

**Access token JWT**

* Extract user info directly from access token

### Field mapping

Map user data fields from your provider to Privy user attributes using dot notation for nested fields. Review your auth provider's documentation to determine which fields are available for extraction and tell Privy where to put that information on the user's linked account.

```json  theme={"system"}
{
  "path_to_name": "display_name",
  "path_to_username": "login",
  "path_to_email": "user.email",
  "path_to_profile_picture_url": "profile_image_url"
}
```

## Step 3: Implement in your application

Once configured in the Dashboard, your custom OAuth provider works automatically with Privy's SDKs.

### Using Privy UIs

Your custom OAuth provider will appear automatically in Privy's login UI:

```tsx  theme={"system"}
import {useLogin, usePrivy} from '@privy-io/react-auth';

function LoginPage() {
  const {ready, authenticated, user} = usePrivy();
  const {login} = useLogin();

  // Custom providers appear automatically in the login modal
  if (!ready) return <div>Loading...</div>;

  if (!authenticated) {
    return <button onClick={login}>Sign in</button>;
  }

  return <UserDashboard user={user} />;
}
```

### Using whitelabel UIs

Your app can also use our whitelabel hooks to login with custom OAuth providers. As a parameter to the `initOAuth` method, pass an object with `provider` field set to `custom:<your-provider-name>`.

```tsx  theme={"system"}
import {useLoginWithOAuth} from '@privy-io/react-auth';

function CustomTwitchButton() {
  const {initOAuth} = useLoginWithOAuth({
    onComplete: (user) => {
      console.log('Twitch login successful:', user);
    },
    onError: (error) => {
      console.error('Twitch login failed:', error);
    }
  });

  const handleTwitchLogin = () => {
    initOAuth({provider: 'custom:twitch'});
  };

  return (
    <button onClick={handleTwitchLogin}>
      <img src="/twitch-icon.png" alt="Twitch" width="20" height="20" />
      Connect Twitch account
    </button>
  );
}
```

### Accessing custom OAuth account data

Custom OAuth accounts are available in the user object. Filter the linked accounts by `type === custom:<your-provider-name>` to find the account.

```tsx  theme={"system"}
import {usePrivy} from '@privy-io/react-auth';

function UserProfile() {
  const {user} = usePrivy();

  // Find custom OAuth accounts
  const customAccounts = user?.linkedAccounts?.filter((account) =>
    account.type.startsWith('custom:')
  );

  // Find specific provider account
  const twitchAccount = user?.linkedAccounts?.find((account) => account.type === 'custom:twitch');

  return (
    <div>
      <h2>Connected Accounts</h2>
      {customAccounts?.map((account) => (
        <div key={account.type}>
          <strong>{account.type.replace('custom:', '')}</strong>
          <p>Username: {account.username}</p>
          <p>Email: {account.email}</p>
        </div>
      ))}
    </div>
  );
}
```

<Tip>Your app can configure multiple custom OAuth providers with Privy.</Tip>


# Email
Source: https://docs.privy.io/authentication/user-authentication/login-methods/email



Privy enables users to login to your application with SMS or email. With Privy, your application can verify ownership of a user's email address or phone number to send them notifications, campaigns, and more to keep them activated.

<Tip>
  Enable email authentication in the [Privy
  Dashboard](https://dashboard.privy.io/apps?page=login-methods) before implementing this feature.
</Tip>

<Info>
  Privy uses [`disposable`](https://github.com/disposable/disposable) to detect temporary email
  domains. To block them automatically, turn the setting on in the [Privy
  Dashboard](https://dashboard.privy.io/apps?page=login-methods).
</Info>

<Tabs>
  <Tab title="React">
    To authenticate your users with a one-time passcode (OTP) sent to their email address, use the `useLoginWithEmail` hook.

    <Info>
      To authenticate your users with Privy's out of the box UIs, check out UI components [here](/authentication/user-authentication/ui-component).
    </Info>

    ## Send Code

    ```tsx  theme={"system"}
    sendCode: ({email: string, disableSignup?: boolean}) => Promise<void>
    ```

    ### Parameters

    <ParamField path="email" type="string" required>
      The email address of the user to log in.
    </ParamField>

    <ParamField path="disableSignup" type="boolean">
      Whether to disable the ability to sign up with the email address.
    </ParamField>

    ### Returns

    <ResponseField name="void" type="Promise<void>">
      A promise that resolves when the code is sent.
    </ResponseField>

    ## Login with Code

    ```tsx  theme={"system"}
    loginWithCode: ({ code: string }) => Promise<void>;
    ```

    ### Parameters

    <ParamField path="code" type="string" required>
      The one-time passcode sent to the user's email address.
    </ParamField>

    ### Returns

    <ResponseField name="void" type="Promise<void>">
      A promise that resolves when the user is logged in.
    </ResponseField>

    ## Usage

    ```tsx  theme={"system"}
    import { useState } from "react";
    import { useLoginWithEmail } from "@privy-io/react-auth";

    export default function LoginWithEmail() {
      const [email, setEmail] = useState("");
      const [code, setCode] = useState("");
      const { sendCode, loginWithCode } = useLoginWithEmail();

      return (
          <div>
              <input onChange={(e) => setEmail(e.currentTarget.value)} value={email} />
              <button onClick={() => sendCode({ email })}>Send Code</button>
              <input onChange={(e) => setCode(e.currentTarget.value)} value={code} />
              <button onClick={() => loginWithCode({ code })}>Login</button>
          </div>
      );
    }
    ```

    ## Tracking Flow State

    Track the state of the OTP flow via the `state` variable returned by the
    `useLoginWithEmail` hook.

    ```ts  theme={"system"}
    type OtpFlowState =
      | {status: 'initial'}
      | {status: 'error'; error: Error | null}
      | {status: 'sending-code'}
      | {status: 'awaiting-code-input'}
      | {status: 'submitting-code'}
      | {status: 'done'};
    ```

    <ResponseField name="status" type="'initial' | 'error' | 'sending-code' | 'awaiting-code-input' | 'submitting-code' | 'done'">
      The current state of the OTP flow.
    </ResponseField>

    <ResponseField name="error" type="Error | null">
      The error that occurred during the OTP flow.
    </ResponseField>

    ## Callbacks

    You can optionally pass callbacks into the `useLoginWithEmail` hook to run custom logic after a successful login or to handle errors that occur during the flow.

    ### `onComplete`

    ```tsx  theme={"system"}
    onComplete?: ((params: {
        user: User;
        isNewUser: boolean;
        wasAlreadyAuthenticated: boolean;
        loginMethod: LoginMethod | null;
        loginAccount: LinkedAccountWithMetadata | null;
    }) => void) | undefined
    ```

    #### Parameters

    <ParamField path="user" type="User">
      The user object corresponding to the authenticated user.
    </ParamField>

    <ParamField path="isNewUser" type="boolean">
      Whether the user is a new user or an existing user.
    </ParamField>

    <ParamField path="wasAlreadyAuthenticated" type="boolean">
      Whether the user entered the application already authenticated.
    </ParamField>

    <ParamField path="loginMethod" type="LoginMethod | null">
      The method used by the user to login.
    </ParamField>

    <ParamField path="loginAccount" type="LinkedAccountWithMetadata | null">
      The account corresponding to the loginMethod used.
    </ParamField>

    ### `onError`

    ```tsx  theme={"system"}
    onError: (error: Error) => void
    ```

    #### Parameters

    <ParamField path="error" type="Error">
      The error that occurred during the login flow.
    </ParamField>

    ## Resources

    <Columns cols={3}>
      <Card title="React starter repo" href="https://github.com/privy-io/examples/tree/main/privy-react-starter" icon="github" arrow="true">
        Get started with React and Privy.
      </Card>

      <Card title="Next.js starter repo" href="https://github.com/privy-io/examples/tree/main/privy-next-starter" icon="github" arrow="true">
        Get started with Next.js and Privy.
      </Card>

      <Card title="Whitelabel starter repo" href="https://github.com/privy-io/examples/tree/main/privy-react-whitelabel-starter" icon="github" arrow="true">
        Get started with a whitelabel Privy integration.
      </Card>
    </Columns>
  </Tab>

  <Tab title="React Native">
    To authenticate your users with a one-time passcode (OTP) sent to their email address, use the `useLoginWithEmail` hook.

    <Info>
      To authenticate your users with Privy's out of the box UIs, check out UI components [here](/authentication/user-authentication/ui-component#react-native).
    </Info>

    ## Send Code

    ```jsx  theme={"system"}
    sendCode: ({email: string}) => Promise<{success: boolean}>
    ```

    ### Parameters

    <ParamField path="email" type="string" required>
      The email address of the user to log in.
    </ParamField>

    ### Returns

    <ResponseField name="success" type="boolean">
      A promise that resolves to an object with a success property indicating if the code was sent successfully.
    </ResponseField>

    ## Login with Code

    ```jsx  theme={"system"}
    loginWithCode: ({ code: string, email?: string, disableSignup?: boolean }) => Promise<{user: PrivyUser; isNewUser: boolean}>
    ```

    ### Parameters

    <ParamField path="code" type="string" required>
      The one-time passcode sent to the user's email address.
    </ParamField>

    <ParamField path="email" type="string">
      The user's email address. Though this parameter is optional, it is highly recommended that you pass the user's email address explicitly.
    </ParamField>

    <ParamField path="disableSignup" type="boolean">
      Whether to disable the ability to sign up with the email address.
    </ParamField>

    ### Returns

    <ResponseField name="user" type="PrivyUser">
      The user object returned by the login process.
    </ResponseField>

    ## Usage

    ```jsx  theme={"system"}
    import { useState } from 'react';
    import { useLoginWithEmail } from '@privy-io/expo';

    export default function LoginWithEmail() {
    const [email, setEmail] = useState('');
    const [code, setCode] = useState('');
    const { sendCode, loginWithCode } = useLoginWithEmail();

    return (
        <View>
        <TextInput value={email} onChangeText={setEmail} placeholder="Email" />
        <Button onPress={() => sendCode({ email })}>Send Code</Button>
        <TextInput value={code} onChangeText={setCode} placeholder="Code" />
        <Button onPress={() => loginWithCode({ code, email })}>Login</Button>
        </View>
    );
    }
    ```

    ## Tracking login flow state

    The state variable returned from useLoginWithEmail will always be one of the following values.

    ```ts  theme={"system"}
    type OtpFlowState =
    | {status: 'initial'}
    | {status: 'error'; error: Error | null}
    | {status: 'sending-code'}
    | {status: 'awaiting-code-input'}
    | {status: 'submitting-code'}
    | {status: 'done'};
    ```

    <ResponseField name="status" type="'initial' | 'error' | 'sending-code' | 'awaiting-code-input' | 'submitting-code' | 'done'">
      The current state of the email login flow.
    </ResponseField>

    <ResponseField name="error" type="Error | null">
      The error that occurred during the email login flow.
    </ResponseField>

    ## Callbacks

    You can optionally pass callbacks into the `useLoginWithEmail` hook to run custom logic after an OTP has been sent, after a successful login, or to handle errors that occur during the flow.

    ### `onSendCodeSuccess`

    ```tsx  theme={"system"}
    onSendCodeSuccess?: ((email: string) => void) | undefined
    ```

    #### Parameters

    <ParamField path="email" type="string">
      The email the code was sent to.
    </ParamField>

    ### `onLoginSuccess`

    ```tsx  theme={"system"}
    onLoginSuccess?: ((user: User, isNewUser: boolean) => void) | undefined
    ```

    #### Parameters

    <ParamField path="user" type="User">
      The PrivyUser returned by loginWithCode.
    </ParamField>

    <ParamField path="isNewUser" type="boolean">
      Whether the user is a new user or an existing user.
    </ParamField>

    ### `onError`

    ```tsx  theme={"system"}
    onError?: (error: Error) => void
    ```

    #### Parameters

    <ParamField path="error" type="Error">
      The error that occurred during the login flow.
    </ParamField>

    ## Resources

    <Columns cols={3}>
      <Card title="Expo starter repo" href="https://github.com/privy-io/examples/tree/main/privy-expo-starter" icon="github" arrow="true">
        Get started with Expo and Privy.
      </Card>

      <Card title="Expo bare starter repo" href="https://github.com/privy-io/examples/tree/main/privy-expo-bare-starter" icon="github" arrow="true">
        Get started with Expo bare and Privy.
      </Card>
    </Columns>
  </Tab>

  <Tab title="Swift">
    To authenticate a user via their email address, use the Privy client's `email` handler.

    ## Send Code

    ```swift  theme={"system"}
    sendCode(to email: String) async throws
    ```

    ### Parameters

    <ParamField path="to" type="String" required>
      The email address of the user to log in.
    </ParamField>

    ### Returns

    <ResponseField>
      Nothing, indicating success.
    </ResponseField>

    ### Throws

    An error if sending the code fails.

    ## Login with Code

    ```swift  theme={"system"}
    loginWithCode(_ code: String, sentTo email: String) async throws -> PrivyUser
    ```

    ### Parameters

    <ParamField path="code" type="String" required>
      The one-time passcode sent to the user's email address.
    </ParamField>

    <ParamField path="sentTo" type="String" required>
      The user's email address.
    </ParamField>

    ### Returns

    <ResponseField name="PrivyUser" type="PrivyUser">
      The authenticated Privy user
    </ResponseField>

    ### Throws

    An error if logging the user in is unsuccessful.

    ## Usage

    ```swift  theme={"system"}
    // Send code to user's email
    do {
        try await privy.email.sendCode(to: "myuser@privy.io")
        // successfully sent code to users email
    } catch {
        print("error sending code to \(email): \(error)")
    }

    // Log the user in
    do {
        let user = try await privy.email.loginWithCode("123456", sentTo: "myuser@privy.io")
        // user successfully logged in
    } catch {
        print("error logging user in: \(error)")
    }
    ```
  </Tab>

  <Tab title="Android">
    To authenticate a user via their email address, use the Privy client's `email` handler.

    ## Send Code

    ```kotlin  theme={"system"}
    sendCode(email: String): Result<Unit>
    ```

    ### Parameters

    <ParamField path="email" type="String" required>
      The email address of the user to log in.
    </ParamField>

    ### Returns

    <ResponseField name="Result<Unit>" type="Result<Unit>">
      A Result object that indicates whether the operation was successful. Returns Result.success if the code was sent successfully, or Result.failure if there was an error.
    </ResponseField>

    ## Login with Code

    ```kotlin  theme={"system"}
    loginWithCode(code: String, email: String?): Result<PrivyUser>
    ```

    ### Parameters

    <ParamField path="code" type="String" required>
      The one-time passcode sent to the user's email address.
    </ParamField>

    <ParamField path="email" type="String">
      (Optional) The user's email address. Though this parameter is optional, it is highly recommended that you pass the user's email address explicitly. If email is omitted, the email from sendCode will be used.
    </ParamField>

    ### Returns

    <ResponseField name="Result<PrivyUser>" type="Result<PrivyUser>">
      A Result object containing the PrivyUser if successful, or an error if the operation failed.
    </ResponseField>

    ## Usage

    ```kotlin  theme={"system"}
    // Send code to user's email
    val result: Result<Unit> = privy.email.sendCode(email = "user_email@gmail.com")

    result.fold(
      onSuccess = {
        // OTP was successfully sent
      },
      onFailure = {
        println("Error sending OTP: ${it.message}")
      }
    )

    // Authenticate with the OTP code
    val result: Result<PrivyUser> = privy.email.loginWithCode(code = "123456", email = "user_email@gmail.com")

    result.fold(
      onSuccess = { user ->
        // User logged in
      },
      onFailure = {
        println("Error logging in user: ${it.message}")
      }
    )
    ```
  </Tab>

  <Tab title="Unity">
    To authenticate a user via their email address, use the Privy client's `Email` handler.

    ## Send Code

    ```csharp  theme={"system"}
    SendCode(string email): Task<bool>
    ```

    ### Parameters

    <ParamField path="email" type="string" required>
      The email address of the user to log in.
    </ParamField>

    ### Returns

    <ResponseField name="Task<bool>" type="Task<bool>">
      A Task that resolves to a boolean indicating whether the code was sent successfully.
    </ResponseField>

    ## Login with Code

    ```csharp  theme={"system"}
    LoginWithCode(string email, string code): Task
    ```

    ### Parameters

    <ParamField path="email" type="string" required>
      The user's email address.
    </ParamField>

    <ParamField path="code" type="string" required>
      The one-time passcode sent to the user's email address.
    </ParamField>

    ### Returns

    <ResponseField name="Task" type="Task">
      A Task that completes when the user is successfully authenticated, or throws an exception if authentication fails.
    </ResponseField>

    ## Usage

    ```csharp  theme={"system"}
    // Send code to user's email
    bool success = await PrivyManager.Instance.Email.SendCode(email);

    if (success)
    {
        // Prompt user to enter the OTP they received at their email address through your UI
    }
    else
    {
        // There was an error sending an OTP to your user's email
    }

    // Authenticate with the OTP code
    try
    {
        // User will be authenticated if this call is successful
        await PrivyManager.Instance.Email.LoginWithCode(email, code);
        // User is now logged in
    }
    catch
    {
        // If "LoginWithCode" throws an exception, user login was unsuccessful.
        Debug.Log("Error logging user in.");
    }
    ```
  </Tab>

  <Tab title="Flutter">
    To authenticate a user via their email address, use the Privy client's `email` handler.

    ## Send Code

    ```dart  theme={"system"}
    sendCode(String email): Future<Result<void>>
    ```

    ### Parameters

    <ParamField path="email" type="String" required>
      The email address of the user to log in.
    </ParamField>

    ### Returns

    <ResponseField name="Result<void>" type="Future<Result<void>>">
      A Result object that indicates whether the operation was successful. Returns Result.success if the code was sent successfully, or Result.failure if there was an error.
    </ResponseField>

    ## Login with Code

    ```dart  theme={"system"}
    loginWithCode({required String code, String? email}): Future<Result<PrivyUser>>
    ```

    ### Parameters

    <ParamField path="code" type="String" required>
      The one-time passcode sent to the user's email address.
    </ParamField>

    <ParamField path="email" type="String">
      (Optional) The user's email address. Though this parameter is optional, it is highly recommended that you pass the user's email address explicitly. If email is omitted, the email from sendCode will be used.
    </ParamField>

    ### Returns

    <ResponseField name="Result<PrivyUser>" type="Future<Result<PrivyUser>>">
      A Result object containing the PrivyUser if successful, or an error if the operation failed.
    </ResponseField>

    ## Usage

    ```dart  theme={"system"}
    // Send code to user's email
    final Result<void> result = await privy.email.sendCode(email);

    result.fold(
      onSuccess: (_) {
        // OTP was sent successfully
      },
      onFailure: (error) {
        // Handle error sending OTP
        print(error.message);
      },
    );

    // Authenticate with the OTP code
    final Result<PrivyUser> result = await privy.email.loginWithCode(
      code: code,
      email: email,
    );

    result.fold(
      onSuccess: (user) {
        // User authenticated successfully
      },
      onFailure: (error) {
        // Handle authentication error
      },
    );
    ```

    ## Resources

    <Columns cols={3}>
      <Card title="Flutter starter repo" href="https://github.com/privy-io/examples/tree/main/privy-flutter-starter" icon="github" arrow="true">
        Get started with Flutter and Privy.
      </Card>
    </Columns>
  </Tab>
</Tabs>


# Farcaster
Source: https://docs.privy.io/authentication/user-authentication/login-methods/farcaster



[**Farcaster**](https://www.farcaster.xyz/) is a sufficiently decentralized social network whose core social graph is stored onchain.
Privy enables your users to log in to your application using their Farcaster account. Privy uses a standard called **Sign in with Farcaster** ([FIP-11](https://github.com/farcasterxyz/protocol/discussions/110))
to issue a signature request to a user's Farcaster account via the client a user has.

<Tip>
  Enable Farcaster authentication in the [Privy
  Dashboard](https://dashboard.privy.io/apps?page=login-methods\&logins=socials) before implementing
  this feature.
</Tip>

Your application can even request permissions from the user to become a signer for their Farcaster account, allowing your application to engage with the Farcaster social graph on their behalf.

<Tip>
  Interested in building a Farcaster Mini App? Check out our [Farcaster Mini App
  recipe](/recipes/farcaster/mini-apps)!
</Tip>

<Tabs>
  <Tab title="React">
    <Info>
      Privy currently only supports Farcaster login in React via the Privy UIs. To enable Farcaster login, you need to configure the Privy SDK with the `farcaster` login method. Explore our UI components [here](/authentication/user-authentication/ui-component).
    </Info>

    ```tsx  theme={"system"}
    <PrivyProvider
      appId={process.env.NEXT_PUBLIC_PRIVY_APP_ID}
      config={{
        // This configures farcaster and other login methods for your app.
        appearance: {
            loginMethods: ['farcaster', ...otherLoginMethods]
        },
        ...otherConfig
      }}
    >
    ```

    From there, you can prompt your users to authenticate via the `login` method:

    ```tsx  theme={"system"}
    import { usePrivy } from '@privy-io/react';
    ...
    const { login } = usePrivy();
    login();
    ```

    ## Resources

    <Columns cols={3}>
      <Card title="React starter repo" href="https://github.com/privy-io/examples/tree/main/privy-react-starter" icon="github" arrow="true">
        Get started with React and Privy.
      </Card>

      <Card title="Next.js starter repo" href="https://github.com/privy-io/examples/tree/main/privy-next-starter" icon="github" arrow="true">
        Get started with Next.js and Privy.
      </Card>

      <Card title="Whitelabel starter repo" href="https://github.com/privy-io/examples/tree/main/privy-react-whitelabel-starter" icon="github" arrow="true">
        Get started with a whitelabel Privy integration.
      </Card>
    </Columns>
  </Tab>

  <Tab title="React Native">
    To authenticate a user via Farcaster ([SIWF](https://github.com/farcasterxyz/protocol/discussions/110)), use the `loginWithFarcaster` method
    from the `useLoginWithFarcaster` hook.

    <Info>
      To authenticate your users with Privy's out of the box UIs, check out UI components [here](/authentication/user-authentication/ui-component#react-native).
    </Info>

    ```javascript  theme={"system"}
    loginWithFarcaster(input: {
      relyingParty: string;
      redirectUrl?: string;
      disableSignup?: boolean;
    }, config?: {
      pollIntervalMs?: number;
      pollAttempts?: number;
    }): Promise<PrivyUser | null>;
    ```

    ### Initializing the login flow

    To initialize login, use the `loginWithFarcaster` function from the `useLoginWithFarcaster` hook to start the Farcaster login flow.

    ```tsx  theme={"system"}
    import { useLoginWithFarcaster } from '@privy-io/expo';

    const { loginWithFarcaster, state } = useLoginWithFarcaster();
    ```

    As a parameter to `loginWithFarcaster`, you should pass an object containing:

    <ParamField path="input.relyingParty" type="string" required>
      Your app's website. Described in SIWF spec as "Origin domain of app frontend."
    </ParamField>

    <ParamField path="input.redirectUrl" type="string">
      A URL path that Farcaster will automatically redirect to after successful authentication. This defaults to a link back to your app root, eg. `'/'`, if not provided.
    </ParamField>

    <ParamField path="input.disableSignup" type="boolean">
      If true, the flow will only allow existing users to log in, preventing new account creation.
    </ParamField>

    <ParamField path="options.pollIntervalMs" type="number">
      The interval in milliseconds which your app will poll a status endpoint to check if the user has successfully signed in using Farcaster.
    </ParamField>

    <ParamField path="options.pollAttempts" type="number">
      The number of polling attempts that will be made to check for successful login.
    </ParamField>

    <Warning>
      If you pass in custom polling configuration, make sure to give the user enough time to go through the login process on Farcaster. The default values are `pollIntervalMs = 1000` and `pollAttempts = 10` giving the user 10 seconds to go through the login process. In our testing, this is usually enough time, but you may want to make it longer.
    </Warning>

    When this method is invoked, the user will be deeplinked to the Farcaster app on their device if they have it installed, or an installation page for the app. Within the Farcaster app, they can complete the login flow.

    If `loginWithFarcaster` succeeds, it will return a `PrivyUser` object with details about the authenticated user.

    Reasons `loginWithFarcaster` might fail include:

    * the network request fails
    * the login attempt is made after the user is already logged in
    * the user cancels the login flow after being linked out to Farcaster
    * the user takes too long to login and the polling time expires

    ### Tracking Flow State

    Track the state of the Farcaster flow via the `state` variable returned by the `useLoginWithFarcaster` hook.

    ```tsx  theme={"system"}
    state:
      | {status: 'initial'}
      | {status: 'error'; error: Error | null}
      | {status: 'generating-uri'}
      | {status: 'awaiting-uri'}
      | {status: 'polling-status'}
      | {status: 'submitting-token'}
      | {status: 'done'};
    ```

    <ResponseField name="status" type="'initial' | 'error' | 'generating-uri' | 'awaiting-uri' | 'polling-status' | 'submitting-token' | 'done'">
      The current state of the Farcaster flow.
    </ResponseField>

    <ResponseField name="error" type="Error | null">
      The error that occurred during the Farcaster flow (only present when status is 'error').
    </ResponseField>

    ### Usage: Conditional Rendering

    ```tsx  theme={"system"}
    import { View, ActivityIndicator, Text } from 'react-native';
    import { useLoginWithFarcaster, hasError } from '@privy-io/expo';

    export function LoginScreen() {
      const { state, loginWithFarcaster } = useLoginWithFarcaster();

      return (
        <View>
          <Button
            onPress={() => loginWithFarcaster({ relyingParty: 'https://example.app' })}
            title="Login with Farcaster"
            disabled={state.status !== 'initial' && state.status !== 'error'}
          />

          {state.status === 'polling-status' && (
            <View>
              <ActivityIndicator />
              <Text>Waiting for Farcaster confirmation...</Text>
            </View>
          )}

          {hasError(state) && (
            <Text style={{ color: 'red' }}>
              Error: {state.error.message}
            </Text>
          )}
        </View>
      );
    }
    ```

    ### Callbacks

    You can optionally pass callbacks to the `useLoginWithFarcaster` hook to run custom logic after a successful login or to handle errors.

    #### `onSuccess`

    ```tsx  theme={"system"}
    onSuccess: (user: PrivyUser, isNewUser: boolean) => Promise<void>
    ```

    ##### Parameters

    <ParamField path="user" type="PrivyUser">
      The user object returned after successful login.
    </ParamField>

    <ParamField path="isNewUser" type="boolean">
      Whether the user is a new user or an existing user.
    </ParamField>

    #### `onError`

    ```tsx  theme={"system"}
    onError: (error: Error) => Promise<void>
    ```

    ##### Parameters

    <ParamField path="error" type="Error">
      The error that occurred during the Farcaster flow.
    </ParamField>

    #### Usage with Callbacks

    ```tsx  theme={"system"}
    import { useLoginWithFarcaster } from '@privy-io/expo';

    export function LoginScreen() {
      const { loginWithFarcaster } = useLoginWithFarcaster({
        onSuccess(user, isNewUser) {
          console.log('Login successful', { user, isNewUser });
          // Navigate to home screen, show welcome message, etc.
        },
        onError(error) {
          console.error('Login failed', error);
          // Show error toast, update UI, etc.
        }
      });

      return (
        <Button
          onPress={() => loginWithFarcaster({ relyingParty: 'https://example.app' })}
          title="Login with Farcaster"
        />
      );
    }
    ```

    ## Resources

    <Columns cols={3}>
      <Card title="Expo starter repo" href="https://github.com/privy-io/examples/tree/main/privy-expo-starter" icon="github" arrow="true">
        Get started with Expo and Privy.
      </Card>

      <Card title="Expo bare starter repo" href="https://github.com/privy-io/examples/tree/main/privy-expo-bare-starter" icon="github" arrow="true">
        Get started with Expo bare and Privy.
      </Card>
    </Columns>
  </Tab>
</Tabs>


# Guest accounts
Source: https://docs.privy.io/authentication/user-authentication/login-methods/guest



<Info>
  Privy enables developers to create Guest accounts for users, so that users can immediately use your app without going through a login flow.

  Guest accounts are available in @privy-io/react-auth\@1.77.0 and above.
</Info>

Privy guest accounts have powerful features:

* They are locally persisted, so guest users can leave and return to the same account on the same device.
* They have **fully functioning** embedded wallets that can transact and mint on-chain.
* They are upgradable to fully logged-in accounts by simply calling `login()`.
* They have stable user IDs that do not change once a user is fully logged in.
* They can be logged out and deleted as needed.

## Integration tips

* **Guest account creation:** If a user is not logged in at all (via guest or normal user account), we recommend showing guest account creation and normal user login side-by-side.
  * e.g. a “Continue as Guest” button next to a “Login or Create Account” button. This is so users do not create guest accounts unintentionally when they mean to log in with an existing account.
* **Guest account upgrade:** If a user is logged in as a guest, we recommend showing two options: upgrade or delete.
  * *Upgrade guest account*: When a guest upgrades to a full user, they must enter a new login credential. If they try to upgrade with a credential (e.g. email address) that already is associated with an existing account, they will see a “Could not link existing account” error message.
  * *Delete guest account*: If a guest prefers to use an existing account instead, they must delete their guest account first. We recommend surfacing a “delete” option explicitly so guests can opt-into abandoning their guest account in favor of an existing account.
* You can make use of [login and error callbacks](/authentication/user-authentication/login-methods/email) to customize your desired behavior when a user upgrades out of guest-mode.

## Please note

<Warning>
  Guest accounts are **valid for 30 days**. If the guest does not upgrade to a full user account
  within 30 days, the guest session will expire.
</Warning>

* User data and embedded wallets from guest sessions **cannot** be merged into an existing user account — guest accounts can only be *upgraded* into a new user account. If a guest user wants to log in with an existing account, you must delete the guest user session first.
* Note that Telegram is not available as an upgrade login method for guest accounts.

## Configure guest accounts

<Tip>
  Enable guest accounts in the [Privy
  Dashboard](https://dashboard.privy.io/apps?page=login-methods\&logins=advanced) before implementing
  this feature.
</Tip>

<Tabs>
  <Tab title="React">
    ### Usage

    Use the `createGuestAccount` function from the `useGuestAccounts` hook in the React SDK to integrate guest accounts. The `createGuestAccount` function returns an [authenticated `User` object](/user-management/users/the-user-object).

    ```jsx  theme={"system"}
    import {useGuestAccounts} from '@privy-io/react-auth';
    // createGuestAccount: () => Promise<User>
    const {createGuestAccount} = useGuestAccounts();
    ```

    `createGuestAccount` is an asynchronous call that will create and authenticate users as guests. If the user is already a guest, this call is idempotent. If the user is already *logged in* as a non-guest user, this will throw an error indicating as such.

    ### Check if a user is a guest

    To check if a User is a guest account, use the `isGuest` property on the `User` object returned by the `usePrivy` hook.

    ```jsx  theme={"system"}
    const {user} = usePrivy();

    // isGuest: boolean
    user.isGuest;
    ```

    ### Access a guest user ID

    To access the guest’s user data including their stable user ID and wallet address, access the user object from the `usePrivy` hook.

    ```tsx  theme={"system"}
    const {user} = usePrivy();

    // Get the user's stable User ID and their wallet address.
    user.id;
    user.wallet.address;
    ```

    ### Access a guest user’s embedded wallet

    To transact with the guest user’s embedded wallet, [use the appropriate wallet from the connected `wallets` array.](/wallets/wallets/get-a-wallet) All embedded wallet functionality that is available for logged-in users is also available to guest users.

    ```tsx  theme={"system"}
    const {wallets} = useWallets();
    const embeddedWallet = getEmbeddedConnectedWallet(wallets);

    // Get the embedded wallet address or send a transaction.
    embeddedWallet.address;
    const provider = await embeddedWallet.getEthereumProvider()
    provider.request({method: 'eth_sendTransaction', params: [...]});
    ```

    ### Upgrade a guest user to a logged-in user

    Simply call `login()` to enable the guest user to upgrade their account to a logged-in account using any authentication method of their choice.

    ```tsx  theme={"system"}
    // login: (options?) => void
    const {login} = usePrivy();
    ```

    ### Enable a guest user to delete their guest session

    Call `logout()` to enable the guest user to delete their guest session. This is an important interface to support so that users who start a guest session but would prefer to log in with a pre-existing account, are able to do so.

    ```tsx  theme={"system"}
    // logout: (options?) => void
    const {logout} = usePrivy();
    ```

    ## Resources

    <Columns cols={3}>
      <Card title="React starter repo" href="https://github.com/privy-io/examples/tree/main/privy-react-starter" icon="github" arrow="true">
        Get started with React and Privy.
      </Card>

      <Card title="Next.js starter repo" href="https://github.com/privy-io/examples/tree/main/privy-next-starter" icon="github" arrow="true">
        Get started with Next.js and Privy.
      </Card>

      <Card title="Whitelabel starter repo" href="https://github.com/privy-io/examples/tree/main/privy-react-whitelabel-starter" icon="github" arrow="true">
        Get started with a whitelabel Privy integration.
      </Card>
    </Columns>
  </Tab>

  <Tab title="React Native">
    ### Usage

    Use `guest` from the `useCreateGuestAccount` hook in the React SDK to integrate guest accounts. The `guest.create()` function returns an [authenticated `User` object](/user-management/users/the-user-object).

    ```jsx  theme={"system"}
    import {useCreateGuestAccount} from '@privy-io/expo';
    const guest = useCreateGuestAccount();
    ```

    `guest.create()` is an asynchronous call that will create and authenticate users as guests. If the user is already a guest, this call is idempotent. If the user is already *logged in* as a non-guest user, this will throw an error indicating as such.

    ### Check if a user is a guest

    To check if a User is a guest account, use the `isGuest` property on the `User` object returned by the `usePrivy` hook.

    ```jsx  theme={"system"}
    const {user} = usePrivy();

    // isGuest: boolean
    user.isGuest;
    ```

    ### Access a guest user ID

    To access the guest’s user data including their stable user ID and wallet address, access the user object from the `usePrivy` hook.

    ```tsx  theme={"system"}
    const {user} = usePrivy();

    // Get the user's stable User ID and their wallet address.
    user.id;
    user.wallet.address;
    ```

    ### Access a guest user’s embedded wallet

    To transact with the guest user’s embedded wallet, [use the appropriate wallet from the connected `wallets` array.](/wallets/wallets/get-a-wallet) All embedded wallet functionality that is available for logged-in users is also available to guest users.

    ```tsx  theme={"system"}
    import {useEmbeddedEthereumWallet} from '@privy-io/expo';
    const {wallets} = useEmbeddedEthereumWallet();
    const desiredWallet = wallets.find((wallet) => wallet.address === desiredAddress);
    ```

    ### Upgrade a guest user to a logged-in user

    Simply call `login()` to enable the guest user to upgrade their account to a logged-in account using any authentication method of their choice.

    ```tsx  theme={"system"}
    // login: (options?) => void
    const {login} = useLogin();
    ```

    ### Enable a guest user to delete their guest session

    Call `logout()` to enable the guest user to delete their guest session. This is an important interface to support so that users who start a guest session but would prefer to log in with a pre-existing account, are able to do so.

    ```tsx  theme={"system"}
    // logout: (options?) => void
    const {logout} = usePrivy();
    ```

    ## Resources

    <Columns cols={3}>
      <Card title="Expo starter repo" href="https://github.com/privy-io/examples/tree/main/privy-expo-starter" icon="github" arrow="true">
        Get started with Expo and Privy.
      </Card>

      <Card title="Expo bare starter repo" href="https://github.com/privy-io/examples/tree/main/privy-expo-bare-starter" icon="github" arrow="true">
        Get started with Expo bare and Privy.
      </Card>
    </Columns>
  </Tab>
</Tabs>


# OAuth
Source: https://docs.privy.io/authentication/user-authentication/login-methods/oauth



export const platform_4 = "Flutter"

export const providers_4 = "Google, Apple, Twitter, and Discord"

export const platform_3 = "Android"

export const providers_3 = "Google, Discord, and Twitter"

export const platform_2 = "Swift"

export const providers_2 = "Google, Apple, Twitter and Discord"

export const platform_1 = "React Native"

export const providers_1 = "Google, Apple, Twitter, GitHub, Discord, LinkedIn, Spotify, TikTok, LINE, and Instagram"

export const platform_0 = "React"

export const providers_0 = "Google, Apple, Twitter, GitHub, Discord, LinkedIn, Spotify, TikTok, Instagram, and Line"

Privy offers the ability to sign up and log users in using OAuth providers. Users can sign in with familiar flows on Google, Apple, Twitter, Github, Discord, LinkedIn, TikTok, Spotify, Instagram, and LINE.

<Info>
  {' '}

  Google OAuth login may not work in in-app browsers (IABs), such as those embedded in social apps,
  due to Google's restrictions in these environments. Other OAuth providers are generally
  unaffected.
</Info>

<Tip>
  Enable your desired OAuth login method in the [Privy
  Dashboard](https://dashboard.privy.io/apps?page=login-methods\&logins=socials) before implementing
  this feature.
</Tip>

Login with OAuth is the onboarding flow your users are used to, integrated into your application in just a few lines of code.

<Tabs>
  <Tab title="React">
    <Tip>
      The {platform_0} SDK supports OAuth login with {providers_0}. For all other OAuth providers, you can
      use [JWT-based authentication](/authentication/user-authentication/jwt-based-auth/overview).
    </Tip>

    <Info>
      To authenticate your users with Privy's out of the box UIs, check out UI components [here](/authentication/user-authentication/ui-component).
    </Info>

    Use `initOAuth` from the `useLoginWithOAuth` hook to trigger the OAuth login flow.

    ```jsx  theme={"system"}
    initOAuth: ({ provider: OAuthProviderType, disableSignup?: boolean }) => Promise<void>
    ```

    <ParamField path="provider" type="OAuthProviderType" required>
      The OAuth provider to use for authentication. Valid values are: `'google'`, `'apple'`, `'twitter'`,
      `'github'`, `'discord'`, `'linkedin'`, `'spotify'`, `'tiktok'`, `'instagram'`, `'line'`.
    </ParamField>

    <ParamField path="disableSignup" type="boolean">
      If set to true, the OAuth flow will only allow users to log in with existing accounts and prevent new account creation.
    </ParamField>

    ### Usage

    ```jsx  theme={"system"}
    import { useLoginWithOAuth } from '@privy-io/react-auth';

    export default function LoginWithOAuth() {
      const { state, loading, initOAuth } = useLoginWithOAuth();

      const handleLogin = async () => {
          try {
              // The user will be redirected to OAuth provider's login page
              await initOAuth({ provider: 'google' });
          } catch (err) {
              // Handle errors (network issues, validation errors, etc.)
              console.error(err);
          }
      };

      return (
          <div>
              <button onClick={handleLogin} disabled={loading}>
                  {loading ? 'Logging in...' : 'Log in with Google'}
              </button>
          </div>
      );
    }
    ```

    ## Tracking Flow State

    Track the state of the OAuth flow via the `state` variable returned by the `useLoginWithOAuth` hook.

    ```tsx  theme={"system"}
    state:
    | {status: 'initial'}
    | {status: 'loading'}
    | {status: 'done'}
    | {status: 'error'; error: Error | null};
    ```

    <ResponseField name="status" type="'initial' | 'loading' | 'done' | 'error'">
      The current state of the OAuth flow.
    </ResponseField>

    <ResponseField name="error" type="Error | null">
      The error that occurred during the OAuth flow (only present when status is 'error').
    </ResponseField>

    ## Callbacks

    You can optionally pass callbacks to the `useLoginWithOAuth` hook to run custom logic after a successful login or to handle errors.

    ### `onComplete`

    ```tsx  theme={"system"}
    onComplete: ({user, isNewUser, wasAlreadyAuthenticated, loginMethod, linkedAccount}) => void
    ```

    #### Parameters

    <ParamField path="user" type="User">
      The user object returned after successful login.
    </ParamField>

    <ParamField path="isNewUser" type="boolean">
      Whether the user is a new user or an existing user.
    </ParamField>

    <ParamField path="wasAlreadyAuthenticated" type="boolean">
      Whether the user was already authenticated before the OAuth flow.
    </ParamField>

    <ParamField path="loginMethod" type="string">
      The login method used ('google', 'apple', etc.).
    </ParamField>

    <ParamField path="linkedAccount" type="LinkedAccount">
      The linked account if the user was already authenticated.
    </ParamField>

    ### `onError`

    ```tsx  theme={"system"}
    onError: (error: Error) => void
    ```

    #### Parameters

    <ParamField path="error" type="Error">
      The error that occurred during the OAuth flow.
    </ParamField>

    ### Example with Callbacks

    ```jsx  theme={"system"}
    import { useLoginWithOAuth } from '@privy-io/react-auth';

    export default function LoginWithOAuth() {
        const { initOAuth } = useLoginWithOAuth({
            onComplete: ({ user, isNewUser }) => {
                console.log('User logged in successfully', user);
                if (isNewUser) {
                    // Perform actions for new users
                }
            },
            onError: (error) => {
                console.error('Login failed', error);
            }
        });

        return (
            <button onClick={() => initOAuth({ provider: 'google' })}>
                Log in with Google
            </button>
        );
    }
    ```

    ## Security

    We recommend configuring allowed OAuth redirect URLs to restrict where users can be redirected after they log in with an external OAuth provider. [Learn more here](/recipes/react/allowed-oauth-redirects)!

    ## Accessing OAuth tokens

    For any OAuth login method for which you configure your own credentials, you are able to have the user’s OAuth and Refresh access tokens accessible to your app by toggling Return OAuth tokens and making use of the [useOAuthTokens](/recipes/react/oauth-tokens) hook.

    ## Resources

    <Columns cols={3}>
      <Card title="React starter repo" href="https://github.com/privy-io/examples/tree/main/privy-react-starter" icon="github" arrow="true">
        Get started with React and Privy.
      </Card>

      <Card title="Next.js starter repo" href="https://github.com/privy-io/examples/tree/main/privy-next-starter" icon="github" arrow="true">
        Get started with Next.js and Privy.
      </Card>

      <Card title="Whitelabel starter repo" href="https://github.com/privy-io/examples/tree/main/privy-react-whitelabel-starter" icon="github" arrow="true">
        Get started with a whitelabel Privy integration.
      </Card>
    </Columns>
  </Tab>

  <Tab title="React Native">
    <Info>
      To authenticate your users with Privy's out of the box UIs, check out UI components [here](/authentication/user-authentication/ui-component#react-native).
    </Info>

    <Tip>
      The {platform_1} SDK supports OAuth login with {providers_1}. For all other OAuth providers, you can
      use [JWT-based authentication](/authentication/user-authentication/jwt-based-auth/overview).
    </Tip>

    ### Configure allowed URL schemes

    Prior to integrating OAuth login, make sure you have [properly configured your app's allowed URL schemes in the Privy dashboard](/basics/get-started/dashboard/app-clients#allowed-url-schemes).

    <Warning>Login with OAuth will **not** work if you have not completed this step.</Warning>

    ## Initializing the login flow

    <Tip>
      Privy supports native [Apple login](https://developer.apple.com/sign-in-with-apple/) when running
      on iOS. To configure native Apple login, follow this
      [guide](/basics/react-native/advanced/setup-apple-login).
    </Tip>

    Use `login` from the `useLoginWithOAuth` hook to authenticate users using an OAuth provider.

    ```tsx  theme={"system"}
    login: ({
      provider: OAuthProviderType,
      disableSignup?: boolean
    }) => Promise<PrivyUser>
    ```

    ### Parameters

    <ParamField path="provider" type="OAuthProviderType" required>
      The OAuth provider to use for authentication. Valid values are: `'google'`, `'apple'`, `'twitter'`,
      `'github'`, `'discord'`, `'linkedin'`, `'spotify'`, `'tiktok'`, `'instagram'`.
    </ParamField>

    <ParamField path="disableSignup" type="boolean">
      If true, the OAuth flow will only allow existing users to log in, preventing new account creation.
    </ParamField>

    ### Response

    <ResponseField name="user" type="PrivyUser">
      The user object returned after successful login.
    </ResponseField>

    ### Usage

    ```tsx  theme={"system"}
    import { useLoginWithOAuth } from '@privy-io/expo';

    export function LoginButton() {
      const { login, state } = useLoginWithOAuth();

      return (
        <Button
          onPress={() => login({ provider: 'google' })}
          disabled={state.status === 'loading'}
        >
          {state.status === 'loading' ? 'Logging in...' : 'Login with Google'}
        </Button>
      );
    }
    ```

    ### Handling errors

    The promise returned by the `login` method will reject with an error if the OAuth flow fails.

    ```tsx  theme={"system"}
    import { useLoginWithOAuth } from '@privy-io/expo';

    export function LoginScreen() {
      const [isLoading, setIsLoading] = useState(false);
      const { login } = useLoginWithOAuth();

      const onPress = async () => {
        try {
          setIsLoading(true);
          const user = await login({ provider: 'google' });
          console.log('Login successful', user.id);
        } catch (error) {
          console.error('Login failed', error);
        } finally {
          setIsLoading(false);
        }
      };

      return (
        <Button
          disabled={isLoading}
          onPress={onPress}
          title="Login with Google"
        />
      );
    }
    ```

    ## Tracking Flow State

    Track the state of the OAuth flow via the `state` variable returned by the `useLoginWithOAuth` hook.

    ```tsx  theme={"system"}
    state:
      | {status: 'initial'}
      | {status: 'loading'}
      | {status: 'done'}
      | {status: 'error'; error: Error | null};
    ```

    <ResponseField name="status" type="'initial' | 'loading' | 'done' | 'error'">
      The current state of the OAuth flow.
    </ResponseField>

    <ResponseField name="error" type="Error | null">
      The error that occurred during the OAuth flow (only present when status is 'error').
    </ResponseField>

    ### Usage: Conditional Rendering

    ```tsx  theme={"system"}
    import { View, Text, Button } from 'react-native';
    import { usePrivy, useLoginWithOAuth, hasError } from '@privy-io/expo';

    export function LoginScreen() {
      const { user } = usePrivy();
      const { state, login } = useLoginWithOAuth();

      return state.status === 'done' ? (
        <View>
          <Text>You logged in successfully</Text>
        </View>
      ) : (
        <View>
          <Button
            disabled={state.status === 'loading'}
            onPress={() => login({ provider: 'google' })}
            title={state.status === 'loading' ? 'Logging in...' : 'Login with Google'}
          />

          {hasError(state) && (
            <Text>Error: {state.error.message}</Text>
          )}
        </View>
      );
    }
    ```

    ## Resources

    <Columns cols={3}>
      <Card title="Expo starter repo" href="https://github.com/privy-io/examples/tree/main/privy-expo-starter" icon="github" arrow="true">
        Get started with Expo and Privy.
      </Card>

      <Card title="Expo bare starter repo" href="https://github.com/privy-io/examples/tree/main/privy-expo-bare-starter" icon="github" arrow="true">
        Get started with Expo bare and Privy.
      </Card>
    </Columns>
  </Tab>

  <Tab title="Swift">
    <Tip>
      The {platform_2} SDK supports OAuth login with {providers_2}. For all other OAuth providers, you can
      use [JWT-based authentication](/authentication/user-authentication/jwt-based-auth/overview).
    </Tip>

    ### Configure allowed URL schemes

    Prior to integrating OAuth login, make sure you have [properly configured your app's allowed URL schemes in the Privy dashboard](/basics/get-started/dashboard/app-clients#allowed-url-schemes).

    <Warning>Login with OAuth will **not** work if you have not completed this step.</Warning>

    ## Initializing the login flow

    <Tip>
      Privy supports native [Apple login](https://developer.apple.com/sign-in-with-apple/) when running
      on iOS. To configure native Apple login, follow this [guide](/recipes/swift/apple).
    </Tip>

    To launch the oAuth flow, simply call `privy.oAuth.login`. As parameters to this method, pass the following fields:

    <ParamField path="provider" type="OAuthProvider" required>
      A member of the `OAuthProvider` enum specifying which OAuth provider the user should login with. Currently, `.google`, `.apple`, `.discord`, and `.twitter` are supported.
    </ParamField>

    <ParamField path="appUrlScheme" type="String">
      (Optional). Your app's URL scheme as a string. If you do not pass this value, Privy will use the first valid app URL scheme from your app's `info.plist`.
    </ParamField>

    ### Returns

    <ResponseField name="PrivyUser" type="PrivyUser">
      The authenticated Privy user
    </ResponseField>

    ### Throws

    An error if logging the user in is unsuccessful.

    ### Usage

    ```swift  theme={"system"}
    do {
        let privyUser = try await privy.oAuth.login(with: OAuthProvider.google, appUrlScheme: "privyiosdemo")
    } catch {
        print("OAuth login error: \(error)")
    }
    ```

    That's it! If your user was successfully authenticated, the `login` method will return the new AuthSession.

    ### Handling errors

    An error could be thrown if:

    * Your app url scheme is not explicitly provided or set in your info.plist
    * Your app url scheme is not registered in the Privy dashboard.
    * There was an issue generating the OAuth provider login URL
    * The user declined or cancelled the login attempt, or there was another error during authentication

    If an error is thrown, you can get a description of the error as a `string` from the `error` thrown by `privy.oAuth.login`.

    ## Native Apple login

    To configure native apple login, follow this [guide](/recipes/swift/apple).
  </Tab>

  <Tab title="Android">
    <Tip>
      The {platform_3} SDK supports OAuth login with {providers_3}. For all other OAuth providers, you can
      use [JWT-based authentication](/authentication/user-authentication/jwt-based-auth/overview).
    </Tip>

    ### Configure allowed URL schemes

    Prior to integrating OAuth login, make sure you have [properly configured your app's allowed URL schemes in the Privy dashboard](/basics/get-started/dashboard/app-clients#allowed-url-schemes).

    <Warning>Login with OAuth will **not** work if you have not completed this step.</Warning>

    ## Configure your Android Manifest

    Add the following activity to your `AndroidManifest.xml` file to handle OAuth redirects:

    ```xml  theme={"system"}
    <activity
        android:name="io.privy.sdk.oAuth.PrivyRedirectActivity"
        android:exported="true"
        android:launchMode="singleTask">
        <intent-filter android:autoVerify="true">
            <action android:name="android.intent.action.VIEW" />
            <category android:name="android.intent.category.DEFAULT" />
            <category android:name="android.intent.category.BROWSABLE" />
            <data android:scheme="YOUR_CUSTOM_PRIVY_OAUTH_SCHEME" />
        </intent-filter>
    </activity>
    ```

    **Replace `YOUR_CUSTOM_PRIVY_OAUTH_SCHEME` with your app's custom URL scheme.**

    <Warning>
      This scheme must be unique for this activity as it can cause issues if they clash with other activities or apps.
    </Warning>

    ## Initializing the login flow

    To launch the oAuth flow, simply call `privy.oAuth.login`. As parameters to this method, pass the following fields:

    <ParamField path="provider" type="OAuthProvider" required>
      A member of the `OAuthProvider` enum specifying which OAuth provider the user should login with. Currently, `Google`, `Discord`, and `Twitter` are supported.
    </ParamField>

    <ParamField path="appUrlScheme" type="String" required>
      Your app's URL scheme as a string. This must match the scheme configured in your AndroidManifest.xml.
    </ParamField>

    ### Returns

    <ResponseField name="PrivyUser" type="Result<PrivyUser>">
      A `Result` containing the authenticated `PrivyUser`. Returns `Result.success` with the PrivyUser if authentication was successful, or `Result.failure` if there was an error.
    </ResponseField>

    ### Usage

    ```kotlin  theme={"system"}
    val scheme = "privytestapp://"

    viewModelScope.launch {
        val result = privy.oAuth.login(OAuthProvider.Google, scheme)
        result
            .onSuccess { user ->
                // Handle successful authentication
                println("OAuth login successful: ${user.id}")
            }
            .onFailure { error ->
                // Handle authentication error
                println("OAuth login error: ${error.message}")
            }
    }
    ```

    That's it! If your user was successfully authenticated, the `login` method will return the authenticated `PrivyUser`.

    ### Handling errors

    The `login` method returns a `Result` that will contain a failure if:

    * Your app URL scheme is not provided in the method call
    * Your app URL scheme is not registered in the Privy dashboard
    * Your app URL scheme doesn't match the one configured in your AndroidManifest.xml
    * There was an issue generating the OAuth provider login URL
    * The user declined or cancelled the login attempt, or there was another error during authentication

    You can handle these errors using the `onFailure` method as shown in the usage example above.
  </Tab>

  <Tab title="Unity">
    ### Configure allowed URL schemes

    Prior to integrating OAuth login, make sure you have [properly configured your app's allowed URL schemes in the Privy dashboard](/basics/get-started/dashboard/app-clients#allowed-url-schemes).

    <Warning>Login with OAuth will **not** work if you have not completed this step.</Warning>

    ## Initializing the login flow

    To authenticate a user via an OAuth account (e.g. Google, Discord, Apple), use the Privy client's `OAuth` handler.

    This is a two step process, though Privy's Unity SDK wraps it into a single method call:

    1. Generate an OAuth login URL corresponding to your desired OAuth provider
    2. Redirect the user to the login URL to have them authenticate with the chosen OAuth provider

    ## Supported OAuth Providers

    Privy's Unity SDK currently supports OAuth login with Google, Apple, Twitter, and Discord.

    We're actively working to expand our support for other OAuth providers.
    Interested in a specific provider that isn't currently supported? Contact us at [sales@privy.io](mailto:sales@privy.io).

    ## Initializing the login flow

    To launch the OAuth flow, simply call `PrivyManager.Instance.OAuth.LoginWithProvider`. As parameters to this method, pass the following fields:

    <ParamField path="provider" type="OAuthProvider" required>
      A member of the `OAuthProvider` enum specifying which OAuth provider the user should login with.
    </ParamField>

    <ParamField path="redirectUri" type="String" required>
      For WebGL builds, this will be your redirect URL. For applications, this will be your app's URL scheme.
    </ParamField>

    ### Usage

    ```csharp  theme={"system"}
    try
    {
        // Log the user in with Google OAuth
        await PrivyManager.Instance.OAuth.LoginWithProvider(OAuthProvider.Google, "myappscheme");
    }
    catch
    {
        // Login with OAuth was unsuccessful
        Debug.Log("Error logging user in.");
    }
    ```

    That's it! If your user was successfully authenticated, the `LoginWithProvider` method will return the new `AuthState` for a user.

    This method will throw an error if:

    * a `redirectUri` is not provided
    * the network call to authenticate the user fails
  </Tab>

  <Tab title="Flutter">
    <Tip>
      The {platform_4} SDK supports OAuth login with {providers_4}. For all other OAuth providers, you can
      use [JWT-based authentication](/authentication/user-authentication/jwt-based-auth/overview).
    </Tip>

    ### Configure allowed URL schemes

    Prior to integrating OAuth login, make sure you have [properly configured your app's allowed URL schemes in the Privy dashboard](/basics/get-started/dashboard/app-clients#allowed-url-schemes).

    <Warning>Login with OAuth will **not** work if you have not completed this step.</Warning>

    ## Platform Configuration

    Before implementing OAuth login, you need to configure your app for OAuth redirects on both Android and iOS.

    ### Android Configuration

    Add the following activity to your `android/app/src/main/AndroidManifest.xml` file to handle OAuth redirects:

    ```xml  theme={"system"}
    <activity
        android:name="io.privy.sdk.oAuth.PrivyRedirectActivity"
        android:exported="true"
        android:launchMode="singleTask"
        android:theme="@android:style/Theme.Translucent.NoTitleBar">
        <intent-filter>
            <action android:name="android.intent.action.VIEW" />
            <category android:name="android.intent.category.DEFAULT" />
            <category android:name="android.intent.category.BROWSABLE" />
            <data android:scheme="YOUR_CUSTOM_PRIVY_OAUTH_SCHEME" />
        </intent-filter>
    </activity>
    ```

    **Replace `YOUR_CUSTOM_PRIVY_OAUTH_SCHEME` with your app's custom URL scheme.**

    <Warning>
      This scheme must be unique for this activity as it can cause issues if they clash with other activities or apps.
    </Warning>

    ### iOS Configuration

    Add your custom URL scheme to your `ios/Runner/Info.plist` file:

    ```xml  theme={"system"}
    <key>CFBundleURLTypes</key>
    <array>
        <dict>
            <key>CFBundleURLName</key>
            <string>privy.oauth</string>
            <key>CFBundleURLSchemes</key>
            <array>
                <string>YOUR_CUSTOM_PRIVY_OAUTH_SCHEME</string>
            </array>
        </dict>
    </array>
    ```

    **Replace `YOUR_CUSTOM_PRIVY_OAUTH_SCHEME` with your app's custom URL scheme.**

    <Tip>
      Privy supports native [Apple login](https://developer.apple.com/sign-in-with-apple/) when running
      on iOS. Apple Sign In requires iOS 13.0+ and is only available on iOS devices. To configure native Apple login, follow this [guide](/basics/get-started/dashboard/configure-login-methods#oauth-login-methods-google-twitter-etc:apple).
    </Tip>

    ## Initializing the login flow

    Use the `login` method from your Privy instance's OAuth module to authenticate users using an OAuth provider.

    ```dart  theme={"system"}
    Future<Result<PrivyUser>> login({
      required OAuthProvider provider,
      required String appUrlScheme,
    })
    ```

    ### Parameters

    <ParamField path="provider" type="OAuthProvider" required>
      The OAuth provider to use for authentication. Valid values are: `OAuthProvider.google`, `OAuthProvider.apple` (iOS only), `OAuthProvider.twitter`,
      `OAuthProvider.discord`.
    </ParamField>

    <ParamField path="appUrlScheme" type="String" required>
      Your app's custom URL scheme for redirecting back to the app after OAuth authentication.
    </ParamField>

    ### Response

    <ResponseField name="Result<PrivyUser>" type="Result<PrivyUser>">
      A `Result` containing the authenticated `PrivyUser` on success, or a `Failure` with error details.
    </ResponseField>

    ### Usage

    ```dart  theme={"system"}
    final result = await privy.oAuth.login(
      provider: OAuthProvider.google,
      appUrlScheme: 'your-app-scheme',
    );

    result.fold(
      onSuccess: (user) {
        print('Login successful: ${user.id}');
      },
      onFailure: (error) {
        print('Login failed: $error');
      },
    );
    ```

    ## Handling errors

    An error could be thrown if:

    * Your app URL scheme is not provided in the method call
    * Your app URL scheme is not registered in the Privy dashboard
    * There was an issue generating the OAuth provider login URL
    * The user declined or cancelled the login attempt, or there was another error during authentication
    * Apple Sign In is attempted on Android (Apple Sign In is only supported on iOS)

    You can handle these errors using the `Result.fold()` method as shown in the usage example above.

    ## Resources

    <Columns cols={3}>
      <Card title="Flutter starter repo" href="https://github.com/privy-io/examples/tree/main/privy-flutter-starter" icon="github" arrow="true">
        Get started with Flutter and Privy.
      </Card>
    </Columns>
  </Tab>
</Tabs>


# Passkey
Source: https://docs.privy.io/authentication/user-authentication/login-methods/passkey



export const ExpoUserObject = ({description}) => {
  return <ResponseField name="user" type="PrivyUser">
      {description}
      <Expandable title="child attributes" defaultOpen="true">
        <ResponseField name="id" type="string">
          The Privy DID which you may use to identify your user on your backend
        </ResponseField>
        <ResponseField name="created_at" type="number">
          UNIX timestamp of when the user was created
        </ResponseField>
        <ResponseField name="linked_accounts" type="Array">
          An array of the user's linked accounts
          <Expandable title="Account Types">
            <ResponseField name="AppleAccount" type="Object">
              <Expandable title="child attributes" defaultOpen="true">
                <ResponseField name="type" type="string">
                  'apple_oauth'
                </ResponseField>
                <ResponseField name="email" type="string">
                  Email address associated with the user's Apple account
                </ResponseField>
                <ResponseField name="subject" type="number">
                  ID of user from Apple's user API
                </ResponseField>
                <ResponseField name="first_verified_at" type="number">
                  UNIX timestamp for when the account was first verified and linked to the user
                </ResponseField>
                <ResponseField name="latest_verified_at" type="number">
                  UNIX timestamp for when the account was last verified
                </ResponseField>
              </Expandable>
            </ResponseField>
            <ResponseField name="CustomJwtAccount" type="Object">
              <Expandable title="child attributes" defaultOpen="true">
                <ResponseField name="type" type="string">
                  'custom_auth'
                </ResponseField>
                <ResponseField name="custom_user_id" type="string">
                  ID of user from custom auth provider
                </ResponseField>
                <ResponseField name="first_verified_at" type="number">
                  UNIX timestamp for when the account was first verified and linked to the user
                </ResponseField>
                <ResponseField name="latest_verified_at" type="number">
                  UNIX timestamp for when the account was last verified
                </ResponseField>
              </Expandable>
            </ResponseField>
            <ResponseField name="DiscordAccount" type="Object">
              <Expandable title="child attributes" defaultOpen="true">
                <ResponseField name="type" type="string">
                  'discord_oauth'
                </ResponseField>
                <ResponseField name="subject" type="string">
                  ID of user from Discord user API response
                </ResponseField>
                <ResponseField name="email" type="string">
                  Email of user from Discord user API response
                </ResponseField>
                <ResponseField name="username" type="string">
                  Username of user from Discord user API response, including the 4-digit
                  discriminator prefixed by '#'
                </ResponseField>
                <ResponseField name="first_verified_at" type="number">
                  UNIX timestamp for when the account was first verified and linked to the user
                </ResponseField>
                <ResponseField name="latest_verified_at" type="number">
                  UNIX timestamp for when the account was last verified
                </ResponseField>
              </Expandable>
            </ResponseField>
            <ResponseField name="EmailAccount" type="Object">
              <Expandable title="child attributes" defaultOpen="true">
                <ResponseField name="type" type="string">
                  'email'
                </ResponseField>
                <ResponseField name="address" type="string">
                  Email address of user account
                </ResponseField>
                <ResponseField name="first_verified_at" type="number">
                  UNIX timestamp for when the account was first verified and linked to the user
                </ResponseField>
                <ResponseField name="latest_verified_at" type="number">
                  UNIX timestamp for when the account was last verified
                </ResponseField>
              </Expandable>
            </ResponseField>
            <ResponseField name="FarcasterAccount" type="Object">
              <Expandable title="child attributes" defaultOpen="true">
                <ResponseField name="type" type="string">
                  'farcaster'
                </ResponseField>
                <ResponseField name="fid" type="number">
                  FID of the user from Farcaster user API response
                </ResponseField>
                <ResponseField name="owner_address" type="string">
                  Wallet address of the user from Farcaster user API response (Farcaster wallet
                  address, not Privy embedded wallet address)
                </ResponseField>
                <ResponseField name="username" type="string" optional>
                  Username of user from Farcaster user API response (does not include the '@')
                </ResponseField>
                <ResponseField name="display_name" type="string" optional>
                  Display name of user from Farcaster user API response
                </ResponseField>
                <ResponseField name="bio" type="string" optional>
                  Bio of user from Farcaster user API response
                </ResponseField>
                <ResponseField name="profile_picture_url" type="string" optional>
                  Profile picture URL of the user from Farcaster user API response
                </ResponseField>
                <ResponseField name="homepage_url" type="string" optional>
                  Profile URL of the user from Farcaster user API response
                </ResponseField>
                <ResponseField name="first_verified_at" type="number">
                  UNIX timestamp for when the account was first verified and linked to the user
                </ResponseField>
                <ResponseField name="latest_verified_at" type="number">
                  UNIX timestamp for when the account was last verified
                </ResponseField>
              </Expandable>
            </ResponseField>
            <ResponseField name="GithubAccount" type="Object">
              <Expandable title="child attributes" defaultOpen="true">
                <ResponseField name="type" type="string">
                  'github_oauth'
                </ResponseField>
                <ResponseField name="subject" type="string">
                  ID of user from GitHub user API response
                </ResponseField>
                <ResponseField name="email" type="string">
                  Email of user from GitHub user API response
                </ResponseField>
                <ResponseField name="name" type="string">
                  Name of user from GitHub user API response
                </ResponseField>
                <ResponseField name="username" type="string">
                  Username of user from GitHub user API response
                </ResponseField>
                <ResponseField name="first_verified_at" type="number">
                  UNIX timestamp for when the account was first verified and linked to the user
                </ResponseField>
                <ResponseField name="latest_verified_at" type="number">
                  UNIX timestamp for when the account was last verified
                </ResponseField>
              </Expandable>
            </ResponseField>
            <ResponseField name="GoogleAccount" type="Object">
              <Expandable title="child attributes" defaultOpen="true">
                <ResponseField name="type" type="string">
                  'google_oauth'
                </ResponseField>
                <ResponseField name="subject" type="string">
                  'sub' pulled from Google-provided JWT with "openid" scope
                </ResponseField>
                <ResponseField name="email" type="string">
                  'email' from Google-provided JWT with "email" scope
                </ResponseField>
                <ResponseField name="name" type="string">
                  'name' from Google-provided JWT with "profile" scope
                </ResponseField>
                <ResponseField name="first_verified_at" type="number">
                  UNIX timestamp for when the account was first verified and linked to the user
                </ResponseField>
                <ResponseField name="latest_verified_at" type="number">
                  UNIX timestamp for when the account was last verified
                </ResponseField>
              </Expandable>
            </ResponseField>
            <ResponseField name="InstagramAccount" type="Object">
              <Expandable title="child attributes" defaultOpen="true">
                <ResponseField name="type" type="string">
                  'instagram_oauth'
                </ResponseField>
                <ResponseField name="subject" type="string">
                  ID of user from Instagram user API response
                </ResponseField>
                <ResponseField name="username" type="string">
                  The name displayed on a user's profile from Instagram's `/me` API response
                </ResponseField>
                <ResponseField name="first_verified_at" type="number">
                  UNIX timestamp for when the account was first verified and linked to the user
                </ResponseField>
                <ResponseField name="latest_verified_at" type="number">
                  UNIX timestamp for when the account was last verified
                </ResponseField>
              </Expandable>
            </ResponseField>
            <ResponseField name="LinkedinAccount" type="Object">
              <Expandable title="child attributes" defaultOpen="true">
                <ResponseField name="type" type="string">
                  'linkedin_oauth'
                </ResponseField>
                <ResponseField name="subject" type="string">
                  ID of user from LinkedIn user API response
                </ResponseField>
                <ResponseField name="email" type="string">
                  Email of user from LinkedIn user API response
                </ResponseField>
                <ResponseField name="name" type="string">
                  Name of user from LinkedIn user API response (does not include the '@')
                </ResponseField>
                <ResponseField name="first_verified_at" type="number">
                  UNIX timestamp for when the account was first verified and linked to the user
                </ResponseField>
                <ResponseField name="latest_verified_at" type="number">
                  UNIX timestamp for when the account was last verified
                </ResponseField>
              </Expandable>
            </ResponseField>
            <ResponseField name="PhoneAccount" type="Object">
              <Expandable title="child attributes" defaultOpen="true">
                <ResponseField name="type" type="string">
                  'phone'
                </ResponseField>
                <ResponseField name="number" type="string">
                  Phone number of user account (non-international numbers default to US)
                </ResponseField>
                <ResponseField name="first_verified_at" type="number">
                  UNIX timestamp for when the account was first verified and linked to the user
                </ResponseField>
                <ResponseField name="latest_verified_at" type="number">
                  UNIX timestamp for when the account was last verified
                </ResponseField>
              </Expandable>
            </ResponseField>
            <ResponseField name="SpotifyAccount" type="Object">
              <Expandable title="child attributes" defaultOpen="true">
                <ResponseField name="type" type="string">
                  'spotify_oauth'
                </ResponseField>
                <ResponseField name="subject" type="string">
                  ID of user from Spotify user API response
                </ResponseField>
                <ResponseField name="email" type="string">
                  Email of user from Spotify user API
                </ResponseField>
                <ResponseField name="name" type="string">
                  The name displayed on a user's profile from Spotify display_name API response
                </ResponseField>
                <ResponseField name="first_verified_at" type="number">
                  UNIX timestamp for when the account was first verified and linked to the user
                </ResponseField>
                <ResponseField name="latest_verified_at" type="number">
                  UNIX timestamp for when the account was last verified
                </ResponseField>
              </Expandable>
            </ResponseField>
            <ResponseField name="TelegramAccount" type="Object">
              <Expandable title="child attributes" defaultOpen="true">
                <ResponseField name="type" type="string">
                  'telegram'
                </ResponseField>
                <ResponseField name="telegram_user_id" type="string">
                  ID of a user's telegram account
                </ResponseField>
                <ResponseField name="first_name" type="string">
                  The first name displayed on a user's telegram account
                </ResponseField>
                <ResponseField name="last_name" type="string" optional>
                  The last name displayed on a user's telegram account
                </ResponseField>
                <ResponseField name="username" type="string" optional>
                  The username displayed on a user's telegram account
                </ResponseField>
                <ResponseField name="photo_url" type="string" optional>
                  The url of a user's telegram account profile picture
                </ResponseField>
                <ResponseField name="first_verified_at" type="number">
                  UNIX timestamp for when the account was first verified and linked to the user
                </ResponseField>
                <ResponseField name="latest_verified_at" type="number">
                  UNIX timestamp for when the account was last verified
                </ResponseField>
              </Expandable>
            </ResponseField>
            <ResponseField name="TwitterAccount" type="Object">
              <Expandable title="child attributes" defaultOpen="true">
                <ResponseField name="type" type="string">
                  'twitter_oauth'
                </ResponseField>
                <ResponseField name="subject" type="string">
                  ID of user from Twitter user API response
                </ResponseField>
                <ResponseField name="name" type="string">
                  Name of user from Twitter user API response
                </ResponseField>
                <ResponseField name="username" type="string">
                  Username of user from Twitter user API response (does not include the '@')
                </ResponseField>
                <ResponseField name="profile_picture_url" type="string" optional>
                  Profile picture URL of the user from Twitter user API response
                </ResponseField>
                <ResponseField name="first_verified_at" type="number">
                  UNIX timestamp for when the account was first verified and linked to the user
                </ResponseField>
                <ResponseField name="latest_verified_at" type="number">
                  UNIX timestamp for when the account was last verified
                </ResponseField>
              </Expandable>
            </ResponseField>
            <ResponseField name="WalletAccount" type="Object">
              <Expandable title="child attributes" defaultOpen="true">
                <ResponseField name="type" type="string">
                  'wallet'
                </ResponseField>
                <ResponseField name="chain_type" type="string">
                  Type of chain for the wallet: 'ethereum' or 'solana'
                </ResponseField>
                <ResponseField name="address" type="string">
                  Checksummed wallet address
                </ResponseField>
                <ResponseField name="first_verified_at" type="number">
                  UNIX timestamp for when the account was first verified and linked to the user
                </ResponseField>
                <ResponseField name="latest_verified_at" type="number">
                  UNIX timestamp for when the account was last verified
                </ResponseField>
              </Expandable>
            </ResponseField>
          </Expandable>
        </ResponseField>
      </Expandable>
    </ResponseField>;
};

Privy offers the ability to sign up and log users in using a passkey. This lets users access their account simply and securely.

<Tip>
  Enable passkey authentication in the [Privy
  Dashboard](https://dashboard.privy.io/apps?page=login-methods) before implementing this feature.
</Tip>

<Tabs>
  <Tab title="React">
    ## Login with Passkey

    <Info>
      To authenticate your users with Privy's out of the box UIs, check out UI components [here](/authentication/user-authentication/ui-component).
    </Info>

    Use `loginWithPasskey` from the `useLoginWithPasskey` hook to trigger the passkey login flow.

    ```jsx  theme={"system"}
    loginWithPasskey: ({ passkey?: string }) => void
    ```

    <ParamField path="passkey" type="string">
      Optionally prompt the user to sign in with a specific passkey credential.
    </ParamField>

    ### Usage

    ```jsx  theme={"system"}
    import { useLoginWithPasskey } from '@privy-io/react-auth';

    export default function LoginWithPasskey() {
      const { loginWithPasskey } = useLoginWithPasskey();

      return (
        <div>
          <button onClick={loginWithPasskey}>Log in with passkey</button>
        </div>
      );
    }
    ```

    ## Sign up with Passkey

    Use `signupWithPasskey` from the `useSignupWithPasskey` hook to trigger the passkey signup flow.

    ```jsx  theme={"system"}
    signupWithPasskey: () => void
    ```

    ### Usage

    ```jsx  theme={"system"}
    import { useSignupWithPasskey } from '@privy-io/react-auth';

    export default function SignupWithPasskey() {
      const { signupWithPasskey } = useSignupWithPasskey();

      return (
        <div>
          <button onClick={signupWithPasskey}>Sign up with passkey</button>
        </div>
      );
    }
    ```

    ## Tracking Flow State

    Track the state of the passkey flow via the `state` variable returned by both the
    `useLoginWithPasskey` and `useSignupWithPasskey` hooks.

    ```tsx  theme={"system"}
    state:
      | {status: 'initial'}
      | {status: 'error'; error: Error | null}
      | {status: 'generating-challenge'}
      | {status: 'awaiting-passkey'}
      | {status: 'submitting-response'}
      | {status: 'done'};
    ```

    <ResponseField name="status" type="'initial' | 'error' | 'generating-challenge' | 'awaiting-passkey' | 'submitting-response' | 'done'">
      The current state of the passkey flow.
    </ResponseField>

    <ResponseField name="error" type="Error | null">
      The error that occurred during the passkey flow.
    </ResponseField>

    ## Callbacks

    You can optionally pass callbacks into the `useLoginWithPasskey` and `useSignupWithPasskey` hooks to run custom logic after a successful login or signup, or to handle errors that occur during the flow.

    ### `onComplete`

    ```tsx  theme={"system"}
    onComplete: ({user, isNewUser, wasAlreadyAuthenticated, loginMethod, linkedAccount}) => void
    ```

    #### Parameters

    <ParamField path="User" type="PrivyUser">
      The [user object](/user-management/users/the-user-object) returned after successful login or signup."
    </ParamField>

    <ParamField path="isNewUser" type="boolean">
      Whether the user is a new user or an existing user.
    </ParamField>

    <ParamField path="wasAlreadyAuthenticated" type="boolean">
      Whether the user was already authenticated before the passkey flow.
    </ParamField>

    <ParamField path="loginMethod" type="'passkey'">
      The login method used to authenticate the user.
    </ParamField>

    <ParamField path="linkedAccount" type="LinkedAccount">
      The linked account if the user was already authenticated.
    </ParamField>

    ### `onError`

    ```tsx  theme={"system"}
    onError: (error: Error) => void
    ```

    #### Parameters

    <ParamField path="error" type="Error">
      The error that occurred during the passkey flow.
    </ParamField>

    ## Resources

    <Columns cols={3}>
      <Card title="React starter repo" href="https://github.com/privy-io/examples/tree/main/privy-react-starter" icon="github" arrow="true">
        Get started with React and Privy.
      </Card>

      <Card title="Next.js starter repo" href="https://github.com/privy-io/examples/tree/main/privy-next-starter" icon="github" arrow="true">
        Get started with Next.js and Privy.
      </Card>

      <Card title="Whitelabel starter repo" href="https://github.com/privy-io/examples/tree/main/privy-react-whitelabel-starter" icon="github" arrow="true">
        Get started with a whitelabel Privy integration.
      </Card>
    </Columns>
  </Tab>

  <Tab title="React Native">
    <Tip>
      Follow the [passkeys setup guide](/basics/react-native/advanced/setup-passkeys) to enable passkey authentication in your React Native app.
    </Tip>

    <Info>
      To authenticate your users with Privy's out of the box UIs, check out UI components [here](/authentication/user-authentication/ui-component#react-native).
    </Info>

    ## Login with Passkey

    Use `loginWithPasskey` from the `useLoginWithPasskey` hook to authenticate users using a passkey. Before using this method, ensure you have setup passkeys as described in this [guide](/basics/react-native/advanced/setup-passkeys).

    ```tsx  theme={"system"}
    loginWithPasskey: ({ relyingParty: string }) => Promise<PrivyUser>
    ```

    ### Parameters

    <ParamField path="relyingParty" type="string" required>
      The URL origin where your Apple App Site Association or Digital Asset Links are available (e.g. `https://example.com`).
    </ParamField>

    ### Response

    <ExpoUserObject description="The user object returned after successful login." />

    ### Usage

    ```tsx  theme={"system"}
    import {useLoginWithPasskey} from '@privy-io/expo/passkey';

    export function LoginButton() {
      const {loginWithPasskey} = useLoginWithPasskey();

      return (
        <Button onPress={() => loginWithPasskey({relyingParty: '<your-applications-relying-party>'})}>
          Login
        </Button>
      );
    }
    ```

    ## Sign up with Passkey

    Use `signupWithPasskey` from the `useSignupWithPasskey` hook to sign up users using a passkey.

    ```tsx  theme={"system"}
    signupWithPasskey: ({ relyingParty: string }) => Promise<PrivyUser>
    ```

    ### Parameters

    <ParamField path="relyingParty" type="string" required>
      The URL origin where your Apple App Site Association or Digital Asset Links are available (e.g. `https://example.com`).
    </ParamField>

    ### Response

    <ExpoUserObject description="The user object returned after successful signup." />

    ### Usage

    ```tsx  theme={"system"}
    import {useSignupWithPasskey} from '@privy-io/expo/passkey';

    export function SignupButton() {
      const {signupWithPasskey} = useSignupWithPasskey();

      return (
        <Button onPress={() => signupWithPasskey({relyingParty: '<your-applications-relying-party>'})}>
          Signup
        </Button>
      );
    }
    ```

    ## Tracking Flow State

    Track the state of the passkey flow via the `state` variable returned by both the
    `useLoginWithPasskey` and `useSignupWithPasskey` hooks.

    ```tsx  theme={"system"}
    state:
      | {status: 'initial'}
      | {status: 'error'; error: Error | null}
      | {status: 'generating-challenege'}
      | {status: 'awaiting-passkey'}
      | {status: 'submitting-response'}
      | {status: 'done'};
    ```

    <ResponseField name="status" type="'initial' | 'error' | 'generating-challenege' | 'awaiting-passkey' | 'submitting-response' | 'done'">
      {/* spellchecker:disable-line */}

      The current state of the passkey flow.
    </ResponseField>

    <ResponseField name="error" type="Error | null">
      The error that occurred during the passkey flow.
    </ResponseField>

    ## Callbacks

    You can optionally pass callbacks into the `useLoginWithPasskey` and `useSignupWithPasskey` hooks to run custom logic after a successful login or signup, or to handle errors that occur during the flow.

    ### `onSuccess`

    ```tsx  theme={"system"}
    onSuccess: (user: PrivyUser, isNewUser: boolean) => Promise<void>
    ```

    #### Parameters

    <ExpoUserObject description="The user object returned after successful login or signup." />

    <ParamField path="isNewUser" type="boolean">
      Whether the user is a new user or an existing user.
    </ParamField>

    #### Usage

    ```tsx  theme={"system"}
    import {useLoginWithPasskey} from '@privy-io/expo/passkey';

    export function LoginScreen() {
      const {loginWithPasskey} = useLoginWithPasskey({
        onSuccess(user, isNewUser) {
          // show a toast, send analytics event, etc...
        },
      });

      // ...
    }
    ```

    ### `onError`

    ```tsx  theme={"system"}
    onError: (error: Error) => Promise<void>
    ```

    #### Parameters

    <ParamField path="error" type="Error">
      The error that occurred during the passkey flow.
    </ParamField>

    #### Usage

    ```tsx  theme={"system"}
    import {useLoginWithPasskey} from '@privy-io/expo/passkey';

    export function LoginScreen() {
      const {loginWithPasskey} = useLoginWithPasskey({
        onError(error) {
          // show a toast, update form errors, etc...
        },
      });

      // ...
    }
    ```

    ## Resources

    <Columns cols={3}>
      <Card title="Expo starter repo" href="https://github.com/privy-io/examples/tree/main/privy-expo-starter" icon="github" arrow="true">
        Get started with Expo and Privy.
      </Card>

      <Card title="Expo bare starter repo" href="https://github.com/privy-io/examples/tree/main/privy-expo-bare-starter" icon="github" arrow="true">
        Get started with Expo bare and Privy.
      </Card>
    </Columns>
  </Tab>

  <Tab title="Android">
    <Tip>
      Follow the [passkeys setup guide](/basics/android/advanced/setup-passkeys) to enable passkey authentication in your Android app.
    </Tip>

    ## Login with Passkey

    Use `login` from the `privy.passkey` interface to authenticate an existing user who has already registered a passkey. This method allows returning users to log in using their previously created passkey credentials. Before using this method, ensure you have setup passkeys as described in the passkey setup guide.

    ```kotlin  theme={"system"}
    suspend fun login(relyingParty: String): Result<PrivyUser>
    ```

    ### Parameters

    <ParamField path="relyingParty" type="String" required>
      The URL origin where your Digital Asset Links are available (e.g., `https://example.com`).
    </ParamField>

    ### Response

    Returns a `Result<PrivyUser>` containing the user object after successful login.

    <Expandable title="PrivyUser">
      <ParamField body="id" type="String" required>
        The unique identifier for this user
      </ParamField>

      <ParamField body="linkedAccounts" type="List<LinkedAccount>" required>
        A list of linked accounts for this user. A linked account can be any of the methods a user
        authenticated with, or a user's embedded wallet

        <Expandable title="Properties">
          <Expandable title="CustomAuth">
            <ParamField body="customUserId" type="String" required>
              ID of user from custom auth provider
            </ParamField>

            <ParamField body="firstVerifiedAt" type="Int?">
              UNIX timestamp for when the account was first verified and linked to the user
            </ParamField>

            <ParamField body="latestVerifiedAt" type="Int?">
              UNIX timestamp for when the account was last verified
            </ParamField>
          </Expandable>

          <Expandable title="EmbeddedEthereumWalletAccount">
            <ParamField body="id" type="String?">
              The unique identifier for this embedded wallet
            </ParamField>

            <ParamField body="address" type="String" required>
              The wallet address
            </ParamField>

            <ParamField body="chainId" type="String?">
              The chain ID for this wallet
            </ParamField>

            <ParamField body="recoveryMethod" type="String?">
              The recovery method configured for this wallet
            </ParamField>

            <ParamField body="hdWalletIndex" type="Int" required>
              The HD wallet index (0 is the primary wallet)
            </ParamField>
          </Expandable>

          <Expandable title="EmbeddedSolanaWalletAccount">
            <ParamField body="id" type="String?">
              The unique identifier for this embedded wallet
            </ParamField>

            <ParamField body="address" type="String" required>
              The wallet address
            </ParamField>

            <ParamField body="chainId" type="String?">
              The chain ID for this wallet
            </ParamField>

            <ParamField body="recoveryMethod" type="String?">
              The recovery method configured for this wallet
            </ParamField>

            <ParamField body="hdWalletIndex" type="Int" required>
              The HD wallet index (0 is the primary wallet)
            </ParamField>
          </Expandable>

          <Expandable title="ExternalWalletAccount">
            <ParamField body="address" type="String" required>
              The wallet address
            </ParamField>

            <ParamField body="chainType" type="ChainType" required>
              The type of blockchain: ethereum or solana
            </ParamField>

            <ParamField body="chainId" type="String?">
              The chain ID for this wallet
            </ParamField>

            <ParamField body="walletClientType" type="String?">
              The wallet client type
            </ParamField>

            <ParamField body="connectorType" type="String?">
              The connector type used
            </ParamField>

            <ParamField body="firstVerifiedAt" type="Int?">
              UNIX timestamp for when the account was first verified and linked to the user
            </ParamField>

            <ParamField body="latestVerifiedAt" type="Int?">
              UNIX timestamp for when the account was last verified
            </ParamField>
          </Expandable>

          <Expandable title="PhoneAccount">
            <ParamField body="phoneNumber" type="String" required>
              Phone number of user account
            </ParamField>
          </Expandable>

          <Expandable title="EmailAccount">
            <ParamField body="emailAddress" type="String" required>
              Email address of user account
            </ParamField>
          </Expandable>

          <Expandable title="GoogleOAuthAccount">
            <ParamField body="subject" type="String" required>
              ID of user from Google user API response
            </ParamField>

            <ParamField body="email" type="String" required>
              Email of user from Google user API response
            </ParamField>

            <ParamField body="name" type="String?">
              Name of user from Google user API response
            </ParamField>

            <ParamField body="firstVerifiedAt" type="Int?">
              UNIX timestamp for when the account was first verified and linked to the user
            </ParamField>

            <ParamField body="latestVerifiedAt" type="Int?">
              UNIX timestamp for when the account was last verified
            </ParamField>
          </Expandable>

          <Expandable title="TwitterOAuthAccount">
            <ParamField body="subject" type="String" required>
              ID of user from Twitter user API response
            </ParamField>

            <ParamField body="username" type="String" required>
              Username of user from Twitter user API response (does not include the '@')
            </ParamField>

            <ParamField body="name" type="String?">
              Name of user from Twitter user API response
            </ParamField>

            <ParamField body="email" type="String?">
              Email of user from Twitter user API response
            </ParamField>

            <ParamField body="profilePictureUrl" type="String?">
              Profile picture URL of the user from Twitter user API response
            </ParamField>

            <ParamField body="firstVerifiedAt" type="Int?">
              UNIX timestamp for when the account was first verified and linked to the user
            </ParamField>

            <ParamField body="latestVerifiedAt" type="Int?">
              UNIX timestamp for when the account was last verified
            </ParamField>
          </Expandable>

          <Expandable title="DiscordOAuthAccount">
            <ParamField body="subject" type="String" required>
              ID of user from Discord user API response
            </ParamField>

            <ParamField body="username" type="String" required>
              Username of user from Discord user API response
            </ParamField>

            <ParamField body="email" type="String?">
              Email of user from Discord user API response
            </ParamField>

            <ParamField body="firstVerifiedAt" type="Int?">
              UNIX timestamp for when the account was first verified and linked to the user
            </ParamField>

            <ParamField body="latestVerifiedAt" type="Int?">
              UNIX timestamp for when the account was last verified
            </ParamField>
          </Expandable>

          <Expandable title="PasskeyAccount">
            <ParamField body="credentialId" type="String" required>
              The credential ID for this passkey
            </ParamField>

            <ParamField body="authenticatorName" type="String?">
              Name of the authenticator device
            </ParamField>

            <ParamField body="createdWithBrowser" type="String?">
              Browser used to create the passkey
            </ParamField>

            <ParamField body="createdWithOs" type="String?">
              Operating system used to create the passkey
            </ParamField>

            <ParamField body="createdWithDevice" type="String?">
              Device used to create the passkey
            </ParamField>

            <ParamField body="publicKey" type="String?">
              The public key for this passkey
            </ParamField>

            <ParamField body="enrolledInMfa" type="Boolean" required>
              Whether this passkey is enrolled in multi-factor authentication
            </ParamField>

            <ParamField body="verifiedAt" type="Long" required>
              UNIX timestamp for when the account was verified
            </ParamField>

            <ParamField body="firstVerifiedAt" type="Long?">
              UNIX timestamp for when the account was first verified and linked to the user
            </ParamField>

            <ParamField body="latestVerifiedAt" type="Long?">
              UNIX timestamp for when the account was last verified
            </ParamField>
          </Expandable>

          <br />
        </Expandable>
      </ParamField>

      <ParamField body="identityToken" type="String?">
        The identity token for this user, if configured in the Privy dashboard. This token is an optional
        JWT provided by Privy when identity token generation is enabled in the dashboard settings. It
        returns null if the user is unauthenticated or if the feature is not configured
      </ParamField>

      <ParamField body="embeddedEthereumWallets" type="List<EmbeddedEthereumWallet>" required>
        A list of the user's embedded Ethereum wallets. These wallets expose a "provider" instance which
        can be used to take wallet actions
      </ParamField>

      <ParamField body="embeddedSolanaWallets" type="List<EmbeddedSolanaWallet>" required>
        A list of the user's embedded Solana wallets. These wallets expose a "provider" instance which can
        be used to take wallet actions
      </ParamField>

      <br />
    </Expandable>

    ### Usage

    ```kotlin  theme={"system"}
    val result = privy.passkey.login(relyingParty = "https://<your-applications-relying-party>")

    result.fold(
        onSuccess = { user ->
            // Handle successful login
        },
        onFailure = { error ->
            // Handle login error
        }
    )
    ```

    ## Sign up with Passkey

    Use `signup` from the `privy.passkey` interface to create a new user account and register a passkey for them. This method creates a new user in your Privy app, whereas `login` authenticates an existing user who has already registered a passkey.

    ```kotlin  theme={"system"}
    suspend fun signup(relyingParty: String, displayName: String? = null): Result<PrivyUser>
    ```

    ### Parameters

    <ParamField path="relyingParty" type="String" required>
      The URL origin where your Digital Asset Links are available (e.g., `https://example.com`).
    </ParamField>

    <ParamField path="displayName" type="String">
      An optional display name to associate with the passkey. This name will be shown to the user when selecting which passkey to use for authentication.
    </ParamField>

    ### Response

    Returns a `Result<PrivyUser>` containing the user object after successful signup.

    <Expandable title="PrivyUser">
      <ParamField body="id" type="String" required>
        The unique identifier for this user
      </ParamField>

      <ParamField body="linkedAccounts" type="List<LinkedAccount>" required>
        A list of linked accounts for this user. A linked account can be any of the methods a user
        authenticated with, or a user's embedded wallet

        <Expandable title="Properties">
          <Expandable title="CustomAuth">
            <ParamField body="customUserId" type="String" required>
              ID of user from custom auth provider
            </ParamField>

            <ParamField body="firstVerifiedAt" type="Int?">
              UNIX timestamp for when the account was first verified and linked to the user
            </ParamField>

            <ParamField body="latestVerifiedAt" type="Int?">
              UNIX timestamp for when the account was last verified
            </ParamField>
          </Expandable>

          <Expandable title="EmbeddedEthereumWalletAccount">
            <ParamField body="id" type="String?">
              The unique identifier for this embedded wallet
            </ParamField>

            <ParamField body="address" type="String" required>
              The wallet address
            </ParamField>

            <ParamField body="chainId" type="String?">
              The chain ID for this wallet
            </ParamField>

            <ParamField body="recoveryMethod" type="String?">
              The recovery method configured for this wallet
            </ParamField>

            <ParamField body="hdWalletIndex" type="Int" required>
              The HD wallet index (0 is the primary wallet)
            </ParamField>
          </Expandable>

          <Expandable title="EmbeddedSolanaWalletAccount">
            <ParamField body="id" type="String?">
              The unique identifier for this embedded wallet
            </ParamField>

            <ParamField body="address" type="String" required>
              The wallet address
            </ParamField>

            <ParamField body="chainId" type="String?">
              The chain ID for this wallet
            </ParamField>

            <ParamField body="recoveryMethod" type="String?">
              The recovery method configured for this wallet
            </ParamField>

            <ParamField body="hdWalletIndex" type="Int" required>
              The HD wallet index (0 is the primary wallet)
            </ParamField>
          </Expandable>

          <Expandable title="ExternalWalletAccount">
            <ParamField body="address" type="String" required>
              The wallet address
            </ParamField>

            <ParamField body="chainType" type="ChainType" required>
              The type of blockchain: ethereum or solana
            </ParamField>

            <ParamField body="chainId" type="String?">
              The chain ID for this wallet
            </ParamField>

            <ParamField body="walletClientType" type="String?">
              The wallet client type
            </ParamField>

            <ParamField body="connectorType" type="String?">
              The connector type used
            </ParamField>

            <ParamField body="firstVerifiedAt" type="Int?">
              UNIX timestamp for when the account was first verified and linked to the user
            </ParamField>

            <ParamField body="latestVerifiedAt" type="Int?">
              UNIX timestamp for when the account was last verified
            </ParamField>
          </Expandable>

          <Expandable title="PhoneAccount">
            <ParamField body="phoneNumber" type="String" required>
              Phone number of user account
            </ParamField>
          </Expandable>

          <Expandable title="EmailAccount">
            <ParamField body="emailAddress" type="String" required>
              Email address of user account
            </ParamField>
          </Expandable>

          <Expandable title="GoogleOAuthAccount">
            <ParamField body="subject" type="String" required>
              ID of user from Google user API response
            </ParamField>

            <ParamField body="email" type="String" required>
              Email of user from Google user API response
            </ParamField>

            <ParamField body="name" type="String?">
              Name of user from Google user API response
            </ParamField>

            <ParamField body="firstVerifiedAt" type="Int?">
              UNIX timestamp for when the account was first verified and linked to the user
            </ParamField>

            <ParamField body="latestVerifiedAt" type="Int?">
              UNIX timestamp for when the account was last verified
            </ParamField>
          </Expandable>

          <Expandable title="TwitterOAuthAccount">
            <ParamField body="subject" type="String" required>
              ID of user from Twitter user API response
            </ParamField>

            <ParamField body="username" type="String" required>
              Username of user from Twitter user API response (does not include the '@')
            </ParamField>

            <ParamField body="name" type="String?">
              Name of user from Twitter user API response
            </ParamField>

            <ParamField body="email" type="String?">
              Email of user from Twitter user API response
            </ParamField>

            <ParamField body="profilePictureUrl" type="String?">
              Profile picture URL of the user from Twitter user API response
            </ParamField>

            <ParamField body="firstVerifiedAt" type="Int?">
              UNIX timestamp for when the account was first verified and linked to the user
            </ParamField>

            <ParamField body="latestVerifiedAt" type="Int?">
              UNIX timestamp for when the account was last verified
            </ParamField>
          </Expandable>

          <Expandable title="DiscordOAuthAccount">
            <ParamField body="subject" type="String" required>
              ID of user from Discord user API response
            </ParamField>

            <ParamField body="username" type="String" required>
              Username of user from Discord user API response
            </ParamField>

            <ParamField body="email" type="String?">
              Email of user from Discord user API response
            </ParamField>

            <ParamField body="firstVerifiedAt" type="Int?">
              UNIX timestamp for when the account was first verified and linked to the user
            </ParamField>

            <ParamField body="latestVerifiedAt" type="Int?">
              UNIX timestamp for when the account was last verified
            </ParamField>
          </Expandable>

          <Expandable title="PasskeyAccount">
            <ParamField body="credentialId" type="String" required>
              The credential ID for this passkey
            </ParamField>

            <ParamField body="authenticatorName" type="String?">
              Name of the authenticator device
            </ParamField>

            <ParamField body="createdWithBrowser" type="String?">
              Browser used to create the passkey
            </ParamField>

            <ParamField body="createdWithOs" type="String?">
              Operating system used to create the passkey
            </ParamField>

            <ParamField body="createdWithDevice" type="String?">
              Device used to create the passkey
            </ParamField>

            <ParamField body="publicKey" type="String?">
              The public key for this passkey
            </ParamField>

            <ParamField body="enrolledInMfa" type="Boolean" required>
              Whether this passkey is enrolled in multi-factor authentication
            </ParamField>

            <ParamField body="verifiedAt" type="Long" required>
              UNIX timestamp for when the account was verified
            </ParamField>

            <ParamField body="firstVerifiedAt" type="Long?">
              UNIX timestamp for when the account was first verified and linked to the user
            </ParamField>

            <ParamField body="latestVerifiedAt" type="Long?">
              UNIX timestamp for when the account was last verified
            </ParamField>
          </Expandable>

          <br />
        </Expandable>
      </ParamField>

      <ParamField body="identityToken" type="String?">
        The identity token for this user, if configured in the Privy dashboard. This token is an optional
        JWT provided by Privy when identity token generation is enabled in the dashboard settings. It
        returns null if the user is unauthenticated or if the feature is not configured
      </ParamField>

      <ParamField body="embeddedEthereumWallets" type="List<EmbeddedEthereumWallet>" required>
        A list of the user's embedded Ethereum wallets. These wallets expose a "provider" instance which
        can be used to take wallet actions
      </ParamField>

      <ParamField body="embeddedSolanaWallets" type="List<EmbeddedSolanaWallet>" required>
        A list of the user's embedded Solana wallets. These wallets expose a "provider" instance which can
        be used to take wallet actions
      </ParamField>

      <br />
    </Expandable>

    ### Usage

    ```kotlin  theme={"system"}
    val result = privy.passkey.signup(relyingParty = "https://<your-applications-relying-party>")

    result.fold(
        onSuccess = { user ->
            // Handle successful signup
        },
        onFailure = { error ->
            // Handle signup error
        }
    )
    ```
  </Tab>
</Tabs>


# SMS and WhatsApp
Source: https://docs.privy.io/authentication/user-authentication/login-methods/sms-whatsapp



Privy enables users to login with SMS or WhatsApp. Configure your app following this guide and make sure to read our recipe on [enabling SMS or WhatsApp](/recipes/dashboard/login-methods/sms).

<Note>
  Developers can enable **either** SMS or WhatsApp, but cannot utilize both. Once your account is
  enabled for SMS with your chosen provider, it **cannot** be switched.
</Note>

<Tabs>
  <Tab title="React">
    ## Configuring your application

    Through your app's Privy configuration, you can set the default country code for phone numbers. This is useful if your application primarily serves users from a specific country. The default country can be set in your PrivyProvider, like so:

    ```tsx {5} theme={"system"}
    <PrivyProvider
      appId="your-privy-app-id"
      config={{
        intl: {
          defaultCountry: "US",
        },
        ...insertTheRestOfYourPrivyProviderConfig
      }}
    >
      {children}
    </PrivyProvider>
    ```

    To authenticate your users with a one-time passcode (OTP) sent to their phone number via either SMS or WhatsApp, use the `useLoginWithSms` hook.

    <Info>
      To authenticate your users with Privy's out of the box UIs, check out UI components [here](/authentication/user-authentication/ui-component).
    </Info>

    ## Send Code

    ```tsx  theme={"system"}
    sendCode: ({phoneNumber: string, disableSignup?: boolean}) => Promise<void>
    ```

    ### Parameters

    <ParamField path="phoneNumber" type="string" required>
      The phone number of the user to log in. Must follow specific formatting conventions (see below).
    </ParamField>

    <ParamField path="disableSignup" type="boolean">
      Whether to disable the ability to sign up with the phone number.
    </ParamField>

    ### Returns

    <ResponseField name="void" type="Promise<void>">
      A promise that resolves when the code is sent.
    </ResponseField>

    ## Formatting the phone number

    The `sendCode` method requires a `phoneNumber` string param that must follow these formatting conventions:

    * By default, the implicit phone number country code is +1/US.
    * Explicitly prepending a `(+)1` to the phone number will still be read as a US phone number.
    * For non-US phone numbers, append a `+${countryCode}` to the beginning of the input value.
    * Non-numerical values in the string are ignored, except for a leading `+` that denotes a custom country code.

    ## Login with Code

    ```tsx  theme={"system"}
    loginWithCode: ({ code: string }) => Promise<void>;
    ```

    ### Parameters

    <ParamField path="code" type="string" required>
      The one-time passcode sent to the user's phone number.
    </ParamField>

    ### Returns

    <ResponseField name="void" type="Promise<void>">
      A promise that resolves when the user is logged in.
    </ResponseField>

    ## Usage

    ```tsx  theme={"system"}
    import { useState } from "react";
    import { useLoginWithSms } from "@privy-io/react-auth";

    export default function LoginWithSms() {
      const [phoneNumber, setPhoneNumber] = useState("");
      const [code, setCode] = useState("");
      const { state, sendCode, loginWithCode } = useLoginWithSms();

      return (
        <div>
          {/* Prompt your user to enter their phone number */}
          <input onChange={(e) => setPhoneNumber(e.currentTarget.value)} value={phoneNumber} />
          {/* Once a phone number has been entered, send the OTP to it on click */}
          <button onClick={() => sendCode({ phoneNumber })}>Send Code</button>

          {/* Prompt your user to enter the OTP */}
          <input onChange={(e) => setCode(e.currentTarget.value)} value={code} />
          {/* Once an OTP has been entered, submit it to Privy on click */}
          <button onClick={() => loginWithCode({ code })}>Log in</button>
        </div>
      );
    }
    ```

    ## Tracking Flow State

    Track the state of the OTP flow via the `state` variable returned by the
    `useLoginWithSms` hook.

    ```ts  theme={"system"}
    type OtpFlowState =
      | {status: 'initial'}
      | {status: 'error'; error: Error | null}
      | {status: 'sending-code'}
      | {status: 'awaiting-code-input'}
      | {status: 'submitting-code'}
      | {status: 'done'};
    ```

    <ResponseField name="status" type="'initial' | 'error' | 'sending-code' | 'awaiting-code-input' | 'submitting-code' | 'done'">
      The current state of the OTP flow.
    </ResponseField>

    <ResponseField name="error" type="Error | null">
      The error that occurred during the OTP flow.
    </ResponseField>

    ## Callbacks

    You can optionally pass callbacks into the `useLoginWithSms` hook to run custom logic after a successful login or to handle errors that occur during the flow.

    ### `onComplete`

    ```tsx  theme={"system"}
    onComplete?: ((params: {
        user: User;
        isNewUser: boolean;
        wasAlreadyAuthenticated: boolean;
        loginMethod: LoginMethod | null;
        loginAccount: LinkedAccountWithMetadata | null;
    }) => void) | undefined
    ```

    #### Parameters

    <ParamField path="user" type="User">
      The user object corresponding to the authenticated user.
    </ParamField>

    <ParamField path="isNewUser" type="boolean">
      Whether the user is a new user or an existing user.
    </ParamField>

    <ParamField path="wasAlreadyAuthenticated" type="boolean">
      Whether the user entered the application already authenticated.
    </ParamField>

    <ParamField path="loginMethod" type="LoginMethod | null">
      The method used by the user to login.
    </ParamField>

    <ParamField path="loginAccount" type="LinkedAccountWithMetadata | null">
      The account corresponding to the loginMethod used.
    </ParamField>

    ### `onError`

    ```tsx  theme={"system"}
    onError: (error: Error) => void
    ```

    #### Parameters

    <ParamField path="error" type="Error">
      The error that occurred during the login flow.
    </ParamField>

    ## Resources

    <Columns cols={3}>
      <Card title="React starter repo" href="https://github.com/privy-io/examples/tree/main/privy-react-starter" icon="github" arrow="true">
        Get started with React and Privy.
      </Card>

      <Card title="Next.js starter repo" href="https://github.com/privy-io/examples/tree/main/privy-next-starter" icon="github" arrow="true">
        Get started with Next.js and Privy.
      </Card>

      <Card title="Whitelabel starter repo" href="https://github.com/privy-io/examples/tree/main/privy-react-whitelabel-starter" icon="github" arrow="true">
        Get started with a whitelabel Privy integration.
      </Card>
    </Columns>
  </Tab>

  <Tab title="React Native">
    To authenticate your users with a one-time passcode (OTP) sent to their phone number, use the `useLoginWithSMS` hook.

    <Info>
      To authenticate your users with Privy's out of the box UIs, check out UI components [here](/authentication/user-authentication/ui-component#react-native).
    </Info>

    ## Send Code

    ```jsx  theme={"system"}
    sendCode: ({phone: string}) => Promise<{success: boolean}>
    ```

    ### Parameters

    <ParamField path="phone" type="string" required>
      The phone number of the user to log in.
    </ParamField>

    ### Returns

    <ResponseField name="success" type="boolean">
      A promise that resolves to an object with a success property indicating if the code was sent successfully.
    </ResponseField>

    ## Login with Code

    ```jsx  theme={"system"}
    loginWithCode: ({ code: string, phone?: string, disableSignup?: boolean }) => Promise<{user: PrivyUser; isNewUser: boolean}>
    ```

    ### Parameters

    <ParamField path="code" type="string" required>
      The one-time passcode sent to the user's phone number.
    </ParamField>

    <ParamField path="phone" type="string">
      The user's phone number. Though this parameter is optional, it is highly recommended that you pass the user's phone number explicitly.
    </ParamField>

    <ParamField path="disableSignup" type="boolean">
      Whether to disable the ability to sign up with the phone number.
    </ParamField>

    ### Returns

    <ResponseField name="user" type="PrivyUser">
      The user object returned by the login process.
    </ResponseField>

    ## Usage

    ```jsx  theme={"system"}
    import { useState } from 'react';
    import { useLoginWithSMS } from '@privy-io/expo';

    export function LoginScreen() {
      const [phone, setPhone] = useState('');
      const [code, setCode] = useState('');
      const { sendCode, loginWithCode } = useLoginWithSMS();

      return (
        <View style={styles.container}>
          <Text>Login</Text>
          <TextInput value={phone} onChangeText={setPhone} placeholder="Phone" inputMode="tel" />
          <Button onPress={() => sendCode({ phone })}>Send Code</Button>

          <TextInput value={code} onChangeText={setCode} placeholder="Code" inputMode="numeric" />
          <Button onPress={() => loginWithCode({ code, phone })}>Login</Button>
        </View>
      );
    }
    ```

    ## Tracking login flow state

    The state variable returned from useLoginWithSMS will always be one of the following values.

    ```ts  theme={"system"}
    type OtpFlowState =
      | {status: 'initial'}
      | {status: 'error'; error: Error | null}
      | {status: 'sending-code'}
      | {status: 'awaiting-code-input'}
      | {status: 'submitting-code'}
      | {status: 'done'};
    ```

    <ResponseField name="status" type="'initial' | 'error' | 'sending-code' | 'awaiting-code-input' | 'submitting-code' | 'done'">
      The current state of the SMS login flow.
    </ResponseField>

    <ResponseField name="error" type="Error | null">
      The error that occurred during the SMS login flow.
    </ResponseField>

    ## Callbacks

    You can optionally pass callbacks into the `useLoginWithSMS` hook to run custom logic after an OTP has been sent, after a successful login, or to handle errors that occur during the flow.

    ### `onSendCodeSuccess`

    ```tsx  theme={"system"}
    onSendCodeSuccess?: ((phone: string) => void) | undefined
    ```

    #### Parameters

    <ParamField path="phone" type="string">
      The phone number the code was sent to.
    </ParamField>

    ### `onLoginSuccess`

    ```tsx  theme={"system"}
    onLoginSuccess?: ((user: User, isNewUser: boolean) => void) | undefined
    ```

    #### Parameters

    <ParamField path="user" type="User">
      The PrivyUser returned by loginWithCode.
    </ParamField>

    <ParamField path="isNewUser" type="boolean">
      Whether the user is a new user or an existing user.
    </ParamField>

    ### `onError`

    ```tsx  theme={"system"}
    onError?: (error: Error) => void
    ```

    #### Parameters

    <ParamField path="error" type="Error">
      The error that occurred during the login flow.
    </ParamField>

    ## Resources

    <Columns cols={3}>
      <Card title="Expo starter repo" href="https://github.com/privy-io/examples/tree/main/privy-expo-starter" icon="github" arrow="true">
        Get started with Expo and Privy.
      </Card>

      <Card title="Expo bare starter repo" href="https://github.com/privy-io/examples/tree/main/privy-expo-bare-starter" icon="github" arrow="true">
        Get started with Expo bare and Privy.
      </Card>
    </Columns>
  </Tab>

  <Tab title="Swift">
    To authenticate a user via their phone number, use the Privy client's `sms` handler.

    ## Send Code

    ```swift  theme={"system"}
    sendCode(to phoneNumber: String) async throws
    ```

    ### Parameters

    <ParamField path="to" type="String" required>
      The phone number of the user to log in. Must be in E.164 format (e.g., "+14155552671").
    </ParamField>

    ### Returns

    <ResponseField>
      Nothing, indicating success.
    </ResponseField>

    ### Throws

    An error if sending the code fails.

    ## Login with Code

    ```swift  theme={"system"}
    loginWithCode(_ code: String, sentTo phoneNumber: String) async throws -> PrivyUser
    ```

    ### Parameters

    <ParamField path="code" type="String" required>
      The one-time passcode sent to the user's phone number.
    </ParamField>

    <ParamField path="sentTo" type="String" required>
      The user's phone number.
    </ParamField>

    ### Returns

    <ResponseField name="PrivyUser" type="PrivyUser">
      The authenticated Privy user
    </ResponseField>

    ### Throws

    An error if logging the user in is unsuccessful.

    ## Usage

    ```swift  theme={"system"}
    // Send code to user's phone
    do {
        try await privy.sms.sendCode(to: "+14155552671")
        // successfully sent code to users phone
    } catch {
        print("error sending code: \(error)")
    }

    // Log the user in
    do {
        let user = try await privy.sms.loginWithCode("123456", sentTo: "+14155552671")
        // user successfully logged in
    } catch {
        print("error logging user in: \(error)")
    }
    ```
  </Tab>

  <Tab title="Android">
    To authenticate a user via their phone number, use the Privy client's `sms` handler.

    ## Send Code

    ```kotlin  theme={"system"}
    sendCode(phoneNumber: String): Result<Unit>
    ```

    ### Parameters

    <ParamField path="phoneNumber" type="String" required>
      The phone number of the user to log in. Must be in E.164 format (e.g., "+14155552671").
    </ParamField>

    ### Returns

    <ResponseField name="Result<Unit>" type="Result<Unit>">
      A Result object that indicates whether the operation was successful. Returns Result.success if the code was sent successfully, or Result.failure if there was an error.
    </ResponseField>

    ## Login with Code

    ```kotlin  theme={"system"}
    loginWithCode(code: String, phoneNumber: String?): Result<PrivyUser>
    ```

    ### Parameters

    <ParamField path="code" type="String" required>
      The one-time passcode sent to the user's phone number.
    </ParamField>

    <ParamField path="phoneNumber" type="String">
      (Optional) The user's phone number. Though this parameter is optional, it is highly recommended that you pass the user's phone number explicitly. If phone number is omitted, the phone number from sendCode will be used.
    </ParamField>

    ### Returns

    <ResponseField name="Result<PrivyUser>" type="Result<PrivyUser>">
      A Result object containing the PrivyUser if successful, or an error if the operation failed.
    </ResponseField>

    ## Usage

    ```kotlin  theme={"system"}
    // Send code to user's phone number
    val result: Result<Unit> = privy.sms.sendCode(phoneNumber = "+14155552671")

    result.fold(
      onSuccess = {
        // OTP was successfully sent
      },
      onFailure = {
        println("Error sending OTP: ${it.message}")
      }
    )

    // Authenticate with the OTP code
    val result: Result<PrivyUser> = privy.sms.loginWithCode(code = "123456", phoneNumber = "+14155552671")

    result.fold(
      onSuccess = { user ->
        // User logged in
      },
      onFailure = {
        println("Error logging in user: ${it.message}")
      }
    )
    ```
  </Tab>

  <Tab title="Flutter">
    To authenticate a user via their phone number, use the Privy client's `sms` handler.

    ## Send Code

    ```dart  theme={"system"}
    sendCode(String phoneNumber): Future<Result<void>>
    ```

    ### Parameters

    <ParamField path="phoneNumber" type="String" required>
      The phone number of the user to log in. Must be in E.164 format (e.g., "+14155552671").
    </ParamField>

    ### Returns

    <ResponseField name="Result<void>" type="Future<Result<void>>">
      A Result object that indicates whether the operation was successful. Returns Result.success if the code was sent successfully, or Result.failure if there was an error.
    </ResponseField>

    ## Login with Code

    ```dart  theme={"system"}
    loginWithCode({required String code, String? phoneNumber}): Future<Result<PrivyUser>>
    ```

    ### Parameters

    <ParamField path="code" type="String" required>
      The one-time passcode sent to the user's phone number.
    </ParamField>

    <ParamField path="phoneNumber" type="String">
      (Optional) The user's phone number. Though this parameter is optional, it is highly recommended that you pass the user's phone number explicitly. If phone number is omitted, the phone number from sendCode will be used.
    </ParamField>

    ### Returns

    <ResponseField name="Result<PrivyUser>" type="Future<Result<PrivyUser>>">
      A Result object containing the PrivyUser if successful, or an error if the operation failed.
    </ResponseField>

    ## Usage

    ```dart  theme={"system"}
    // Send code to user's phone number
    final Result<void> result = await privy.sms.sendCode("+14155552671");

    result.fold(
      onSuccess: (_) {
        // OTP was sent successfully
      },
      onFailure: (error) {
        // Handle error sending OTP
        print(error.message);
      },
    );

    // Authenticate with the OTP code
    final Result<PrivyUser> result = await privy.sms.loginWithCode(
      code: code,
      phoneNumber: phoneNumber,
    );

    result.fold(
      onSuccess: (user) {
        // User authenticated successfully
      },
      onFailure: (error) {
        // Handle authentication error
      },
    );
    ```

    ## Resources

    <Columns cols={3}>
      <Card title="Flutter starter repo" href="https://github.com/privy-io/examples/tree/main/privy-flutter-starter" icon="github" arrow="true">
        Get started with Flutter and Privy.
      </Card>
    </Columns>
  </Tab>
</Tabs>


# Telegram
Source: https://docs.privy.io/authentication/user-authentication/login-methods/telegram



Telegram is an end to end encrypted messaging platform with in-application experiences.

Privy enables your application to easily integrate Login with Telegram in multiple ways. From a regular web environment, users can authenticate to your application with their Telegram account.

<Tip>
  Enable Telegram authentication in the [Privy
  Dashboard](https://dashboard.privy.io/apps?page=login-methods\&logins=socials) before implementing
  this feature.
</Tip>

<Warning>
  Telegram does not support `.xyz` domains for authentication. If your application uses a `.xyz`
  domain, Telegram will not send authentication messages during the login flow. To work around this
  limitation, you must use a different top-level domain (TLD) for your application, or set up a
  separate domain with a different TLD specifically for handling Telegram authentication.
</Warning>

<Tip>
  Privy also enables seamless login within Telegram, so users can zero-click authenticate to your
  Telegram bot or mini-app. Check out our recipe for setting up [seamless login with
  Telegram](/recipes/react/seamless-telegram).
</Tip>

<Tabs>
  <Tab title="React">
    <Info>
      To authenticate your users with Privy's out of the box UIs, check out UI components [here](/authentication/user-authentication/ui-component).
    </Info>

    To authenticate your users with Telegram, use the `useLoginWithTelegram` hook.

    ```tsx  theme={"system"}
    login: () => Promise<void>
    ```

    ## Usage

    ```tsx  theme={"system"}
    import {useLoginWithTelegram} from '@privy-io/react-auth';

    export default function LoginWithTelegram() {
      const {login, state} = useLoginWithTelegram();

      const handleLogin = async () => {
        try {
          // Telegram's authentication pop-up will emerge, the user can then follow the steps to link its account.
          // If the login is successful, the user will be authenticated and the authentication information will be returned as a result
          const authenticationInfo = await login();
        } catch (err) {
          // Handle errors due to network availability, captcha failure, or input validation here
        }
      };

      return <button onClick={handleLogin}>Log in with Telegram</button>;
    }
    ```

    <Tip>
      Before using the `useLoginWithTelegram` hook, ensure that Telegram is enabled in **Socials** tab of the **Login Methods** page on the the Privy [dashboard](https://dashboard.privy.io/apps?page=login-methods\&logins=socials)
    </Tip>

    ## Tracking Flow State

    Track the state of the Telegram authentication flow via the `state` variable returned by the
    `useLoginWithTelegram` hook.

    ```ts  theme={"system"}
    type TelegramAuthFlowState =
      | {status: 'initial'}
      | {status: 'loading'}
      | {status: 'done'}
      | {status: 'error'; error: Error | null};
    ```

    <ResponseField name="status" type="'initial' | 'loading' | 'done' | 'error'">
      The current state of the Telegram authentication flow.
    </ResponseField>

    <ResponseField name="error" type="Error | null">
      The error that occurred during the Telegram authentication flow.
    </ResponseField>

    ## Callbacks

    You can optionally pass callbacks into the `useLoginWithTelegram` hook to run custom logic after a successful login or to handle errors that occur during the flow.

    ### `onComplete`

    ```tsx  theme={"system"}
    onComplete?: ((params: {
        user: User;
        isNewUser: boolean;
        wasAlreadyAuthenticated: boolean;
        loginMethod: LoginMethod | null;
        loginAccount: LinkedAccountWithMetadata | null;
    }) => void) | undefined
    ```

    #### Parameters

    <ParamField path="user" type="User">
      The user object corresponding to the authenticated user.
    </ParamField>

    <ParamField path="isNewUser" type="boolean">
      Whether the user is a new user or an existing user.
    </ParamField>

    <ParamField path="wasAlreadyAuthenticated" type="boolean">
      Whether the user entered the application already authenticated.
    </ParamField>

    <ParamField path="loginMethod" type="LoginMethod | null">
      The method used by the user to login.
    </ParamField>

    <ParamField path="loginAccount" type="LinkedAccountWithMetadata | null">
      The account corresponding to the loginMethod used.
    </ParamField>

    ### `onError`

    ```tsx  theme={"system"}
    onError: (error: Error) => void
    ```

    #### Parameters

    <ParamField path="error" type="Error">
      The error that occurred during the login flow.
    </ParamField>

    ## Resources

    <Columns cols={3}>
      <Card title="React starter repo" href="https://github.com/privy-io/examples/tree/main/privy-react-starter" icon="github" arrow="true">
        Get started with React and Privy.
      </Card>

      <Card title="Next.js starter repo" href="https://github.com/privy-io/examples/tree/main/privy-next-starter" icon="github" arrow="true">
        Get started with Next.js and Privy.
      </Card>

      <Card title="Whitelabel starter repo" href="https://github.com/privy-io/examples/tree/main/privy-react-whitelabel-starter" icon="github" arrow="true">
        Get started with a whitelabel Privy integration.
      </Card>
    </Columns>
  </Tab>
</Tabs>


# Wallet
Source: https://docs.privy.io/authentication/user-authentication/login-methods/wallet



export const chain_2 = "Solana"

export const chain_1 = "Ethereum"

export const chain_0 = "Ethereum"

For users who already have wallets, Privy supports signing in with Ethereum (SIWE) or Solana (SIWS). With this flow, users who are already onchain can bring their existing wallet to your app, verify ownership of assets, and take onchain actions.

<Tip>
  Enable wallet authentication in the [Privy
  Dashboard](https://dashboard.privy.io/apps?page=login-methods) before implementing this feature.
</Tip>

<Tabs>
  <Tab title="React">
    To authenticate a user via an Ethereum wallet ([SIWE](https://eips.ethereum.org/EIPS/eip-4361)) without Privy UIs, use the React SDK's `useLoginWithSiwe` hook.

    <Info>
      In order to use Privy's login with wallet flow, users must actively have a {chain_0} wallet
      connected to your app from which you can request signatures.
    </Info>

    ## Generate SIWE message

    ```tsx  theme={"system"}
    generateSiweMessage({ address: string, chainId: `eip155:${number}`, disableSignup?: boolean }) => Promise<string>
    ```

    ### Parameters

    <ParamField path="address" type="string" required>
      EIP-55 checksum-encoded wallet address performing the signing.
    </ParamField>

    <ParamField path="chainId" type="`eip155:${number}`" required>
      EIP-155 Chain ID to which the session is bound (in CAIP-2 format), e.g. `eip155:1`.
    </ParamField>

    <ParamField path="disableSignup" type="boolean">
      Whether to disable signup for this login flow.
    </ParamField>

    ### Returns

    <ResponseField name="message" type="string">
      A SIWE message that can be signed by the wallet.
    </ResponseField>

    ## Sign the SIWE message

    Request an EIP-191 `personal_sign` signature for the `message` returned by `generateSiweMessage` from the connected wallet.

    ```tsx  theme={"system"}
    import { useWallets } from '@privy-io/react-auth';

    const { wallets } = useWallets();

    const signature = await wallets[0].sign(message);
    ```

    ## Login with SIWE

    ```tsx  theme={"system"}
    loginWithSiwe({ signature: string, message: string, disableSignup?: boolean }) => Promise<User>
    ```

    ### Parameters

    <ParamField path="signature" type="string" required>
      The EIP-191 signature corresponding to the message.
    </ParamField>

    <ParamField path="message" type="string" required>
      The EIP-4361 message returned by `generateSiweMessage`.
    </ParamField>

    <ParamField path="disableSignup" type="boolean">
      Whether to disable signup for the login flow.
    </ParamField>

    ### Returns

    <ResponseField name="User" type="User">
      The authenticated user.
    </ResponseField>

    ## Usage

    ```tsx  theme={"system"}
    import { useLoginWithSiwe, useWallets } from '@privy-io/react-auth';

    export function LoginWithWalletButton() {
      const { generateSiweMessage, loginWithSiwe } = useLoginWithSiwe();
      const { wallets } = useWallets();

      const handleLogin = async () => {
        if (!wallets?.length) return;
        const activeWallet = wallets[0];

        const message = await generateSiweMessage({
          address: activeWallet.address,
          chainId: 'eip155:1',
        });

        const signature = await activeWallet.sign(message);
        await loginWithSiwe({ signature, message });
      };

      return (
        <button onClick={handleLogin}>Log in with wallet</button>
      );
    }
    ```

    ## Callbacks

    You can optionally pass callbacks into `useLoginWithSiwe` to run custom logic after a successful login, or to handle errors that occur during the flow.

    ### `onComplete`

    ```tsx  theme={"system"}
    onComplete?: (params: {
      user: User;
      isNewUser: boolean;
      wasAlreadyAuthenticated: boolean;
      loginMethod: LoginMethod | null;
      loginAccount: LinkedAccountWithMetadata | null;
    }) => void
    ```

    #### Parameters

    <ParamField path="user" type="User">
      The user object corresponding to the authenticated user.
    </ParamField>

    <ParamField path="isNewUser" type="boolean">
      Whether the user is a new user or an existing user.
    </ParamField>

    <ParamField path="wasAlreadyAuthenticated" type="boolean">
      Whether the user was already authenticated when the flow ran.
    </ParamField>

    <ParamField path="loginMethod" type="LoginMethod | null">
      The method used by the user to login (if applicable).
    </ParamField>

    <ParamField path="loginAccount" type="LinkedAccountWithMetadata | null">
      The account corresponding to the login method.
    </ParamField>

    ### `onError`

    ```tsx  theme={"system"}
    onError?: (error: PrivyErrorCode) => void
    ```

    #### Parameters

    <ParamField path="error" type="PrivyErrorCode">
      The error that occurred during the login flow.
    </ParamField>

    ### Usage

    ```tsx  theme={"system"}
    import { useLoginWithSiwe } from '@privy-io/react-auth';

    export function SiweWithCallbacks() {
      const { generateSiweMessage, loginWithSiwe } = useLoginWithSiwe({
        onComplete: ({
          user,
          isNewUser,
          wasAlreadyAuthenticated,
          loginMethod,
          loginAccount,
        }) => {
           // show a toast, update form errors, etc...
        },
        onError: (error) => {
           // show a toast, update form errors, etc...
        },
      });

      // ... use generateSiweMessage and loginWithSiwe as shown above
      return null;
    }
    ```

    ## Tracking login flow state

    The `state` variable returned from `useLoginWithSiwe` will always be one of the following values.

    ```tsx  theme={"system"}
    type SiweFlowState =
      | { status: 'initial' }
      | { status: 'error'; error: Error | null }
      | { status: 'generating-message' }
      | { status: 'awaiting-signature' }
      | { status: 'submitting-signature' }
      | { status: 'done' };
    ```

    ### Sign in with Ledger on Solana

    Currently, Ledger Solana hardware wallets only support transaction signatures, not the message signatures required
    for Sign-In With Solana (SIWS) authentication. In order to authenticate with a Solana Ledger wallet,
    you must mount the `useSolanaLedgerPlugin` hook **inside** your `PrivyProvider`.

    <Warning>
      **Critical:** The `useSolanaLedgerPlugin` hook **must be placed inside** a component that is
      wrapped by `PrivyProvider`. If the hook is placed alongside or outside the `PrivyProvider`, it
      will not function correctly.
    </Warning>

    ```tsx  theme={"system"}
    import {PrivyProvider} from '@privy-io/react-auth';
    import {useSolanaLedgerPlugin} from '@privy-io/react-auth/solana';

    function SolanaLedgerSetup() {
      // This hook MUST be called inside a component wrapped by PrivyProvider
      useSolanaLedgerPlugin();
      return null;
    }

    export default function App() {
      return (
        <PrivyProvider appId="your-app-id" config={{...}}>
          <SolanaLedgerSetup />
          {/* Your app components */}
        </PrivyProvider>
      );
    }
    ```

    Then, when you attempt to login with a Phantom Solana wallet, you will be prompted to indicate whether you are signing with a Ledger wallet,
    which will initiate a separate SIWS flow wherein which a no-op transaction will be signed and used for verification.

    ## Resources

    <Columns cols={3}>
      <Card title="React starter repo" href="https://github.com/privy-io/examples/tree/main/privy-react-starter" icon="github" arrow="true">
        Get started with React and Privy.
      </Card>

      <Card title="Next.js starter repo" href="https://github.com/privy-io/examples/tree/main/privy-next-starter" icon="github" arrow="true">
        Get started with Next.js and Privy.
      </Card>

      <Card title="Whitelabel starter repo" href="https://github.com/privy-io/examples/tree/main/privy-react-whitelabel-starter" icon="github" arrow="true">
        Get started with a whitelabel Privy integration.
      </Card>
    </Columns>
  </Tab>

  <Tab title="React Native">
    <Tabs>
      <Tab title="Ethereum (SIWE)">
        To authenticate a user via an Ethereum wallet *([SIWE](https://eips.ethereum.org/EIPS/eip-4361))*, use the React Native SDK's `useLoginWithSiwe` hook.

        <Info>
          In order to use Privy's login with wallet flow, users must actively have a {chain_1} wallet
          connected to your app from which you can request signatures.
        </Info>

        ## Generate SIWE message

        ```tsx  theme={"system"}
        generateSiweMessage({wallet: {chainId: string, address: string}, from: {domain: string, uri: string}}) => Promise<string>
        ```

        ### Parameters

        <ParamField path="wallet" type="Object">
          Wallet object containing EIP-55 compliant wallet address and chainId in CAIP-2 format.

          <Expandable defaultOpen="true">
            <ParamField path="chainId" type="string" required>
              The chain ID of the wallet.
            </ParamField>

            <ParamField path="address" type="string" required>
              The address of the wallet.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField path="from" type="Object">
          Origin object containing domain and uri.

          <Expandable defaultOpen="true">
            <ParamField path="domain" type="string" required>
              The domain of the origin. Must be allowlisted in the Privy dashboard.
            </ParamField>

            <ParamField path="uri" type="string" required>
              The uri of the origin.
            </ParamField>
          </Expandable>
        </ParamField>

        ### Returns

        <ResponseField name="message" type="string">
          A SIWE message that can be signed by the wallet.
        </ResponseField>

        ### Usage

        ```tsx  theme={"system"}
        import {useLoginWithSiwe} from '@privy-io/expo';

        export function LoginScreen() {
        const [address, setAddress] = useState('');
        const [message, setMessage] = useState('');
        const {generateSiweMessage} = useLoginWithSiwe();

        const handleGenerate = async () => {
            const message = await generateSiweMessage({
            from: {
                domain: 'my-domain.com', // domain must be allowlisted in the Privy dashboard.
                uri: 'https://my-domain.com',
            },
            wallet: {
                // sepolia chainId with CAIP-2 prefix
                chainId: `eip155:11155111`,
                address,
            },
            });

            setMessage(message);
        };

        return (
            <View>
            <TextInput
                value={address}
                onChangeText={setAddress}
                placeholder="0x..."
                inputMode="ascii-capable"
            />

            <Button onPress={handleGenerate}>Generate Message</Button>

            {Boolean(message) && <Text>{message}</Text>}
            </View>
        );
        }
        ```

        ## Sign the [SIWE message](https://eips.ethereum.org/EIPS/eip-4361)

        Then, request an [ EIP-191 ](https://eips.ethereum.org/EIPS/eip-191) `personal_sign` signature for the `message` returned by `generateSiweMessage`, from a connected wallet.

        <Tip>
          There are many ways to connect a wallet to a mobile app, a few good options are:

          * [Mobile Wallet Protocol](https://mobilewalletprotocol.github.io/wallet-mobile-sdk/)
          * [Metamask React Native SDK](https://docs.metamask.io/wallet/how-to/use-sdk/javascript/react-native/)
          * [WalletConnectClient SDK](https://github.com/WalletConnect/react-native-examples)
        </Tip>

        ## Login with SIWE

        ```tsx  theme={"system"}
        loginWithSiwe({signature: string, messageOverride?: string, disableSignup?: boolean}) => Promise<Result<PrivyUser>>
        ```

        ### Parameters

        <ParamField path="signature" type="string" required>
          The signature of the SIWE message, signed by the user's wallet.
        </ParamField>

        <ParamField path="messageOverride" type="string">
          An optional override for the message that is signed.
        </ParamField>

        <ParamField path="disableSignup" type="boolean">
          If true, the user will not be automatically created if they do not exist in the Privy database.
        </ParamField>

        ### Returns

        <ResponseField name="PrivyUser" type="PrivyUser">
          A PrivyUser object containing the user's information.
        </ResponseField>

        ## Usage

        ```tsx  theme={"system"}
        import {useLoginWithSiwe, usePrivy} from '@privy-io/expo';

        export function LoginScreen() {
        const [signature, setSignature] = useState('');

        const {user} = usePrivy();
        const {loginWithSiwe} = useLoginWithSiwe();

        if (user) {
            return (
            <>
                <Text>Logged In</Text>
                <Text>{JSON.stringify(user, null, 2)}</Text>
            </>
            );
        }

        return (
            <View>
            <TextInput
                value={signature}
                onChangeText={setSignature}
                placeholder="0x..."
                inputMode="ascii-capable"
            />

            <Button onPress={() => loginWithSiwe({signature})}>Login</Button>
            </View>
        );
        }
        ```

        ## Callbacks

        You can optionally pass callbacks into the `useLoginWithSiwe` hook to run custom logic after a message has been generated, after a successful login, or to handle errors that occur during the flow.

        ### `onGenerateMessage`

        ```tsx  theme={"system"}
        onGenerateMessage?: ((message: string) => void) | undefined
        ```

        #### Parameters

        <ParamField path="message" type="string">
          The SIWE message that was generated.
        </ParamField>

        ### `onSuccess`

        ```tsx  theme={"system"}
        onSuccess?: ((user: PrivyUser, isNewUser: boolean) => void) | undefined
        ```

        #### Parameters

        <ParamField path="user" type="PrivyUser">
          The user object corresponding to the authenticated user.
        </ParamField>

        <ParamField path="isNewUser" type="boolean">
          Whether the user is a new user or an existing user.
        </ParamField>

        ### `onError`

        ```tsx  theme={"system"}
        onError?: (error: Error) => void
        ```

        #### Parameters

        <ParamField path="error" type="Error">
          The error that occurred during the login flow.
        </ParamField>

        ## Usage

        ```tsx  theme={"system"}
        import {useLoginWithSiwe} from '@privy-io/expo';

        export function LoginScreen() {
          const {generateSiweMessage, loginWithSiwe} = useLoginWithSiwe({
            onGenerateMessage(message) {
              // show a toast, send analytics event, etc...
            },
            onSuccess(user, isNewUser) {
              // show a toast, send analytics event, etc...
            },
            onError(error) {
              // show a toast, update form errors, etc...
            },
          });

          // ...
        }
        ```

        ## Tracking login flow state

        The `state` variable returned from `useLoginWithSiwe` will **always be one** of the following values.

        ```tsx  theme={"system"}
        type SiweFlowState =
          | { status: "initial" }
          | { status: "error"; error: Error | null }
          | { status: "generating-message" }
          | { status: "awaiting-signature" }
          | { status: "submitting-signature" }
          | { status: "done" };
        ```
      </Tab>

      <Tab title="Solana (SIWS)">
        To authenticate a user via a Solana wallet *([SIWS](https://github.com/phantom/sign-in-with-solana))*, use the React Native SDK's `useLoginWithSiws` hook.

        <Info>
          In order to use Privy's login with wallet flow, users must actively have a {chain_2} wallet
          connected to your app from which you can request signatures.
        </Info>

        ## Generate SIWS message

        ```tsx  theme={"system"}
        generateMessage({wallet: {address: string}, from: {domain: string, uri: string}}) => Promise<{message: string}>
        ```

        ### Parameters

        <ParamField path="wallet" type="Object">
          Wallet object containing Solana wallet address.

          <Expandable defaultOpen="true">
            <ParamField path="address" type="string" required>
              The address of the wallet.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField path="from" type="Object">
          Origin object containing domain and uri.

          <Expandable defaultOpen="true">
            <ParamField path="domain" type="string" required>
              The domain of the origin.
            </ParamField>

            <ParamField path="uri" type="string" required>
              The uri of the origin.
            </ParamField>
          </Expandable>
        </ParamField>

        ### Returns

        <ResponseField name="message" type="string">
          A SIWS message that can be signed by the wallet.
        </ResponseField>

        ### Usage

        ```tsx  theme={"system"}
        import {useLoginWithSiws} from '@privy-io/expo';

        export function LoginScreen() {
          const [address, setAddress] = useState('');
          const [message, setMessage] = useState('');
          const {generateMessage} = useLoginWithSiws();

          const handleGenerate = async () => {
            const {message} = await generateMessage({
              from: {
                domain: 'my-domain.com',
                uri: 'https://my-domain.com',
              },
              wallet: {
                address,
              },
            });

            setMessage(message);
          };

          return (
            <View>
              <TextInput
                value={address}
                onChangeText={setAddress}
                placeholder="0x..."
                inputMode="ascii-capable"
              />

              <Button onPress={handleGenerate}>Generate Message</Button>

              {Boolean(message) && <Text>{message}</Text>}
            </View>
          );
        }
        ```

        ## Sign the SIWS message

        Then, request a signature for the `message` returned by `generateMessage`, from a connected wallet.

        ## Login with SIWS

        ```tsx  theme={"system"}
        login({signature: string, message: string, wallet: {walletClientType: string, connectorType: string}, disableSignup?: boolean}) => Promise<Result<PrivyUser>>
        ```

        ### Parameters

        <ParamField path="signature" type="string" required>
          The signature of the SIWS message, signed by the user's wallet.
        </ParamField>

        <ParamField path="message" type="string" required>
          The original message that was signed.
        </ParamField>

        <ParamField path="wallet" type="Object" required>
          <Expandable defaultOpen="true">
            <ParamField path="walletClientType" type="string" required>
              The client of the connected wallet (e.g. 'phantom').
            </ParamField>

            <ParamField path="connectorType" type="string" required>
              The type of the connector (e.g. 'wallet\_connect' or 'mobile\_wallet\_protocol').
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField path="disableSignup" type="boolean">
          If true, the user will not be automatically created if they do not exist in the Privy database.
        </ParamField>

        ### Returns

        <ResponseField name="PrivyUser" type="PrivyUser">
          A PrivyUser object containing the user's information.
        </ResponseField>

        ## Usage

        ```tsx  theme={"system"}
        import {useLoginWithSiws, usePrivy} from '@privy-io/expo';

        export function LoginScreen() {
          const [signature, setSignature] = useState('');

          const {user} = usePrivy();
          const {login} = useLoginWithSiws();

          if (user) {
            return (
              <>
                <Text>Logged In</Text>
                <Text>{JSON.stringify(user, null, 2)}</Text>
              </>
            );
          }

          return (
            <View>
              <TextInput
                value={signature}
                onChangeText={setSignature}
                placeholder="0x..."
                inputMode="ascii-capable"
              />

              <Button
                onPress={() =>
                  login({
                    signature,
                    message,
                    wallet: {
                      walletClientType,
                      connectorType,
                    },
                  })
                }
              >
                Login
              </Button>
            </View>
          );
        }
        ```
      </Tab>
    </Tabs>

    ## Resources

    <Columns cols={3}>
      <Card title="Expo starter repo" href="https://github.com/privy-io/examples/tree/main/privy-expo-starter" icon="github" arrow="true">
        Get started with Expo and Privy.
      </Card>

      <Card title="Expo bare starter repo" href="https://github.com/privy-io/examples/tree/main/privy-expo-bare-starter" icon="github" arrow="true">
        Get started with Expo bare and Privy.
      </Card>
    </Columns>
  </Tab>

  <Tab title="Swift">
    <Tabs>
      <Tab title="Ethereum (SIWE)">
        To authenticate a user via an Ethereum wallet *([SIWE](https://eips.ethereum.org/EIPS/eip-4361))*, use the Privy client's `siwe` handler.

        ## Generate SIWE message

        ```swift  theme={"system"}
        func generateSiweMessage(params: SiweMessageParams) async throws -> String
        ```

        ### Parameters

        <ParamField path="params" type="SiweMessageParams">
          Set of parameters required to generate the message.

          <Expandable defaultOpen="true">
            <ParamField path="appDomain" type="String" required>
              Your app's domain. e.g. "my-domain.com"
            </ParamField>

            <ParamField path="appUri" type="String" required>
              Your app's URI. e.g. "[https://my-domain.com](https://my-domain.com)"
            </ParamField>

            <ParamField path="chainId" type="String" required>
              EVM Chain ID, e.g. "1" for Ethereum Mainnet
            </ParamField>

            <ParamField path="walletAddress" type="String" required>
              The user's [ERC-55](https://eips.ethereum.org/EIPS/eip-55) compliant wallet address.
            </ParamField>
          </Expandable>
        </ParamField>

        ### Returns

        <ResponseField name="String" type="String">
          A SIWE message that can be signed by the wallet.
        </ResponseField>

        ### Usage

        ```swift  theme={"system"}
        do {
            let params = SiweMessageParams(
                appDomain: "my-domain.com",
                appUri: "https://my-domain.com",
                chainId: "1",
                walletAddress: "0x12345..."
            )

            let siweMessage = try await privy.siwe.generateSiweMessage(params: params)
        } catch {
            // An error can be thrown if the network call to generate the message fails,
            // or if invalid metadata was passed in.
        }
        ```

        ## Sign the SIWE message

        Using the message returned by `generateSiweMessage`, request an EIP-191 `personal_sign` signature from the user's connected wallet. You should do this using the library your app uses to connect to external wallets (e.g. the MetaMask iOS SDK or WalletConnect).
        Once the user successfully signs the message, pass it into `loginWithSiwe`.

        ## Login with SIWE

        ```swift  theme={"system"}
        func loginWithSiwe(
            message: String,
            signature: String,
            params: SiweMessageParams,
            metadata: WalletLoginMetadata?
        ) async throws -> PrivyUser
        ```

        ### Parameters

        <ParamField path="message" type="String" required>
          The message returned from "generateSiweMessage".
        </ParamField>

        <ParamField path="signature" type="String" required>
          The signature of the SIWE message, signed by the user's wallet.
        </ParamField>

        <ParamField path="params" type="SiweMessageParams" required>
          The same SiweMessageParams passed into "generateSiweMessage".
        </ParamField>

        <ParamField path="metadata" type="WalletLoginMetadata">
          (Optional) you can pass additional metadata that will be stored with the linked wallet.

          <Expandable defaultOpen="true">
            <ParamField path="walletClientType" type="WalletClientType">
              An enum specifying the type of wallet used to login. e.g. WalletClientType.metamask
            </ParamField>

            <ParamField path="connectorType" type="String">
              A string identifying how wallet was connected. e.g. "wallet\_connect"
            </ParamField>
          </Expandable>
        </ParamField>

        ### Returns

        <ResponseField name="PrivyUser" type="PrivyUser">
          The authenticated Privy user
        </ResponseField>

        ### Throws

        An error if logging the user in is unsuccessful.

        ## Usage

        ```swift  theme={"system"}
        do {
            let params = SiweMessageParams(
                appDomain: "my-domain.com",
                appUri: "https://my-domain.com",
                chainId: "1",
                walletAddress: "0x12345..."
            )

            // Generate SIWE message
            let siweMessage = try await privy.siwe.generateSiweMessage(params: siweParams)

            // Optional metadata
            let metadata = WalletLoginMetadata(
                walletClientType: WalletClientType.metamask,
                connectorType: "wallet_connect"
            )

            // Login
            try await privy.siwe.loginWithSiwe(
              message: siweMessage,
              // the signature generated by the user's wallet
              signature: signature,
              params: siweParams,
              metadata: metadata
            )
        } catch {
            // error logging user in
        }
        ```
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Android">
    <Tabs>
      <Tab title="Ethereum (SIWE)">
        To authenticate a user via an Ethereum wallet *([SIWE](https://eips.ethereum.org/EIPS/eip-4361))*, use the Privy client's `siwe` handler.

        ## Generate SIWE message

        ```kotlin  theme={"system"}
        public suspend fun generateSiweMessage(params: SiweMessageParams): Result<String>
        ```

        ### Parameters

        <ParamField path="params" type="SiweMessageParams">
          Set of parameters required to generate the message.

          <Expandable defaultOpen="true">
            <ParamField path="appDomain" type="String" required>
              Your app's domain. e.g. "my-domain.com"
            </ParamField>

            <ParamField path="appUri" type="String" required>
              Your app's URI. e.g. "[https://my-domain.com](https://my-domain.com)"
            </ParamField>

            <ParamField path="chainId" type="String" required>
              EVM Chain ID, e.g. "1" for Ethereum Mainnet
            </ParamField>

            <ParamField path="walletAddress" type="String" required>
              The user's [ERC-55](https://eips.ethereum.org/EIPS/eip-55) compliant wallet address.
            </ParamField>
          </Expandable>
        </ParamField>

        ### Returns

        <ResponseField name="String" type="Result<String>">
          A result type encapsulating the SIWE message that can be signed by the wallet on success.
        </ResponseField>

        ### Usage

        ```kotlin  theme={"system"}
        val params = SiweMessageParams(
            appDomain = domain,
            appUri = uri,
            chainId = chainId,
            walletAddress = walletAddress
        )

        privy.siwe.generateSiweMessage(params = params).fold(
            onSuccess = { message ->
                // request an EIP-191 `personal_sign` signature on the message
            },
            onFailure = { e ->
                // An error can be thrown if the network call to generate the message fails,
                // or if invalid metadata was passed in.
            }
        )
        ```

        ## Sign the SIWE message

        Using the message returned by `generateSiweMessage`, request an EIP-191 `personal_sign` signature from the user's connected wallet. You should do this using the library your app uses to connect to external wallets (e.g. the MetaMask SDK or WalletConnect).
        Once the user successfully signs the message, pass the signature into the `loginWithSiwe` function.

        ## Login with SIWE

        ```kotlin  theme={"system"}
        public suspend fun loginWithSiwe(
            message: String,
            signature: String,
            params: SiweMessageParams,
            metadata: WalletLoginMetadata?,
        ): Result<PrivyUser>
        ```

        ### Parameters

        <ParamField path="message" type="String" required>
          The message returned from "generateSiweMessage".
        </ParamField>

        <ParamField path="signature" type="String" required>
          The signature of the SIWE message, signed by the user's wallet.
        </ParamField>

        <ParamField path="params" type="SiweMessageParams" required>
          The same SiweMessageParams passed into "generateSiweMessage".
        </ParamField>

        <ParamField path="metadata" type="WalletLoginMetadata">
          (Optional) you can pass additional metadata that will be stored with the linked wallet.

          <Expandable defaultOpen="true">
            <ParamField path="walletClientType" type="WalletClientType">
              An enum specifying the type of wallet used to login. e.g. WalletClientType.Metamask
            </ParamField>

            <ParamField path="connectorType" type="String">
              A string identifying how wallet was connected. e.g. "wallet\_connect"
            </ParamField>
          </Expandable>
        </ParamField>

        ### Returns

        <ResponseField name="PrivyUser" type="Result<PrivyUser>">
          A result type ecapsulating the PrivyUser on success.
        </ResponseField>

        ## Usage

        ```kotlin  theme={"system"}
        val params = SiweMessageParams(
            appDomain = domain,
            appUri = uri,
            chainId = chainId,
            walletAddress = walletAddress
        )

        // optional metadata
        val metadata = WalletLoginMetadata(walletClientType = walletClient, connectorType = connectorType)

        privy.siwe.loginWithSiwe(message, signature, params, metadata).fold(
            onSuccess = { privyUser ->
                // Login success
            },
            onFailure = { e ->
                // Login failure, either due to invalid signature or network error
            }
        )
        ```
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Flutter">
    <Tabs>
      <Tab title="Ethereum (SIWE)">
        To authenticate a user via an Ethereum wallet *([SIWE](https://eips.ethereum.org/EIPS/eip-4361))*, use the Privy client's `siwe` handler.

        ## Generate SIWE message

        ```dart  theme={"system"}
        Future<Result<String>> generateSiweMessage(SiweMessageParams params)
        ```

        ### Parameters

        <ParamField path="params" type="SiweMessageParams">
          Set of parameters required to generate the message.

          <Expandable defaultOpen="true">
            <ParamField path="appDomain" type="String" required>
              Your app's domain. e.g. "my-domain.com"
            </ParamField>

            <ParamField path="appUri" type="String" required>
              Your app's URI. e.g. "[https://my-domain.com](https://my-domain.com)"
            </ParamField>

            <ParamField path="chainId" type="String" required>
              EVM Chain ID, e.g. "1" for Ethereum Mainnet
            </ParamField>

            <ParamField path="walletAddress" type="String" required>
              The user's [ERC-55](https://eips.ethereum.org/EIPS/eip-55) compliant wallet address.
            </ParamField>
          </Expandable>
        </ParamField>

        ### Returns

        <ResponseField name="String" type="Result<String>">
          A result type encapsulating the SIWE message that can be signed by the wallet on success.
        </ResponseField>

        ### Usage

        ```dart  theme={"system"}
        final params = SiweMessageParams(
          appDomain: domain,
          appUri: uri,
          chainId: chainId,
          walletAddress: walletAddress,
        );

        final result = await privy.siwe.generateSiweMessage(params);

        result.fold(
          onSuccess: (message) {
            // request an EIP-191 `personal_sign` signature on the message
          },
          onFailure: (error) {
            // An error can be thrown if the network call to generate the message fails,
            // or if invalid metadata was passed in.
          },
        );
        ```

        ## Sign the SIWE message

        Using the message returned by `generateSiweMessage`, request an EIP-191 `personal_sign` signature from the user's connected wallet.
        You should do this using the library your app uses to connect to external wallets (e.g. the MetaMask SDK or WalletConnect). Once
        the user successfully signs the message, pass the signature into the `loginWithSiwe` function.

        ## Login with SIWE

        ```dart  theme={"system"}
        Future<Result<PrivyUser>> loginWithSiwe({
          required String message,
          required String signature,
          required SiweMessageParams params,
          WalletLoginMetadata? metadata,
        })
        ```

        ### Parameters

        <ParamField path="message" type="String" required>
          The message returned from "generateSiweMessage".
        </ParamField>

        <ParamField path="signature" type="String" required>
          The signature of the SIWE message, signed by the user's wallet.
        </ParamField>

        <ParamField path="params" type="SiweMessageParams" required>
          The same SiweMessageParams passed into "generateSiweMessage".
        </ParamField>

        <ParamField path="metadata" type="WalletLoginMetadata">
          (Optional) you can pass additional metadata that will be stored with the linked wallet.

          <Expandable defaultOpen="true">
            <ParamField path="walletClientType" type="WalletClientType">
              An enum specifying the type of wallet used to login. e.g. WalletClientType.metamask
            </ParamField>

            <ParamField path="connectorType" type="String">
              A string identifying how wallet was connected. e.g. "wallet\_connect"
            </ParamField>
          </Expandable>
        </ParamField>

        ### Returns

        <ResponseField name="PrivyUser" type="Result<PrivyUser>">
          A result type encapsulating the PrivyUser on success.
        </ResponseField>

        ### Usage

        ```dart  theme={"system"}
        final params = SiweMessageParams(
          appDomain: domain,
          appUri: uri,
          chainId: chainId,
          walletAddress: walletAddress,
        );

        // optional metadata
        final metadata = WalletLoginMetadata(
          walletClientType: walletClient,
          connectorType: connectorType,
        );

        final result = await privy.siwe.loginWithSiwe(
          message: message,
          signature: signature,
          params: params,
          metadata: metadata,
        );

        result.fold(
          onSuccess: (privyUser) {
            // Login success
          },
          onFailure: (error) {
            // Login failure, either due to invalid signature or network error
          },
        );
        ```
      </Tab>
    </Tabs>
  </Tab>
</Tabs>


# Logging users out
Source: https://docs.privy.io/authentication/user-authentication/logout



Logging out a user ends their authenticated session, removing their access credentials from the device and requiring them to authenticate again to access protected resources.

<Tabs>
  <Tab title="React">
    ```tsx  theme={"system"}
    logout: () => Promise<void>
    ```

    ### Usage

    To log a user out, use the `logout` method from the `usePrivy` hook:

    ```tsx  theme={"system"}
    import { usePrivy } from '@privy-io/react-auth';

    function LogoutButton() {
      const { ready, authenticated, logout } = usePrivy();

      // Disable logout when Privy is not ready or the user is not authenticated
      const disableLogout = !ready || (ready && !authenticated);

      return (
        <button disabled={disableLogout} onClick={logout}>
          Log out
        </button>
      );
    }
    ```

    ### Callbacks

    You can attach callbacks to the logout process using the `useLogout` hook:

    ```tsx  theme={"system"}
    import { useLogout } from '@privy-io/react-auth';

    function LogoutButton() {
      const { logout } = useLogout({
        onSuccess: () => {
          console.log('User successfully logged out');
          // Redirect to landing page or perform other post-logout actions
        },
        onError: (error) => {
          console.error('Logout failed', error);
        }
      });

      return <button onClick={logout}>Log out</button>;
    }
    ```
  </Tab>

  <Tab title="React Native">
    ```tsx  theme={"system"}
    logout: () => Promise<void>
    ```

    ### Usage

    To log a user out, use the `logout` method from the `usePrivy` hook:

    ```tsx  theme={"system"}
    import { usePrivy } from '@privy-io/expo';

    function LogoutButton() {
      const { logout } = usePrivy();

      return <Button onPress={() => logout()}>Log out</Button>;
    }
    ```

    ### Async Handling

    Since `logout` returns a Promise, you can await it to run code after the user has been logged out:

    ```tsx  theme={"system"}
    import { usePrivy } from '@privy-io/expo';

    function LogoutButton() {
      const { logout } = usePrivy();

      const handleLogout = async () => {
        await logout();
        // Perform actions after logout completes
        console.log('User logged out successfully');
      };

      return <Button onPress={handleLogout}>Log out</Button>;
    }
    ```
  </Tab>

  <Tab title="Swift">
    ```swift  theme={"system"}
    func logout()
    ```

    ### Usage

    To log out an authenticated user, call the `logout` method on the user object:

    ```swift  theme={"system"}
    privy.user.logout()
    ```

    ### Example

    ```swift  theme={"system"}
    import PrivySDK

    class ProfileViewController: UIViewController {
      @IBAction func logoutButtonTapped(_ sender: UIButton) {
        // Check if user is authenticated
        if let user = privy.user {
          user.logout()
          // Navigate back to login screen
          self.navigationController?.popToRootViewController(animated: true)
        }
      }
    }
    ```

    ### Effect

    This will clear the user state and delete the persisted user session.
  </Tab>

  <Tab title="Android">
    ```kotlin  theme={"system"}
    suspend fun logout()
    ```

    ### Usage

    To log out an authenticated user, call the `logout` method:

    ```kotlin  theme={"system"}
    coroutineScope.launch {
      privy.logout()
    }
    ```

    ### Example

    ```kotlin  theme={"system"}
    import io.privy.android.Privy
    import kotlinx.coroutines.launch
    import kotlinx.coroutines.CoroutineScope
    import kotlinx.coroutines.Dispatchers

    class ProfileActivity : AppCompatActivity() {
      private val coroutineScope = CoroutineScope(Dispatchers.Main)

      private fun setupLogoutButton() {
        logoutButton.setOnClickListener {
          coroutineScope.launch {
            privy.logout()
            // Navigate back to login activity
            startActivity(Intent(this@ProfileActivity, LoginActivity::class.java))
            finish()
          }
        }
      }
    }
    ```

    ### Effect

    This will clear the user state and delete the persisted user session.
  </Tab>

  <Tab title="Flutter">
    ```dart  theme={"system"}
    Future<void> logout()
    ```

    ### Usage

    To log out an authenticated user, call the `logout` method:

    ```dart  theme={"system"}
    await privy.logout();
    ```

    ### Example

    ```dart  theme={"system"}
    import 'package:flutter/material.dart';
    import 'package:privy_flutter/privy_flutter.dart';

    class ProfileScreen extends StatelessWidget {
      final Privy privy;

      const ProfileScreen({Key? key, required this.privy}) : super(key: key);

      @override
      Widget build(BuildContext context) {
        return Scaffold(
          appBar: AppBar(title: Text('Profile')),
          body: Center(
            child: ElevatedButton(
              onPressed: () async {
                await privy.logout();
                // Navigate back to login screen
                Navigator.of(context).pushReplacementNamed('/login');
              },
              child: Text('Log out'),
            ),
          ),
        );
      }
    }
    ```

    ### Effect

    This will clear the user state and delete the persisted user session.
  </Tab>
</Tabs>


# Using custom UIs
Source: https://docs.privy.io/authentication/user-authentication/mfa/custom-ui



<Tip>
  **By default, Privy's wallet MFA feature will use Privy's UIs** for enrolling users in MFA, managing MFA methods, and having users complete MFA to authorize signatures and transactions for the embedded wallet.

  This section is intended only for apps that would like to use wallet MFA with their own custom UIs, instead of Privy's defaults.
</Tip>

<Warning>
  Implementing wallet MFA with custom UIs is *substantially* more involved than integrating Privy's
  out-of-the-box wallet MFA feature. Make sure to consider the development trade-offs of using
  custom UIs over Privy defaults before finalizing on your approach!
</Warning>

<Tabs>
  <Tab title="React">
    ### Configuring MFA to be used with custom UIs

    If you plan to use your own custom UIs for wallet MFA, **set the `mfa.noPromptOnMfaRequired` field to true in the Privy provider**.

    ```tsx  theme={"system"}
    function MyApp({Component, pageProps}: AppProps) {
      return (
        <>
          <PrivyProvider
            appId={process.env.NEXT_PUBLIC_PRIVY_APP_ID}
            config={{
              mfa: {
                // Defaults to 'false'
                noPromptOnMfaRequired: true,
              },
              ...insertTheRestOfYourConfig,
            }}
          >
            <Component {...pageProps} />
          </PrivyProvider>
        </>
      );
    }
    ```

    This will configure Privy to not show its default UIs for wallet MFA, and instead rely on your custom implementation.

    ### Enrolling in MFA

    To enroll your users in MFA, use the  hook from Privy. Currently, users can enroll in three MFA methods:

    * **SMS**, where users authenticate with a 6-digit MFA code sent to their phone number
    * **TOTP**, where users authenticate with a 6-digit MFA code from an authentication app, like Authy or Google Authenticator
    * **Passkey**, where users verify with a previously registered passkey, generally through biometric authentication on their device

    #### SMS

    To enroll your users in MFA with SMS, use the  and  methods returned by the  hook:

    ```tsx  theme={"system"}
    const {initEnrollmentWithSms, submitEnrollmentWithSms} = useMfaEnrollment();
    ```

    First, initiate enrollment by prompting your user to enter the phone number they'd like to use for MFA. Then, call Privy's  method. As a parameter to this , pass a JSON object with a  field that contains the user's provide phone number as a string.

    ```tsx  theme={"system"}
    // Prompt the user for their phone number
    const phoneNumberInput = 'insert-phone-number-from-user';
    // Send an enrollment code to their phone number
    await initEnrollmentWithSms({phoneNumber: phoneNumberInput});
    ```

    Once  is called with a valid , Privy will then send a 6-digit MFA enrollment code to the provided number. This method returns a `Promise` that will resolve to `void` if the code was successfully sent, or will reject with an `error` if there was an error sending the code (e.g. invalid phone number).

    Next, prompt the user to enter the 6-digit code that was sent to their phone number, and use the  method to complete enrollment of that phone number. As a parameter to , you must pass a JSON object with both the original  that the user enrolled, and the  they received at that number.

    ```tsx  theme={"system"}
    // Prompt the user for the code sent to their phone number
    const mfaCodeInput = 'insert-mfa-code-received-by-user';
    await submitEnrollmentWithSms({
      phoneNumber: phoneNumberInput, // From above
      mfaCode: mfaCodeInput,
    });
    ```

    <Accordion title="See an end-to-end example of enrolling users in MFA with SMS">
      The component below serves as a reference implementation for how to enroll your users in MFA with SMS!

      ```tsx Example enrolling a phone number for MFA theme={"system"}
      import {useMfaEnrollment} from '@privy-io/react-auth';

      export default function MfaEnrollmentWithSms() {
        const {initEnrollmentWithSms, submitEnrollmentWithSms} = useMfaEnrollment();

        const [phoneNumber, setPhoneNumber] = useState<string | null>(null);
        const [mfaCode, setMfaCode] = useState<string | null>(null);
        const [pendingMfaCode, setPendingMfaCode] = useState<boolean>(false);

        // Handler for when the user enters their phone number to enroll in MFA.
        const onEnteredPhoneNumber = () => {
          await initEnrollmentWithSms({phoneNumber: phoneNumber}); // Sends an MFA code to the `phoneNumber`
          setPendingMfaCode(true);
        }

        // Handler for when the user enters the MFA code sent to their phone number.
        const onEnteredMfaCode = () => {
          await submitEnrollmentWithSms({phoneNumber: phoneNumber, mfaCode: mfaCode});
          // See the "Handling errors with code submission" section of this guide
          // for details on how to handle errors raised by `submitEnrollmentWithSms`
          setPendingMfaCode(false);
        }

        // If no MFA code has been sent yet, prompt the user for their phone number to enroll
        if (!pendingMfaCode) {
          // Input field for the user to enter the phone number they'd like to enroll for MFA
          return <>
            <input placeholder='(555) 555 5555' onChange={(event) => setPhoneNumber(event.target.value)}/>
            <button onClick={onEnteredPhoneNumber}>Enroll a Phone with MFA</button>
          </>;
        }

        // Input field for the user to enter the MFA code sent to their phone number
        return <>
          <input placeholder='123456' onChange={(event) => setMfaCode(event.target.value)}/>
          <button onClick={onEnteredMfaCode}>Submit Enrollment Code</button>
        </>;
      }
      ```
    </Accordion>

    <Info>
      If your app has enabled SMS as a possible *login* method, users will **not** be able to enroll SMS as a valid *MFA* method.

      SMS must be either be used as a login method to secure user accounts, or as an MFA method for additional security on the users' wallets.
    </Info>

    #### TOTP

    To enroll your users in MFA with TOTP, use the  and  methods returned by the  hook:

    ```tsx  theme={"system"}
    const {initEnrollmentWithTotp, submitEnrollmentWithTotp} = useMfaEnrollment();
    ```

    First, initiate enrollment by calling Privy's  method with no parameters. This method returns a `Promise` for an  and  that the user will need in order to complete enrollment.

    ```tsx  theme={"system"}
    const {authUrl, secret} = await initEnrollmentWithTotp();
    ```

    Then, to have the user enroll, you can either:

    * display the TOTP  as a QR code to the user, and prompt them to scan it with their TOTP client (commonly, a mobile app like Google Authenticator or Authy)
    * allow the user to copy the TOTP  and paste it into their TOTP client

    <Tip>
      You can directly pass in the  from above into a library like  to render the URL as a QR code to your user.
    </Tip>

    Once your user has successfully scanned the QR code, an enrollment code for Privy will appear within their TOTP client. Prompt the user to enter this code in your app, and call Privy's  method. As a parameter to , pass a JSON object with an  field that contains the MFA code from the user as a string.

    ```tsx  theme={"system"}
    const mfaCodeInput = 'insert-mfa-code-from-user-totp-app'; // Prompt the user for the code in their TOTP app
    await submitEnrollmentWithTotp({mfaCode: mfaCodeInput});
    ```

    <Accordion title="See an end-to-end example of enrolling users in MFA with TOTP">
      The component below serves as a reference implementation for how to enroll your users in MFA with TOTP!

      ```tsx Example enrolling a TOTP client for MFA theme={"system"}
      import {useMfaEnrollment} from '@privy-io/react-auth';
      import QRCode from 'react-qr-code';
      import {CopyableElement} from '../components/CopyableElement';

      export default function MfaEnrollmentWithTotp() {
        const {initEnrollmentWithTotp, submitEnrollmentWithTotp} = useMfaEnrollment();
        const [totpAuthUrl, setTotpAuthUrl] = useState<string | null>(null);
        const [totpSecret, setTotpSecret] = useState<string | null>(null);
        const [mfaCode, setMfaCode] = useState<string | null>(null);

        // Handler for when the user is ready to enroll in TOTP MFA
        const onGenerateTotpUrl = async () => {
          const {authUrl, secret} = await initEnrollmentWithTotp();
          setTotpAuthUrl(authUrl);
          setTotpSecret(secret);
        }

        // Handler for when the user enters the MFA code from their TOTP client
        const onEnteredMfaCode = async () => {
          await submitEnrollmentWithTotp({mfaCode: mfaCode});
          // See the "Handling errors with code submission" section of this guide
          // for details on how to handle errors raised by `submitEnrollmentWithTotp`
        }

        return(
          <div>
            {/* QR code for the user to scan */}
            {totpAuthUrl && totpSecret ?
              {/* If TOTP values have been generated... */}
              <>
                {/* ...show the user a QR code with the `authUrl` that they can scan...  */}
                <QRCode value={totpAuthUrl} />
                {/* ...or give them the option to copy the `secret` into their TOTP client  */}
                <CopyableElement value={totpSecret} />
              </> :
              {/* Else, show a button to generate the totpAuthUrl */}
              <button onClick={() => onGenerateTotpUrl()}>Show QR Code</button>
            }
            {/* Input field for the user to enter their MFA code */}
            <p>Enter the code from your authenticator app below.</p>
            <input placeholder='123456' onChange={(event) => setMfaCode(event.target.value)}/>
            <button onClick={() => submitEnrollmentWithTotp({mfaCode: mfaCode})}>Submit Enrollment Code</button>
          </div>
        );
      }
      ```
    </Accordion>

    #### Passkey

    <Tip>
      In order to use passkeys as a MFA method, make sure a valid passkey is linked to the user. You can set this up by following the steps [here](/user-management/users/linking-accounts)!
    </Tip>

    To enroll your users in MFA with passkeys, use the  and  methods returned by the  hook:

    ```tsx  theme={"system"}
    const {initEnrollmentWithPasskey, submitEnrollmentWithPasskey} = useMfaEnrollment();
    ```

    First, initiate enrollment by calling Privy's  method with no parameters. This method returns a `Promise` that will resolve to `void` indicating success.

    ```tsx  theme={"system"}
    await initEnrollmentWithPasskey();
    ```

    Then, to have the user enroll, you must call Privy's `submitEnrollmentWithPasskey` method with a list of the user's passkey account `credentialIds`. You can find this list by querying the `user`'s `linkedAccounts` array for all accounts of `type: 'passkey'`:

    ```tsx  theme={"system"}
    const {user} = usePrivy();

    // ...

    const credentialIds = user.linkedAccounts
      .filter((account): account is PasskeyWithMetadata => account.type === 'passkey')
      .map((x) => x.credentialId);

    await submitEnrollmentWithPasskey({credentialIds});
    ```

    <Accordion title="See an end-to-end example of enrolling users in MFA with passkeys">
      The component below serves as a reference implementation for how to enroll your users in MFA with passkeys!

      ```tsx Example enrolling passkeys for MFA theme={"system"}
      import {useMfaEnrollment} from '@privy-io/react-auth';

      export default function MfaEnrollmentWithPasskey() {
        const {user} = usePrivy();
        const {initEnrollmentWithPasskey, submitEnrollmentWithPasskey} = useMfaEnrollment();

        const handleEnrollmentWithPasskey = async () => {
          await initEnrollmentWithPasskey();

          const credentialIds = user.linkedAccounts
            .filter((account): account is PasskeyWithMetadata => account.type === 'passkey')
            .map((x) => x.credentialId);

          await submitEnrollmentWithPasskey({credentialIds});
        };

        return (
          <div>
            <div>Enable your passkeys for MFA</div>
            {user.linkedAccounts
              .filter((account): account is PasskeyWithMetadata => account.type === 'passkey')
              .map((account) => (
                <div key={account.id}>{account.credentialId}</div>
              ))}
            <button onClick={handleEnrollmentWithPasskey}>Enroll</button>
          </div>
        );
      }
      ```
    </Accordion>

    ### Completing MFA

    Once users have successfully enrolled in MFA with Privy, they will be required to complete MFA whenever the private key for their embedded wallet must be used. This includes signing messages and transactions, recovering the embedded wallet on new devices, exporting the wallet's private key, and setting a password on the wallet.

    **To ensure users can complete MFA when required, your app must do the following:**

    1. Set up a flow to guide the user through completing MFA when required.
    2. Register an event listener to configure Privy to invoke the flow from step (1) whenever MFA is required.

    <Tip>
      Once a user has completed MFA on a given device, they can continue to use the wallet on that device *without* needing to complete MFA for 15 minutes.

      After 15 minutes have elapsed, Privy will require that the user complete MFA again to re-authorize use of the wallet's private key.
    </Tip>

    #### Guiding the user through MFA

    To set up a flow to have the user complete MFA, use Privy's  hook.

    ```tsx  theme={"system"}
    const {init, submit, cancel} = useMfa();
    ```

    This flow has three core components:

    1. Requesting an MFA code be sent to the user's MFA method ()
    2. Submitting the MFA code provided by the user ()
    3. Cancelling an in-progress MFA flow ()

    ## Requesting an MFA challenge

    To request an MFA challenge for the current user, call the  method from the  hook, passing the user's desired MFA method (`'sms'`, `'totp'`, or `'passkey'`) as a parameter.

    ```tsx  theme={"system"}
    const selectedMfaMethod = 'sms'; // Must be 'sms', 'totp' or 'passkey'
    await init(selectedMfaMethod);
    ```

    The  method will then prepare an MFA challenge for the desired MFA method, and returns a `Promise` that resolves if the challenge was successfully created, and rejects with an error if there was an issue.

    * If the MFA method is `'sms'`, the user will receive an SMS with their MFA code at the phone number they originally enrolled.
    * If the MFA method is `'totp'`, the user will receive the MFA code within their authenticator app.
    * If the MFA method is `'passkey'`, `init` will return an object with options to pass to the native passkey system

    ## Submitting the MFA verification

    <Tabs>
      <Tab title="Submitting a user-input code (SMS/TOTP)">
        Once  has resolved successfully, prompt the user to get their MFA code from their MFA method and to enter it within your app. Then, call the  method from . As parameters to , pass the MFA method being used (`'sms'` or `'totp'`) and the MFA code that the user entered.

        ```tsx  theme={"system"}
        const mfaCode = 'insert-mfa-code-from-user';
        await submit(selectedMfaMethod, mfaCode);
        ```
      </Tab>

      <Tab title="Submitting a passkey">
        Once  has resolved successfully, prompt the user to select a passkey by calling `submit` with the options returned from the `init` method.

        ```tsx  theme={"system"}
        const options = await init('passkey');

        // Submit will trigger the system's native passkey prompt
        await submit('passkey', options);
        ```
      </Tab>
    </Tabs>

    ## Cancelling the MFA flow

    After  has been called and the corresponding  call has not yet occurred, the user may cancel their in-progress MFA flow if they wish.

    To cancel the current MFA flow, call the  method from the  hook.

    ```tsx  theme={"system"}
    cancel();
    ```

    <Accordion title="See a recommended abstraction for guiding users to complete MFA">
      To simplify the implementation, we recommend abstracting the logic above into a self-contained component that can be used whenever the user needs to complete an MFA flow.

      For instance, you might write an `MFAModal` component that allows the user to (1) select their desired method of their enrolled MFA methods, (2) request an MFA code, and (3) submit the MFA code to Privy for verification. A sample implementation is below:

      ```tsx Example modal for guiding users through the MFA flow theme={"system"}
      import Modal from 'react-modal';

      import {
        useMfaEnrollment,
        errorIndicatesMfaVerificationFailed,
        errorIndicatesMfaMaAttempts,
        errorIndicatesMfaTimeout,
        MfaMethod,
      } from '@privy-io/react-auth';

      type Props = {
        // List of available MFA methods that the user has enrolled in
        mfaMethods: MfaMethod[];
        // Boolean indicator to determine whether or not the modal should be open
        isOpen: boolean;
        // Helper function to open/close the modal */
        setIsOpen: (isOpen: boolean) => void;
      };

      export const MFAModal = ({mfaMethods, isOpen, setIsOpen}: Props) => {
        const {init, submit, cancel} = useMfa();
        // Stores the user's selected MFA method
        const [selectedMethod, setSelectedMethod] = useState<MfaMethod | null>(null);
        // Stores the user's MFA code
        const [mfaCode, setMfaCode] = useState('');
        // Stores the options for passkey MFA
        const [options, setOptions] = useState(null);
        // Stores an error message to display
        const [error, setError] = useState('');

        // Helper function to request an MFA code for a given method
        const onMfaInit = async (method: MfaMethod) => {
          const response = await init(method);
          setError('');
          setSelectedMethod(method);
          if (method === 'passkey') {
            setOptions(response);
          }
        };

        // Helper function to submit an MFA code to Privy for verification
        const onMfaSubmit = async () => {
          try {
            if (selectedMethod === 'passkey') {
              await submit(selectedMethod, options);
            } else {
              await submit(selectedMethod, mfaCode);
            }
            setSelectedMethod(null); // Clear the MFA flow once complete
            setIsOpen(false); // Close the modal
          } catch (e) {
            // Handling possible errors with MFA code submission
            if (errorIndicatesMfaVerificationFailed(e)) {
              setError('Incorrect MFA code, please try again.');
              // Allow the user to re-enter the code and call `submit` again
            } else if (errorIndicatesMfaMaxAttempts(e)) {
              setError('Maximum MFA attempts reached, please request a new code.');
              setSelectedMethod(null); // Clear the MFA flow to allow the user to try again
            } else if (errorIndicatesMfaTimeout(e)) {
              setError('MFA code has expired, please request a new code.');
              setSelectedMethod(null); // Clear the MFA flow to allow the user to try again
            }
          }
        };

        // Helper function to clean up state when the user closes the modal
        const onModalClose = () => {
          cancel(); // Cancel any in-progress MFA flows
          setIsOpen(false);
        };

        return (
          <Modal isOpen={isOpen} onAfterClose={onModalClose}>
            {/* Button for the user to select an MFA method and request an MFA code */}
            {mfaMethods.map((method) => (
              <button onClick={() => onMfaInit(method)}>Choose to MFA with {method}</button>
            ))}
            {/* Input field for the user to enter their MFA code and submit it */}
            {selectedMethod && selectedMethod !== 'passkey' && (
              <div>
                <p>Enter your MFA code below</p>
                <input placeholder="123456" onChange={(event) => setMfaCode(event.target.value)} />
                <button onClick={() => onMfaSubmit()}>Submit Code</button>
              </div>
            )}
            {/* Display error message if there is one */}
            {!!error.length && <p>{error}</p>}
          </Modal>
        );
      };
      ```

      Notice how the modal contains all logic for requesting the MFA code, submitting the MFA code, handling errors, and cancelling an in-progress MFA code.

      Then, when your app needs to prompt a user to complete MFA, they can simply display this  component and configure the  prop with the list of MFA methods that are available for the current user.
    </Accordion>

    #### Registering an event listener

    Once you've set up your app's logic for guiding a user to complete MFA, you lastly need to configure Privy to invoke this logic whenever MFA is required by the user's embedded wallet.

    To set up this configuration, use Privy's  hook. As a parameter to , you must pass a JSON object with an  callback, described below.

    ## onMfaRequired

    Privy will invoke the  callback you set whenever the user is required to complete MFA to use the embedded wallet. When this occurs, any use of the embedded wallet will be "paused" until the user has successfully completed MFA with Privy.

    In this callback, you should invoke your app's logic for guiding through completing MFA (done via the  hook, as documented above). Within this callback, you can also access an  parameter that contains a list of available MFA methods that the user has enrolled in (`'sms'` and/or `'totp'` and/or `'passkey'`).

    <Tabs>
      <Tab title="Registering an event listener">
        ```tsx MFAProvider.tsx theme={"system"}
        import {useRegisterMfaListener, MfaMethod} from '@privy-io/react-auth';

        import {MFAModal} from '../components/MFAModal';

        export const MFAProvider = ({children}: {children: React.ReactNode}) => {
          const [isMfaModalOpen, setIsMfaModelOpen] = useState(false);
          const [mfaMethods, setMfaMethods] = useState<MfaMethod[]>([]);

          useRegisterMfaListener({
            // Privy will invoke this whenever the user is required to complete MFA
            onMfaRequired: (methods) => {
              // Update app's state with the list of available MFA methods for the user
              setMfaMethods(methods);
              // Open MFA modal to allow user to complete MFA
              setIsMfaModalOpen(true);
            },
          });

          return (
            <div>
              {/* This `MFAModal` component includes all logic for completing the MFA flow with Privy's `useMfa` hook */}
              <MFAModal isOpen={isMfaModalOpen} setIsOpen={setIsMfaModalOpen} mfaMethods={mfaMethods} />
              {children}
            </div>
          );
        };
        ```
      </Tab>
    </Tabs>

    <Info>
      In order for Privy to invoke your app's MFA flow, the component that calls Privy's  hook **must be mounted** whenever the user's embedded wallet requires that they complete MFA.

      In kind, we recommend that you render this component near the root of your application, so that it is always rendered whenever the embedded wallet may be used.
    </Info>

    ### Handling errors with code submission

    When both enrolling in and completing MFA, Privy sends a 6-digit code to the user's selected MFA method, that the user must submit to Privy in order to verify their identity.

    When submitting this MFA code, Privy may respond with an error if the code is incorrect, if the user has reached the maximum number of attempts for this MFA flow, or if the MFA flow has timed out. If the user enters in an incorrect code (e.g. by mistyping), the user is allowed to retry code submission up to a **maximum of four attempts.**

    **To simplify handling errors with MFA code submission, Privy provides the following helper functions to parse errors raised by the MFA code submission methods listed above.** Each of these functions accepts the raw  raised as a parameter, and returns a `Boolean` indicating if the error meets a certain condition:

    * : indicates the user entered an incorrect MFA code
    * indicates has reached the maximum number of attempts for this MFA flow, and that a new MFA code must be requested via
    * indicates that the current MFA code has expired, and that a new MFA code must be requested via

    As an example, to handle errors raised by , you might use these helpers like so:

    ```tsx Handling errors during MFA code submission theme={"system"}
    try {
      // Errors from `submitEnrollmentWithSms` and `submitEnrollmentWithTotp` can be handled similarly
      await submit('insert-mfa-code', 'insert-mfa-method');
    } catch (e) {
      if (errorIndicatesMfaVerificationFailed(e)) {
        console.error('Incorrect MFA code, please try again.');
        // Allow the user to re-enter the code and call `submit` again
      } else if (errorIndicatesMfaMaxAttempts(e)) {
        console.error('Maximum MFA attempts reached, please request a new code.');
        // Allow the user to request a new code with `init`
      } else if (errorIndicatesMfaTimeout(e)) {
        console.error('MFA code has expired, please request a new code.');
        // Allow the user to request a new code with `init`
      }
    }
    ```
  </Tab>

  <Tab title="React Native">
    ### Enrollment flows with custom UIs in Expo

    To enroll your users in MFA, use the  and  methods returned by the  hook:

    ```tsx  theme={"system"}
    const {initMfaEnrollment, submitMfaEnrollment} = useMfaEnrollment();
    ```

    Currently, users can enroll in three MFA methods:

    * , where users authenticate with a 6-digit MFA code sent to their phone number
    * , where users authenticate with a 6-digit MFA code from an authentication app, like Authy or Google Authenticator
    * , where users verify with a previously registered passkey, generally through biometric authentication on their device

    #### SMS

    First, initiate enrollment by prompting your user to enter the phone number they'd like to use for MFA. Then, call Privy's  method with the appropriate parameters:

    ```tsx  theme={"system"}
    // Prompt the user for their phone number
    const phoneNumberInput = 'insert-phone-number-from-user';
    // Send an enrollment code to their phone number
    await initMfaEnrollment({method: 'sms', phoneNumber: phoneNumberInput});
    ```

    Once  is called with a valid , Privy will then send a 6-digit MFA enrollment code to the provided number.

    Next, prompt the user to enter the 6-digit code that was sent to their phone number, and use the  method to complete enrollment:

    ```tsx  theme={"system"}
    // Prompt the user for the code sent to their phone number
    const mfaCodeInput = 'insert-mfa-code-received-by-user';
    await submitMfaEnrollment({
      method: 'sms',
      phoneNumber: phoneNumberInput, // From above
      code: mfaCodeInput,
    });
    ```

    <Accordion title="See an end-to-end example of enrolling users in MFA with SMS">
      The component below serves as a reference implementation for how to enroll your users in MFA with SMS!

      ```tsx Example enrolling a phone number for MFA theme={"system"}
      import {useMfaEnrollment} from '@privy-io/expo';

      export default function MfaEnrollmentWithSms() {
        const {initMfaEnrollment, submitMfaEnrollment} = useMfaEnrollment();

        const [phoneNumber, setPhoneNumber] = useState<string | null>(null);
        const [mfaCode, setMfaCode] = useState<string | null>(null);
        const [pendingMfaCode, setPendingMfaCode] = useState<boolean>(false);

        // Handler for when the user enters their phone number to enroll in MFA.
        const onEnteredPhoneNumber = () => {
          await initMfaEnrollmen({method: 'sms', phoneNumber: phoneNumber}); // Sends an MFA code to the `phoneNumber`
          setPendingMfaCode(true);
        }

        // Handler for when the user enters the MFA code sent to their phone number.
        const onEnteredMfaCode = () => {
          await submitMfaEnrollment({ method: 'sms', phoneNumber: phoneNumber, code: mfaCode});
          // See the "Handling errors with code submission" section of this guide
          // for details on how to handle errors raised by `submitEnrollmentWithSms`
          setPendingMfaCode(false);
        }

        // If no MFA code has been sent yet, prompt the user for their phone number to enroll
        if (!pendingMfaCode) {
          // Input field for the user to enter the phone number they'd like to enroll for MFA
          return (
            <YStack gap={12}>
              <Input value={mfaCode}
                onChangeText={setPhoneNumber}
                flex={1}
                keyboardType="number-pad"
              />
              <Button onPress={onEnteredPhoneNumber} flex={1}>
                <Text>Enroll a Phone with MFA</Text>
              </Button>
            </YStack>
          )
        }

        // Input field for the user to enter the MFA code sent to their phone number
        return
        <>
          <Input value={mfaCode} onChangeText={setMfaCode}/>
          <Button onPress={onEnteredMfaCode}><Text>Submit Enrollment Code</Text></Button>
        </>;
      }
      ```
    </Accordion>

    <Info>
      If your app has enabled SMS as a possible *login* method, users will **not** be able to enroll SMS as a valid *MFA* method.

      SMS can be either be used as a login method to secure user accounts, or as an MFA method for additional security on the users' wallets, but cannot be used for both.
    </Info>

    #### TOTP

    First, initiate enrollment by calling Privy's  method with a JSON parameter of :

    ```tsx  theme={"system"}
    const {authUrl} = await initMfaEnrollment({method: 'totp'});
    ```

    Then, to have the user enroll, you can display the TOTP  as a QR code to the user, and prompt them to scan it with their TOTP client.

    <Tip>
      You can directly pass in the  from above into a library like  to deep link into a TOTP application for MFA.
    </Tip>

    Once your user has successfully linked into their TOTP application, prompt the user to enter the code in your app, and call Privy's  method:

    ```tsx  theme={"system"}
    const mfaCodeInput = 'insert-mfa-code-from-user-totp-app'; // Prompt the user for the code in their TOTP app
    await submitMfaEnrollment({method: 'totp', mfaCode: mfaCodeInput});
    ```

    <Accordion title="See an end-to-end example of enrolling users in MFA with TOTP">
      The component below serves as a reference implementation for how to enroll your users in MFA with TOTP!

      ```tsx Example enrolling a TOTP client for MFA theme={"system"}
      import {useMfaEnrollment} from '@privy-io/expo';

      export default function MfaEnrollmentWithTotp() {
        const {initMfaEnrollment, submitMfaEnrollment} = useMfaEnrollment();
        const [totpAuthUrl, setTotpAuthUrl] = useState<string | null>(null);
        const [mfaCode, setMfaCode] = useState<string | null>(null);

        // Handler for when the user is ready to enroll in TOTP MFA
        const onGenerateTotpUrl = async () => {
          const {authUrl} = await initMfaEnrollment({method: 'totp'});
          setTotpAuthUrl(authUrl);
        }

        // Handler for when the user enters the MFA code from their TOTP client
        const onMfaEnrollmentSubmit = async () => {
          await submitMfaEnrollment({method: 'totp', code: mfaCode});
          // See the "Handling errors with code submission" section of this guide
          // for details on how to handle errors raised by `submitEnrollmentWithTotp`
        }

        return(
            {/* QR code for the user to scan */}
            <YStack gap={12}>
                    <Text>TOTP MFA Enrollment</Text>
                    {
                      // Check to see if the totpUrl is generated
                      !!totpUrl && <Text onPress={() => Linking.openURL(totpUrl)} >{totpUrl}</Text>
                      <XStack gap={12}>
                        <Input
                          value={totpCode}
                          onChangeText={setTotpCode}
                          flex={1}
                          keyboardType="number-pad"
                        />
                        {// Once the TOTP code is received in the authenticator app and input above, submit for enrollment}
                        <Button onPress={onMfaEnrollmentSubmit} flex={1}>
                          <Text>Verify OTP</Text>
                        </Button>
                      </XStack>
                    }
                  </YStack>
        );
      }
      ```
    </Accordion>

    #### Passkey

    <Tip>
      In order to use passkeys as a MFA method, make sure a valid passkey is linked to the user. You can set this up by following the steps [here](/user-management/users/linking-accounts)!
    </Tip>

    First, initiate enrollment by calling Privy's  method with a JSON parameter of :

    ```tsx  theme={"system"}
    await initMfaEnrollment({method: 'passkey'});
    ```

    Then, to have the user enroll, you must call Privy's `submitMfaEnrollment` method with a list of the user's passkey account `credentialIds`:

    ```tsx  theme={"system"}
    const {user} = usePrivy();

    // ...

    const credentialIds = user.linked_accounts
      .filter((account): account is PasskeyWithMetadata => account.type === 'passkey')
      .map((x) => x.credentialId);

    await submitMfaEnrollment({method: 'passkey', credentialIds});
    ```

    <Accordion title="See an end-to-end example of enrolling users in MFA with passkeys">
      The component below serves as a reference implementation for how to enroll your users in MFA with passkeys!

      ```tsx Example enrolling passkeys for MFA theme={"system"}
      import {useMfaEnrollment, usePrivy} from '@privy-io/expo';

      export default function MfaEnrollmentWithPasskey() {
        const {user} = usePrivy();
        const {iniMfaEnrollment, submitMfaEnrollment} = useMfaEnrollment();

        const handleEnrollmentWithPasskey = async () => {
          await initMfaEnrollment({method: 'passkey'});

          const credentialIds = user.linked_accounts
            .filter((account): account is PasskeyWithMetadata => account.type === 'passkey')
            .map((x) => x.credentialId);

          await submitMfaEnrollment({method: 'passkey', credentialIds});
        };

        return (
          <YStack>
            <Text>Enable your passkeys for MFA</Text>
            {user.linkedAccounts
              .filter((account): account is PasskeyWithMetadata => account.type === 'passkey')
              .map((account) => (
                <Text >ID: {account.id} {' '} Credential ID: {account.credentialId}</div>
              ))}
            {// Initialize and submit the passkey credentials for MFA enrollment in one step }
            <Button onPress={handleEnrollmentWithPasskey}>
              <Text>Enroll</Text>
            </Button>
          </YStack>
        );
      }
      ```
    </Accordion>

    ### Completing MFA with custom UIs in Expo

    To set up a flow to have the user complete MFA, use Privy's  hook:

    ```tsx  theme={"system"}
    const {init, submit, cancel} = useMfa();
    ```

    This flow has three core components:

    1. Requesting an MFA code be sent to the user's MFA method ()
    2. Submitting the MFA code provided by the user ()
    3. Cancelling an in-progress MFA flow ()

    #### Requesting and submitting an MFA challenge

    <Tabs>
      <Tab title="Submitting a user-input code (SMS/TOTP)">
        To request an MFA challenge and then submit the code:

        ```tsx  theme={"system"}
        const selectedMfaMethod = 'sms'; // Must be 'sms', 'totp' or 'passkey'
        await init({method: selectedMfaMethod});

        // After user enters the code
        const mfaCode = 'insert-mfa-code-from-user';
        await submit({method: selectedMfaMethod, mfaCode});
        ```
      </Tab>

      <Tab title="Submitting a passkey">
        For passkey verification:

        ```tsx  theme={"system"}
        const options = await init({method: 'passkey'});

        // Submit will trigger the system's native passkey prompt
        await submit({method: 'passkey', mfaCode: options});
        ```
      </Tab>
    </Tabs>

    When invoked,  returns a `Promise` that resolves to `void` if the user has successfully completed MFA, or rejects with an error if there was an issue completing MFA.

    #### Cancelling the MFA flow

    To cancel the current MFA flow, call the  method from the  hook:

    ```tsx  theme={"system"}
    cancel();
    ```

    <Accordion title="See a recommended abstraction for guiding users to complete MFA">
      To simplify the implementation, we recommend abstracting the logic into a self-contained component. For example:

      ```tsx Example modal for guiding users through the MFA flow theme={"system"}
      import Modal from 'react-native';

      import {
        errorIndicatesMfaVerificationFailed,
        errorIndicatesMfaMaAttempts,
        errorIndicatesMfaTimeout,
        MfaMethod,
      } from '@privy-io/expo';

      type Props = {
        // List of available MFA methods that the user has enrolled in
        mfaMethods: MfaMethod[];
        // Boolean indicator to determine whether or not the modal should be open
        isOpen: boolean;
        // Helper function to open/close the modal */
        setIsOpen: (isOpen: boolean) => void;
      };

      export const MFAModal = ({mfaMethods, isOpen, setIsOpen}: Props) => {
        const {init, submit, cancel} = useMfa();
        const [selectedMethod, setSelectedMethod] = useState<MfaMethod | null>(null);
        const [mfaCode, setMfaCode] = useState('');
        const [options, setOptions] = useState(null);
        const [error, setError] = useState('');

        const onMfaInit = async (method: MfaMethod) => {
          const response = await init({method});
          setError('');
          setSelectedMethod(method);
          if (method === 'passkey') {
            setOptions(response);
          }
        };

        const onMfaSubmit = async () => {
          try {
            if (selectedMethod === 'passkey') {
              await submit({method: selectedMethod, mfaCode: options});
            } else {
              await submit({method: selectedMethod, mfaCode});
            }
            setSelectedMethod(null);
            setIsOpen(false);
          } catch (e) {
            if (errorIndicatesMfaVerificationFailed(e)) {
              setError('Incorrect MFA code, please try again.');
            } else if (errorIndicatesMfaMaxAttempts(e)) {
              setError('Maximum MFA attempts reached, please request a new code.');
              setSelectedMethod(null);
            } else if (errorIndicatesMfaTimeout(e)) {
              setError('MFA code has expired, please request a new code.');
              setSelectedMethod(null);
            }
          }
        };

        const onModalClose = () => {
          cancel();
          setIsOpen(false);
        };

        return (
          <Modal visible={isOpen} animationType="slide" onRequestClose={onModalClose}>
            <View style={{padding: 20}}>
              {mfaMethods.map((method) => (
                <Button
                  key={method}
                  title={`Choose to MFA with ${method}`}
                  onPress={() => onMfaInit(method)}
                />
              ))}

              {selectedMethod && selectedMethod !== 'passkey' && (
                <View>
                  <Text>Enter your MFA code below</Text>
                  <TextInput
                    placeholder="123456"
                    value={mfaCode}
                    onChangeText={setMfaCode}
                    keyboardType="numeric"
                    style={{borderBottomWidth: 1, marginBottom: 10}}
                  />
                  <Button title="Submit Code" onPress={onMfaSubmit} />
                </View>
              )}

              {error.length > 0 && <Text style={{color: 'red'}}>{error}</Text>}
              <Button title="Close" onPress={onModalClose} />
            </View>
          </Modal>
        );
      };
      ```
    </Accordion>

    #### Registering an event listener

    To set up this configuration, use Privy's  hook:

    ```tsx MFAProvider.tsx theme={"system"}
    import {useRegisterMfaListener, MfaMethod} from '@privy-io/expo';

    import {MFAModal} from '../components/MFAModal';

    export const MFAProvider = ({children}: {children: React.ReactNode}) => {
      const [isMfaModalOpen, setIsMfaModelOpen] = useState(false);
      const [mfaMethods, setMfaMethods] = useState<MfaMethod[]>([]);

      useRegisterMfaListener({
        // Privy will invoke this whenever the user is required to complete MFA
        onMfaRequired: (methods) => {
          // Update app's state with the list of available MFA methods for the user
          setMfaMethods(methods);
          // Open MFA modal to allow user to complete MFA
          setIsMfaModalOpen(true);
        },
      });

      return (
        <View>
          {/* This `MFAModal` component includes all logic for completing the MFA flow with Privy's `useMfa` hook */}
          <MFAModal isOpen={isMfaModalOpen} setIsOpen={setIsMfaModalOpen} mfaMethods={mfaMethods} />
          {children}
        </View>
      );
    };
    ```

    <Info>
      In order for Privy to invoke your app's MFA flow, the component that calls Privy's  hook **must be mounted** whenever the user's embedded wallet requires that they complete MFA.

      We recommend that you render this component near the root of your application, so that it is always rendered whenever the embedded wallet may be used.
    </Info>

    ### Managing MFA methods

    Privy also allows users to also delete MFA methods via the method returned from the  hook:

    ```tsx Example unenrolling SMS/TOTP/passkey theme={"system"}
    import {useMfaEnrollment} from '@privy-io/expo';

    export default function MfaUnenrollment() {
      const {unenrollMfa} = useMfaEnrollment();

      return (
        <YStack>
          <Button onClick={() => unenrollMfa({method: 'sms'})}>
            <Text>Unenroll SMS</Text>
          </Button>
          <Button onClick={() => unenrollMfa({method: 'totp'})}>
            <Text>Unenroll TOTP</Text>
          </Button>
          <Button onClick={() => unenrollMfa({method: 'passkey'})}>
            <Text>Unenroll passkey</Text>
          </Button>
        </YStack>
      );
    }
    ```

    <Info>
      By default, unenrolling a passkey will also unlink it as a valid login method. In order to modify this behavior, you can set the `removeForLogin` option to `false` on the `unenrollMfa` call:

      ```tsx  theme={"system"}
      <Button onClick={() => unenrollMfa({method: 'passkey', removeForLogin: false})}>
        <Text>Unenroll passkey, keep as login method</Text>
      </Button>
      ```
    </Info>
  </Tab>
</Tabs>


# Using default Privy UIs
Source: https://docs.privy.io/authentication/user-authentication/mfa/default-ui



<Tip>
  Enable MFA methods in the [Privy
  Dashboard](https://dashboard.privy.io/apps?page=login-methods\&logins=mfa) before implementing this
  feature.
</Tip>

<Tabs>
  <Tab title="React">
    ### Enrolling users in MFA

    Once you have enabled MFA for your app, **to prompt your users to enroll in MFA for their embedded wallet, use the `showMfaEnrollmentModal` method from the `useMfaEnrollment` hook.**

    ```tsx Example button for enrolling in wallet MFA theme={"system"}
    import {useMfaEnrollment} from '@privy-io/react-auth';

    function MfaEnrollmentButton() {
      const {showMfaEnrollmentModal} = useMfaEnrollment();
      return <button onClick={showMfaEnrollmentModal}>Enroll in MFA</button>;
    }
    ```

    When invoked,  will open a Privy modal that prompts the user to select their desired MFA method from the ones you've enabled for your app, and will guide them through the enrollment process.

        <img src="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/MFA.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=2ad6a50823b29bacbabd08067f025e0b" alt="images/MFA.png" data-og-width="1843" width="1843" data-og-height="1317" height="1317" data-path="images/MFA.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/MFA.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=9a8d1f6020125a076482d74e95d8ea2b 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/MFA.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=5a7c136cc852f732d138ee205001bc6e 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/MFA.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=48b0c6df688ff0e5ec3ab71bb797d659 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/MFA.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=14ba64d7a86446fdd19d9869eb901c33 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/MFA.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=16ab2c892a1d9cee061253917c9cb4e5 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/MFA.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=13d8d546414fbf6ae64d23d14f50ed34 2500w" />

    Once a user has successfully enrolled an MFA method, the user's enrolled method will appear under the  field of their  object:

    ```tsx  theme={"system"}
    const {user} = usePrivy();
    console.log(user.mfaMethods);
    // ['sms', 'totp', 'passkey'] for a user who has enrolled in all of SMS, TOTP, and passkey MFA
    ```

    ### Managing MFA methods

    To allow your users to modify their MFA methods, **simply invoke the `showMfaEnrollmentModal` method from the `useMfaEnrollment` hook.**  This is the *same* method you would use to prompt your user to enroll in MFA for the first time.

    Within this modal, users can **remove existing MFA methods or enroll in additional ones** for their embedded wallet. Prior to making changes to their MFA methods, users will be prompted to re-verify their identity using one of their existing MFA methods.

    <Info>
      By default, removing a passkey as MFA will also unlink it as a valid login method. In order to modify this behavior, you can set the `shouldUnlinkOnUnenrollMfa` option to `false` under the `passkeys` config in `PrivyProvider`.

      ```tsx  theme={"system"}
      <PrivyProvider
        appId="your-privy-app-id"
        config={{
          ...theRestOfYourConfig,
          passkeys: {
            // Set this to `false` if you wish to keep the passkey as a login method after unenrolling from MFA.
            shouldUnlinkOnUnenrollMfa: false,
          },
        }}
      >
        {/* your app's content */}
      </PrivyProvider>
      ```
    </Info>

    ### Authorizing signatures and transactions

    Once a user has enrolled in MFA, **every attempt to use the wallet's private key (every signature or transaction) will require the user to complete MFA using their method.** This logic is automatic; you do not need to do anything else once your user has enrolled in wallet MFA.

    When your app requests a signature or a transaction from the embedded wallet, **Privy will show the user a modal prompting them to enter a 6-digit MFA code sent to their MFA method.** If the user has enrolled in multiple MFA methods, they can choose which method they'd like to use for this given request.

    <img src="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/mfa-usage.png?fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=180dd7aec11922e9e59692313f20ebca" alt="Authorizing signatures and transactions with wallet MFA" data-og-width="1843" width="1843" data-og-height="1317" height="1317" data-path="images/mfa-usage.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/mfa-usage.png?w=280&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=777201bcf9f1d4e321a1af905a872ed5 280w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/mfa-usage.png?w=560&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=da5c112b68602563ba33af185ee8dcb7 560w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/mfa-usage.png?w=840&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=c9e59f6603b07be66dc40faecab850ea 840w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/mfa-usage.png?w=1100&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=bb29ff8d0b1d1a4dd19ad5a259a528bb 1100w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/mfa-usage.png?w=1650&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=59f3b5d98592061be80c6c21f48107e5 1650w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/mfa-usage.png?w=2500&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=7e0a6099288f9f63a1255cf9e0b5b073 2500w" />

    Users must enter their MFA code within 5 minutes of receiving it, and are allowed up to a maximum of 4 code attempts if they incorrectly enter their code.

    **If the user correctly enters their MFA code, the signature or transaction request will be processed by the wallet.** Additionally, their MFA verification status will be cached for **15 minutes**. This means that for additional signatures or transactions requested within this window, Privy will **not** prompt the user to re-complete MFA.

    **If the user does not complete MFA or enters in an incorrect code 4 times or more, the signature or transaction will raise an error as if the user rejected the request.**

    ### Manually prompting for MFA verification

    If you want to manually prompt your users for MFA verification, you can use the `useMfa` hook. The `useMfa` hook provides a set of functions and state for managing MFA flows in your application. It allows you to:

    * Prompt the user to complete MFA verification if required.
    * Initialize and submit MFA challenges (e.g., sending and verifying codes).
    * Cancel and ongoing MFA flow.
    * Access the list of available MFA methods for your app.

    Here's an example of how to use the `useMfa` hook to prompt for MFA verification:

    ```tsx Example button for prompting MFA verification theme={"system"}
    import {useMfa} from '@privy-io/react-auth';

    function MfaVerificationButton() {
      const {promptMfa, init} = useMfa();

      const handleMfaVerification = async () => {
        try {
          await init('totp')
          await promptMfa();
          // Your code on successful MFA verification
        } catch (error) {
          // Your code on cancelled or otherwise unsuccessful MFA verification
        }
      };

      return <button onClick={handleMfaVerification}>Verify MFA</button>;
    }
    ```

    In this example, when the user clicks the "Verify MFA" button, the `promptMfa` function is called. If the user has enrolled in MFA, they will be prompted to complete the verification process. If successful, you can execute your desired actions after the verification.
  </Tab>

  <Tab title="React Native">
    ### Setting up MFA UIs in React Native

    Once you've set up `PrivyElements`, you can use Privy's default UIs to enroll your users in MFA and prompt them for MFA during wallet actions.

    <Info>
      Before integrating MFA UIs, make sure to also set up multi-factor authentication in the dashboard per [this guide](/authentication/user-authentication/mfa).
    </Info>

    ### MFA enrollment

    Privy's default UIs for React Native can also be used for allowing your users to enroll their first MFA verification method, or any number of additional ones.

    For this, use the `useMfaEnrollmentUI` hook to get an `init` method, that you can use to launch the flow. This method takes in a configuration object with the following fields:

    <ParamField path="mfaMethods" type="MfaMethod[]">
      This will be the array of mfa methods that will be available in the UI. Make sure to have the methods you set here enabled.
    </ParamField>

    <ParamField path="relyingParty" type="string">
      It should be the URL origin where your [Apple App Site Association](/authentication/user-authentication/login-methods/passkey) or [Digital Asset Links](/authentication/user-authentication/login-methods/passkey) are available (e.g. `https://example.com`).
    </ParamField>

    ```tsx  theme={"system"}
    import {useMfaEnrollmentUI} from '@privy-io/expo/ui';

    export function EnrollMFAMethodButton() {
      const {init: initMfaEnrollmentUI} = useMfaEnrollmentUI();

      const onEnrollMfa = async () => {
        try {
          await initMfaEnrollmentUI({mfaMethods: ['sms', 'totp', 'passkey']});
          // Your code on actions to execute after successful mfa enrollment
        } catch (error) {
          // Your code on cancelled or otherwise unsuccessful mfa enrollment
        }
      };

      return <Button onPress={onEnrollMfa}>Enroll an MFA method</Button>;
    }
    ```

    <Tip>
      The UIs that will show up using `useMfaEnrollmentUI` will also **allow the user to unenroll** MFA methods.
    </Tip>

    ### Passkey unenrollment

    Using the MFA enrollment UIs means users will also be able to **unenroll** a method they had previously set up too.

    For passkeys, the default behavior when unenrolling is that the passkey is also **removed** as a valid login method.

    You can change this behavior in the MFA UIs, by setting the `shouldUnlinkOnUnenrollMfa` option in the `PrivyElements` component:

    ```tsx  theme={"system"}
    import {PrivyElements} from '@privy-io/expo/ui';

    export default function RootLayout() {
      return (
        <>
          {/* Your app's content */}
          <PrivyElements config={{passkeys: {shouldUnlinkOnUnenrollMfa: false}}} />
        </>
      );
    }
    ```

    ### MFA verification

    Privy's default UIs for React Native can be used for your users to verify their already set MFA methods, such as SMS or passkeys.

    <Tip>
      You can use Privy's default UIs for MFA verification even if you're using headless flows for working with the wallet. This way, Privy's UIs can integrate smoothly with your custom flows and experiences.
    </Tip>

    To do this, you must enable the `enableMfaVerificationUIs` option on the `PrivyElements` component:

    ```tsx  theme={"system"}
    import {PrivyElements} from '@privy-io/expo/ui';

    export default function RootLayout() {
      return (
        <>
          {/* Your app's content */}
          <PrivyElements config={{mfa: {enableMfaVerificationUIs: true}}} />
        </>
      );
    }
    ```

    After doing this, all operations you do on the wallet (such as signing messages or preparing transactions) will automatically trigger the MFA UIs if MFA verification is required at that moment.

    <Warning>
      If you were using the `useRegisterMfaListener` hook before you should now remove it from your codebase, as Privy will handle the MFA events and UI for you.
    </Warning>

    ### Manually prompting for MFA verification

    If you want to manually prompt your users for MFA verification, you can use the `useMfa` hook. The `useMfa` hook provides a set of functions and state for managing Multi-Factor Authentication (MFA) flows in your application. It allows you to:

    * Prompt the user to complete MFA verification if required.
    * Initialize and submit MFA challenges (e.g., sending and verifying codes).
    * Cancel and ongoing MFA flow.
    * Access the list of available MFA methods for your app.

    Here's an example of how to use the `useMfa` hook to prompt for MFA verification:

    ```tsx Example button for prompting MFA verification theme={"system"}
    import {useMfa} from '@privy-io/expo';
    import {Button} from 'react-native';

    export function MfaVerificationButton() {
      const {prompt, init} = useMfa();

      const handleMfaVerification = async () => {
        try {
          await init({ mfaMethods: ['sms', 'totp', 'passkey']});
          await prompt();
          // Your code on successful MFA verification
        } catch (error) {
          // Your code on cancelled or otherwise unsuccessful MFA verification
        }
      };

      return <Button onPress={handleMfaVerification} title="Verify MFA" />;
    }
    ```
  </Tab>
</Tabs>


# Overview
Source: https://docs.privy.io/authentication/user-authentication/mfa/overview



**Privy enables users to set up multi-factor authentication (MFA) for embedded wallets on both EVM networks and Solana.** MFA helps secure the embedded wallet by requiring additional verification of a user's identity when the wallet is used.

<img src="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/MFA.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=2ad6a50823b29bacbabd08067f025e0b" alt="images/MFA.png" data-og-width="1843" width="1843" data-og-height="1317" height="1317" data-path="images/MFA.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/MFA.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=9a8d1f6020125a076482d74e95d8ea2b 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/MFA.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=5a7c136cc852f732d138ee205001bc6e 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/MFA.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=48b0c6df688ff0e5ec3ab71bb797d659 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/MFA.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=14ba64d7a86446fdd19d9869eb901c33 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/MFA.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=16ab2c892a1d9cee061253917c9cb4e5 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/MFA.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=13d8d546414fbf6ae64d23d14f50ed34 2500w" />

Once a user enrolls in wallet MFA, **any action that requires use of the embedded wallet's private key will require the user to complete MFA verification.** This includes signing messages, sending transactions, exporting the embedded wallet, and recovering the embedded wallet for use on new devices.

**Privy currently supports three methods of wallet MFA:**

* **SMS**, where users verify with a 6-digit MFA code sent to their phone number
* **Time-based one-time password (TOTP)**, where users verify with a 6-digit MFA code from an authentication app, like Authy or Google Authenticator
* **Passkeys**, where users verify with a previously registered passkey, generally through biometric authentication on their device

<Danger>
  Once a user enrolls in MFA, it will remain enabled **even if you disable MFA for your app**. Users
  must manually disable MFA on their wallets if they wish to remove it.
</Danger>

<Tip>
  If a user has multiple embedded wallets (e.g. on EVM and Solana, or multiple HD addresses),
  enrolling in MFA will require MFA for signatures and transactions from **any** of their embedded
  wallets.
</Tip>


# Setting up wallet MFA for your app
Source: https://docs.privy.io/authentication/user-authentication/mfa/setup



<Danger>
  Once a user enrolls in MFA, it will remain enabled **even if you disable MFA for your app**. Users
  must manually disable MFA on their wallets if they wish to remove it.
</Danger>

To enable MFA for your app, select your desired app from the sidebar and navigate to the **User management > Authentication > MFA** page.

Within the **MFA** tab, scroll down to the **Enable MFA for transactions** section and **select the desired MFA methods** you'd like to enable for your app.

<img src="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/MFA2.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=45f480bd8d2b74a238b6b7213fb71214" alt="images/MFA2.png" data-og-width="1843" width="1843" data-og-height="1317" height="1317" data-path="images/MFA2.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/MFA2.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=cceb295a4e8b3c06e950eb9a4fc5e0c5 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/MFA2.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=d7bfd57e9bed00df1b8faebb204654a8 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/MFA2.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=f5b087e4425a13ed3d3762cd288a6bab 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/MFA2.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=0a86010bfab22822e4f9c36b59059e11 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/MFA2.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=1cbf3aee20131fb7c0a6b15be47694c4 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/MFA2.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=fb394ec802f7cd2d6b32b50cda008652 2500w" />

Once you have selected your desired MFA methods and saved changes, you can prompt your users to enroll in any of the methods you've enabled!

Please note that:

* If your app has SMS enabled as a login method, you **may not** enable SMS as an MFA method as well.
  With SMS login enabled, SMS can already be used as the primary factor to authenticate the user for access to their wallet; it cannot be enabled as an additional factor as well.
* To use passkeys as an MFA method, you *must* also enable passkeys as a login method

## Implementation Options

Privy offers two main approaches to implement wallet MFA in your application:

1. **Using Privy's default UIs** - The simplest approach where Privy handles the UI components
2. **Building custom UIs (headless)** - More involved but gives you complete control over the user experience


# Using Privy as your authentication provider
Source: https://docs.privy.io/authentication/user-authentication/privy-auth



Privy offers a variety of authentication methods, including:

* **[Email](/authentication/user-authentication/login-methods/email) or [SMS](/authentication/user-authentication/login-methods/sms)**: Passwordless login via a one-time passcode sent to a user's email address or phone number.
* **[Passkey](/authentication/user-authentication/login-methods/passkey)**: Biometric or passkey-based login based on the WebAuthn standard.
* **[OAuth and socials](/authentication/user-authentication/login-methods/oauth)**: Social login with Google, Apple, Twitter, Discord, GitHub, LinkedIn, Spotify, Telegram, Farcaster, and more.
* **[Wallets](/authentication/user-authentication/login-methods/wallet)**: External wallet login via Sign-In With Ethereum and Sign-In With Solana.

Your app can configure each of the account types above to be an upfront login method, or as an account that users link to their profile after login.

Privy also supports [MFA](/authentication/user-authentication/mfa/overview) for taking actions on wallets, enhancing the security of your users' accounts for higher-value transactions.

All of Privy's authentication methods create a common [user object](/user-management/users/the-user-object), where you can easily find a user's unique ID and all of the accounts they've linked to their profile. A user is a user, regardless of whether they've connected with a wallet, email or Discord account.

Once a user of your application successfully authenticates with Privy, Privy issues an [access token](/authentication/user-authentication/access-tokens) for the user that you app can additionally use to represent an authenticated session or to make authenticated requests to your backend.


# UI components
Source: https://docs.privy.io/authentication/user-authentication/ui-component



Privy supports easy onboarding with an out-of-the-box user interface to log users in.

The fastest way to integrate Privy is with the Privy login modal. Your application can integrate this modal in just a few lines of code and easily toggle on login methods for your application in the Privy dashboard.

You can also design your own login UIs, and integrate with Privy's authentication APIs to offer a login experience that feels seamless within your application.

<img src="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Onboard.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=73a585da38b0eae634f6446982028b74" alt="images/Onboard.png" data-og-width="1843" width="1843" data-og-height="1317" height="1317" data-path="images/Onboard.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Onboard.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=a0181bc0854c3c81409ca325f82ae997 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Onboard.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=d21a8d48921fbd16ee8bab7ab5fbc905 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Onboard.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=8162f91ae65032eb2584b4127ac9afb4 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Onboard.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=952ae4c1d5ecb7dec7f6b88a35c9c4af 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Onboard.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=66c54a8e3f6aadd2241f0ed5a0f3d7b8 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Onboard.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=559b2d8255c227df7ad73f02e5ed4e35 2500w" />

<Info>
  [Configure your login methods](/basics/get-started/dashboard/configure-login-methods) in the Privy
  Dashboard before using the UI components.
</Info>

<Tabs>
  <Tab title="React">
    <Tip>
      Privy's UIs are highly-customizable to seamlessly match the branding and design system of your
      app. Learn more about [customizing the login modal](/basics/react/advanced/configuring-appearance).
    </Tip>

    To have users login to your app with Privy's UIs, use the `login` method from the `useLogin` hook.

    ```tsx  theme={"system"}
    login: ({ loginMethods: PrivyClientConfig['loginMethods'], prefill?: { type: 'email' | 'phone', value: string }, disableSignup?: boolean, walletChainType?: 'ethereum-only' | 'solana-only' | 'ethereum-or-solana' }) => PrivyUser;
    ```

    ### Usage

    ```tsx  theme={"system"}
    import { useLogin, usePrivy } from '@privy-io/react-auth';

    function LoginButton() {
        const { ready, authenticated} = usePrivy();
        const { login } = useLogin();
        // Disable login when Privy is not ready or the user is already authenticated
        const disableLogin = !ready || (ready && authenticated);

        return (
            <button disabled={disableLogin} onClick={login}>
                Log in
            </button>
        );
    }
    ```

    ### Parameters

    <ParamField path="loginMethods" type="PrivyClientConfig['loginMethods']">
      Optionally specify which login methods to display in the modal.

      <Expandable title="Login Methods">
        The following login methods are supported:

        <ul>
          <ParamField path="wallet" type="string" />

          <ParamField path="email" type="string" />

          <ParamField path="sms" type="string" />

          <ParamField path="google" type="string" />

          <ParamField path="twitter" type="string" />

          <ParamField path="discord" type="string" />

          <ParamField path="github" type="string" />

          <ParamField path="linkedin" type="string" />

          <ParamField path="spotify" type="string" />

          <ParamField path="instagram" type="string" />

          <ParamField path="tiktok" type="string" />

          <ParamField path="apple" type="string" />

          <ParamField path="farcaster" type="string" />

          <ParamField path="telegram" type="string" />

          <ParamField path="line" type="string" />

          <ParamField path="passkey" type="string" />
        </ul>
      </Expandable>
    </ParamField>

    <ParamField path="prefill" type="{ type: 'email' | 'phone', value: string }">
      Optionally pre-fill the login modal with the user's email or phone number.
    </ParamField>

    <ParamField path="disableSignup" type="boolean">
      Prevent users from signing up for your app. This is useful when you want to enforce that users can only log in with existing accounts.
    </ParamField>

    <ParamField path="walletChainType" type="'ethereum-only' | 'solana-only' | 'ethereum-or-solana'">
      Filter the login wallet options to only show wallets that support the specified chain type.
    </ParamField>

    ### Callbacks

    You can easily attach callbacks to the `login` method using the `useLogin` hook. This allows you to run custom logic when a user successfully logs in or when there's an error.

    ```tsx  theme={"system"}
    import { useLogin } from '@privy-io/react-auth';

    function LoginButton() {
        const { login } = useLogin({
            onComplete: ({ user, isNewUser, wasAlreadyAuthenticated, loginMethod, loginAccount }) => {
                console.log('User logged in successfully', user);
                console.log('Is new user:', isNewUser);
                console.log('Was already authenticated:', wasAlreadyAuthenticated);
                console.log('Login method:', loginMethod);
                console.log('Login account:', loginAccount);
                // Navigate to dashboard, show welcome message, etc.
            },
            onError: (error) => {
                console.error('Login failed', error);
                // Show error message
            }
        });

        return <button onClick={login}>Log in</button>;
    }
    ```

    <ParamField path="onComplete" type="({ user, isNewUser, wasAlreadyAuthenticated, loginMethod, linkedAccount }) => void">
      Callback that executes when a user completes authentication. If the user is already authenticated when the component mounts, this callback executes immediately. Otherwise, it executes after successful login.

      <Expandable title="Callback Parameters">
        <ParamField path="user" type="PrivyUser">The user object with DID, linked accounts, and more.</ParamField>
        <ParamField path="isNewUser" type="boolean">Whether this is the user's first login or a returning user.</ParamField>
        <ParamField path="wasAlreadyAuthenticated" type="boolean">Whether the user was already authenticated when the component mounted.</ParamField>
        <ParamField path="loginMethod" type="string | null">The authentication method used ('email', 'sms', 'siwe', 'apple', 'discord', 'github', 'google', 'linkedin', 'spotify', 'tiktok', 'twitter', 'farcaster', 'passkey', 'telegram', 'line') or null if already authenticated.</ParamField>
        <ParamField path="loginAccount" type="object">The account used for authentication with type ('wallet', 'email', 'phone', 'google\_oauth', 'twitter\_oauth', 'discord\_oauth', 'github\_oauth', 'spotify\_oauth', 'instagram\_oauth', 'tiktok\_oauth', 'linkedin\_oauth', 'apple\_oauth', 'line\_oauth', 'custom\_auth', 'farcaster', 'passkey').</ParamField>
      </Expandable>
    </ParamField>

    <ParamField path="onError" type="(error) => void">
      Callback that executes when there's an error during login or when the user exits the login flow.
    </ParamField>
  </Tab>

  <Tab title="React Native">
    <Tip>
      Make sure you have [properly configured PrivyElements](/basics/react-native/advanced/setup-privyelements) before using UI components for authentication.
    </Tip>

    <Info>
      Privy's UIs are highly-customizable to seamlessly match the branding and design system of your app. Learn more about [customizing the login modal](/basics/react-native/advanced/configuring-appearance).
    </Info>

    To have users login to your app with Privy's UIs, use the `login` method from the `useLogin` hook.

    ```javascript  theme={"system"}
    login: ({ loginMethods: LoginMethod[], appearance?: { logo?: string } }) => void;
    ```

    ### Usage

    ```tsx  theme={"system"}
    import { useLogin } from '@privy-io/expo/ui';

    function LoginButton() {
        const { login } = useLogin();

        return (
            <Button
                onPress={() => {
                    login({ loginMethods: ['email', 'sms']})
                        .then((session) => {
                            console.log('User logged in', session.user);
                        })
                }}
                title="Log in"
            />
        );
    }
    ```

    ### Parameters

    <ParamField path="loginMethods" type="LoginMethod[]">
      An array of login methods for your users to choose from. The supported methods are `'email'`, `'sms'`, `'discord'`, `'twitter'`, `'github'`, `'spotify'`, `'instagram'`, `'tiktok'`, `'linkedin'`, and `'apple'`.
    </ParamField>

    <ParamField path="appearance.logo" type="string">
      (Optional) a url for the logo shown in the Login Method selection step. Aspect ratio should be 2:1.
    </ParamField>

    ### Returns

    <ResponseField name="user" type="PrivyUser">
      The user that logged in, with all of their properties.
    </ResponseField>
  </Tab>
</Tabs>


# Whitelabel
Source: https://docs.privy.io/authentication/user-authentication/whitelabel



All of Privy's frontend SDKs let you fully customize authentication to match your app’s brand and user experience. You can implement every authentication flow—including email, SMS, social logins, passkeys, Telegram, and multi-factor authentication (MFA)—with your own UI, while Privy manages security and backend logic.

<Tabs>
  <Tab title="React">
    All of Privy's authentication flows can be whitelabeled, from email and SMS passwordless flows to social logins and passkeys.

    <Accordion title="Email" defaultOpen>
      To whitelabel Privy's passwordless email flow, use the `useLoginWithEmail` hook. Then, call `sendCode` and `loginWithCode` with the desired email address.

      ```tsx  theme={"system"}
      import {useLoginWithEmail} from '@privy-io/react-auth';
      ```

      ```tsx  theme={"system"}
      const {sendCode, loginWithCode} = useLoginWithEmail();
      sendCode({email: 'test@test.com'});
      loginWithCode({code: '123456'});
      ```

      Learn more about [email authentication and tracking login flow state](/authentication/user-authentication/login-methods/email).
    </Accordion>

    <Accordion title="SMS">
      To whitelabel the passwordless SMS flow, use the `useLoginWithSms` hook. Then, call `sendCode` and `loginWithCode` with the desired phone number.

      ```tsx  theme={"system"}
      import {useLoginWithSms} from '@privy-io/react-auth';
      ```

      ```tsx  theme={"system"}
      const {sendCode, loginWithCode} = useLoginWithSms();
      sendCode({phoneNumber: '+1234567890'});
      loginWithCode({code: '123456'});
      ```

      Learn more about [SMS authentication and tracking login flow state](/authentication/user-authentication/login-methods/sms).
    </Accordion>

    <Accordion title="Social logins">
      To whitelabel social login, use the `useLoginWithSocial` hook and call `initOAuth` with your desired social login provider.

      ```tsx  theme={"system"}
      import {useLoginWithSocial} from '@privy-io/react-auth';
      ```

      ```tsx  theme={"system"}
      const {initOAuth} = useLoginWithSocial();
      initOAuth({provider: 'google'});
      ```

      Learn more about [social logins and tracking login flow state](/authentication/user-authentication/login-methods/oauth).
    </Accordion>

    <Accordion title="Passkeys">
      To whitelabel passkeys, use the `useLoginWithPasskey` hook and call `loginWithPasskey`.

      ```tsx  theme={"system"}
      import {useLoginWithPasskey} from '@privy-io/react-auth';
      ```

      ```tsx  theme={"system"}
      const {loginWithPasskey} = useLoginWithPasskey();
      loginWithPasskey();
      ```

      To sign up with a passkey:

      ```tsx  theme={"system"}
      import {useSignupWithPasskey} from '@privy-io/react-auth';
      ```

      ```tsx  theme={"system"}
      const {signupWithPasskey} = useSignupWithPasskey();
      signupWithPasskey();
      ```

      To link a passkey to an existing user:

      ```tsx  theme={"system"}
      import {useLinkWithPasskey} from '@privy-io/react-auth';
      ```

      ```tsx  theme={"system"}
      const {linkWithPasskey} = useLinkWithPasskey();
      linkWithPasskey();
      ```

      Learn more about [passkeys and tracking login flow state](/authentication/user-authentication/login-methods/passkey).
    </Accordion>

    <Accordion title="Telegram">
      To whitelabel the Telegram login flow, it's as simple as using the `useLoginWithTelegram` hook and calling `login`.

      ```tsx  theme={"system"}
      import {useLoginWithTelegram} from '@privy-io/react-auth';
      ```

      ```tsx  theme={"system"}
      const {login, state} = useLoginWithTelegram();
      login();
      ```

      Learn more about [Telegram authentication and tracking login flow state](/authentication/user-authentication/login-methods/telegram).
    </Accordion>

    <Accordion title="MFA">
      To whitelabel MFA with SMS, TOTP, or passkeys, follow the [custom UI guide](/authentication/user-authentication/mfa/custom-ui).
    </Accordion>
  </Tab>

  <Tab title="React Native">
    Privy’s React Native SDK is whitelabel by default, enabling apps to implement custom authentication UI and flows using the SDK’s functions. Get started with email login [here](/authentication/user-authentication/login-methods/email#react-native).
  </Tab>

  <Tab title="Swift">
    Privy’s Swift SDK is whitelabel by default, enabling apps to implement custom authentication UI and flows using the SDK’s functions. Get started with email login [here](/authentication/user-authentication/login-methods/email#swift).
  </Tab>

  <Tab title="Android">
    Privy’s Android SDK is whitelabel by default, enabling apps to implement custom authentication UI and flows using the SDK’s functions. Get started with email login [here](/authentication/user-authentication/login-methods/email#android).
  </Tab>

  <Tab title="Unity">
    Privy’s Unity SDK is whitelabel by default, enabling apps to implement custom authentication UI and flows using the SDK’s functions. Get started with email login [here](/authentication/user-authentication/login-methods/email#unity).
  </Tab>

  <Tab title="Flutter">
    Privy’s Flutter SDK is whitelabel by default, enabling apps to implement custom authentication UI and flows using the SDK’s functions. Get started with email login [here](/authentication/user-authentication/login-methods/email#flutter).
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/basics/android/advanced/setup-passkeys



## Setup passkeys for Android

To enable passkey support for your Android app, associate your app with a website that your app owns.

### 1. Get your SHA256 fingerprint

For detailed instructions on obtaining your certificate fingerprints, see [Android's official passkey documentation](https://developer.android.com/identity/passkeys/create-passkeys#verify).

Run the following command to get your app's certificate fingerprints:

```sh  theme={"system"}
keytool -list -v -keystore <path-to-your-keystore> | grep SHA256
```

The output should look like this:

```txt  theme={"system"}
Certificate fingerprints:
         SHA1: A1:B2:C3:D4:E5:F6:07:08:09:0A:1B:2C:3D:4E:5F:60:71:82:93:A4
         SHA256: 1A:2B:3C:4D:5E:6F:70:81:92:A3:B4:C5:D6:E7:F8:09:1A:2B:3C:4D:5E:6F:70:81:92:A3:B4:C5:D6:E7:F8:09
```

<Info>**Note:** You'll need the **SHA256** fingerprint (not SHA1) for the next steps.</Info>

### 2. Digital Asset Links

* Create a `JSON` file with *at least* the following content

```json  theme={"system"}
[
  {
    "relation": ["delegate_permission/common.handle_all_urls"],
    "target": {
      "namespace": "android_app",
      "package_name": "<package_name>",
      "sha256_cert_fingerprints": ["<sha256_cert_fingerprint>"]
    }
  }
]
```

* Make the file accessible on your website at the following path

```txt  theme={"system"}
https://<your_domain>/.well-known/assetlinks.json
```

**Make sure to use your `package_name` and `sha256_cert_fingerprint` (from step 1) in the file hosted on your website.**

For more information about generally supporting Digital Asset Links [see Google's documentation](https://developer.android.com/training/sign-in/passkeys#add-support-dal).

### 3. Dashboard

You will also need to add your `sha256_cert_fingerprint` to the allowed Android key hashes list in the `Settings` tab of the Privy dashboard.

### 4. Optional Biometric Permission

If you would like to optionally associate passkeys with biometric data, add this permission to your `AndroidManifest.xml`:

```xml  theme={"system"}
<uses-permission android:name="android.permission.USE_BIOMETRIC" />
```


# Features
Source: https://docs.privy.io/basics/android/features

Learn about the features supported by the Android SDK

export const FeatureMatrix = ({sdk}) => {
  const sdks = sdk ? [sdk] : ['react', 'reactNative', 'swift', 'android', 'flutter', 'unity'];
  const sdkNames = {
    react: 'React',
    reactNative: 'React Native',
    swift: 'Swift',
    android: 'Android',
    flutter: 'Flutter',
    unity: 'Unity'
  };
  const matrix = [{
    name: 'Authentication',
    features: [{
      name: 'Email',
      react: true,
      reactNative: true,
      swift: true,
      android: true,
      flutter: true,
      unity: true
    }, {
      name: 'SMS',
      react: true,
      reactNative: true,
      swift: true,
      android: true,
      flutter: true
    }, {
      name: 'OAuth',
      react: true,
      reactNative: true,
      swift: 'Google, Apple, Twitter, Discord',
      android: 'Google, Discord, Twitter',
      flutter: 'Google, Apple, Twitter, Discord',
      unity: 'Google, Apple, Twitter, Discord'
    }, {
      name: 'SIWE (Sign In with Ethereum)',
      react: true,
      reactNative: true,
      swift: true
    }, {
      name: 'SIWS (Sign In with Solana)',
      react: true,
      reactNative: true
    }, {
      name: 'Farcaster',
      react: true,
      reactNative: true
    }, {
      name: 'Telegram',
      react: true
    }, {
      name: 'Custom Auth',
      react: true,
      reactNative: true,
      swift: true,
      android: true,
      flutter: true
    }, {
      name: 'Passkeys',
      react: true,
      reactNative: true
    }]
  }, {
    name: 'Farcaster',
    features: [{
      name: 'SIWF',
      react: true,
      reactNative: true
    }]
  }, {
    name: 'Embedded Wallets',
    features: [{
      name: 'Creating wallets manually',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum', 'solana'],
      android: ['ethereum', 'solana'],
      flutter: ['ethereum', 'solana'],
      unity: ['ethereum', 'solana']
    }, {
      name: 'Creating wallets automatically',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Pregenerating wallets',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum', 'solana'],
      android: ['ethereum', 'solana'],
      flutter: ['ethereum', 'solana']
    }, {
      name: 'Signing messages and transactions',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum', 'solana'],
      android: ['ethereum', 'solana'],
      flutter: ['ethereum', 'solana'],
      unity: ['ethereum', 'solana']
    }, {
      name: 'Broadcasting transactions',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum'],
      android: ['ethereum'],
      flutter: ['ethereum'],
      unity: ['ethereum']
    }, {
      name: 'Native smart wallets',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: 'Automatic recovery',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum', 'solana'],
      android: ['ethereum', 'solana'],
      flutter: ['ethereum', 'solana'],
      unity: ['ethereum']
    }, {
      name: 'User controlled recovery',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Transaction MFA',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Key Export',
      react: ['ethereum', 'solana']
    }, {
      name: 'Key Import',
      react: ['ethereum', 'solana']
    }, {
      name: 'HD wallets',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum'],
      android: ['ethereum'],
      flutter: ['ethereum'],
      unity: ['ethereum']
    }, {
      name: 'Session signers',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Global wallets (Cross App Accounts)',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: 'Custom EVM (Ethereum) network support',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: 'Custom SVM (Solana) network support',
      react: ['solana'],
      reactNative: ['solana']
    }]
  }, {
    name: 'Connectors',
    features: [{
      name: 'External wallets',
      react: ['ethereum', 'solana']
    }, {
      name: 'Wagmi',
      react: ['ethereum']
    }, {
      name: 'Viem',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: 'Ethers',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: '@solana/web3.js',
      react: ['solana']
    }, {
      name: 'web3swift',
      swift: ['ethereum']
    }]
  }, {
    name: 'Funding',
    features: [{
      name: 'Transfer or bridge from wallet',
      react: ['ethereum', 'solana']
    }, {
      name: 'Transfer from exchange',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Pay with card',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }]
  }];
  const filteredMatrix = matrix.map(section => {
    return {
      ...section,
      features: section.features.filter(featureItem => {
        if (sdk) {
          return featureItem[sdk] !== undefined;
        }
        return true;
      })
    };
  }).filter(section => {
    return section.features.length > 0;
  });
  return <table style={{
    display: 'table',
    width: '100%'
  }}>
      {sdk ? null : <thead>
          <tr>
            <th></th>
            {sdks.map(sdk => <th>{sdkNames[sdk]}</th>)}
          </tr>
        </thead>}
      <tbody>
        {filteredMatrix.map(section => <>
            <tr>
              <td>
                <strong>{section.name}</strong>
              </td>
              {sdks.map(() => <td></td>)}
            </tr>
            {section.features.map(feature => <tr>
                <td>
                  <em>{feature.name}</em>
                </td>
                {sdks.map(sdk => {
    const supported = feature[sdk];
    if (supported === true) {
      return <td>✅</td>;
    } else if (!supported) {
      return <td></td>;
    } else if (Array.isArray(supported)) {
      return <td>
                        {supported.map(item => item === 'ethereum' ? <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/ethereum.png" noZoom style={{
        display: 'inline',
        margin: '2px',
        width: '18px'
      }} /> : <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/solana.png" noZoom style={{
        display: 'inline',
        margin: '2px',
        width: '18px'
      }} />)}
                      </td>;
    } else {
      return <td>{supported}</td>;
    }
  })}
              </tr>)}
          </>)}
      </tbody>
    </table>;
};

## Supported features

<FeatureMatrix sdk="android" />


# null
Source: https://docs.privy.io/basics/android/installation



## Requirements

* Android API 28+ (Android 9.0 Pie or newer)
* Kotlin 2.1.0+

## Installation

The Privy Android SDK is available on Maven Central.

1. Include the `mavenCentral()` repository in your gradle files:

```kotlin  theme={"system"}
repositories {
    google()
    mavenCentral()
}
```

2. Add the latest Privy SDK dependency to your app's `build.gradle` file:

```kotlin  theme={"system"}
dependencies {
  // Privy Core
  implementation("io.privy:privy-core:X.Y.Z") // Replace with the latest version

  // other dependencies
}
```

The latest version can be found [here](https://mvnrepository.com/artifact/io.privy/privy-core).


# Quickstart
Source: https://docs.privy.io/basics/android/quickstart

Learn how to authenticate users, create embedded wallets, and send transactions in your Android app

## Prerequisites

This guide assumes that you have completed the [setup](/basics/android/setup) guide.

## Check user's authentication state

```kotlin  theme={"system"}
coroutineScope.launch {
  val authState = privy.getAuthState()

  when(authState) {
      is AuthState.Authenticated -> {
          // User is authenticated. Grab the user's linked accounts
          val privyUser = authState.user
      }
      AuthState.NotReady -> {
          // Privy was just initialized and has not determined auth state yet
          // authState will never be this case after calling getAuthState()
      }
      is AuthState.AuthenticatedUnverified -> {
          // Prior user session exists, but can't be verified due to no network connectivity.
          // Privy will automatically attempt to verify authenticated state when network is restored.
      }
      AuthState.Unauthenticated -> {
          // User in not authenticated.
      }
  }
}
```

## Authenticate your user

<Tip>
  This quickstart guide will demonstrate how to authenticate a user with a one time password as an
  example, but Privy supports many authentication methods. Explore our [Authentication
  docs](/authentication/overview) to learn about other methods such as socials, passkeys, and
  external wallets to authenticate users in your app.
</Tip>

Privy offers a variety of authentication mechanisms. The example below showcases authenticating a user via SMS.

This is a two step process:

1. Send an OTP to the user provided phone number.
2. Verify the OTP sent to the user.

<Note>
  Please be sure to configure SMS as a login method on the [**Privy Developer
  Dashboard**](https://dashboard.privy.io) under User Management > Authentication.
</Note>

#### 1. Send an OTP to the user's phone number via SMS

After collecting and validating your users phone number, send an OTP by calling the **`sendCode`** method.
Note: you must provide the phone number in [E.164 format](https://www.twilio.com/docs/glossary/what-e164).

```kotlin  theme={"system"}
val result: Result<Unit> = privy.sms.sendCode(phoneNumber = "+14155552671")

result.fold(
  onSuccess = {
    // OTP was successfully sent
  },
  onFailure = {
    println("Error sending OTP: ${it.message}")
  }
)
```

If the OTP is sent successfully, `sendCode` will return `Result.success` with no associated type.
If the provided phone number is invalid, or sending the OTP fails, **`sendCode`** will return `Result.failure`.

#### 2. Authenticate with OTP

The user will then receive an SMS with a 6-digit OTP. Prompt for this OTP within your application, then authenticate the user with the `loginWithCode` method. Pass the following parameters to this method:

<ParamField name="code" type="String">
  OTP code inputted by the user in your app.
</ParamField>

<ParamField name="phoneNumber" type="String">
  The user's phone number.
</ParamField>

```kotlin  theme={"system"}
val result: Result<PrivyUser> = privy.sms.loginWithCode(code = "123456", phoneNumber = "+14155552671")

result.fold(
  onSuccess = { user ->
    // User logged in
  },
  onFailure = {
    println("Error logging in user: ${it.message}")
  }
)
```

If the OTP/phone number combination is valid, Privy will successfully authenticate your user and `loginWithCode` will return `Result.success` with an encapsulated `PrivyUser`.
If the provided OTP/phone number combination is invalid, `loginWithCode` will return `Result.failure`.

## The Embedded wallet

<Tabs>
  <Tab title="Ethereum">
    ### Create an embedded wallet

    To create an EVM embedded wallet for your user, call the `createEthereumWallet` method on your `PrivyUser` instance.

    ```kotlin  theme={"system"}
    public interface PrivyUser {
      // Other privy user methods

      public suspend fun createEthereumWallet(allowAdditional: Boolean = false):  Result<EmbeddedEthereumWallet>

      // ...
    }
    ```

    <ParamField name="allowAdditional" type="Boolean" optional default="false">
      Ethereum embedded wallets are [hierarchical deterministic (HD)
      wallets](https://www.ledger.com/academy/crypto/what-are-hierarchical-deterministic-hd-wallets),
      and a user's seed entropy can support multiple separate embedded wallets. If a user already has a
      wallet and you'd like to create additional HD wallets for them, pass in `true` for the
      `allowAdditional` parameter.
    </ParamField>

    If a wallet is successfully created for the user, an **`EmbeddedEthereumWallet`** object is returned as an encapsulated value of Result.success.

    This method will `Result.failure` if:

    * The user is not authenticated
    * If a user already has 9 or more wallets
    * If the network call to create the wallet fails
    * If a user already has an embedded wallet and `allowAdditional` is not set to true.

    #### Example

    ```kotlin  theme={"system"}
    privy.user?.let { privyUser ->
      // non null user means user is authenticated
      val result = privyUser.createEthereumWallet(allowAdditional = false)

      result.fold(
        onSuccess = { ethereumWallet ->
          println("Created wallet with address: ${ethereumWallet.address}")
        },
        onFailure = {
          println("Error creating Ethereum wallet: ${it.message}")
        }
      )
    }
    ```

    ### Using the embedded wallet

    To enable your app to request signatures and transactions from the embedded wallet, Privy Ethereum embedded wallets expose a provider *inspired by* the [**EIP-1193 provider**](https://eips.ethereum.org/EIPS/eip-1193) standard. This allows you request signatures and transactions from the wallet via a familiar [**JSON-RPC API**](https://ethereum.org/en/developers/docs/apis/json-rpc/) (e.g. [`personal_sign`](https://docs.metamask.io/wallet/reference/personal_sign/)).

    Once you have an instance of an `EmbeddedEthereumWallet`, you can make RPC requests by using the `provider: EmbeddedEthereumWalletProvider` hook and using its `request` method. For example, `wallet.provider.request(request: rpcRequest)`. This request method will suspend and await if the embedded wallet needs to wait for any internal ready state.

    ```kotlin  theme={"system"}
    public interface EmbeddedEthereumWalletProvider {
     /**
      * Sends a request to the Ethereum provider
      *
      * @param The RPC request
      * @return The response received
      */
     public suspend fun request(request: EthereumRpcRequest): Result<EthereumRpcResponse>
    }
    ```

    As a parameter to this method, to this method, pass an **`EthereumRpcRequest`** object that contains:

    * **`method`**: the name of the JSON-RPC method for the wallet to execute (e.g. `'personal_sign'`)
    * **`params`**: an array of parameters required by your specified **`method`**

    By default, embedded wallets are connected to the Ethereum mainnet. To send a transaction on a different network, simply set the wallet's `chainId` in the transaction request.

    Example usage:

    ```kotlin  theme={"system"}
    // Get Privy user
    val user = privy.user

    // check if user is authenticated
    if (user != null) {
      // Retrieve list of user's embedded Ethereum wallets
      val ethereumWallets = user.embeddedEthereumWallets

      if (ethereumWallets.isNotEmpty()) {
        // Grab the desired wallet. Here, we retrieve the first wallet
        val ethereumWallet = ethereumWallets.first()

        // Make an rpc request
        ethereumWallet.provider.request(
          request = EthereumRpcRequest.personalSign("A message to sign", ethereumWallet.address),
        )
      }
    }
    ```
  </Tab>

  <Tab title="Solana">
    ### Create an embedded wallet

    To create a Solana embedded wallet for your user, call the `createSolanaWallet` method on your `PrivyUser` instance.

    ```kotlin  theme={"system"}
    public interface PrivyUser {
      // Other privy user methods

      public suspend fun createSolanaWallet():  Result<EmbeddedSolanaWallet>

      // ...
    }
    ```

    If a wallet is successfully created for the user, an **`EmbeddedSolanaWallet`** object is returned as an encapsulated value of Result.success.

    This method will `Result.failure` if:

    * The user is not authenticated
    * A user already has a Solana wallet
    * If the network call to create the wallet fails

    #### Example

    ```kotlin  theme={"system"}
    privy.user?.let { privyUser ->
      // non null user means user is authenticated
      val result = privyUser.createSolanaWallet()

      result.fold(
        onSuccess = { solanaWallet ->
          println("Created wallet with address: ${solanaWallet.address}")
        },
        onFailure = {
          println("Error creating Solana wallet: ${it.message}")
        }
      )
    }
    ```

    ### Using the embedded wallet

    Privy supports requesting signatures on messages and transactions from a user's Solana embedded wallet using the `signMessage` RPC. To request a signature, get the Solana embedded wallet provider and call the `signMessage` method on it with a base-64 encoded message to sign. If the signature is computed successfully, `signMessage` will return it as a base64-encoded string.

    ```kotlin  theme={"system"}
    public interface EmbeddedSolanaWalletProvider {
      /**
       * Request a signature on a Base64 encoded message or transaction
       *
       * @param message Base64 encoded message or transaction
       * @return The Base64 encoded computed signature
       */
      public suspend fun signMessage(message: String): Result<String>
    }
    ```

    Example usage:

    ```kotlin  theme={"system"}
    // Get current auth state
    val user = privy.user

    // check if user is authenticated
    if (user != null) {
        // Retrieve the user's Solana wallet
        val solanaWallet = user.embeddedSolanaWallets.first()

        if (solanaWallet != null) {
            // Base 64 encoded: "Hello! I am the base64 encoded message to be signed."
            val result = solanaWallet.provider.signMessage("SGVsbG8hIEkgYW0gdGhlIGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2UgdG8gYmUgc2lnbmVkLg==")
        }
    }
    ```
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/basics/android/setup



## Prerequisites

Before you begin, make sure you have [set up your Privy app and obtained your app ID](/basics/get-started/dashboard/create-new-app) and [client ID](/basics/get-started/dashboard/app-clients) from the Privy Dashboard.

<Warning>
  A properly set up app client is required for mobile apps and other non-web platforms to allow your
  app to interact with the Privy API. Please follow [this
  guide](/basics/get-started/dashboard/app-clients) to configure an app client.
</Warning>

## Initializing Privy

Initialize a **Privy** instance with your application context and a **`PrivyConfig`** object:

```kotlin  theme={"system"}
private val privy: Privy =
   Privy.init(
       context = applicationContext, // be sure to only pass in Application context
       config = PrivyConfig(
           appId = "YOUR_APP_ID",
           appClientId = "YOUR_APP_CLIENT_ID",
           logLevel = PrivyLogLevel.VERBOSE
       )
   )
```

Initialization must occur on the main (UI) thread. Initializing from a background thread may cause unexpected behavior or runtime errors.

## Configuration

The configuration fields for the PrivyConfig are:

<ParamField body="appId" type="String" required>
  Your Privy application ID, which can be obtained from the [**Privy Developer
  Dashboard**](https://dashboard.privy.io), under App Settings > Basics
</ParamField>

<ParamField body="appClientId" type="String" required>
  Your app client ID, which can be obtained from the [**Privy Developer
  Dashboard**](https://dashboard.privy.io), under App Settings > Clients
</ParamField>

<ParamField body="logLevel" type="PrivyLogLevel" optional>
  (Optional) Your preferred log level. If no log level is specified, it will default to
  `PrivyLogLevel.NONE`.
</ParamField>

<ParamField body="customAuthConfig" type="LoginWithCustomAuthConfig" optional>
  (Optional) Only use this if you plan to use custom authentication. Find more information
  [here](/authentication/user-authentication/jwt-based-auth/overview).
</ParamField>

<Tip>
  Be sure to maintain a single instance of Privy across the lifetime of your application.
  Initializing multiple instances of Privy will result in unexpected errors.
</Tip>


# Features
Source: https://docs.privy.io/basics/flutter/features

Learn about the features supported by the Flutter SDK

export const FeatureMatrix = ({sdk}) => {
  const sdks = sdk ? [sdk] : ['react', 'reactNative', 'swift', 'android', 'flutter', 'unity'];
  const sdkNames = {
    react: 'React',
    reactNative: 'React Native',
    swift: 'Swift',
    android: 'Android',
    flutter: 'Flutter',
    unity: 'Unity'
  };
  const matrix = [{
    name: 'Authentication',
    features: [{
      name: 'Email',
      react: true,
      reactNative: true,
      swift: true,
      android: true,
      flutter: true,
      unity: true
    }, {
      name: 'SMS',
      react: true,
      reactNative: true,
      swift: true,
      android: true,
      flutter: true
    }, {
      name: 'OAuth',
      react: true,
      reactNative: true,
      swift: 'Google, Apple, Twitter, Discord',
      android: 'Google, Discord, Twitter',
      flutter: 'Google, Apple, Twitter, Discord',
      unity: 'Google, Apple, Twitter, Discord'
    }, {
      name: 'SIWE (Sign In with Ethereum)',
      react: true,
      reactNative: true,
      swift: true
    }, {
      name: 'SIWS (Sign In with Solana)',
      react: true,
      reactNative: true
    }, {
      name: 'Farcaster',
      react: true,
      reactNative: true
    }, {
      name: 'Telegram',
      react: true
    }, {
      name: 'Custom Auth',
      react: true,
      reactNative: true,
      swift: true,
      android: true,
      flutter: true
    }, {
      name: 'Passkeys',
      react: true,
      reactNative: true
    }]
  }, {
    name: 'Farcaster',
    features: [{
      name: 'SIWF',
      react: true,
      reactNative: true
    }]
  }, {
    name: 'Embedded Wallets',
    features: [{
      name: 'Creating wallets manually',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum', 'solana'],
      android: ['ethereum', 'solana'],
      flutter: ['ethereum', 'solana'],
      unity: ['ethereum', 'solana']
    }, {
      name: 'Creating wallets automatically',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Pregenerating wallets',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum', 'solana'],
      android: ['ethereum', 'solana'],
      flutter: ['ethereum', 'solana']
    }, {
      name: 'Signing messages and transactions',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum', 'solana'],
      android: ['ethereum', 'solana'],
      flutter: ['ethereum', 'solana'],
      unity: ['ethereum', 'solana']
    }, {
      name: 'Broadcasting transactions',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum'],
      android: ['ethereum'],
      flutter: ['ethereum'],
      unity: ['ethereum']
    }, {
      name: 'Native smart wallets',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: 'Automatic recovery',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum', 'solana'],
      android: ['ethereum', 'solana'],
      flutter: ['ethereum', 'solana'],
      unity: ['ethereum']
    }, {
      name: 'User controlled recovery',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Transaction MFA',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Key Export',
      react: ['ethereum', 'solana']
    }, {
      name: 'Key Import',
      react: ['ethereum', 'solana']
    }, {
      name: 'HD wallets',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum'],
      android: ['ethereum'],
      flutter: ['ethereum'],
      unity: ['ethereum']
    }, {
      name: 'Session signers',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Global wallets (Cross App Accounts)',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: 'Custom EVM (Ethereum) network support',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: 'Custom SVM (Solana) network support',
      react: ['solana'],
      reactNative: ['solana']
    }]
  }, {
    name: 'Connectors',
    features: [{
      name: 'External wallets',
      react: ['ethereum', 'solana']
    }, {
      name: 'Wagmi',
      react: ['ethereum']
    }, {
      name: 'Viem',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: 'Ethers',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: '@solana/web3.js',
      react: ['solana']
    }, {
      name: 'web3swift',
      swift: ['ethereum']
    }]
  }, {
    name: 'Funding',
    features: [{
      name: 'Transfer or bridge from wallet',
      react: ['ethereum', 'solana']
    }, {
      name: 'Transfer from exchange',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Pay with card',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }]
  }];
  const filteredMatrix = matrix.map(section => {
    return {
      ...section,
      features: section.features.filter(featureItem => {
        if (sdk) {
          return featureItem[sdk] !== undefined;
        }
        return true;
      })
    };
  }).filter(section => {
    return section.features.length > 0;
  });
  return <table style={{
    display: 'table',
    width: '100%'
  }}>
      {sdk ? null : <thead>
          <tr>
            <th></th>
            {sdks.map(sdk => <th>{sdkNames[sdk]}</th>)}
          </tr>
        </thead>}
      <tbody>
        {filteredMatrix.map(section => <>
            <tr>
              <td>
                <strong>{section.name}</strong>
              </td>
              {sdks.map(() => <td></td>)}
            </tr>
            {section.features.map(feature => <tr>
                <td>
                  <em>{feature.name}</em>
                </td>
                {sdks.map(sdk => {
    const supported = feature[sdk];
    if (supported === true) {
      return <td>✅</td>;
    } else if (!supported) {
      return <td></td>;
    } else if (Array.isArray(supported)) {
      return <td>
                        {supported.map(item => item === 'ethereum' ? <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/ethereum.png" noZoom style={{
        display: 'inline',
        margin: '2px',
        width: '18px'
      }} /> : <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/solana.png" noZoom style={{
        display: 'inline',
        margin: '2px',
        width: '18px'
      }} />)}
                      </td>;
    } else {
      return <td>{supported}</td>;
    }
  })}
              </tr>)}
          </>)}
      </tbody>
    </table>;
};

## Supported features

<FeatureMatrix sdk="flutter" />


# null
Source: https://docs.privy.io/basics/flutter/installation



## Supported Platforms

* ✅ Android
* ✅ iOS
* ❌ Web

## Requirements

* Flutter: 3.24.0+
* Dart: 3.0.0+
* Android: API 27+ (Android 8.1 Oreo or newer) and Kotlin 2.1.0+
* iOS: 16+ and Swift Package Manager

## Installation

### Enable Swift Package Manager

The Privy Flutter SDK uses Swift Package Manager. To enable it, run:

```bash  theme={"system"}
flutter config --enable-swift-package-manager
```

<Note>
  You'll need to either use Flutter 3.24.0 on the main channel (experimental) or Flutter 3.27.0+ on
  stable. While 3.24.0 support is available by switching to Flutter's main channel, this is not
  recommended for production apps as the main channel can be unstable.
</Note>

### Add the Dependency

1. The Privy Flutter SDK is available on pub.dev. Add it to your `pubspec.yaml` file:

```yaml  theme={"system"}
dependencies:
  flutter:
    sdk: flutter
  privy_flutter: X.Y.Z # Replace with the latest version from pub.dev
```

2. Run the following command to install the dependency:

```bash  theme={"system"}
flutter pub get
```


# Quickstart
Source: https://docs.privy.io/basics/flutter/quickstart

Learn how to authenticate users, create embedded wallets, and send transactions in your Flutter app

## Prerequisites

This guide assumes that you have completed the [setup](/basics/flutter/setup) guide.

## Authenticate your user

<Tip>
  This quickstart guide will demonstrate how to authenticate a user with a one time password as an
  example, but Privy supports many authentication methods. Explore our [Authentication
  docs](/authentication/overview) to learn about other methods such as socials, passkeys, and
  external wallets to authenticate users in your app.
</Tip>

Privy offers a variety of authentication mechanisms. The example below showcases authenticating a user via SMS.

This is a two step process:

1. Send an OTP to the user provided phone number.
2. Verify the OTP sent to the user.

<Note>
  Please be sure to configure SMS as a login method on the [**Privy Developer
  Dashboard**](https://dashboard.privy.io) under User Management > Authentication.
</Note>

#### 1. Send an OTP to the user's phone number via SMS

After collecting and validating your users phone number, send an OTP by calling the **`sendCode`** method.
Note: you must provide the phone number in [E.164 format](https://www.twilio.com/docs/glossary/what-e164).

```dart  theme={"system"}
final Result<void> result = await privy.sms.sendCode("+14155552671");

result.fold(
  onSuccess: (_) {
    // OTP was sent successfully
  },
  onFailure: (error) {
    // Handle error sending OTP
    print(error.message);
  },
);

```

If the OTP is sent successfully, **`sendCode`** will return `Success()` with no associated type. If the provided email address is invalid, or sending the OTP fails, **`sendCode`** will return `Failure()` containing a `PrivyException`.

#### 2. Authenticate with OTP

The user will then receive an SMS with a 6-digit OTP. Prompt for this OTP within your application, then authenticate the user with the `loginWithCode` method. Pass the following parameters to this method:

<ParamField name="code" type="String" required>
  OTP code inputted by the user in your app.
</ParamField>

<ParamField name="phoneNumber" type="String" required>
  The user's phone number.
</ParamField>

```dart  theme={"system"}
final Result<PrivyUser> result = await privy.sms.loginWithCode(
  code: code,
  phoneNumber: phoneNumber,
);

result.fold(
  onSuccess: (user) {
    // User authenticated successfully
  },
  onFailure: (error) {
    // Handle authentication error
  },
);

```

If the OTP/phone number combination is valid, Privy will successfully authenticate your user and `loginWithCode` will return `Success()` with an encapsulated `PrivyUser`.
If the provided OTP/phone number combination is invalid, `loginWithCode` will return `Failure()`, containing a PrivyException.

## The embedded wallet

<Tabs>
  <Tab title="Ethereum">
    ### Create an embedded wallet

    To create an EVM embedded wallet for your user, call the `createEthereumWallet` method on your `PrivyUser` instance.

    ```dart  theme={"system"}
    abstract class PrivyUser {
      // Other privy user methods

      /// Creates an Ethereum embedded wallet for the user.
      Future<Result<EmbeddedEthereumWallet>> createEthereumWallet({bool allowAdditional = false});
    }

    ```

    <ParamField name="allowAdditional" type="Bool" optional default="false">
      Ethereum embedded wallets are [hierarchical deterministic (HD)
      wallets](https://www.ledger.com/academy/crypto/what-are-hierarchical-deterministic-hd-wallets),
      and a user's seed entropy can support multiple separate embedded wallets. If a user already has a
      wallet and you'd like to create additional HD wallets for them, pass in `true` for the
      `allowAdditional` parameter.
    </ParamField>

    If a wallet is successfully created for the user, an **`EmbeddedEthereumWallet`** object is returned as an encapsulated value of `Success()`.

    This method will fail if:

    * The user is not authenticated
    * If a user already has 9 or more wallets
    * If the network call to create the wallet fails
    * If a user already has an embedded wallet and `allowAdditional` is not set to true.

    ### Using the embedded wallet

    To enable your app to request signatures and transactions from the embedded wallet, Privy Ethereum embedded wallets expose a provider *inspired by* the [**EIP-1193 provider**](https://eips.ethereum.org/EIPS/eip-1193) standard. This allows you request signatures and transactions from the wallet via a familiar [**JSON-RPC API**](https://ethereum.org/en/developers/docs/apis/json-rpc/) (e.g. [`personal_sign`](https://docs.metamask.io/wallet/reference/personal_sign/)).

    Once you have an instance of an `EmbeddedEthereumWallet`, you can make RPC requests by using the `provider: EmbeddedEthereumWalletProvider` hook and using its `request` method. For example, `wallet.provider.request(request: rpcRequest)`. This request method will suspend and await if the embedded wallet needs to wait for any internal ready state.

    ```dart  theme={"system"}
    /// Defines the Ethereum Wallet Provider interface for sending RPC requests.
    abstract class EmbeddedEthereumWalletProvider {
       /**
        * Sends a request to the Ethereum provider
        *
        * @param The RPC request
        * @return The response received
        */
      Future<Result<EthereumRpcResponse>> request(EthereumRpcRequest request);
    }
    ```

    As a parameter to this method, to this method, pass an **`EthereumRpcRequest`** object that contains:

    * **`method`**: the name of the JSON-RPC method for the wallet to execute (e.g. `'personal_sign'`)
    * **`params`**: an array of parameters required by your specified **`method`**

    By default, embedded wallets are connected to the Ethereum mainnet. To send a transaction on a different network, simply set the wallet's `chainId` in the transaction request.

    Example usage:

    ```dart  theme={"system"}
    // Get the Privy user
    final user = privy.user;

    // Check if the user is authenticated
    if (user != null) {
      // Retrieve the list of user's embedded Ethereum wallets
      final ethereumWallets = user.embeddedEthereumWallets;

      if (ethereumWallets.isNotEmpty) {
        // Grab the desired wallet. Here, we retrieve the first wallet
        final ethereumWallet = ethereumWallets.first;

        // Make an RPC request
        ethereumWallet.provider.request(
          request: EthereumRpcRequest(
            method: "personal_sign",
            params: ["A message to sign", ethereumWallet.address],
          ),
        );
      }
    }
    ```
  </Tab>

  <Tab title="Solana">
    ### Creating the embedded wallet

    To create a Solana embedded wallet for your user, call the `createSolanaWallet` method on your `PrivyUser` instance.

    ```dart  theme={"system"}
    abstract class PrivyUser {
      /// Creates a Solana embedded wallet for the user.
      Future<Result<EmbeddedSolanaWallet>> createSolanaWallet();
    }
    ```

    If a wallet is successfully created for the user, an **`EmbeddedSolanaWallet`** object is returned as an encapsulated value of `Success()`.

    This method will `Failure()` with a PrivyException if:

    * The user is not authenticated
    * A user already has a Solana wallet
    * If the network call to create the wallet fails

    ### Using the embedded wallet

    Privy supports requesting signatures on messages and transactions from a user's Solana embedded wallet using the `signMessage` RPC. To request a signature, get the Solana embedded wallet provider and call the `signMessage` method on it with a base-64 encoded message to sign. If the signature is computed successfully, `signMessage` will return it as a base64-encoded string.

    ```dart  theme={"system"}
    abstract class EmbeddedSolanaWalletProvider {
      /**
       * Request a signature on a Base64 encoded message or transaction
       *
       * @param message Base64 encoded message or transaction
       * @return The Base64 encoded computed signature
       */
      Future<Result<String>> signMessage(String message);
    }
    ```

    Example usage:

    ```dart  theme={"system"}
    // Get the current user
    final user = privy.user;

    // Check if the user is authenticated
    if (user != null) {
      // Check if the user has at least one Solana wallet
      if (user.embeddedSolanaWallets.isNotEmpty) {
        // Retrieve the user's Solana wallet
        final solanaWallet = user.embeddedSolanaWallets.first;

        // Sign a message
        final result = await solanaWallet.provider.signMessage(
          // Base 64 encoded: "Hello! I am the base64 encoded message to be signed."
          "SGVsbG8hIEkgYW0gdGhlIGJhc2U2NCBlbmNvZGVkIG1lY3NhZ2UgdG8gYmUgc2lnbmVkLg=="
        );
      }
    }
    ```
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/basics/flutter/setup



## Prerequisites

Before you begin, make sure you have [set up your Privy app and obtained your app ID](/basics/get-started/dashboard/create-new-app) and [client ID](/basics/get-started/dashboard/app-clients) from the Privy Dashboard.

<Warning>
  A properly set up app client is required for mobile apps and other non-web platforms to allow your
  app to interact with the Privy API. Please follow this guide to configure an app client by
  following this guide [here](/basics/get-started/dashboard/app-clients).
</Warning>

## Initializing Privy

First, import the Privy package at the top of your file:

```dart  theme={"system"}
import 'package:privy_flutter/privy_flutter.dart';
```

Initialize a **Privy** instance with a **`PrivyConfig`** object:

```dart  theme={"system"}
final privyConfig = PrivyConfig(
  appId: "YOUR_APP_ID",
  appClientId: "YOUR_CLIENT_ID",
  logLevel: PrivyLogLevel.verbose,
);

final privy = Privy(config: privyConfig);
```

## Configuration

The configuration fields for the PrivyConfig are:

<ParamField body="appId" type="String" required>
  Your Privy application ID, which can be obtained from the [**Privy Developer
  Dashboard**](https://dashboard.privy.io), under App Settings > Basics
</ParamField>

<ParamField body="appClientId" type="String" required>
  Your app client ID, which can be obtained from the [**Privy Developer
  Dashboard**](https://dashboard.privy.io), under App Settings > Clients
</ParamField>

<ParamField body="logLevel" type="PrivyLogLevel" optional>
  (Optional) Your preferred log level. If no log level is specified, it will default to
  `PrivyLogLevel.NONE`.
</ParamField>

<ParamField body="customAuthConfig" type="LoginWithCustomAuthConfig" optional>
  (Optional) Only use this if you plan to use custom authentication. Find more information
  [here](/authentication/user-authentication/jwt-based-auth/overview).
</ParamField>

<Tip>
  Be sure to maintain a single instance of Privy across the lifetime of your application.
  Initializing multiple instances of Privy will result in unexpected errors.
</Tip>

## Waiting for Privy to be ready

When the Privy SDK is initialized, the user's authentication state will be set to `NotReady` until Privy finishes initialization. This might include checking if the user has a wallet connected, refreshing expired auth tokens, fetching up-to-date user data, and more.

**It's important to wait until Privy has finished initializing *before* you consume Privy's state and interfaces**, to ensure that the state you consume is accurate and not stale.

For your convenience, we've added an async `awaitReady()` function that you can use to wait for Privy to finish initializing:

```dart  theme={"system"}
Future<void> checkPrivyAuth() async {
  // Show loading state
  setState(() => isLoading = true);

  // Wait for Privy SDK to be ready
  await privy.awaitReady();

  // Check if user is authenticated
  bool isAuthenticated = privy.currentAuthState.isAuthenticated;

  // Update UI based on authentication state
  setState(() {
    isLoading = false;
    isUserAuthenticated = isAuthenticated;
  });
}

// Example usage in a widget
@override
Widget build(BuildContext context) {
  return isLoading
    ? LoadingScreen()
    : (isUserAuthenticated ? AppScreen() : LoginScreen());
}
```

<CardGroup cols={2}>
  <Card title="Quickstart Guide" icon="rocket" href="/basics/flutter/quickstart">
    Learn how to [log users in](/authentication/user-authentication/login-methods/email) and
    [transact with embedded wallets](/wallets/wallets/create/create-a-wallet)
  </Card>

  <Card title="Flutter Starter Repo" icon="code" href="https://github.com/privy-io/examples/tree/main/privy-flutter-starter">
    Check out our [Flutter starter
    repo](https://github.com/privy-io/examples/tree/main/privy-flutter-starter) for a complete
    example
  </Card>
</CardGroup>


# About Privy
Source: https://docs.privy.io/basics/get-started/about



Privy builds authentication and wallet infrastructure to enable better products built on
crypto rails. Get started in minutes to onboard users with wallets, spin up self-custodial wallets for users,
and securely sign transactions through your app.

Broadly, Privy enables:

**User onboarding** — Privy helps developers onboard users regardless of their experience with crypto-based systems. This means libraries to authenticate them, help them connect their existing wallets and provision self-custodial embedded wallets for them if they don't already have one.

**Wallet infrastructure** — Developers can spin up user-centric wallets from the client or general-purpose wallets from their backend directly to provision and manage cross-chain wallets for any use case.

Privy surfaces both user-centric abstractions enabling you to authenticate users and generate wallets for them, as well as wallet-centric abstractions whereby you can create wallets with assigned authorization keys to control them.

## Engineering principles

At Privy, we believe technical decisions are moral decisions. Below are the principles that guide our engineering decisions.

### Secure

Nothing is more important than your user's security. Privy’s key management system uses distributed key sharding to ensure Privy can never access your user's keys — only their rightful owner can. Keys are only ever reconstituted in a secure execution environment at the point of signing a message or sending a transaction.

Privy regularly undergoes rigorous audits to ensure your users control and privacy over their wallets.

### Flexible

Privy gives your application low level access to users and their wallets to support a fully customized product experience. Your application can access Privy's functionality all the way down to the API level, supporting unique wallet flows including provisioning multiple wallets per user.

### Easy to use

Privy has out of the box UIs so your app can support authentication and wallet flows in minutes. These UIs are highly customizable and can even be fully whitelabeled. This means access to out of the box funding methods, smart wallet creation pipelines, and more.

### Portable

Privy is compatible with any chain your application operates on. Your application can provision embedded wallets (or link external wallets to a Privy account) on Solana, Ethereum, and all EVM/SVM compatible chains. Privy is at the bleeding edge of distributed systems so when you want to build on a new chain, that chain is already supported.

With layers of customizability, Privy supports a wide range of product experiences.

<img src="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Customization.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=efcb8c7656d6bd33f886240a7583c52f" alt="images/Customization.png" data-og-width="5529" width="5529" data-og-height="3949" height="3949" data-path="images/Customization.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Customization.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=bdeb87d0a7beb0447b9e5e7737f459b0 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Customization.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=cb260579ff196b91d8a35b3065f75308 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Customization.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=e9b5bf191d635505cc5ee08efec601de 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Customization.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=672ec82fe3a4fb36d9029a09c840a022 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Customization.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=1cbf9749a26fa36466143aaf6b78304b 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Customization.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=b7ac9e8bebce7ee86fd66e00a5f49ae6 2500w" />


# Create an account
Source: https://docs.privy.io/basics/get-started/account



To get started, visit the [Privy Dashboard](https://dashboard.privy.io) and create an account. You can use the Dashboard to manage your apps, configurations, wallets, users, and more.

While setting up your account, Privy will prompt you to share some basic information about what you're building and your technical stack. These details will be used to set up default configurations for your apps that are optimized for your setup.

<img src="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Dash.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=34dff276c7dd9344453dbf3b473fba08" alt="images/Dash.png" data-og-width="1843" width="1843" data-og-height="1317" height="1317" data-path="images/Dash.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Dash.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=d7c2ab3513fa433f746a7308dc35d469 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Dash.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=e0f30014b8c29207c480570750a09122 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Dash.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=15637f0457782c2f4fb95822731a3ae1 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Dash.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=764c012fe40ba7b54b496271487faf03 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Dash.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=0e38a866c25e0d1ad21a14e390d202f4 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Dash.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=5f3864090f4f5ef74c2a8ae2af62c110 2500w" />


# null
Source: https://docs.privy.io/basics/get-started/dashboard/app-clients



App clients allow you to create configure specific settings for different consumers/platforms for your app, including
mobile apps, web apps, and more. App client settings will override your app's default settings.

To add a client, go to the [Configuration > App settings page > Clients](https://dashboard.privy.io/apps?setting=clients\&page=settings) tab, and find the "Add app client" button.

<Tip>
  This step is optional if you're using the React SDK. App clients are required for all other mobile
  and non-web platforms to allow your app to interact with the Privy API.
</Tip>

<Tabs>
  <Tab title="Web Environments">
    ### Cookies

    Once you enable HttpOnly cookies on your app and add an app domain, Privy will automatically store a user's token as an HttpOnly cookie on the app domain.
    You can use app clients to enable or disable cookies for different environments.

    [Learn more about cookies here!](/recipes/react/cookies).

    ### Allowed origins

    Each app client can have a different set of allowed origins. You can set allowed origins on your app client.
    Note that if cookies are enabled, the app's domain must be one of the allowed origins.

    [Learn more about allowed origins here!](/recipes/react/allowed-domains).

    ### Session duration

    You can set the session duration for each app client. The session duration is the number of days that a user's session will last before they are logged out.

    ### Apple OAuth Client ID override

    If your application uses Apple as a social login method, you can specify a different client ID depending on which environment your application is running in. In order to use Apple login on an iOS app, the `Client ID` must be the Apple OAuth `bundleId`. All other platforms will require the `Client ID` to be the `Identifier` of the [Sign in with Apple service](https://developer.apple.com/documentation/signinwithapple/configuring-your-environment-for-sign-in-with-apple#Create-a-Services-ID).
  </Tab>

  <Tab title="Mobile/Other Environments">
    ### Allowed app identifiers

    To enforce secure usage of your Privy App ID, configure Privy to restrict which mobile apps can use your Privy App ID based on your mobile applications' application identifiers.
    An empty list will mean all requests are denied. You **must** configure at least one application identifier to use the React Native SDK.

    <Tabs>
      <Tab title="React Native">
        We'll use the unique value that identifies your app in the Apple App Store or Google Play Store.

        * For iOS apps, this is the [`bundleIdentifier`](https://docs.expo.dev/versions/latest/config/app/#bundleidentifier).
        * For Android apps, this is the [`package`](https://docs.expo.dev/versions/latest/config/app/#package).

        <CodeGroup>
          ```ts ios {2} theme={"system"}
          "iOS": {
              "bundleIdentifier": "com.myorg.app"
          }
          ```

          ```ts Android {2} theme={"system"}
          "android": {
              "package": "com.myorg.app"
          }
          ```
        </CodeGroup>

        <Tip>
          If you are using [Expo Go](https://expo.dev/client), add `host.exp.Exponent` to allow requests.
        </Tip>
      </Tab>

      <Tab title="Swift">
        We'll use your project's bundle identifier, which you can find under the "Identity" section of your app's target file.
        It likely has reverse domain format, like "com.myorg.app".
      </Tab>

      <Tab title="Android">
        We'll use your projects application ID from your app's build.gradle file.

        ```kotlin {3} theme={"system"}
        android {
            defaultConfig {
                applicationId = "com.myorg.app"
            }
        }
        ```
      </Tab>

      <Tab title="Unity">
        Copy your project's bundle identifier, which you can find under the "Identity" section of your app's target file. It likely has reverse domain format, like "com.myorg.app".
      </Tab>

      <Tab title="Flutter">
        To enforce secure usage of your Privy client ID, register your app's bundle identifier under the app client that was just created.

        1. Copy your iOS project's bundle identifier, which you can find under the "Identity" section of your app's target file.
        2. Copy your Android project's application ID from your app's build.gradle file.
      </Tab>
    </Tabs>

    ### Allowed URL schemes

    To use Privy's social login flows (e.g. Apple, Google, etc.) or integrate with a [global wallet](/wallets/global-wallets/overview),
    you must register the **URL scheme** (e.g. `myapp://`) for your application with Privy.

    An empty list will mean that all redirects coming from URL schemes will be rejected. You **must** register at least one URL scheme.

    <Tip>
      A full URL scheme, including path (e.g. `myapp://shire`) will only allow exactly that path. By
      specifying a scheme only (e.g. `myapp`), all paths will be supported.
    </Tip>

    <Tabs>
      <Tab title="React Native">
        To register your URL scheme, **copy your application's URL `scheme` from `app.json` or `app.config.ts`** and register it in the app client settings.

        <Warning>For **development only** if you are using [Expo Go](https://expo.dev/client), enter **`exp`** as the URL scheme for the Expo Go app.</Warning>

        ### Apple OAuth Client ID override

        If your application uses Apple as a social login method, you can specify a different client ID depending on which environment your application is running in. In order to use Apple login on an iOS app, the `Client ID` must be the Apple OAuth `bundleId`. All other platforms will require the `Client ID` to be the `Identifier` of the [Sign in with Apple service](https://developer.apple.com/documentation/signinwithapple/configuring-your-environment-for-sign-in-with-apple#Create-a-Services-ID).
      </Tab>

      <Tab title="Swift">
        First, register your URL scheme in your Xcode project. If you're unsure how, you can follow [these steps](https://developer.apple.com/documentation/xcode/defining-a-custom-url-scheme-for-your-app#Register-your-URL-scheme).
        Then, use the URL scheme you registered in the app client settings.

        ### Apple OAuth Client ID override

        If your application uses Apple as a social login method, you can specify a different client ID depending on which environment your application is running in. In order to use Apple login on an iOS app, the `Client ID` must be the Apple OAuth `bundleId`. All other platforms will require the `Client ID` to be the `Identifier` of the [Sign in with Apple service](https://developer.apple.com/documentation/signinwithapple/configuring-your-environment-for-sign-in-with-apple#Create-a-Services-ID).
      </Tab>

      <Tab title="Android">
        Add your URL scheme in your Android manifest. If you're unsure how, you can follow [this guide](https://developer.android.com/training/app-links/deep-linking).
        Then, use the URL scheme you registered in the app client settings.
      </Tab>

      <Tab title="Unity">
        For non-web platforms, be sure to [setup deeplinking](https://docs.unity3d.com/Manual/deep-linking.html) with your allowed URL scheme.

        ### Apple OAuth Client ID override

        If your application uses Apple as a social login method, you can specify a different client ID depending on which environment your application is running in. In order to use Apple login on an iOS app, the `Client ID` must be the Apple OAuth `bundleId`. All other platforms will require the `Client ID` to be the `Identifier` of the [Sign in with Apple service](https://developer.apple.com/documentation/signinwithapple/configuring-your-environment-for-sign-in-with-apple#Create-a-Services-ID).
      </Tab>
    </Tabs>

    <details>
      <summary><b>Why is this required?</b></summary>

      Certain flows within the Privy authentication process require Privy to register allowed callback URLs with third-party service providers. The plainest example of this is social login flows using the OAuth 2.0 Protocol, where Privy must register allowed callback URLs with Google, Apple, and other OAuth login providers.

      Configuring your allowed URL schemes in the Privy Dashboard ensures Privy updates the appropriate settings with these third-party service providers!
    </details>

    ### Session duration

    You can set the session duration for each app client. The session duration is the number of days that a user's session will last before they are logged out.
  </Tab>
</Tabs>


# Configure login methods
Source: https://docs.privy.io/basics/get-started/dashboard/configure-login-methods



If you plan on using Privy for user onboarding, you'll need to configure the login methods you want to use in your app.
All client SDKs require at least one login method to be enabled - follow the steps below to set up different options for your users!

### Basic login methods

For most apps, we recommend either including alternative login options alongside the following, or enabling [Multi-Factor Authentication](/authentication/user-authentication/mfa). This ensures broad accessibility across all regions and that users can continue accessing their accounts in the event that they lose access to one login method.

<AccordionGroup>
  <Accordion title="Email login">
    Privy enables your users to log in via email or link verified email addresses to their account. You can enable email login and linking via the Authentication page of the dashboard.

    #### One-Time Password Authentication

    When a user attempts to log in with their email, a one-time password (OTP) will be sent to their email address. This password is valid for 10 minutes and must be entered to complete the authentication process.

    #### Allow/disallow `+` in email addresses

    You can configure whether to allow email addresses containing the + character in the Authentication page of the dashboard.

    This is useful for users who want to use email aliases.

    <Info>
      Allowing + in email addresses enables users to create multiple accounts using
      email aliases with a single base email address. Consider your application's
      security requirements when configuring this option.
    </Info>
  </Accordion>

  <Accordion title="SMS login">
    Privy enables your users to log in via SMS or link verified phone numbers to their account. You can enable SMS login and linking via the **Authentication** page of the dashboard.

    #### One-Time Password Authentication

    Similar to email authentication, when a user attempts to log in via SMS, a one-time password (OTP) will be sent to their phone number. This password is valid for 10 minutes and must be entered to complete the authentication process.

    #### US and Canada support

    US and Canada support is included at no additional cost on the Core, Scale, and Enterprise plans.

    You can enable access to US and Canada SMS via the **Authentication** page of the dashboard.

    <Info>
      If you enable SMS login, you may be responsible for additional charges per SMS sent. Underlying
      Twilio network costs will be passed through directly. See Twilio's pricing page
      [here](https://assets.cdn.prod.twilio.com/pricing-csv/SMSPricing.csv).
    </Info>

    #### International region support

    You can request access to international SMS by reaching out to [**support@privy.io**](mailto:support@privy.io). By default, Privy supports the following regions for the international SMS plan:

    <details>
      <summary>See a list of supported international regions for SMS</summary>

      | Region         | Region Code |
      | -------------- | ----------- |
      | Argentina      | +54         |
      | Australia      | +61         |
      | Canada         | +1          |
      | Chile          | +56         |
      | Czech Republic | +420        |
      | Germany        | +49         |
      | Hong Kong      | +852        |
      | Hungary        | +36         |
      | Japan          | +81         |
      | New Zealand    | +64         |
      | Portugal       | +351        |
      | Saudi Arabia   | +966        |
      | Singapore      | +65         |
      | South Korea    | +82         |
      | Sweden         | +46         |
      | Taiwan         | +886        |
      | Thailand       | +66         |
      | Turkey         | +90         |
      | United Kingdom | +44         |
      | United States  | +1          |
    </details>

    <Info>
      Region support is subject to change. If you would like to request access to
      additional SMS regions for your account, please reach out to [support@privy.io](mailto:support@privy.io)!
    </Info>
  </Accordion>

  <Accordion title="Wallet login">
    Privy supports blockchain wallet-based authentication methods that allow users to securely connect using their existing wallets.

    #### Supported wallet types

    Currently, Privy supports both **Sign in with Ethereum (SIWE)** and **Sign in with Solana (SIWS)** to authenticate your user into the application with any EVM or SVM compatible wallet.

    <Note>
      We're actively working to expand our support for other networks, such as Bitcoin, Sui, etc.
      Interested in a specific network that isn't currently supported? Contact us at [support@privy.io](mailto:support@privy.io) to
      inquire about additional chain support or to discuss your specific use case requirements.
    </Note>

    #### Restrict Users to a Single Wallet

    You can enable the **`Restrict users to linking a single third-party wallet`** option for your application.

    When enabled, users can only link one wallet to their account, preventing potential confusion or security issues that might arise from multiple linked wallets.
  </Accordion>
</AccordionGroup>

### Social providers

Privy allows you to log users into their accounts with existing social accounts, such as Google, Twitter, Farcaster, Telegram, and more! Follow the steps below to enable different social account login methods for your users.

<Info>
  {' '}

  Google OAuth login may not work in in-app browsers (IABs), such as those embedded in social apps,
  due to Google's restrictions in these environments. Other OAuth providers are generally
  unaffected.
</Info>

<AccordionGroup>
  <Accordion title="OAuth login methods (Google, Twitter, etc.)">
    ## OAuth login methods

    Privy allows you to log users in with their existing social accounts via the [OAuth 2.0 protocol](https://datatracker.ietf.org/doc/html/rfc6749). Privy currently supports many of the most popular OAuth providers (Google, Twitter, etc.) -- follow the guide below in order to enable these login methods for your application.

    ### Default vs custom credentials

    You can enable OAuth (social) logins quickly by just toggling it on in the Dashboard page. This will use default OAuth credentials that the Privy team has configured with each provider.

    However, best practice is to **configure your own app's OAuth credentials for each account type.**

    **Configuring your own OAuth credentials has many benefits:**

    * Your app has more control over security and resiliency.
    * Your users will see your branding on the social login provider's authentication screen.

    <Tip>
      **Just getting started with Privy?** We recommend you complete your integration in development
      using Privy's default credentials first. Before going to production, you can easily swap in your
      own credentials!
    </Tip>

    ### Configure your OAuth credentials

    Follow this guide to configure your own app's OAuth credentials.

    <Steps>
      <Step title="Setup your OAuth apps for each provider">
        To configure OAuth credentials for a given provider, first create an OAuth app with your chosen provider, following the provider-specific instructions below.

        For all providers, during setup, specify Privy's OAuth callback endpoint as your redirect URI:

        ```
        https://auth.privy.io/api/v1/oauth/callback
        ```
      </Step>

      <Step title="Configure your credentials with Privy">
        <Warning>
          Your custom credentials will go live to all your users as soon as you save them in the dashboard.
          We highly encourage you to test them in a development app before setting them for your production
          app.
        </Warning>

        Navigate to the **Login methods** page on the [Privy dashboard](https://dashboard.privy.io) by selecting your app and clicking Login Methods on the side bar. Click on the socials tab to see the social providers. Enter the OAuth credentials under the drop down for you set up.

        If a provider does not have a drop down, it does not currently support configuring your own credentials.

        <AccordionGroup>
          <Accordion title="Apple">
            #### Apple

            Follow [this](https://developer.apple.com/documentation/signinwithapple/configuring-your-environment-for-sign-in-with-apple) guide to configure your Apple app, service, and key. Note that Apple differs from the rest of the providers in a few ways.

            <Info>
              When creating the Service ID with the associated `Sign in with Apple` feature, be sure to add
              `https://auth.privy.io/api/v1/oauth/callback` as a registered redirect URI for your service.
            </Info>

            You will need to provide the following to Privy upon completion:

            * Team ID: the identifier associated with your Apple developer account.
            * Service ID: this will be used as your `Client ID`. You can find this value listed under the `Identifier` field in the `Service IDs` section:
              {" "}
              <img src="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/apple-services-id.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=2201a3fcb22313740cbb9c8a9c99433d" alt="Apple services id" data-og-width="2652" width="2652" data-og-height="644" height="644" data-path="images/apple-services-id.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/apple-services-id.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=75b47034da46fb7cc4b2455c6565bbd5 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/apple-services-id.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=806ec9d6ca526c82773b0b0f26d23b46 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/apple-services-id.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=385c370f865228c0ce28fece52e5e96d 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/apple-services-id.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=30ff1fa1a70550f7a876218bfac07542 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/apple-services-id.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=3345a5fab29a267d4b618a7a143eb78b 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/apple-services-id.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=c891f94bcb17c72f9fb19665543d628a 2500w" />

            <Tip>
              If you are building an iOS mobile app, you will need to use the App ID instead of the Service ID.
              This should be the same as your application's `BundleId` and should be entered as your `Client ID`
              in the privy dashboard. You will still need to create a `Sign in with Apple` service associated
              with this App ID. Android apps should continue to use the Service ID as their `Client ID`.
            </Tip>

            * Key ID: the identifier associated with your key, found in the `Keys` section of the Apple Developer dashboard.
            * Key: this private key will be generated alongside the `Key ID` and will be used as your `Signing key`. Be sure to copy and paste the entire key with the header and footer into the `Signing key` input.

            <Info>
              If you have an app that has users who have already logged in using Privy's default credentials, we
              do not yet support migrating these users. If you'd like to test using your own credentials in a
              development environment, you can do so by creating a new app and setting your credentials before
              any Apple users log in.
            </Info>
          </Accordion>

          <Accordion title="Discord">
            #### Discord

            Follow [this](https://discord.com/developers/docs/topics/oauth2) guide to register a developer application. After Creating a Discord app, use the OAuth2 settings to generate a `Client Secret` and set `Redirects`. You will need to provide the following to Privy upon completion:

            * Client ID
            * Client Secret
          </Accordion>

          <Accordion title="GitHub">
            #### GitHub

            Follow [this](https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/creating-an-oauth-app) guide to create a GitHub OAuth App. Do not enable device flow. You will need to provide the following to Privy upon completion:

            * Client ID
            * Client secret
          </Accordion>

          <Accordion title="Google">
            #### Google

            Follow [this](https://support.google.com/cloud/answer/6158849?hl=en) guide. When you are creating your app, make sure to specify `Web App` for your app type (it will be treated as a web app in the context of OAuth since you are using Privy). You will need to provide the following to Privy upon completion:

            * Client ID
            * Client secret
          </Accordion>

          <Accordion title="Instagram">
            #### Instagram

            Privy makes use of the Instagram API to allow your users to log in with and connect their Instagram business profiles to a Privy application. Follow [this](https://developers.facebook.com/docs/instagram-platform/instagram-api-with-instagram-login/create-a-meta-app-with-instagram/) guide to create a Facebook Business application with an associated Instagram product, from which you can access the [Instagram API with Instagram Login](https://developers.facebook.com/docs/instagram-platform/instagram-api-with-instagram-login). After creating the Instagram product, use the OAuth2 settings to generate a `Client Secret` and set `Redirects`. You will need to provide the following to Privy upon completion:

            * Client ID
            * Client Secret

            Please note that this is the Client ID and Secret associated with the Instagram **Product** associated with your Facebook app, and not the Client ID and secret associated with the Facebook app.

            <Info>
              The Instagram API only allows for login with Instagram
              [business](https://www.facebook.com/business/instagram) or
              [creator](https://help.instagram.com/2358103564437429/?helpref=uf_share) accounts. Personal
              Instagram accounts cannot be used to log into Privy applications.
            </Info>
          </Accordion>

          <Accordion title="LinkedIn">
            #### LinkedIn

            Follow [this](https://learn.microsoft.com/en-us/linkedin/shared/authentication/authorization-code-flow?context=linkedin%2Fcontext\&tabs=HTTPS1#step-1-configure-your-application) guide. You will need to provide the following to Privy upon completion:

            * Client ID
            * Primary Client Secret

            <Info>
              If you have an app that has users who have already logged in using Privy's default credentials, we
              do not yet support migrating these users. If you'd like to test using your own credentials in a
              development environment, you can do so by creating a new app and setting your credentials before
              any LinkedIn users log in.
            </Info>
          </Accordion>

          <Accordion title="LINE">
            #### LINE

            Follow [this](https://developers.line.biz/en/docs/line-login/integrate-line-login/) guide to create a LINE Login channel. When setting up your channel:

            <Info>
              **Important**: When configuring LINE with your own credentials (BYO), make sure to request **email
              access** for your LINE channel. This ensures users' email addresses can be retrieved during
              authentication.
            </Info>

            You will need to provide the following to Privy upon completion:

            * Channel ID
            * Channel Secret
          </Accordion>

          <Accordion title="Spotify">
            #### Spotify

            Follow [this](https://developer.spotify.com/documentation/web-api/concepts/apps) guide to register a developer application. After Creating a Spotify app, use the OAuth2 settings to generate a `Client Secret` and set `Redirects`. You will need to provide the following to Privy upon completion:

            * Client ID
            * Client Secret
          </Accordion>

          <Accordion title="TikTok">
            #### TikTok

            Follow the instructions in the 'Prerequisites' section of [this](https://developers.tiktok.com/doc/login-kit-desktop/) guide to register your app and enable LoginKit. When you are creating your app, make sure to specify `Configure for Web` for your app type (it will be treated as a web app in the context of OAuth since you are using Privy).

            TikTok is different from other providers in a few key ways:

            * Your OAuth `client_id` is referred to as `client_key`.
            * You are required to provide a Terms of Service URL and Privacy Policy URL when creating your app.
            * TikTok conducts a review process, and your new credentials will not work until your app is approved and move to `Production` status.

            You will need to provide the following to Privy upon completion:

            * Client key (as described above)
            * Client secret

            <Info>
              If you have an app that has users who have already logged in using Privy's default credentials, we
              do not yet support migrating these users. If you'd like to test using your own credentials in a
              development environment, you can do so by creating a new app and setting your credentials before
              any TikTok users log in.
            </Info>
          </Accordion>

          <Accordion title="Twitch">
            #### Twitch

            Follow [this](https://dev.twitch.tv/docs/authentication/register-app/) guide to register a developer application. After creating a Twitch app, use the OAuth2 settings to generate a `Client Secret` and set redirect URIs. You will need to provide the following to Privy upon completion:

            * Client ID
            * Client Secret
          </Accordion>

          <Accordion title="X (formerly known as Twitter)">
            #### X (formerly known as Twitter)

            Follow [this](https://developer.twitter.com/en/docs/apps/app-management) guide to create an X (formerly known as Twitter) app. Make sure to configure your app as a "Confidential client". In the application authentication settings this is the `Web app, Automated App or Bot` option for `Type of App`. You will need to provide the following to Privy upon completion:

            * Client ID
            * Client Secret

            The X option for Native App doesn't enforce the use of a Client Secret. This is useful for authenticating with X on your mobile device, without any server involved in the process. You can learn more about Confidential clients [in the official X developer documentation](https://developer.x.com/en/docs/authentication/oauth-2-0/authorization-code).

            <Accordion title="OAuth 1.0a for Twitter">
              #### Setting up Twitter OAuth 1.0a

              To configure [OAuth 1.0a](https://docs.x.com/resources/fundamentals/authentication/oauth-1-0a/api-key-and-secret) for X integration with Privy, first ensure your X developer account has at least Basic tier access, as OAuth 1.0a is only available for this tier and higher.

              Then, configure your app's permissions to match your integration needs (Read or Read and Write).

              Once you have completed setting up your Twitter app to allow for OAuth 1.0a authorization, you will need to provide the following to Privy in the dashboard:

              * Consumer API Key
              * Consumer API Secret

              #### Which OAuth version should I use?

              This guide explains the differences between OAuth 2.0 and OAuth 1.0a to help you determine which is most appropriate for your implementation. You can also read more about the differences between the 2 versions in the [X API docs.](https://docs.x.com/resources/fundamentals/authentication/overview)

              ##### OAuth 2.0

              OAuth 2.0 is the default authentication flow and recommended for most integrations due to its simplicity and ease of setup.

              #### Advantages

              * **Simple Implementation**: This flow is straightforward to set up and implement.
              * **Granular Permission Scopes**: You can specify which permissions to request (e.g., `users.tweet.read`, `users.tweet.write`).

              #### Limitations

              * **API Restriction**: OAuth 2.0 tokens can only access the X v2 API, not the v1.1 API.
              * **App-wide Rate Limits**: Rate limits are enforced across your entire application rather than per user.
                * For example, if the `users/me` endpoint has a rate limit of 450 requests per 15 minutes, and 500 users attempt to authenticate, the last 50 users would be rate-limited and unable to complete the login process.

              ### OAuth 1.0a

              OAuth 1.0a provides a different authentication approach with user-specific access tokens and separate rate limits.

              #### Advantages

              * **User-Specific Rate Limits**: Each user's API usage is rate-limited individually, preventing one user's activity from affecting others.
              * **Broader API Access**: OAuth 1.0a tokens can access both v2 and v1.1 APIs.
              * **Isolated User Authorization**: Returns user-specific access tokens with either read-only or read-write permissions.

              #### Limitations

              * **Less Granular Permissions**: OAuth 1.0a offers less specific permission control—tokens typically grant either full read access, full read-write access, or no authorization.
              * **Higher Tier Requirement**: Only supported for X developer accounts with Basic tier or higher.
              * **Implementation Complexity**: Creating OAuth signatures for API requests requires [additional code and setup](https://docs.x.com/resources/fundamentals/authentication/oauth-1-0a/creating-a-signature) compared to OAuth 2.0.
            </Accordion>
          </Accordion>
        </AccordionGroup>
      </Step>

      <Step title="Configure token return and custom scopes">
        For any OAuth login method for which you configure your own credentials, you are able to have the user's OAuth and Refresh access tokens returned to your application's front by toggling `Return OAuth tokens` and making use of the [useOAuthTokens](/recipes/react/oauth-tokens) hook.

        If you allow for your application to return OAuth tokens to the front-end, you are also able to configure custom scopes for the OAuth authorization flow, so that the OAuth token returned can be authorized to make API requests beyond the standard scope (such as writes, or authorized access to more granular user data).

        <Warning>
          It is important that OAuth and refresh tokens are highly sensitive tokens that should be handled
          and stored in a secure fashion, inaccessible to any other third-party systems. Contact us if you
          have questions or would like guidance on token management best practices.
        </Warning>
      </Step>
    </Steps>

    ### Notes

    * You can update them anytime, with the exception of Apple, LinkedIn, and TikTok.
    * You can set and save credentials for disabled providers. These credentials will be stored and will be used for that provider's requests once you enable it.
    * If you are experiencing an issue after setting your own credentials, you can roll back to using Privy's default credentials by removing your own from the configuration screen. We only recommend doing this if you are experiencing an issue as moving to use your own credentials is best practice. This will not work for Apple, LinkedIn, or TikTok if you have existing users.

    ### FAQ

    <br />

    #### Can I delete my custom credentials and go back to using the Privy default ones?

    You can remove your credentials from the same page you configured them to go back to using Privy's defaults. We only recommend doing this if you are experiencing an issue with your own credentials as migrating to your own credentials is the best practice.

    For Apple, LinkedIn, and TikTok, once your credentials are in use, you will not be able to reset them due to user migration (see below).

    #### Will migrating to custom credentials impact my users?

    For most providers, the change will be undetectable by end users, other than their seeing your app's name next time the log in (rather than Privy's). For Apple, LinkedIn, and TikTok, if your app currently uses Privy's default credentials, we do not support updating to custom credentials. This process requires a migration which we have not yet built.

    #### Can I configure my own custom OAuth provider to work with Privy?

    No, we do not support the use of OAuth providers outside of our supported set. If you'd like to use a different provider, you may be able to through the use of [custom auth](/authentication/user-authentication/jwt-based-auth/overview).
  </Accordion>

  <Accordion title="Telegram login">
    ## Telegram Login

    Follow [this](https://core.telegram.org/bots/tutorial#obtain-your-bot-token) guide to create a telegram bot. After creating a Telegram bot, you must set your domain using the `/setdomain` command in the `@BotFather` chat. You will need to provide the following to Privy via the Privy Dashboard upon completion:

    * Bot token (eg: `1234567890:AzByCxDwEvFuGtHsIr1k2M4o5Q6s7U8w9Y0`)
    * Bot handle (eg: `@MyBot_bot`)

    Note that when configuring Telegram login:

    * Your domain must be configured as your bot's allowed domain.
    * If you have CSP enforcement, you'll need to update these directives:
      * `script-src` must allow `https://telegram.org` in order to be able to download Telegram's widget script.
      * `frame-src` must allow `https://oauth.telegram.org` in order to be able to render Telegram's widget iframe.

    <Tip>
      To use your app as a Telegram Mini-App in the Telegram web client, add `http://web.telegram.org`
      and `https://web.telegram.org` to your allowed domains in the dashboard
      [Settings](https://dashboard.privy.io?page=settings) page.
    </Tip>

    <Warning>
      Telegram login requires developers to create a Telegram bot with a bot secret. This bot secret controls the Telegram bot and is also used as a symmetric key for authentication. Control over this key enables a developer to sign over authentication data, meaning compromise of this key puts your users (and their accounts) at risk.

      **Securing this symmetric key is essential for the security of all of your app's Telegram logins.**
    </Warning>

    <Info>
      Since you need to set your bot's allowed domain you'll need to use a tunneling tool for local
      development such as [Cloudflare
      tunnels](https://developers.cloudflare.com/pages/how-to/preview-with-cloudflare-tunnel/) or
      [ngrok](https://ngrok.com/).
    </Info>

    Learn more about Telegram authentication [here](/recipes/react/seamless-telegram).
  </Accordion>

  <Accordion title="Farcaster login">
    ## Farcaster login

    [**Farcaster**](https://www.farcaster.xyz/) is a sufficiently decentralized social network whose core social graph is stored on-chain. Users can choose how content they create is stored and it enables unique, composable experiences by enabling users to link their accounts with a wallet of their choosing.

    **Privy enables your users to easily log in to your app using their Farcaster account.** This means you can easily integrate Privy with Farcaster to compose experiences with a user's existing social graph or network.

    #### Automatically link connected wallets on when logging in with Farcaster

    Farcaster accounts generally have associated embedded and verified addresses. By toggling this option, upon logging in with Farcaster, Privy will also add the associated wallet addresses as linked external wallets of the authenticated user.
  </Accordion>
</AccordionGroup>

### Third-Party auth provider

If you plan to use Privy with a custom authentication provider like Auth0, Stytch, or Firebase, use the **Third-Party auth** page of the dashboard to register the required information from your provider. Otherwise, skip this guide!

<Info>
  **Don't see the Third-Party Auth page in the Dashboard?** Please request access to this feature
  via the [Plugins](https://dashboard.privy.io/apps?page=integrations\&tab=plugins) tab on the
  Integrations page.
</Info>

<AccordionGroup>
  <Accordion title="JWT Verification Details">
    To verify your user's auth status, Privy requires a verification key to ensure the JWTs received by Privy are valid. You must provide **one** of the following:

    * **JWKS endpoint**: If your provider uses [JWKS](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets) to sign JWTs, provide a JWKS endpoint to allow Privy to get your auth provider's JWT public key.

    ```
    {
      "keys": [
        {
          // JWKS
        }
      ]
    }
    ```

    * **Public Verification Key**: If your provider uses a single key to sign JWTs, provide the corresponding public key certificate used for verification.

    For Auth0, you can follow [these instructions](https://auth0.com/docs/get-started/tenant-settings/signing-keys/view-signing-certificates) to get these details.
  </Accordion>

  <Accordion title="JWT ID Claim">
    Enter the claim from your user's JWT that contains the user's unique ID. **In most access tokens and identity tokens, this is the [`sub`](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-claims) claim.**
  </Accordion>

  <Accordion title="JWT `aud` Claim (Optional)">
    `aud` accepts multiple values. If any of the `aud` values in the JWT are included in the set of allowed `aud` values, the JWT will be successfully verified.

    <Accordion title="Why does Privy need this information?">
      When a user logs into your app, your auth provider issues them an **access** and/or an
      **identity** token to represent their auth status. To provision your user's embedded wallet,
      **Privy must validate this token to authenticate your user.** Privy will verify both the token's
      signature and its expiration time
      ([`exp`](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.4) claim).
    </Accordion>
  </Accordion>
</AccordionGroup>


# Configuring appearance
Source: https://docs.privy.io/basics/get-started/dashboard/configuring-appearance



**Privy's UIs are highly-customizable to seamlessly match the branding and design system of your app.**

Read below to learn how to customize several aspects of Privy, including your app's [name](#app-name), [logo](), [theme](#theme), [login ordering](#order-of-login-methods), [displayed wallet options](#external-wallet-options), and more.

<Tip>
  Looking for sample UIs in Figma? Use Privy's [Figma community
  file](https://www.figma.com/community/file/1370772828942381228/sample-privy-uis?searchSessionId=lw15kidv-kln22bn8s6),
  which contains sample UIs for progressive onboarding, authentication, and embedded wallet
  transaction flows.
</Tip>

## App name

To change the name of your application, go to the **Privy Dashboard** and select your desired app from the dropdown in the navigation bar.

Then, navigate to the **UI components** page for your app and enter your app's name (as you'd like it to be presented to your users) in the **Name** field under the Branding tab.

The **Name** you enter here will be used to identify your application for your users, throughout Privy's UIs in your app modals, emails, and SMS messages sent to users with login codes.

## Logo

To configure a logo for your application, go to the **Privy Dashboard** and select your desired app from the dropdown in the navigation bar.

Then, navigate to the **UI components** page for your app and enter a URL for your app's logo in the **Logo** field. We recommend using an asset with a 2:1 aspect ratio and with a size of 180px x 90px. SVGs are not allowed due to poor compatibility with modern email clients. The URL should end in .png.

The **Logo** you save here will be used in the upfront login modal shown to users within your app, as well as emails sent to your users with their login codes. If you'd like to use a different logo for the upfront login modal versus the login email, you can override the logo shown in the login modal via the **`config.appearance.logo`** property of the **`PrivyProvider`** component, like so:

```tsx {6} theme={"system"}
<PrivyProvider
  appId="your-privy-app-id"
  config={{
    appearance: {
      // Defaults to the logo you set in the Dashboard
      logo: 'https://your.logo.url',
      ...insertTheRestOfYourAppearanceConfig
    },
    ...insertTheRestOfYourPrivyProviderConfig
  }}
>
  {children}
</PrivyProvider>
```

You can also opt to show no logo in the login modal by passing an empty string (`''`) to **`appearance.logo`**.

## Login screen header text

To configure the header text of the Privy login modal's landing screen, set a custom `string` as the **`config.appearance.landingHeader`** property of the **`PrivyProvider`** component, like so:

```tsx {6} theme={"system"}
<PrivyProvider
  appId="your-privy-app-id"
  config={{
    appearance: {
      // Defaults to 'Log in or sign up'
      landingHeader: 'Your custom header text',
      ...insertTheRestOfYourAppearanceConfig
    },
    ...insertTheRestOfYourPrivyProviderConfig
  }}
>
  {children}
</PrivyProvider>
```

We recommend using a `string` of length 35 or less. Strings longer than the width of the login modal will be ellipsified.

If you do not set a custom header text, it will default to 'Log in or sign up'.

## Login screen message text

To configure the message text of the Privy login modal's login screen, set a custom `string` as the **`config.appearance.loginMessage`** property of the **`PrivyProvider`** component, like so:

```tsx {6} theme={"system"}
<PrivyProvider
  appId="your-privy-app-id"
  config={{
    appearance: {
      // Defaults to 'Log in or sign up'
      loginMessage: 'Your custom header text',
      ...insertTheRestOfYourAppearanceConfig
    },
    ...insertTheRestOfYourPrivyProviderConfig
  }}
>
  {children}
</PrivyProvider>
```

We recommend using a `string` of length 100 or less. Strings longer than 100 characters will be truncated.

If you do not set a custom header text, there is no default.

## Theme

To configure a theme for your application, set the **`config.appearance.theme`** property of the **`PrivyProvider`** to `'light'`, `'dark'`, or a custom color as a hexadecimal string. The **`theme`** sets the core foreground and background colors for Privy's UIs in your app.

```tsx {6} theme={"system"}
<PrivyProvider
  appId="your-privy-app-id"
  config={{
    appearance: {
      // Defaults to 'light'
      theme: 'dark',
      ...insertTheRestOfYourAppearanceConfig
    },
    ...insertTheRestOfYourPrivyProviderConfig
  }}
>
  {children}
</PrivyProvider>
```

If you set the **`theme`** to `'light'` or `'dark'`, Privy's UIs will use Privy's standard light and dark themes, respectively. You can also set Privy's theme based on the user's system preferences by following this guide.

If you set the **`theme`** to a custom hexadecimal color, the **`theme`** color will be used as the *primary background color* for Privy's UIs. All other colors will be automatically generated by modulating the luminance of the theme color you set. This creates a cohesive palette that matches your app's branding.

<Tip>
  If you set a custom hexadecimal color as your **`theme`**, **we strongly recommend choosing a color that is either light *or* dark (> 80% or \< 20% luminance, as defined by [HSL](https://en.wikipedia.org/wiki/HSL_and_HSV))**. This helps ensure there is sufficient contrast between foreground and background colors in the Privy modal.
</Tip>

If you'd like, you may also override specific colors in Privy's UI to match your brand palette.

## Order of login methods

Privy allows you to enable both web2 (email, phone, and socials) and web3 (external wallet) login methods for your app. You can customize Privy to configure how you want these login methods to appear.

<Tip>
  Though Privy provides careful defaults around ordering of login methods, you can also fully customize the ordering of login methods by using the [`loginMethodsAndOrder` override](#order-of-login-methods).

  This will allow you to fully customize the ordering of your login methods, with any overflow items (after the first four) going to a secondary page.
</Tip>

For many apps, it is preferable to display wallet (or social) logins upfront and have users click to access the rest of the options. If you'd like to default to either web2 or web3 login methods appearing in your login modal, you can do so by setting the **`config.appearance.showWalletLoginFirst`** property of the **`PrivyProvider`** like so:

```tsx {6} theme={"system"}
<PrivyProvider
  appId="your-privy-app-id"
  config={{
    appearance: {
      // Defaults to true
      showWalletLoginFirst: true,
      ...insertTheRestOfYourAppearanceConfig
    },
    ...insertTheRestOfYourPrivyProviderConfig
  }}
>
  {children}
</PrivyProvider>
```

## CSS Overrides

Beyond the configuration properties above, Privy also enables you to **explicitly override specific colors** in the login modal, to further match your product's design system and color palette. You might use these overrides if you are using a default Privy [`theme`](#theme) ('light' or 'dark') and wish to tweak a certain color, or if you set a custom [`theme`](#theme) and want to use your exact brand colors instead of the automatically-generated ones.

To explicitly override colors in your Privy modal, simply add the corresponding CSS variable for the color to the CSS [`body`](https://developer.mozilla.org/en-US/docs/Web/CSS/:root) of your app, and set it to your custom color. The possible CSS variables are listed below; we encourage you to [use your browser's developer tools](https://developer.chrome.com/docs/devtools/css/) to experiment with different color combinations to find the right one for your app!

```css  theme={"system"}
body {
  --privy-border-radius-sm: 'your-custom-value';
  --privy-border-radius-md: 'your-custom-value';
  --privy-border-radius-lg: 'your-custom-value';
  --privy-border-radius-full: 'your-custom-value';
  --privy-color-background: 'your-custom-value';
  --privy-color-background-2: 'your-custom-value';
  --privy-color-background-3: 'your-custom-value';
  --privy-color-foreground: 'your-custom-value';
  --privy-color-foreground-2: 'your-custom-value';
  --privy-color-foreground-3: 'your-custom-value';
  --privy-color-foreground-4: 'your-custom-value';
  --privy-color-foreground-accent: 'your-custom-value';
  --privy-color-accent: 'your-custom-value';
  --privy-color-accent-light: 'your-custom-value';
  --privy-color-accent-lightest: 'your-custom-value';
  --privy-color-accent-dark: 'your-custom-value';
  --privy-color-accent-darkest: 'your-custom-value';
  --privy-color-success: 'your-custom-value';
  --privy-color-error: 'your-custom-value';
  --privy-color-error-light: 'your-custom-value';
}
```


# null
Source: https://docs.privy.io/basics/get-started/dashboard/create-new-app



Before using any Privy SDK, you'll need to create a new app in the Privy Dashboard. This will give you an **app ID** and **app secret** that you'll use to authenticate your app with Privy's APIs.

<Tip>
  We recommend creating a new app for each environment (e.g. development, staging, production) to
  keep your API credentials secure.
</Tip>

## Create an app

Login to the [Privy Dashboard](https://dashboard.privy.io) and create a new app if you haven't already.

## Get API credentials

Navigate to the[ Configuration > App settings > Basics ](https://dashboard.privy.io/apps?page=settings\&tab=basics) tab for your app.

Here you'll find your:

* **App ID**: A unique identifier for your application. It is a public value that can be safely exposed.
* **App Secret**: A secret key used to authenticate API requests. Do **not** expose it outside of your backend server.

<Warning>
  Privy does not store your app secret. Lost app secrets cannot be recovered and must be
  re-generated.
</Warning>

## Configure login methods (optional)

If you plan on using Privy for user onboarding, you'll need to configure the login methods you want to use in your app.
All client SDKs require at least one login method to be enabled - follow the steps [here](/basics/get-started/dashboard/configure-login-methods) to set up different options for your users!


# Dashboard MFA
Source: https://docs.privy.io/basics/get-started/dashboard/multi-factor



To keep your Privy developer account secure, Privy supports multi-factor authentication (MFA). Dashboard users can register an authenticator app and/or a passkey. Users will be prompted to verify with their registered method upon login.

To register an MFA method for your account, click the profile icon and open the **Account preferences** panel, then select **Enroll**.

<img src="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/dashboard-mfa-1.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=6f5db8f2d38b584fc31c282ded958f6b" alt="images/dashboard-mfa-1.png" data-og-width="5529" width="5529" data-og-height="3949" height="3949" data-path="images/dashboard-mfa-1.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/dashboard-mfa-1.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=4e2cfd7e07e69ed1d5b4eb0d5f07100d 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/dashboard-mfa-1.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=8a97b2ed86598125225966f35ae93bb3 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/dashboard-mfa-1.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=30ec8e51b4cfc2a59af5a83695f7fbf0 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/dashboard-mfa-1.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=9929c3de10b531a026be4c489325c0d4 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/dashboard-mfa-1.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=22a971291a3c5f37ea886395b9a385b3 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/dashboard-mfa-1.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=c3dd6e3401ce6e5c0b3fcd8151e00306 2500w" />


# Overview
Source: https://docs.privy.io/basics/get-started/dashboard/overview



Once you've set up your account, you can use the Dashboard to manage your **apps** and **team**.

Use the [Applications](https://dashboard.privy.io/account) page of the Dashboard to create and manage new apps for your account. Resources within Privy, including wallets, policies, users and more are scoped to individual apps. Use different apps to segregate development environments, userbases, API credentials, and more.

Use the [Team](https://dashboard.privy.io/team) page of the Dashboard to invite team members with different role permissions. Privy supports three team roles—Admin, Developer, and Viewer—each with specific permissions tailored to different responsibilities. Learn more about [team roles](/basics/get-started/dashboard/teammate-roles).


# Single sign-on
Source: https://docs.privy.io/basics/get-started/dashboard/sso

Configure SSO authentication for your team using Okta, Microsoft Entra ID, Google Workspace, or any SAML 2.0 provider

Single sign-on (SSO) allows your team members to access the Privy dashboard using your organization's identity provider. With SSO enabled, team members can authenticate using their existing corporate credentials, eliminating the need to manage separate login credentials for Privy.

<Info>
  SSO is available as an add-on for all plan tiers. Admins should visit the [Authentication
  tab](https://dashboard.privy.io/team?team=authentication) of the Dashboard to enable SSO.
</Info>

## How SSO works

When SSO is configured for your account, team members with email addresses from your verified domain are automatically redirected to your organization's identity provider when logging into the Privy dashboard. After successful authentication, they are redirected back to the dashboard with full access based on their assigned role.

SSO authentication integrates seamlessly with Privy's role-based access control. Learn more about [team roles](/basics/get-started/dashboard/teammate-roles).

## Supported identity providers

Privy's supports all major identity providers, including:

* **Okta**
* **Microsoft Entra ID** (formerly Azure AD)
* **Google Workspace**
* **OneLogin**
* **JumpCloud**
* **Rippling**
* And any SAML 2.0 compatible identity provider

## Prerequisites

Before setting up SSO, ensure:

* Your account has Admin access to the Privy dashboard
* Your organization has an active identity provider
* Your organization's IT team can configure SAML applications
* Your team members use email addresses from a domain you control

## Setting up SSO

### Domain verification

Domain verification ensures that only authorized members of your organization can use SSO to access your Privy account.

1. Navigate to the [Team page](https://dashboard.privy.io/team) in your dashboard
2. Click on the **Authentication** tab
3. In the **Single-Sign-On (SSO)** section, enter the domain you want to verify (e.g., `yourcompany.com`)
4. Add the provided TXT record to your domain's DNS configuration
5. Wait for DNS propagation (typically 15 minutes to one hour)

<Info>
  You can verify multiple domains for your account. All verified domains will use the same SSO
  configuration and identity provider.
</Info>

### Identity provider configuration

After verifying your domain, configure your identity provider to communicate with Privy:

1. On the **Authentication** tab, click **Configure identity provider**
2. Click **Open setup portal** to access the configuration interface
3. In the portal, select your identity provider from the list
4. Follow the provider-specific instructions to create a new SAML application
5. Copy the ACS URL and Entity ID from the portal into your identity provider's configuration
6. Download the metadata file or copy the SSO URL and certificate from your identity provider
7. Upload or paste these values in the configuration portal
8. Test the connection to ensure it's working correctly

<Tip>
  The configuration portal provides step-by-step instructions tailored to your specific identity
  provider. Follow these carefully to ensure proper configuration.
</Tip>

## Using SSO

Once SSO is configured and active, team members can sign in using SSO:

### For team members

1. Go to the [Privy dashboard login page](https://dashboard.privy.io)
2. Enter your work email address
3. You will be automatically redirected to your organization's identity provider
4. Authenticate using your corporate credentials
5. You will be redirected back to the Privy dashboard

### For admins

As an Admin, you can still access the dashboard using your original login method if needed. This ensures you can always access your account even if there are issues with the SSO configuration.

## Managing SSO

### Adding additional domains

You can add multiple domains to your SSO configuration:

1. Go to the **Authentication** tab on the [Team page](https://dashboard.privy.io/team)
2. Enter the new domain and press **Add**
3. Follow the domain verification process described above

All verified domains will use the same identity provider configuration.

### Removing domains

To remove a domain from your SSO configuration:

1. Navigate to the **Authentication** tab
2. Find the domain you want to remove
3. Click "Delete" in the domain's dropdown menu
4. Confirm the removal

<Warning>
  Removing your last verified domain will disable SSO for your account. Team members will need to
  use their original login method to access the dashboard.
</Warning>

### Updating identity provider settings

To update your identity provider configuration:

1. Navigate to the [Team page](https://dashboard.privy.io/team)
2. Click on the **Authentication** tab
3. In the **SSO configuration** section, click **Manage configuration**
4. Make your changes in the configuration portal
5. Test the connection to verify the changes

## Security considerations

### Automatic account provisioning

By default, automatic account provisioning is disabled. This means only team members who have been explicitly invited can log in via SSO.

To enable automatic provisioning:

1. Navigate to the [Team page](https://dashboard.privy.io/team)
2. Click on the **Authentication** tab
3. In the **Single-Sign-On (SSO)** section, toggle on "Enable automatic account provisioning"

When enabled, users who sign in via SSO for the first time will automatically have their team member account created. New SSO users are assigned the **Viewer** role by default. An Admin must manually update their role if they need elevated permissions.

### Session management

SSO sessions in the Privy dashboard are independent of your identity provider's sessions. Logging out of your identity provider does not automatically log you out of the Privy dashboard.

## Troubleshooting

### Domain verification fails

If domain verification is not working:

* Verify the TXT record was added correctly to your DNS configuration
* Wait longer for DNS propagation (can take up to 24 hours in some cases)
* Check for typos in the verification token
* Ensure the TXT record is added to the root domain, not a subdomain

### Users cannot sign in via SSO

If team members are having trouble signing in:

* Verify the domain is properly verified in the Privy dashboard
* Ensure the identity provider connection is marked as active
* Check that the user's email domain matches a verified domain
* Test the connection in the configuration portal
* Verify the user exists in your identity provider

### Connection not active

If your SSO connection is not showing as active:

* Complete all steps in the identity provider configuration
* Upload or enter all required SAML metadata
* Test the connection in the configuration portal

<Tip>For technical issues with SSO configuration, please [reach out](https://privy.io/slack).</Tip>

## Best practices

### Planning your rollout

* **Communicate changes**: Notify your team before enabling SSO about the new login process
* **Document backup access**: Ensure team members know how to request access if they have login issues

### Ongoing management

* **Review regularly**: Periodically review which domains are verified and ensure they're still needed
* **Monitor new users**: When new SSO users join, verify they have the appropriate role assigned
* **Keep contact information updated**: Ensure your identity provider's administrator contact information is current

### Security recommendations

* **Enable MFA at the identity provider**: Require multi-factor authentication in your identity provider for an additional security layer
* **Use the principle of least privilege**: Assign the minimum role necessary when promoting SSO users from Viewer
* **Regular access reviews**: Audit your team members and their roles periodically


# null
Source: https://docs.privy.io/basics/get-started/dashboard/teammate-roles



To keep your Privy app secure, Privy supports role based access control so you can limit different teammate's access permissions in the Dashboard. There are three teammate roles with different levels of access to your dashboard and account settings. Each role provides specific permissions designed to support different responsibilities within your organization.

## Role overview

| Role          | Access Level  | Primary Use Case                                                                               |
| ------------- | ------------- | ---------------------------------------------------------------------------------------------- |
| **Admin**     | Full access   | Team leads, account owners, and senior developers who need complete control                    |
| **Developer** | Most features | Developers who need to build and configure applications                                        |
| **Viewer**    | Read-only     | Stakeholders, support engineers, and teammates who need visibility without editing permissions |

## Detailed permissions

### Admin

Admins have full access to the dashboard and can manage all aspects of your Privy account.

**Team management:**

* Invite new teammates
* Manage teammate roles and permissions
* Remove teammates from the account

**Account management:**

* Update account payment methods
* Change billing tiers and subscription settings

**Security controls:**

* Create and delete app secrets
* Configure JWT authentication settings
* Rotate webhook verification keys
* Delete applications permanently

### Developer

Developers can view, create, and edit most dashboard features but cannot manage team settings or billing.

**Application development:**

* Create new applications
* Configure login methods and authentication
* Set up wallets and blockchain integrations
* Configure webhooks and API settings

**Limited access:**

* **Cannot** manage team roles or invite teammates
* **Cannot** update payment methods or billing settings
* **Cannot** delete applications
* **Cannot** create or delete app secrets
* **Cannot** configure JWT authentication settings
* **Cannot** rotate webhook verification keys

### Viewer

Viewers have read-only access to the dashboard for monitoring and visibility purposes.

**Read-only access:**

* View all applications and their configurations
* Access analytics and user data

**No editing permissions:**

* **Cannot** create, edit, or delete any configurations
* **Cannot** invite teammates or manage roles
* **Cannot** update billing or payment information

## Managing team roles

<Info>Only Admins can invite new teammates and assign roles.</Info>

### Inviting teammates

1. Navigate to the [Team page](https://dashboard.privy.io/team) in your dashboard
2. Click "Invite teammate"
3. Enter the email address of the person you want to invite
4. Select their role from the dropdown menu
5. Click "Send invitation"

### Changing roles

Admins can update teammate roles at any time:

1. Go to the [Team page](https://dashboard.privy.io/team)
2. Find the teammate whose role you want to change
3. Click on their current role dropdown
4. Select the new role
5. Confirm the change

### Removing teammates

Only Admins can remove teammates from the account:

1. Navigate to the [Team page](https://dashboard.privy.io/team)
2. Find the teammate you want to remove
3. Click the "Remove" button next to their name
4. Confirm the removal

<Warning>
  Removing a teammate immediately revokes their access to your Privy dashboard and all associated
  applications.
</Warning>

## Best practices

### Role assignment guidelines

* **Start with Viewer access**: Give new teammates Viewer access initially to let them familiarize themselves with your setup
* **Use Developer for most technical work**: Developers can handle day-to-day application building and configuration
* **Limit Admin access**: Only assign Admin roles to team leads and senior developers who need full account control

### Security considerations

* **Regularly review teammate access**: Audit your teammates and their roles periodically
* **Use the principle of least privilege**: Assign the minimum role necessary for each teammate's responsibilities
* **Remove access promptly**: When teammates leave your organization, remove their access immediately

<Tip>
  Need help determining the right role for a teammate? Consider their daily responsibilities and
  start with the most restrictive role that allows them to complete their work.
</Tip>


# Choose your platform
Source: https://docs.privy.io/basics/get-started/platforms



export const FeatureMatrix = ({sdk}) => {
  const sdks = sdk ? [sdk] : ['react', 'reactNative', 'swift', 'android', 'flutter', 'unity'];
  const sdkNames = {
    react: 'React',
    reactNative: 'React Native',
    swift: 'Swift',
    android: 'Android',
    flutter: 'Flutter',
    unity: 'Unity'
  };
  const matrix = [{
    name: 'Authentication',
    features: [{
      name: 'Email',
      react: true,
      reactNative: true,
      swift: true,
      android: true,
      flutter: true,
      unity: true
    }, {
      name: 'SMS',
      react: true,
      reactNative: true,
      swift: true,
      android: true,
      flutter: true
    }, {
      name: 'OAuth',
      react: true,
      reactNative: true,
      swift: 'Google, Apple, Twitter, Discord',
      android: 'Google, Discord, Twitter',
      flutter: 'Google, Apple, Twitter, Discord',
      unity: 'Google, Apple, Twitter, Discord'
    }, {
      name: 'SIWE (Sign In with Ethereum)',
      react: true,
      reactNative: true,
      swift: true
    }, {
      name: 'SIWS (Sign In with Solana)',
      react: true,
      reactNative: true
    }, {
      name: 'Farcaster',
      react: true,
      reactNative: true
    }, {
      name: 'Telegram',
      react: true
    }, {
      name: 'Custom Auth',
      react: true,
      reactNative: true,
      swift: true,
      android: true,
      flutter: true
    }, {
      name: 'Passkeys',
      react: true,
      reactNative: true
    }]
  }, {
    name: 'Farcaster',
    features: [{
      name: 'SIWF',
      react: true,
      reactNative: true
    }]
  }, {
    name: 'Embedded Wallets',
    features: [{
      name: 'Creating wallets manually',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum', 'solana'],
      android: ['ethereum', 'solana'],
      flutter: ['ethereum', 'solana'],
      unity: ['ethereum', 'solana']
    }, {
      name: 'Creating wallets automatically',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Pregenerating wallets',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum', 'solana'],
      android: ['ethereum', 'solana'],
      flutter: ['ethereum', 'solana']
    }, {
      name: 'Signing messages and transactions',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum', 'solana'],
      android: ['ethereum', 'solana'],
      flutter: ['ethereum', 'solana'],
      unity: ['ethereum', 'solana']
    }, {
      name: 'Broadcasting transactions',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum'],
      android: ['ethereum'],
      flutter: ['ethereum'],
      unity: ['ethereum']
    }, {
      name: 'Native smart wallets',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: 'Automatic recovery',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum', 'solana'],
      android: ['ethereum', 'solana'],
      flutter: ['ethereum', 'solana'],
      unity: ['ethereum']
    }, {
      name: 'User controlled recovery',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Transaction MFA',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Key Export',
      react: ['ethereum', 'solana']
    }, {
      name: 'Key Import',
      react: ['ethereum', 'solana']
    }, {
      name: 'HD wallets',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum'],
      android: ['ethereum'],
      flutter: ['ethereum'],
      unity: ['ethereum']
    }, {
      name: 'Session signers',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Global wallets (Cross App Accounts)',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: 'Custom EVM (Ethereum) network support',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: 'Custom SVM (Solana) network support',
      react: ['solana'],
      reactNative: ['solana']
    }]
  }, {
    name: 'Connectors',
    features: [{
      name: 'External wallets',
      react: ['ethereum', 'solana']
    }, {
      name: 'Wagmi',
      react: ['ethereum']
    }, {
      name: 'Viem',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: 'Ethers',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: '@solana/web3.js',
      react: ['solana']
    }, {
      name: 'web3swift',
      swift: ['ethereum']
    }]
  }, {
    name: 'Funding',
    features: [{
      name: 'Transfer or bridge from wallet',
      react: ['ethereum', 'solana']
    }, {
      name: 'Transfer from exchange',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Pay with card',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }]
  }];
  const filteredMatrix = matrix.map(section => {
    return {
      ...section,
      features: section.features.filter(featureItem => {
        if (sdk) {
          return featureItem[sdk] !== undefined;
        }
        return true;
      })
    };
  }).filter(section => {
    return section.features.length > 0;
  });
  return <table style={{
    display: 'table',
    width: '100%'
  }}>
      {sdk ? null : <thead>
          <tr>
            <th></th>
            {sdks.map(sdk => <th>{sdkNames[sdk]}</th>)}
          </tr>
        </thead>}
      <tbody>
        {filteredMatrix.map(section => <>
            <tr>
              <td>
                <strong>{section.name}</strong>
              </td>
              {sdks.map(() => <td></td>)}
            </tr>
            {section.features.map(feature => <tr>
                <td>
                  <em>{feature.name}</em>
                </td>
                {sdks.map(sdk => {
    const supported = feature[sdk];
    if (supported === true) {
      return <td>✅</td>;
    } else if (!supported) {
      return <td></td>;
    } else if (Array.isArray(supported)) {
      return <td>
                        {supported.map(item => item === 'ethereum' ? <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/ethereum.png" noZoom style={{
        display: 'inline',
        margin: '2px',
        width: '18px'
      }} /> : <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/solana.png" noZoom style={{
        display: 'inline',
        margin: '2px',
        width: '18px'
      }} />)}
                      </td>;
    } else {
      return <td>{supported}</td>;
    }
  })}
              </tr>)}
          </>)}
      </tbody>
    </table>;
};

export const Solana = () => {
  return <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/solana.png" noZoom style={{
    display: 'inline',
    margin: '2px',
    width: '18px'
  }} />;
};

export const Ethereum = () => {
  return <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/ethereum.png" noZoom style={{
    display: 'inline',
    margin: '2px',
    width: '18px'
  }} />;
};

Privy builds flexible wallet and key management infrastructure to power better products built on crypto rails. You can choose to integrate with Privy's **REST API** directly, or leverage our platform-specific **SDKs** to securely provision wallets and manage assets.

<img src="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Platform2.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=1ae659247712f78f81d6a55be12c2cc9" alt="images/Platform2.png" data-og-width="3688" width="3688" data-og-height="1506" height="1506" data-path="images/Platform2.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Platform2.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=892509b30c619c782c0456e0d285b12e 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Platform2.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=1fbaff392bad8881f58be1aef918884b 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Platform2.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=c65956a6d3fa7720895c08a11149bf96 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Platform2.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=7ecc9d27fac3a0161f5084d6c2df1b81 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Platform2.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=faf57a0c67ee472f54d9cdd600381119 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Platform2.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=f91a2ecd0049b9af12c098f724667d6a 2500w" />

## REST API

The Privy API is a resource-oriented API designed with RESTful principles. You can use the API to create and use wallets on different blockchains, set granular policies and controls, and manage ownership over different resources.

You can make requests to Privy's API from any environment that supports HTTPS requests and securely storing an API secret. Once you've provisioned wallets from Privy's REST API, you can continue to use and manage those wallets from the REST API or additionally integrate Privy's supported SDKs.

<Info>
  Privy's API have extended support for many blockchain ecosystems. Learn more about the distinct
  tiers of support for each blockchain in our [chain support](/wallets/overview/chains) guide.
</Info>

## SDKs

Privy offers multiple SDKs for various languages and frameworks. These SDKs wrap the Privy REST API into interfaces and abstractions that are idiomatic to your framework, streamlining your integration.

If your framework is not supported by the SDKs below, you can always integrate Privy's REST API directly or build a slim client SDK for your framework.

### Client-side SDKs

Client-side SDKs are designed for use in web and mobile applications, providing hooks and components for authenticating users and securely provisioning wallets.

| SDK                                               | Description                                                                                                          | Supported environments                                      |
| ------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------- |
| [React](/basics/react/installation)               | A client-side React SDK with hooks and components for authenticating users and securely provisioning wallets.        | Web apps built with React.                                  |
| [React Native](/basics/react-native/installation) | A client-side React Native SDK with hooks and components for authenticating users and securely provisioning wallets. | Mobile apps (iOS, Android) built with Expo or React Native. |
| [Swift](/basics/swift/installation)               | A client-side Swift SDK with methods for authenticating users and securely provisioning wallets.                     | Mobile apps (iOS) built with Swift.                         |
| [Android](/basics/android/installation)           | A client-side Kotlin SDK with methods for authenticating users and securely provisioning wallets.                    | Mobile apps (Android) built with Kotlin.                    |
| [Flutter](/basics/flutter/installation)           | A client-side Flutter SDK with methods for authenticating users and securely provisioning wallets.                   | Mobile apps (iOS, Android) built with Flutter.              |
| [Unity](/basics/unity/installation)               | A client-side Unity SDK with methods for authenticating users and securely provisioning wallets.                     | Games built with Unity.                                     |

#### Client-side SDK features

Check out the matrix below to determine which features are supported in each client SDK. As a guide:

* <Ethereum /> - indicates the feature is available on EVM chains.
* <Solana /> - indicates the feature is available on Solana.
* <Ethereum /> <Solana /> - indicates the feature is available on both EVM and Solana.

<FeatureMatrix />

### Server-side SDKs

Server-side SDKs are designed for backend environments, with the full functionality of the Privy API to enable a streamlined integration.

| SDK                                                             | Description                                                                                                                                      | Supported environments                                         |
| --------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------- |
| [NodeJS](/basics/nodeJS/installation)                           | A server-side Node SDK that supports securely provisioning wallets, configuring policies and ownership, and managing user data.                  | Server-side JS runtimes, including Node, Deno, Bun, Edge, etc. |
| [Java](/basics/java/installation)                               | A server-side Java SDK that supports securely provisioning wallets, configuring policies and ownership, and managing user data.                  | Server-side Java environments.                                 |
| [Python](/basics/python/installation)                           | A server-side Python SDK that supports securely provisioning wallets, configuring policies and ownership, and managing user data.                | Server-side Python environments.                               |
| [Rust](/basics/rust/installation)                               | A server-side Rust SDK that supports securely provisioning wallets, configuring policies and ownership, and managing user data.                  | Server-side Rust environments.                                 |
| [NodeJS (server-auth)](/basics/nodeJS-server-auth/installation) | **(Deprecated)** A server-side Node SDK that supports securely provisioning wallets, configuring policies and ownership, and managing user data. | Server-side JS runtimes, including Node, Deno, Bun, Edge, etc. |

<Info>
  **Is there a particular feature that you'd like support for within a certain SDK?** [Please reach
  out!](https://privy.io/slack)
</Info>


# null
Source: https://docs.privy.io/basics/java/installation



In a backend Java environment, you can use the
[`io.privy.api:privy-java`](https://central.sonatype.com/artifact/io.privy.api/privy-java) library
to authorize requests and manage your application from your server.
This library enables interacting with Privy's API to query and creates users, create wallets, send
assets, and more.

The package is hosted on Maven Central, and can be pulled into your project through standard
Maven/Gradle/your chosen method. For example, with Maven, this should look like:

```xml title="pom.xml" theme={"system"}
<dependency>
    <groupId>io.privy.api</groupId>
    <artifactId>privy-java</artifactId>
    <version>X.Y.Z</version>
</dependency>
```

<Info>
  `X.Y.Z` is the version of the library you want to use. Check out our [latest version
  here](https://central.sonatype.com/artifact/io.privy.api/privy-java).
</Info>


# Quickstart
Source: https://docs.privy.io/basics/java/quickstart

Learn how to create users, embedded wallets, and send transactions in your Java app

## 0. Prerequisites

This guide assumes that you have completed the [Setup](/basics/java/setup) guide.

## 1. Creating a wallet

First, we will create a wallet.
You will use this wallet's `id` in future calls to sign messages and send transactions.

<Tabs>
  <Tab title="Ethereum">
    ```java  theme={"system"}
    try {
        WalletCreateRequestBody walletRequest = WalletCreateRequestBody.builder()
            .chainType(WalletChainType.ETHEREUM)
            .build();

        WalletCreateResponse response = privyClient.wallets().create(walletRequest)
        if (response.wallet().isPresent()) {
            Wallet createdWallet = response.wallet().get();
        }
    } catch (APIException e) {
        String errorBody = e.bodyAsString();
        System.err.println(errorBody);
    } catch (Exception e) {
        System.err.println(e.getMessage());
    }
    ```
  </Tab>

  <Tab title="Solana">
    ```java  theme={"system"}
    try {
        WalletCreateRequestBody walletRequest = WalletCreateRequestBody.builder()
            .chainType(WalletChainType.SOLANA)
            .build();

        WalletCreateResponse response = privyClient.wallets().create(walletRequest)
        if (response.wallet().isPresent()) {
            Wallet createdWallet = response.wallet().get();
        }
    } catch (APIException e) {
        String errorBody = e.bodyAsString();
        System.err.println(errorBody);
    } catch (Exception e) {
        System.err.println(e.getMessage());
    }
    ```
  </Tab>
</Tabs>

<Tip>[Learn more](/wallets/wallets/create/create-a-wallet) about creating wallets.</Tip>

## 2. Signing a message

Next, we'll sign a plaintext message with the wallet using the `signMessage` method.
Make sure to specify your wallet ID (not address) from creation in the input.

<Tabs>
  <Tab title="Ethereum">
    ```java  theme={"system"}
    try {
        String message = "Hello, Privy!";

        EthereumPersonalSignRpcResponseData response = privyClient
            .wallets()
            .ethereum()
            .signMessage(
                walletId,
                message.getBytes(StandardCharsets.UTF_8),
                AuthorizationContext.builder().build()
            );

        String signature = response.signature();
    } catch (APIException e) {
        String errorBody = e.bodyAsString();
        System.err.println(errorBody);
    } catch (Exception e) {
        System.err.println(e.getMessage());
    }
    ```
  </Tab>

  <Tab title="Solana">
    ```java  theme={"system"}
    try {
        String message = "Hello, Privy!";

        EthereumPersonalSignRpcResponseData response = privyClient
            .wallets()
            .solana()
            .signMessage(
                walletId,
                message.getBytes(StandardCharsets.UTF_8),
                AuthorizationContext.builder().build()
            );

        String signature = response.signature();
    } catch (APIException e) {
        String errorBody = e.bodyAsString();
        System.err.println(errorBody);
    } catch (Exception e) {
        System.err.println(e.getMessage());
    }
    ```
  </Tab>
</Tabs>

<Tip>[Learn more](/wallets/using-wallets/ethereum/sign-a-message) about signing messages.</Tip>

## 3. Sending transactions

<Info>
  Your wallet must have some funds in order to send a transaction. You can use a testnet
  [faucet](https://console.optimism.io/faucet) to test transacting on a testnet (e.g. Base Sepolia)
  or send funds to the wallet on the network of your choice.
</Info>

To send a transaction from your wallet, use the `sendTransaction` method.
It will populate missing network-related values (gas limit, gas fee values, nonce, type), sign your
transaction, broadcast it to the network, and return the transaction hash to you.

In the request, make sure to specify your wallet `id` from your wallet creation above, as well as
the `caip2` chain ID and `chainId` values for the network you want to transact on.
Also, input your recipient or smart contract address in the `to` field.

<Tabs>
  <Tab title="Ethereum">
    ```java  theme={"system"}
    try {
        String caip2 = "eip155:11155111"; // Sepolia testnet

        EthereumSendTransactionRpcInputTransaction txn = EthereumSendTransactionRpcInputTransaction.builder()
            .to(recipientAddress)
            .value(EthereumSendTransactionRpcInputValue.of("0x1")) // 1 wei
            .chainId(EthereumSendTransactionRpcInputChainId.of(11_155_111)) // Sepolia testnet
            .build();

        EthereumSendTransactionRpcResponseData response = privyClient
            .wallets()
            .ethereum()
            .sendTransaction(
                senderWalletId,
                caip2,
                txn,
                AuthorizationContext.builder().build()
            );

        String transactionHash = response.hash();
    } catch (APIException e) {
        String errorBody = e.bodyAsString();
        System.err.println(errorBody);
    } catch (Exception e) {
        System.err.println(e.getMessage());
    }
    ```
  </Tab>

  <Tab title="Solana">
    ```java  theme={"system"}
    try {
        String caip2 = "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp"; // Solana Mainnet

        // A base64 encoded serialized transaction to sign
        String transaction = "insert-base-64-encoded-serialized-transaction";

        SolanaSignAndSendTransactionRpcResponseData response = privyClient.wallets().solana()
            .signAndSendTransaction(
                senderWalletId,
                caip2,
                transaction,
                AuthorizationContext.builder().build()
            );

        String transactionHash = response.hash();
    } catch (APIException e) {
        String errorBody = e.bodyAsString();
        System.err.println(errorBody);
    } catch (Exception e) {
        System.err.println(e.getMessage());
    }
    ```
  </Tab>
</Tabs>

<Tip>
  [Learn more](/wallets/using-wallets/ethereum/send-a-transaction) about sending transactions.
</Tip>

<Tip>
  If you’re interested in more control, you can prepare and broadcast the transaction yourself, and
  simply use `eth_signTransaction` ([EVM](/wallets/using-wallets/ethereum/sign-a-transaction)) and
  `signTransaction` ([Solana](/wallets/using-wallets/solana/sign-a-transaction)) RPCs to sign the
  transaction with a wallet.
</Tip>

## 4. Creating a user

To create a user for your application, you can use the `create` method, passing in
a `UserCreateRequestBody` object, which allows you to specify the linked accounts, custom metadata,
and wallets that should be associated with said user.

```java  theme={"system"}
try {
    // Linked accounts to be created for user
    List<LinkedAccountInput> createUserLinkedAccounts = List.of(
        LinkedAccountInput.customAuth(subjectId),
        LinkedAccountInput.email(email)
    );

    // Build request body
    UserCreateRequestBody requestBody = UserCreateRequestBody
        .builder()
        .linkedAccounts(createUserLinkedAccounts)
        .build();

    // Send request to create user
    UserCreateResponse response = privyClient.users().create(requestBody);
    if (response.user().isPresent()) {
        User user = response.user().get();
        String userId = user.id();
    }
} catch (APIException e) {
    String errorBody = e.bodyAsString();
    System.err.println(errorBody);
} catch (Exception e) {
    System.err.println(e.getMessage());
}
```

<Tip>
  [Learn more](/user-management/migrating-users-to-privy/create-or-import-a-user) about creating
  users, and look at our [pregenerating wallets](/recipes/pregenerate-wallets) guide for linking
  wallets to your users before they even sign in.
</Tip>

## Next steps & advanced topics

* For an additional layer of security, you can choose to sign your requests with [authorization keys](/controls/authorization-keys/overview).
* To restrict what wallets can do, you can set up [policies](/controls/policies/overview).
* To prevent double sending the same transaction, take a look at our support for [idempotency](/api-reference/idempotency-keys) keys.
* If you want to require multiple parties to sign off before sending a transaction for a wallet, you can accomplish this through the use of [quorum approvals](/controls/quorum-approvals/overview).


# null
Source: https://docs.privy.io/basics/java/setup



## Prerequisites

Before you begin, make sure you have [set up your Privy app and obtained your app ID and app
secret](/basics/get-started/dashboard/create-new-app) from the Privy Dashboard.

## Getting the `PrivyClient`

Import the `PrivyClient` class and create an instance of it, passing the Privy **app ID** and
**app secret** as parameters.

```java  theme={"system"}
import io.privy.api.PrivyClient;

PrivyClient client = PrivyClient.builder()
        .appId("your-privy-app-id")
        .appSecret("your-app-secret")
        .build();
```

This `client` is now your entrypoint to manage Privy from your server. With the `PrivyClient` you
can interact with wallets with methods for creating wallets, signing and sending transactions.
You can also manage users with methods for getting a user object, verifying an auth token, and
querying users.

## Authorization

If a resource (i.e. wallet, policy, key quorum) has an [owner](/controls/authorization-keys/using-owners/overview),
[authorization signatures](/api-reference/authorization-signatures) from the owner are required.
Use the [authorization context](/controls/authorization-keys/using-owners/sign/signing-on-the-server) to specify authorization private keys
and user JWTs of the wallet's owners, and the Java SDK will generate signatures and sign requests
under the hood.

<Tip>
  We strongly recommend reading [this
  guide](/controls/authorization-keys/using-owners/sign/signing-on-the-server) before using the Java
  SDK for the best development experience.
</Tip>

```java  theme={"system"}
AuthorizationContext context = AuthorizationContext.builder()
    .addUserJwts(Arrays.asList("jwt1", "jwt2"))
    .addAuthorizationPrivateKeys(Arrays.asList("privateKey1", "privateKey2"))
    .build();
```

## Rate limits

Privy rate limits REST API endpoints that you may call from your server. If you suspect your team
will require an increased rate limit, please [reach out](https://privy.io/slack).

<Tip>
  Learn more about optimizing your setup in our [optimizing](/recipes/dashboard/optimizing) guide!
</Tip>


# Migrating from server-auth
Source: https://docs.privy.io/basics/nodeJS/advanced/migrating-from-server-auth



## Overview

If your app previously used Privy's `@privy-io/server-auth` SDK, follow the migration guide below to
upgrade to the `@privy-io/node` package.

The new `@privy-io/node` package is a major upgrade from the `@privy-io/server-auth` package, with
an improved structure, error handling, and better support for the latest features available in
Privy's API.

## Initialization

### 0. System requirements

The new `@privy-io/node` package, like its predecessor, is compatible with multiple server-side JavaScript runtimes.
Specifically, the following runtime versions are supported:

* Node.js 20 LTS or later ([non-EOL](https://endoflife.date/nodejs)) versions.
* Deno v1.28.0 or higher.
* Bun 1.0 or later.
* Cloudflare Workers.
* Vercel Edge Runtime.
* Nitro v2.6 or greater.

Refer to the [package's README](https://npmjs.com/package/@privy-io/node) for the most up-to-date list of supported runtimes.

### 1. Privy client initialization

The `PrivyClient` class now takes in a single configuration object, instead of
positional `appId` and `appSecret` parameters.

```ts  theme={"system"}
import {PrivyClient} from '@privy-io/server-auth' // [!code --]
import {PrivyClient as NewPrivyClient} from '@privy-io/node'; // [!code ++]

const privy = new PrivyClient('insert-your-app-id', 'insert-your-app-secret'); // [!code --]
const newPrivy = new NewPrivyClient({ // [!code ++]
  appId: 'insert-your-app-id', // [!code ++]
  appSecret: 'insert-your-app-secret' // [!code ++]
}); // [!code ++]
```

This results in a more consistent API as other configuration options are set.

### 2. Working with resources

The new package splits different groups of methods into resource-specific interfaces.

Whereas before you could call methods directly on the `PrivyClient` instance, you now generally need
to call methods on the resource-specific interfaces.

<Tip>
  The new SDK offers a one-to-one mapping of the API endpoints described in the [API
  reference](/api-reference/introduction). To facilitate this, methods called on the `PrivyClient`
  instance that need parameters to be passed in now take those in `snake_case` instead of
  `camelCase`, matching the API format exactly.
</Tip>

For example, for creating or importing a user with the `@privy-io/node` package, you will use the `users()` interface:

```ts {skip-check} theme={"system"}
import {AuthorizationContext, PrivyClient} from '@privy-io/node';

const privy = new PrivyClient({appId: 'insert-your-app-id', appSecret: 'insert-your-app-secret'});

const user = await privy.importUser({ // [!code --]
  linkedAccounts: [{type: 'email', address: 'test@example.com'}], // [!code --]
  wallets: [{chainType: 'ethereum'}] // [!code --]
}); // [!code --]
const user = await privy.users().create({ // [!code ++]
  // [!code ++]
  linked_accounts: [{type: 'email', address: 'test@example.com'}], // [!code ++]
  wallets: [{chain_type: 'ethereum'}] // [!code ++]
}); // [!code ++]
```

Likewise, many of the methods that were previously under the `walletApi` interface are now under the `wallets()` or \` interface.

| In `@privy-io/server-auth`             | In `@privy-io/node`                      |
| -------------------------------------- | ---------------------------------------- |
| `privy.walletApi.createWallet`         | `privy.wallets().create`                 |
| `privy.walletApi.rpc`                  | `privy.wallets().rpc`                    |
| `privy.walletApi.ethereum.signMessage` | `privy.wallets().ethereum().signMessage` |
| `privy.walletApi.createPolicy`         | `privy.policies().create`                |

### 3. Authorization signatures

The new package introduces the [`AuthorizationContext` interface](/controls/authorization-keys/using-owners/sign/signing-on-the-server),
which simplifies the process of generating authorization signatures.

```ts  theme={"system"}
import {PrivyClient} from '@privy-io/server-auth' // [!code --]
import {AuthorizationContext} from '@privy-io/node'; // [!code ++]

const privy = new PrivyClient('insert-your-app-id', 'insert-your-app-secret'); // [!code --]

privy.walletApi.updateAuthorizationKey('insert-your-authorization-private-key'); // [!code --]
const authorizationContext: AuthorizationContext = { // [!code ++]
  authorization_private_keys: ['insert-your-authorization-private-key'] // [!code ++]
}; // [!code ++]
```

Unlike before, where you would need to manually set an authorization key at the level of the client,
you will now **pass the authorization context as a parameter** to the method you are calling, giving you
fine grained control over the authorization context for each call, **allowing you to use different keys or
quorums for each request**.

Further, the new interface support combining different signing mechanisms in the authorization context as you see fit, for example,
by combining a user JWT and an authorization key for a resource that is owned by both a user and a service:

```ts  theme={"system"}
import {PrivyClient} from '@privy-io/server-auth' // [!code --]
import {AuthorizationContext} from '@privy-io/node';

const privy = new PrivyClient('insert-your-app-id', 'insert-your-app-secret'); // [!code --]

const {authorizationKey} = await privy.walletApi.generateUserSigner({ // [!code --]
  userJwt: 'insert-user-jwt' // [!code --]
}); // [!code --]
privy.walletApi.updateAuthorizationKey(authorizationKey); // [!code --]
const authorizationContext: AuthorizationContext = { // [!code ++]
  user_jwts: ['insert-user-jwt'], // [!code ++]
  authorization_private_keys: ['insert-authorization-private-key'] // [!code ++]
}; // [!code ++]
```

Check out the [Authorization Context](/controls/authorization-keys/using-owners/sign/signing-on-the-server) guide in full for more details on the new interface.

<Warning>
  The `privy.walletApi.generateUserSigner` method is no longer available in the `@privy-io/node`
  package. Instead you can set the `user_jwts` property on the authorization context, and the SDK
  will handle the authorization keys automatically.
</Warning>


# null
Source: https://docs.privy.io/basics/nodeJS/installation



<Info>
  This guide is for the **`@privy-io/node`** library. If you are looking for the deprecated
  **`@privy-io/server-auth`** library, please see the
  [NodeJS](/basics/nodeJS-server-auth/installation) guide.
</Info>

In a backend JS environment, you can use the **`@privy-io/node`** library to authorize requests and
manage your application from your server.
This library includes helpful utilities around verifying access tokens issued by Privy and
interacting with Privy's API to query and import users, create wallets, manage invite lists, and
more.

Install the Privy Server SDK using your package manager of choice:

<CodeGroup>
  ```bash npm theme={"system"}
  npm install @privy-io/node@latest
  ```

  ```bash pnpm theme={"system"}
  pnpm install @privy-io/node@latest
  ```

  ```bash yarn theme={"system"}
  yarn add @privy-io/node@latest
  ```
</CodeGroup>


# Quickstart
Source: https://docs.privy.io/basics/nodeJS/quickstart

Learn how to create users, embedded wallets, and send transactions in your NodeJS app

<Info>
  This guide is for the **`@privy-io/node`** library. If you are looking for the deprecated
  **`@privy-io/server-auth`** library, please see the
  [NodeJS](/basics/nodeJS-server-auth/quickstart) guide.
</Info>

## 0. Prerequisites

This guide assumes that you have completed the [Setup](/basics/nodeJS-server-auth/setup) guide,
to get a Privy client instance, `privy`.

## 1. Creating a wallet

First, we will create a wallet.
You will use this wallet's `id` in future calls to sign messages and send transactions.

<Tabs>
  <Tab title="Ethereum">
    ```ts  theme={"system"}
    import { APIError, PrivyAPIError } from '@privy-io/node';

    try {
      const createdWallet = await privy.wallets().create({chain_type: 'ethereum'});
      const walletId = createdWallet.id;
    } catch (error) {
      if (error instanceof APIError) {
        // When the library is unable to connect to the API,
        // or if the API returns a non-success status code (i.e., 4xx or 5xx response),
        // a subclass of `APIError` will be thrown:
        console.log(error.status); // 400
        console.log(error.name); // BadRequestError
      } else if (error instanceof PrivyAPIError) {
        // Other errors from the Privy SDK all subclass `PrivyAPIError`.
        console.log(error.message);
      } else {
        // This error is not related to the Privy SDK.
        throw error;
      }
    }
    ```
  </Tab>

  <Tab title="Solana">
    ```ts  theme={"system"}
    import { APIError, PrivyAPIError } from '@privy-io/node';

    try {
      const createdWallet = privy.wallets().create({chain_type: 'solana'});
      const walletId = createdWallet.id;
    } catch (error) {
      if (error instanceof APIError) {
        // When the library is unable to connect to the API,
        // or if the API returns a non-success status code (i.e., 4xx or 5xx response),
        // a subclass of `APIError` will be thrown:
        console.log(error.status); // 400
        console.log(error.name); // BadRequestError
      } else if (error instanceof PrivyAPIError) {
        // Other errors from the Privy SDK all subclass `PrivyAPIError`.
        console.log(error.message);
      } else {
        // This error is not related to the Privy SDK.
        throw error;
      }
    }
    ```
  </Tab>
</Tabs>

<Tip>[Learn more](/wallets/wallets/create/create-a-wallet) about creating wallets.</Tip>

<Note>
  When using the `PrivyClient` to work with the API, all errors thrown will be instances of
  `APIError` or `PrivyAPIError`. You should catch these errors and handle them accordingly, using
  the error's `status`, `name` and `message`.
</Note>

### User wallets

You can create a self-custodial user wallet using the SDK. First, create a user, then provision a wallet for that user.

<Tabs>
  <Tab title="Ethereum">
    ```ts  theme={"system"}
    try {
      const user = await privy.users().create({
        linked_accounts: [{type: 'email', address: 'batman@privy.io'}],
      });

      const {id, address, chain_type} = await privy.wallets().create({
        chain_type: 'ethereum',
        owner: {user_id: user.id}
      });

    } catch (error) {
      console.error(error);
    }
    ```
  </Tab>

  <Tab title="Solana">
    ```ts  theme={"system"}
    try {
      const user = await privy.users().create({
        linked_accounts: [{type: 'email', address: 'batman@privy.io'}],
      });

     const {id, address, chain_type} = await privy.wallets().create({
        chain_type: 'solana',
        owner: {user_id: user.id}
      });

    } catch (error) {
      console.error(error);
    }
    ```
  </Tab>
</Tabs>

<Info>
  If you are creating a user wallet, you must specify the user ID as the owner of the wallet. You can obtain a user ID by first [creating a user](/user-management/migrating-users-to-privy/create-or-import-a-user) before creating the wallet.

  Or, you can [create a user and wallet at the same time](/user-management/migrating-users-to-privy/create-or-import-a-user).
</Info>

## 2. Signing a message

Next, we'll sign a plaintext message with the wallet using the `signMessage` method.
Make sure to specify your wallet ID (not address) from creation in the input.

<Tabs>
  <Tab title="Ethereum">
    ```ts  theme={"system"}
    try {
      const message = "Hello, Privy!";

      const response = await privy.wallets().ethereum().signMessage(walletId, { message });
      // Signature is hex-encoded for Ethereum
      const signature = response.signature;
    } catch (error) {
      if (error instanceof APIError) {
        console.log(error.status, error.name);
      } else if (error instanceof PrivyAPIError) {
        console.log(error.message);
      } else {
        throw error;
      }
    }
    ```
  </Tab>

  <Tab title="Solana">
    ```ts  theme={"system"}
    try {
      const message = "Hello, Privy!";
      // Solana requires the message to be base64 encoded
      const base64Message = Buffer.from(message, 'utf8').toString('base64')

      const response = await privy.wallets().solana().signMessage(walletId, { message: base64Message });
      // Signature is base64-encoded for Solana
      const signature = response.signature;
    } catch (error) {
      if (error instanceof APIError) {
        console.log(error.status, error.name);
      } else if (error instanceof PrivyAPIError) {
        console.log(error.message);
      } else {
        throw error;
      }
    }
    ```
  </Tab>
</Tabs>

<Tip>[Learn more](/wallets/using-wallets/ethereum/sign-a-message) about signing messages.</Tip>

## 3. Sending transactions

<Info>
  Your wallet must have some funds in order to send a transaction. You can use a testnet
  [faucet](https://console.optimism.io/faucet) to test transacting on a testnet (e.g. Base Sepolia)
  or send funds to the wallet on the network of your choice.
</Info>

To send a transaction from your wallet, use the `sendTransaction` method.
It will populate missing network-related values (gas limit, gas fee values, nonce, type), sign your
transaction, broadcast it to the network, and return the transaction hash to you.

In the request, make sure to specify your wallet `id` from your wallet creation above, as well as
the `caip2` chain ID and `chain_id` values for the network you want to transact on.
Also, input your recipient or smart contract address in the `to` field.

<Tabs>
  <Tab title="Ethereum">
    ```ts  theme={"system"}
    try {
        const caip2 = "eip155:11155111"; // Sepolia testnet

        const response = await privy.wallets().ethereum().sendTransaction(walletId, {
          caip2,
          params: {
            transaction: {
              to: recipientAddress,
              value: "0x1", // 1 wei
              chain_id: 11_155_111, // Sepolia testnet
            },
          },
        });
        const transactionHash = response.hash;
    } catch (error) {
      if (error instanceof APIError) {
        console.log(error.status, error.name);
      } else if (error instanceof PrivyAPIError) {
        console.log(error.message);
      } else {
        throw error;
      }
    }
    ```
  </Tab>

  <Tab title="Solana">
    ```ts  theme={"system"}
    try {
        const caip2 = "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp"; // Solana Mainnet

        // A base64 encoded serialized transaction to sign
        const transaction = "insert-base-64-encoded-serialized-transaction";

        const response = await privy.wallets().solana().signAndSendTransaction(walletId, {
          caip2,
          transaction,
        });
        const transactionHash = response.hash;
    } catch (error) {
      if (error instanceof APIError) {
        console.log(error.status, error.name);
      } else if (error instanceof PrivyAPIError) {
        console.log(error.message);
      } else {
        throw error;
      }
    }
    ```
  </Tab>
</Tabs>

<Tip>
  [Learn more](/wallets/using-wallets/ethereum/send-a-transaction) about sending transactions.
</Tip>

<Tip>
  If you’re interested in more control, you can prepare and broadcast the transaction yourself, and
  simply use `eth_signTransaction` ([EVM](/wallets/using-wallets/ethereum/sign-a-transaction)) and
  `signTransaction` ([Solana](/wallets/using-wallets/solana/sign-a-transaction)) RPCs to sign the
  transaction with a wallet.
</Tip>

## 4. Creating a user

To create a user for your application, you can use the `create` method, passing in
a `UserCreateRequestBody` object, which allows you to specify the linked accounts, custom metadata,
and wallets that should be associated with said user.

```ts  theme={"system"}
import {APIError, PrivyAPIError, PrivyClient} from '@privy-io/node';

const privy = new PrivyClient({appId: 'insert-your-app-id', appSecret: 'insert-your-app-secret'});

try {
  const user = await privy.users().create({
    linked_accounts: [
      {type: 'custom_auth', custom_user_id: '$SUBJECT_ID'},
      {type: 'email', address: '$EMAIL'}
    ]
  });

  const userId = user.id;
} catch (error) {
  if (error instanceof APIError) {
    console.log(error.status, error.name);
  } else if (error instanceof PrivyAPIError) {
    console.log(error.message);
  } else {
    throw error;
  }
}
```

<Tip>
  [Learn more](/user-management/migrating-users-to-privy/create-or-import-a-user) about creating
  users, and look at our [pregenerating wallets](/recipes/pregenerate-wallets) guide for linking
  wallets to your users before they even sign in.
</Tip>

## Next steps & advanced topics

* For an additional layer of security, you can choose to sign your requests with [authorization keys](/controls/authorization-keys/using-owners/overview).
* To restrict what wallets can do, you can set up [policies](/controls/policies/overview).
* To prevent double sending the same transaction, take a look at our support for [idempotency](/api-reference/idempotency-keys) keys.
* If you want to require multiple parties to sign off before sending a transaction for a wallet, you can accomplish this through the use of [quorum approvals](/controls/quorum-approvals/overview).


# null
Source: https://docs.privy.io/basics/nodeJS/setup



## Prerequisites

Before you begin:

* Get your [Privy app ID and app secret](/basics/get-started/dashboard/create-new-app) from the Privy Dashboard
* The following runtimes are supported:
  * Node.js 20 LTS or later ([non-EOL](https://endoflife.date/nodejs)) versions.
  * Deno v1.28.0 or higher.
  * Bun 1.0 or later.
  * Cloudflare Workers.
  * Vercel Edge Runtime.
  * Nitro v2.6 or greater.

## Instantiating the `PrivyClient`

Import the **`PrivyClient`** class and create an instance of it by passing the Privy **app ID** and **app secret** as parameters.

```ts  theme={"system"}
import {PrivyClient} from '@privy-io/node';

const privy = new PrivyClient({
  appId: 'insert-your-app-id',
  appSecret: 'insert-your-app-secret'
});
```

This `privy` **`PrivyClient`** is now your entry point to manage Privy from your server. With the `PrivyClient` you can interact with wallets with methods for creating wallets, signing and sending transactions. You can also manage users with methods for getting a user object, verifying an auth token, and importing new users.

## Rate limits

Privy rate limits REST API endpoints that you may call from your server. If you suspect your team will require an increased rate limit, please reach out to support!

<Tip>
  Learn more about optimizing your setup in our [optimizing](/recipes/dashboard/optimizing) guide!
</Tip>


# null
Source: https://docs.privy.io/basics/python/installation



In a backend Python environment, you can use the [`privy-client`](https://pypi.org/project/privy-client/0.4.0/) library to authorize requests and manage your application from your server. This library includes helpful utilities around verifying access tokens issued by Privy and interacting with Privy's API to query and import users, create wallets, send assets, and more.

Install the Privy Python package using your package manager. For example:

```bash  theme={"system"}
pip install privy-client
```


# Quickstart
Source: https://docs.privy.io/basics/python/quickstart

Learn how to authenticate users, create embedded wallets, and send transactions in your Python app

## 0. Prerequisites

This guide assumes that you have completed the [Setup](/basics/python/setup) guide.

## 1. Creating a wallet

First, we will create a wallet. You will use this wallet's `id` in future calls to sign messages and send transactions.

<Tabs>
  <Tab title="Ethereum">`python wallet = client.wallets.create( chain_type="ethereum", ) `</Tab>
  <Tab title="Solana">`python wallet = client.wallets.create( chain_type="solana", ) `</Tab>
</Tabs>

<Tip>[Learn more](/wallets/wallets/create/create-a-wallet) about creating wallets.</Tip>

## 2. Signing a message

Next, we'll sign a plaintext message with the wallet using the `signMessage` method. Make sure to specify your wallet ID (not address) from creation in the input.

<Tabs>
  <Tab title="Ethereum">
    ```python  theme={"system"}
    message = "Hello Privy!"
    tx = client.wallets.rpc(
        wallet_id=wallet.id,
        method="personal_sign",
        caip2="eip155:1",
        params={
            "message": message,
            "encoding": "utf-8"
        },
    )
    ```
  </Tab>

  <Tab title="Solana">
    ```python  theme={"system"}
    tx = client.wallets.rpc(
        wallet_id=wallet.id,
        chain_type="solana",
        method="signMessage",
        params={
            "message": "SGVsbG8hIEkgYW0gdGhlIGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2UgdG8gYmUgc2lnbmVkLg",
            "encoding": "base64"
        },
    )
    ```
  </Tab>
</Tabs>

<Tip>[Learn more](/wallets/using-wallets/ethereum/sign-a-message) about signing messages.</Tip>

## 3. Sending transactions

<Info>
  In order to send a transaction, your wallet must have some funds to pay for gas. You can use a
  testnet [faucet](https://console.optimism.io/faucet) to test transacting on a testnet (e.g. Base
  Sepolia) or send funds to the wallet on the network of your choice.
</Info>

To send a transaction from your wallet, use the `sendTransaction` method. It will populate missing network-related values (gas limit, gas fee values, nonce, type), sign your transaction, broadcast it to the network, and return the transaction hash to you.

In the request, make sure to specify your wallet `id` from your wallet creation above, as well as the `caip2` chain ID and `chainId` values for the network you want to transact on. Also, input your recipient or smart contract address in the `to` field.

<Tabs>
  <Tab title="Ethereum">
    ```python  theme={"system"}
    tx = client.wallets.rpc(
        wallet_id=wallet.id,
        method="eth_sendTransaction",
        caip2="eip155:1",
        params={
            "transaction": {
                "to": "0xE3070d3e4309afA3bC9a6b057685743CF42da77C",
                "value": 100000,
            },
        },
    )
    ```
  </Tab>

  <Tab title="Solana">
    ````python  theme={"system"}
    tx = client.wallets.rpc(
        wallet_id=wallet.id,
        caip2="solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
        method="signAndSendTransaction",
        params={
            "transaction": "insert-base-64-encoded-serialized-transaction",
            "encoding": "base64"
        }
    )
    </Tab>
    </Tabs>

    To send USDC specifically, you can use the `send_usdc` helper:

    <Tabs>
    <Tab title="Ethereum">
    ```python from privy.lib.stablecoins.usdc import send_usdc tx = send_usdc( wallet_id=wallet.id,
    recipient_address="0xE3070d3e4309afA3bC9a6b057685743CF42da77C", amount_in_usdc=100, chain_id=1 )
    ````
  </Tab>
</Tabs>

<Tip>
  [Learn more](/wallets/using-wallets/ethereum/send-a-transaction) about sending transactions.
</Tip>

<Tip>
  If you’re interested in more control, you can prepare and broadcast the transaction yourself, and
  simply use `eth_signTransaction` ([EVM](/wallets/using-wallets/ethereum/sign-a-transaction)) and
  `signTransaction` ([Solana](/wallets/using-wallets/solana/sign-a-transaction)) RPCs to sign the
  transaction with a wallet.
</Tip>

## Next steps & advanced topics

* For an additional layer of security, you can choose to sign your requests with [authorization keys](/controls/authorization-keys/overview).
* To restrict what wallets can do, you can set up [policies](/controls/policies/overview).
* To prevent double sending the same transaction, take a look at our support for [idempotency](/api-reference/idempotency-keys) keys.
* If you want to require multiple parties to sign off before sending a transaction for a wallet, you can accomplish this through the use of [quorum approvals](/controls/quorum-approvals/overview).


# null
Source: https://docs.privy.io/basics/python/setup



## Prerequisites

Before you begin, make sure you have [set up your Privy app and obtained your app ID and app secret](/basics/get-started/dashboard/create-new-app) from the Privy Dashboard.

## Getting the `PrivyClient`

Import the **`PrivyAPI`** class and create an instance of it, passing the Privy **app ID** and **app secret** as parameters.

```python  theme={"system"}
from privy import PrivyAPI

client = PrivyAPI(
    app_id="insert-your-app-id",
    app_secret="insert-your-app-secret"
)
```

This `client` is now your entrypoint to manage Privy from your server. With the `PrivyAPI` you can interact with wallets with methods for creating wallets, signing and sending transactions. You can also manage users with methods for getting a user object, verifying an auth token, and querying users.

## Interacting with wallets server-side

Authorization keys are the core primitive for managing wallets in Privy. In server-side environments, you can get
an authorization key from a user's JWT, or use one that you manage from your backend.

You can get a user's authorization key from their JWT by calling the `generate_user_signer` method:

```python  theme={"system"}
signer = client.wallets.generate_user_signer(
    user_jwt="insert-user-jwt"
)

client.update_authorization_key(signer.decrypted_authorization_key)
```

## Rate limits

Privy rate limits REST API endpoints that you may call from your server. If you suspect your team will require an increased rate limit, please reach out to support!

<Tip>
  Learn more about optimizing your setup in our [optimizing](/recipes/dashboard/optimizing) guide!
</Tip>


# null
Source: https://docs.privy.io/basics/react-native/advanced/automatic-wallet-creation



If your app uses embedded wallets, you can configure Privy to create wallets **automatically** for your users as part of their **login** flow.

<Tabs>
  <Tab title="Ethereum">
    To configure Privy to automatically create embedded wallets for your user when they login, **set the `config.embedded.solana.createOnLogin`** property of your `PrivyProvider`:

    ```tsx  theme={"system"}
    <PrivyProvider
        appId="your-privy-app-id"
        config={{
            embedded: {
                ethereum: {
                    createOnLogin: 'users-without-wallets',
                },
            },
        }}
    >
        {children}
    </PrivyProvider>
    ```

    <ParamField path="createOnLogin" type="'all-users' | 'users-without-wallets' | 'off'" default="off">
      Determines when to create a wallet for the user.

      * `'all-users'`: Create a wallet for all users on login.
      * `'users-without-wallets'`: Create a wallet for users who do not have a wallet on login.
      * `'off'`: Do not create a wallet on login.
    </ParamField>
  </Tab>

  <Tab title="Solana">
    To configure Privy to automatically create embedded wallets for your user when they login, **set the `config.embedded.solana.createOnLogin`** property of your `PrivyProvider`:

    ```tsx  theme={"system"}
    <PrivyProvider
        appId="your-privy-app-id"
        config={{
            embedded: {
                solana: {
                    createOnLogin: 'users-without-wallets',
                },
            },
        }}
    >
        {children}
    </PrivyProvider>
    ```

    <ParamField path="createOnLogin" type="'all-users' | 'users-without-wallets' | 'off'" default="off">
      Determines when to create a wallet for the user.

      * `'all-users'`: Create a wallet for all users on login.
      * `'users-without-wallets'`: Create a wallet for users who do not have a wallet on login.
      * `'off'`: Do not create a wallet on login.
    </ParamField>
  </Tab>
</Tabs>


# Configuring EVM networks
Source: https://docs.privy.io/basics/react-native/advanced/configure-evm-networks



Read below to learn how to configure supported EVM networks for the Expo SDK and how to switch the embedded wallet's current network.

## Configuring networks

**Privy embedded wallets can support *any* EVM-compatible chain**. You can configure EVM networks for Privy via the **`supportedChains`** property of the **`PrivyProvider`** component, per the instructions below.

### Configuring `viem`-supported networks

<Tip>
  If your desired EVM network is supported by the popular [**`viem/chains`**](https://viem.sh/docs/chains/introduction#chains) package, continue with the instructions below. A full list of the package's supported networks is available [here](https://github.com/wevm/viem/blob/main/src/chains/index.ts).

  Otherwise, skip to the [**Other Networks**](#other-networks) section.
</Tip>

To configure [**`viem`**](https://viem.sh/docs/chains/introduction#chains)-supported networks for Privy, **first, install the [`viem`](https://viem.sh/docs/installation#installation) package**. This package contains JSON representations of several EVM networks, which will be used to initialize the Privy SDK.

```sh  theme={"system"}
npm i viem
```

Next, **import your required chains from the [`viem/chains`](https://viem.sh/docs/chains/introduction#chains) package**:

```tsx  theme={"system"}
// Replace this with any of the networks listed at https://viem.sh/docs/chains/introduction#chains
import {base, baseGoerli, mainnet, goerli, polygon, polygonMumbai} from 'viem/chains';
```

**Lastly, configure the `supportedChains` prop of your `PrivyProvider` with an array including your required networks.**:

```tsx  theme={"system"}
<PrivyProvider
  appId="your-privy-app-id"
  supportedChains={[base, baseGoerli, mainnet, goerli, polygon, polygonMumbai]}
>
  {/* your app's content */}
</PrivyProvider>
```

### Other Networks

<Tip>
  If your desired EVM network is **not** supported by
  [**`viem/chains`**](https://viem.sh/docs/chains/introduction#chains), you can still use Privy with
  it per the steps below!
</Tip>

First, **import `viem` and use the package's [`defineChain`](https://viem.sh/docs/chains/introduction#custom-chains) method to build a JSON representation of your desired network.**

```tsx  theme={"system"}
import {defineChain} from 'viem';

export const myCustomChain = defineChain({
  id: 123456789, // Replace this with your chain's ID
  name: 'My Custom Chain',
  network: 'my-custom-chain',
  nativeCurrency: {
    decimals: 18, // Replace this with the number of decimals for your chain's native token
    name: 'My Native Currency Name',
    symbol: 'My Native Currency Symbol'
  },
  rpcUrls: {
    default: {
      http: ['https://my-custom-chain-https-rpc'],
      webSocket: ['wss://my-custom-chain-websocket-rpc']
    }
  },
  blockExplorers: {
    default: {name: 'Explorer', url: 'my-custom-chain-block-explorer'}
  }
});
```

At minimum, you must provide the network's name and chain ID, native currency, RPC URLs, and a blockexplorer URL.

Then, **pass the returned object (`myCustomChain` in the example above) to the `supportedChains` array of the `PrivyProvider`,** like above.

## Overriding a chain's RPC provider

**By default, transactions from the embedded wallet will be sent using Privy's default RPC providers.** Please note that Privy's default providers are subject to rate limits; these limits are sufficiently generous for developing your integration and moderate amounts of app usage.

**As your app's usage scales, we recommend that you setup your own RPC providers** (with [Alchemy](https://www.alchemy.com/), [QuickNode](https://www.quicknode.com/), [Blast](https://blastapi.io/), etc.) and configure Privy to use these providers per the instructions below. Setting up your own providers gives you maximum control over RPC throughput and rate limits, and offers you much more visibility into RPC analytics and common errors.

To configure Privy to use a custom RPC provider, first, **import the chain you want to override, and import the helper function `addRpcUrlOverrideToChain` from `@privy-io/chains` to override the RPC provider**

```ts  theme={"system"}
import {mainnet} from 'viem/chains';

import {addRpcUrlOverrideToChain} from '@privy-io/chains';

const mainnetOverride = addRpcUrlOverrideToChain(mainnet, 'INSERT_CUSTOM_RPC_URL');
```

Now, you can **add the chain returned by `addRpcUrlOverrideToChain` (e.g. `mainnetOverride`) to the `supportedChains` config option** like before.

## Default Configuration

If neither **`defaultChain`** nor **`supportedChains`** is explicitly set for your app, Privy will automatically default to the following list of EVM-compatible networks:

<Tip>
  **Want to use a chain not listed below?** Configure Privy with any EVM-compatible chain, like
  Berachain, Monad, or Story per the guidance
  [here](/basics/react/advanced/configuring-evm-networks#configuration).
</Tip>

<Expandable title="default networks">
  | Network           | [Chain ID](https://chainlist.org/) | Supported? | Privy RPC |
  | ----------------- | ---------------------------------- | ---------- | --------- |
  | Arbitrum          | 42161                              | ✅          | ✅         |
  | Arbitrum Sepolia  | 421614                             | ✅          | ✅         |
  | Avalanche C-Chain | 43114                              | ✅          |           |
  | Avalanche Fuji    | 43113                              | ✅          |           |
  | Base              | 8453                               | ✅          | ✅         |
  | Base Sepolia      | 84532                              | ✅          | ✅         |
  | Berachain Artio   | 80085                              | ✅          |           |
  | Celo              | 42220                              | ✅          |           |
  | Celo Alfajores    | 44787                              | ✅          |           |
  | Ethereum          | 1                                  | ✅          | ✅         |
  | Ethereum Sepolia  | 11155111                           | ✅          | ✅         |
  | Holesky           | 17000                              | ✅          |           |
  | Holesky Redstone  | 17001                              | ✅          |           |
  | Holesky Garnet    | 17069                              | ✅          |           |
  | Lukso             | 42                                 | ✅          |           |
  | Linea             | 59144                              | ✅          |           |
  | Linea Testnet     | 59140                              | ✅          |           |
  | Optimism          | 10                                 | ✅          | ✅         |
  | Optimism Sepolia  | 11155420                           | ✅          | ✅         |
  | Polygon           | 137                                | ✅          | ✅         |
  | Polygon Amoy      | 80002                              | ✅          | ✅         |
  | Redstone          | 690                                | ✅          |           |
  | Zora              | 7777777                            | ✅          |           |
  | Zora Sepolia      | 999999999                          | ✅          |           |
</Expandable>


# null
Source: https://docs.privy.io/basics/react-native/advanced/configuring-appearance



You can customize the theme and appearance of Privy's default UIs in your app.

## Brand color

Privy's default UIs for Expo support theming by using the **brand color** you have [set in the dashboard](/recipes/dashboard/customization#brand-color), or by setting a value specific to your mobile application by using the `PrivyElements` `config` prop.

If you want to set the value manually, instead of automatically through the dashboard, you should set the `accentColor` config option on the `PrivyElements` component.

```tsx  theme={"system"}
import {PrivyElements} from '@privy-io/expo/ui';

export default function RootLayout() {
  return (
    <>
      {/* Your app's content */}
      <PrivyElements config={{appearance: {accentColor: '#00AF55'}}} />
    </>
  );
}
```

## Color scheme (light and dark mode)

Privy's default UIs also support adapting the color scheme to both light and dark mode, via the `colorScheme` config option.

You can set a fixed value if that best matches the experience and design of your application, or you can use React Native's own `useColorScheme` hook to get a dynamic value and adapt to your user's settings.

```tsx  theme={"system"}
import {useColorScheme} from 'react-native';

import {PrivyElements} from '@privy-io/expo/ui';

export default function RootLayout() {
  const colorScheme = useColorScheme();
  return (
    <>
      {/* Your app's content */}
      <PrivyElements config={{appearance: {colorScheme}}} />
    </>
  );
}
```


# null
Source: https://docs.privy.io/basics/react-native/advanced/customizing-session-persistence



**By default, the Privy Expo SDK makes use of [`expo-secure-store`](https://docs.expo.dev/versions/latest/sdk/securestore/) package to persist sessions after your app is closed.**

### Custom storage adapters

If you'd rather persist sessions in a different way, you can easily build an adapter and provide it as an optional prop to the **`PrivyProvider`** component:

```tsx  theme={"system"}
import MyStorageProvider from 'my-storage-provider';

import {PrivyProvider} from '@privy-io/expo';
import type {Storage} from '@privy-io/js-sdk-core';

import AppContent from './AppContent';

const myStorage: Storage = {
  get: (key) => MyStorageProvider.getItem(key),
  put: (key, val) => MyStorageProvider.setItem(key, val),
  del: (key) => MyStorageProvider.deleteItem(key),
  getKeys: () => MyStorageProvider.allKeys()
};

export function App() {
  return (
    <PrivyProvider appId={'my-app-id'} storage={myStorage}>
      <AppContent />
    </PrivyProvider>
  );
}
```

### Customizing the access policy for `expo-secure-store`

The default **`expo-secure-store`** adapter setup requires the device to be unlocked at least once before accessing storage, which allows you to perform background operations, but still require the user to be in the loop after a device restart. Your app can customize the storage adapter, although be aware that this can have unexpected effects on Privy authentication state. Only do so if you are fully aware of the implications the changes you make will have.

Create a [**Custom Storage Adapter**](#custom-storage-adapters) that specifies the desired value for [**`keychainAccessible`**](https://docs.expo.dev/versions/latest/sdk/securestore/#constants) as a [**configuration option**](https://docs.expo.dev/versions/latest/sdk/securestore/#securestoreoptions) for each method.

```tsx  theme={"system"}
import * as SecureStore from 'expo-secure-store';

import type {Storage} from '@privy-io/js-sdk-core';

// We can require the user to set a passcode on the device to allow accessing storage, so Privy
// state is inaccessible if the user hasn't set or removes a passcode.
export const MyRestrictiveSecureStorageAdapter: Storage = {
  get(key) {
    return SecureStore.getItemAsync(key, {
      keychainAccessible: SecureStore.WHEN_PASSCODE_SET_THIS_DEVICE_ONLY
    });
  },
  put(key, val) {
    return SecureStore.setItemAsync(key, val as string, {
      keychainAccessible: SecureStore.WHEN_PASSCODE_SET_THIS_DEVICE_ONLY
    });
  },
  del(key) {
    return SecureStore.deleteItemAsync(key, {
      keychainAccessible: SecureStore.WHEN_PASSCODE_SET_THIS_DEVICE_ONLY
    });
  },
  getKeys: async () => []
};
```


# null
Source: https://docs.privy.io/basics/react-native/advanced/setup-apple-login



Privy supports native [Apple login](https://developer.apple.com/sign-in-with-apple/) when running on iOS.
Apple is an OAuth2.0 compliant authentication provider, but requires a specific implementation of Apple sign-in within iOS apps.

<Tip>
  Prior to integrating Sign in with Apple, make sure you configure [Apple as a login method in your
  dashboard.](/basics/get-started/dashboard/configure-login-methods) Make sure your app's `Bundle
    ID` rather than the `Service ID`, is configured as the `Client ID` within the **Privy Dashboard**.
</Tip>

### Installing the Apple Authentication module

```sh  theme={"system"}
npx expo install expo-apple-authentication
```

You can configure `expo-apple-authentication` using its built-in [config plugin](https://docs.expo.dev/versions/latest/sdk/apple-authentication/#configuration-in-app-config) if you use config plugins.

In your `app.json` config file:

* Set the `ios.usesAppleSignIn` property to `true`.
* Add `"expo-apple-authentication"` to the `plugins` array.

```json  theme={"system"}
{
  "expo": {
    "ios": {
      "usesAppleSignIn": true
    },
    "plugins": ["expo-apple-authentication"]
  }
}
```

## Initializing the login flow

With Privy's Expo SDK, you can use `'apple'` just as any other [OAuth provider](/authentication/user-authentication/login-methods/oauth).

```tsx  theme={"system"}
import {useLoginWithOAuth} from '@privy-io/expo';

export function LoginScreen() {
  const {login} = useLoginWithOAuth();

  return (
    <View>
      <Button onPress={() => login({provider: 'apple'})}>Login with Apple</Button>
    </View>
  );
}
```

Refer to our [OAuth login](/authentication/user-authentication/login-methods/oauth) guide for more information on login with OAuth providers.

## Using the web based flow instead of the native flow

<Tip>
  Privy will **automatically** fallback to the web-based flow on Android devices, where native Apple
  sign-in isn't supported.
</Tip>

For the best possible user experience, we recommend using the native "Sign in with Apple" flow as described above. However, if you are unable to use the native flow, or prefer not to, you can use the web based flow instead:

```tsx  theme={"system"}
import {useLoginWithOAuth} from '@privy-io/expo';

export function LoginScreen() {
  const {login} = useLoginWithOAuth();

  return (
    <View style={styles.container}>
      <Button onPress={() => login({provider: 'apple', isLegacyAppleIosBehaviorEnabled: true})}>
        Login with Apple
      </Button>
    </View>
  );
}
```


# null
Source: https://docs.privy.io/basics/react-native/advanced/setup-passkeys



<Tip>
  To see an example application that has the Privy Expo SDK configured with passkeys, check out our
  [Expo starter repo!](https://github.com/privy-io/examples/tree/main/privy-expo-starter)
</Tip>

## 0. Ensure you have configured a custom build configuration

<Info>
  If you have not already configured a custom build configuration, follow the [custom build
  configuration guide](/basics/react-native/installation#metro-build-configuration).
</Info>

## 1. Install additional peer dependencies

```sh  theme={"system"}
npx expo install react-native-passkeys
```

## 2. Update native app settings

<Tabs>
  <Tab title="iOS">
    Passkeys require that you associate a website with your app. To do so, you need to have the associated domain file on your website and the appropriate entitlement in your app.

    #### 1. Apple App Site Association

    * Create a `JSON` file with *at least* the following content

    ```json  theme={"system"}
    {
      "webcredentials": {
        "apps": ["<teamID>.<bundleID>"]
      }
    }
    ```

    * Make the file accessible on your website at the following path

    ```txt  theme={"system"}
    https://<your_domain>/.well-known/apple-app-site-association
    ```

    **Make sure to use your `teamID` and `bundleID` in the file hosted on your website.**

    For more information about supporting associated domains [see Apple's documentation](https://developer.apple.com/documentation/xcode/supporting-associated-domains).

    #### 2. App configuration

    Next, update your `app.json` (or `app.config.ts`) to include the `associatedDomains` and `deploymentTarget` like so:

    ```json  theme={"system"}
    {
      "expo": {
        "ios": {
          "associatedDomains": ["webcredentials:<your_domain>"]
        }
        "plugins": [
          [
            "expo-build-properties",
            {
              "ios": {
                "deploymentTarget": "15.0"
              }
            }
          ]
        ]
      }
    }
    ```

    #### 3. Build

    Lastly, build your app!

    ```sh  theme={"system"}
    npx expo prebuild -p ios
    npx expo run:ios
    ```
  </Tab>

  <Tab title="Android">
    To enable passkey support for your Android app, associate your app with a website that your app owns.

    #### 1. Digital Asset Links

    * Create a `JSON` file with *at least* the following content

    ```json  theme={"system"}
    [
      {
        "relation": ["delegate_permission/common.handle_all_urls"],
        "target": {
          "namespace": "android_app",
          "package_name": "<package_name>",
          "sha256_cert_fingerprints": ["<sha256_cert_fingerprint>"]
        }
      }
    ]
    ```

    * Make the file accessible on your website at the following path

    ```txt  theme={"system"}
    https://<your_domain>/.well-known/assetlinks.json
    ```

    **Make sure to use your `package_name` and `sha256_cert_fingerprint` in the file hosted on your website.**

    For more information on obtaining the `sha256_cert_fingerprint` for your app, see the [signing report documentation](https://developer.android.com/studio/publish/app-signing#signing_report). For more information about generally supporting Digital Asset Links [see Google's documentation](https://developer.android.com/training/sign-in/passkeys#add-support-dal).

    #### 2. Dashboard

    You will also need to add your `sha256_cert_fingerprint` to the allowed Android key hashes list in the `Settings` tab of the Privy dashboard.

    #### 3. App configuration

    Next, update your `app.json` (or `app.config.ts`) to look like:

    ```json  theme={"system"}
    {
      "expo": {
        "plugins": [
          [
            "expo-build-properties",
            {
              "android": {
                "compileSdkVersion": 34
              }
            }
          ]
        ]
      }
    }
    ```

    #### 4. Build

    Lastly, build your app!

    ```sh  theme={"system"}
    npx expo prebuild -p android
    npx expo run:android
    ```
  </Tab>
</Tabs>


# Setting up Privy UIs
Source: https://docs.privy.io/basics/react-native/advanced/setup-privyelements



Before integrating Privy's default UIs into your app, you must first ensure the necessary components and fonts are installed.

## Custom Build Configuration

Using Privy UIs requires a custom build configuration for your React Native application. This is necessary to ensure that the Privy SDK can properly interact with the native components and libraries it relies on.

For detailed instructions, see the [Custom Build Configuration](/basics/react-native/installation#metro-build-configuration) guide.

## Install Peer Dependencies

First, install the necessary peer dependencies:

```bash  theme={"system"}
npx expo install react-native-svg expo-clipboard react-native-qrcode-styled react-native-safe-area-context viem
```

## Fonts

### Install Font Packages

Install the following packages:

```bash  theme={"system"}
npx expo install expo-font @expo-google-fonts/inter
```

### Load Fonts

<Tabs>
  <Tab title="Using expo/router">
    Load the necessary fonts in your app's root layout (typically in `app/_layout.tsx`):

    ```tsx  theme={"system"}
    import {Inter_400Regular, Inter_500Medium, Inter_600SemiBold} from '@expo-google-fonts/inter';
    import {useFonts} from 'expo-font';

    export default function RootLayout() {
      useFonts({
        Inter_400Regular,
        Inter_500Medium,
        Inter_600SemiBold,
      });

      // ...
    }
    ```
  </Tab>

  <Tab title="Without expo/router">
    Load the necessary fonts in your app's root component (typically in `App.tsx`):

    ```tsx  theme={"system"}
    import {Inter_400Regular, Inter_500Medium, Inter_600SemiBold} from '@expo-google-fonts/inter';
    import {useFonts} from 'expo-font';

    export default function App() {
      useFonts({
        Inter_400Regular,
        Inter_500Medium,
        Inter_600SemiBold,
      });

      // ...
    }
    ```
  </Tab>
</Tabs>

## PrivyElements Component

Privy's default UIs in the React Native SDK are powered by the `PrivyElements` modal component.

<Warning>Only mount `PrivyElements` once in your app.</Warning>

```tsx  theme={"system"}
import {PrivyElements} from '@privy-io/expo/ui';

export default function RootLayout() {
  return (
    <>
      {/* Your app's content */}
      <PrivyElements />
    </>
  );
}
```


# Features
Source: https://docs.privy.io/basics/react-native/features

Learn about the features supported by the React Native SDK

export const FeatureMatrix = ({sdk}) => {
  const sdks = sdk ? [sdk] : ['react', 'reactNative', 'swift', 'android', 'flutter', 'unity'];
  const sdkNames = {
    react: 'React',
    reactNative: 'React Native',
    swift: 'Swift',
    android: 'Android',
    flutter: 'Flutter',
    unity: 'Unity'
  };
  const matrix = [{
    name: 'Authentication',
    features: [{
      name: 'Email',
      react: true,
      reactNative: true,
      swift: true,
      android: true,
      flutter: true,
      unity: true
    }, {
      name: 'SMS',
      react: true,
      reactNative: true,
      swift: true,
      android: true,
      flutter: true
    }, {
      name: 'OAuth',
      react: true,
      reactNative: true,
      swift: 'Google, Apple, Twitter, Discord',
      android: 'Google, Discord, Twitter',
      flutter: 'Google, Apple, Twitter, Discord',
      unity: 'Google, Apple, Twitter, Discord'
    }, {
      name: 'SIWE (Sign In with Ethereum)',
      react: true,
      reactNative: true,
      swift: true
    }, {
      name: 'SIWS (Sign In with Solana)',
      react: true,
      reactNative: true
    }, {
      name: 'Farcaster',
      react: true,
      reactNative: true
    }, {
      name: 'Telegram',
      react: true
    }, {
      name: 'Custom Auth',
      react: true,
      reactNative: true,
      swift: true,
      android: true,
      flutter: true
    }, {
      name: 'Passkeys',
      react: true,
      reactNative: true
    }]
  }, {
    name: 'Farcaster',
    features: [{
      name: 'SIWF',
      react: true,
      reactNative: true
    }]
  }, {
    name: 'Embedded Wallets',
    features: [{
      name: 'Creating wallets manually',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum', 'solana'],
      android: ['ethereum', 'solana'],
      flutter: ['ethereum', 'solana'],
      unity: ['ethereum', 'solana']
    }, {
      name: 'Creating wallets automatically',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Pregenerating wallets',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum', 'solana'],
      android: ['ethereum', 'solana'],
      flutter: ['ethereum', 'solana']
    }, {
      name: 'Signing messages and transactions',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum', 'solana'],
      android: ['ethereum', 'solana'],
      flutter: ['ethereum', 'solana'],
      unity: ['ethereum', 'solana']
    }, {
      name: 'Broadcasting transactions',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum'],
      android: ['ethereum'],
      flutter: ['ethereum'],
      unity: ['ethereum']
    }, {
      name: 'Native smart wallets',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: 'Automatic recovery',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum', 'solana'],
      android: ['ethereum', 'solana'],
      flutter: ['ethereum', 'solana'],
      unity: ['ethereum']
    }, {
      name: 'User controlled recovery',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Transaction MFA',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Key Export',
      react: ['ethereum', 'solana']
    }, {
      name: 'Key Import',
      react: ['ethereum', 'solana']
    }, {
      name: 'HD wallets',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum'],
      android: ['ethereum'],
      flutter: ['ethereum'],
      unity: ['ethereum']
    }, {
      name: 'Session signers',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Global wallets (Cross App Accounts)',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: 'Custom EVM (Ethereum) network support',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: 'Custom SVM (Solana) network support',
      react: ['solana'],
      reactNative: ['solana']
    }]
  }, {
    name: 'Connectors',
    features: [{
      name: 'External wallets',
      react: ['ethereum', 'solana']
    }, {
      name: 'Wagmi',
      react: ['ethereum']
    }, {
      name: 'Viem',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: 'Ethers',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: '@solana/web3.js',
      react: ['solana']
    }, {
      name: 'web3swift',
      swift: ['ethereum']
    }]
  }, {
    name: 'Funding',
    features: [{
      name: 'Transfer or bridge from wallet',
      react: ['ethereum', 'solana']
    }, {
      name: 'Transfer from exchange',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Pay with card',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }]
  }];
  const filteredMatrix = matrix.map(section => {
    return {
      ...section,
      features: section.features.filter(featureItem => {
        if (sdk) {
          return featureItem[sdk] !== undefined;
        }
        return true;
      })
    };
  }).filter(section => {
    return section.features.length > 0;
  });
  return <table style={{
    display: 'table',
    width: '100%'
  }}>
      {sdk ? null : <thead>
          <tr>
            <th></th>
            {sdks.map(sdk => <th>{sdkNames[sdk]}</th>)}
          </tr>
        </thead>}
      <tbody>
        {filteredMatrix.map(section => <>
            <tr>
              <td>
                <strong>{section.name}</strong>
              </td>
              {sdks.map(() => <td></td>)}
            </tr>
            {section.features.map(feature => <tr>
                <td>
                  <em>{feature.name}</em>
                </td>
                {sdks.map(sdk => {
    const supported = feature[sdk];
    if (supported === true) {
      return <td>✅</td>;
    } else if (!supported) {
      return <td></td>;
    } else if (Array.isArray(supported)) {
      return <td>
                        {supported.map(item => item === 'ethereum' ? <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/ethereum.png" noZoom style={{
        display: 'inline',
        margin: '2px',
        width: '18px'
      }} /> : <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/solana.png" noZoom style={{
        display: 'inline',
        margin: '2px',
        width: '18px'
      }} />)}
                      </td>;
    } else {
      return <td>{supported}</td>;
    }
  })}
              </tr>)}
          </>)}
      </tbody>
    </table>;
};

## Supported features

<FeatureMatrix sdk="reactNative" />


# null
Source: https://docs.privy.io/basics/react-native/installation



## Requirements

* A React Native project using the latest version
* iOS and Android platform support (Web is not supported)

## Installation

### Core Dependencies

Install the Privy React Native SDK and its peer dependencies:

```bash  theme={"system"}
npx expo install expo-apple-authentication expo-application expo-crypto expo-linking expo-secure-store expo-web-browser react-native-passkeys react-native-webview @privy-io/expo-native-extensions @privy-io/expo
```

### Required Polyfills

Install the necessary polyfills:

```bash  theme={"system"}
npm i fast-text-encoding react-native-get-random-values @ethersproject/shims
```

<Tip>
  If your app uses the Expo [bare workflow](https://docs.expo.dev/bare/) ("React Native without Expo"), also run:

  ```bash  theme={"system"}
  npx pod-install
  ```
</Tip>

### Configure Polyfills

<Tabs>
  <Tab title="Using expo/router">
    Create an `entrypoint.js` file and update your `package.json`:

    ```js entrypoint.js theme={"system"}
    // Import required polyfills first
    import 'fast-text-encoding';
    import 'react-native-get-random-values';
    import '@ethersproject/shims';
    // Then import the expo router
    import 'expo-router/entry';
    ```

    ```json package.json theme={"system"}
    {
      "name": "<your app name>",
      "main": "entrypoint.js"
    }
    ```
  </Tab>

  <Tab title="Without expo/router">
    Import the polyfills at the root of your application:

    ```jsx  theme={"system"}
    // Import required polyfills first
    import 'fast-text-encoding';
    import 'react-native-get-random-values';
    import '@ethersproject/shims';

    // Other imports
    ...

    // Your app's root component
    export default function App() {
      ...
    }
    ```
  </Tab>
</Tabs>

<Note>
  If you're using the `@solana/web3.js` package, install the buffer dependency:

  ```bash  theme={"system"}
  npm i buffer
  ```

  And add this code after importing `react-native-get-random-values`:

  ```js  theme={"system"}
  import 'react-native-get-random-values';
  import {Buffer} from 'buffer';
  global.Buffer = Buffer;
  ```
</Note>

<Accordion title="Metro build configuration">
  This guide ensures that your application satisfies the following requirements for integrating:

  * uses an [expo development build](https://docs.expo.dev/develop/development-builds/introduction/).
  * has a custom [`metro.config.js` file](https://docs.expo.dev/guides/customizing-metro/#customizing) to customize the Metro bundler settings
  * enables [package exports for the Metro bundler:](https://reactnative.dev/blog/2023/06/21/package-exports-support#for-app-developers)
  * uses the `bundler` setting for [Typescript's `moduleResolution`](https://www.typescriptlang.org/tsconfig#moduleResolution)

  ## Enabling Package Exports

  <Info>
    React Native 0.79, and Expo 53, have [enabled package exports by default](https://reactnative.dev/blog/2025/04/08/react-native-0.79#metro-faster-startup-and-package-exports-support).

    Some popular packages present incompatibilities with this change, and the community is working to get these fixed at source.
    In the meantime, we present a fix below by disabling package exports for the incompatibilities we have found.
  </Info>

  Update your `metro.config.js` like so:

  ```js  theme={"system"}
  //...other config logic

  // Enable package exports for select libraries
  ...
  const resolveRequestWithPackageExports = (context, moduleName, platform) => {
    // Package exports in `isows` (a `viem`) dependency are incompatible, so they need to be disabled
    if (moduleName === "isows") {
      const ctx = {
        ...context,
        unstable_enablePackageExports: false,
      };
      return ctx.resolveRequest(ctx, moduleName, platform);
    }

    // Package exports in `zustand@4` are incompatible, so they need to be disabled
    if (moduleName.startsWith("zustand")) {
      const ctx = {
        ...context,
        unstable_enablePackageExports: false,
      };
      return ctx.resolveRequest(ctx, moduleName, platform);
    }

    // Package exports in `jose` are incompatible, so the browser version is used
    if (moduleName === "jose") {
      const ctx = {
        ...context,
        unstable_conditionNames: ["browser"],
      };
      return ctx.resolveRequest(ctx, moduleName, platform);
    }

    // The following block is only needed if you are
    // running React Native 0.78 *or older*.
    if (moduleName.startsWith('@privy-io/')) {
      const ctx = {
        ...context,
        unstable_enablePackageExports: true,
      };
      return ctx.resolveRequest(ctx, moduleName, platform);
    }

    return context.resolveRequest(context, moduleName, platform);
  };

  config.resolver.resolveRequest = resolveRequestWithPackageExports;

  ...
  module.exports = config;
  ```

  ## Typescript's Module Resolution

  Also configure your `tsconfig.json` like so:

  ```json  theme={"system"}
  {
    "extends": "expo/tsconfig.base",
    "compilerOptions": {
      "strict": true,
      // Allows us to use conditional/deep imports on published packages
      "moduleResolution": "Bundler"
    }
  }
  ```
</Accordion>


# Quickstart
Source: https://docs.privy.io/basics/react-native/quickstart

Learn how to authenticate users, create embedded wallets, and send transactions in your React Native app

## 0. Prerequisites

This guide assumes that you have completed the [setup](/basics/react-native/setup) guide.

## 1. Enable a user to log in via email

<Tip>
  This quickstart guide will demonstrate how to authenticate a user with a one time password as an
  example, but Privy supports many authentication methods. Explore our [Authentication
  docs](/authentication/overview) to learn about other methods such as socials, passkeys, and
  external wallets to authenticate users in your app.
</Tip>

**To authenticate a user via their email address, use the React Native SDK's `useLoginWithEmail` hook.**

```tsx  theme={"system"}
import {useLoginWithEmail} from '@privy-io/expo';
...
const {sendCode, loginWithCode} = useLoginWithEmail();
```

Ensure that this hook is mounted in a component that is wrapped by the [PrivyProvider](/basics/react-native/setup#initializing-privy).
You can use the returned methods **`sendCode`** and **`loginWithCode`** to authenticate your user per the instructions below.

### Send an OTP

Send a one-time passcode (OTP) to the user's **email** by passing their email address to the **`sendCode`** method returned from `useLoginWithEmail`:

```tsx  theme={"system"}
import {useLoginWithEmail} from '@privy-io/expo';

export function LoginScreen() {
  const [email, setEmail] = useState('');
  const [codeSent, setCodeSent] = useState(false);

  const {sendCode} = useLoginWithEmail();

  return (
    <View>
      <Text>Login</Text>

      {/* prettier-ignore */}
      <TextInput
        value={email}
        onChangeText={setEmail}
        placeholder="Email"
        inputMode="email"
      />

      {!codeSent ? (
        <Button
          onPress={async () => {
            await sendCode({email});
            setCodeSent(true);
          }}
        >
          Send Code
        </Button>
      ) : (
        {/* prettier-ignore */}
        <Button onPress={() => loginWithCode({code: code, email})}>
          Login
        </Button>
      )}
    </View>
  );
}
```

## 2. Create an embedded wallet for the user

Your app can configure Privy to [**automatically** create wallets](/basics/react-native/advanced/automatic-wallet-creation) for your users as part of their **login** flow. The embedded wallet will be generated and linked to the user object upon authentication.

Alternatively your app can [**manually** create wallets](/wallets/wallets/create/create-a-wallet) for users when required.

<Info>Privy can provision wallets for your users on both **Ethereum** and **Solana**.</Info>

## 3. Send and sign transactions using the embedded wallet

To request signatures and transactions from a wallet, you must first get an EIP1193 provider for the wallet.

<Tabs>
  <Tab title="Ethereum">
    ```ts  theme={"system"}
    import {useEmbeddedEthereumWallet} from '@privy-io/expo';
    // Get an EIP-1193 Provider
    const {wallets} = useEmbeddedEthereumWallet();
    const provider = await wallets[0].getProvider();
    ```

    Once you have the embedded wallet's EIP-1193 provider, you can use the provider's **`request`** method to send JSON-RPC requests that request signatures and transactions from the wallet!

    The **`request`** method accepts an object with the fields:

    * **`method`** (required): the name of the JSON-RPC method as a string (e.g. **`personal_sign`** or **`eth_sendTransaction`**)
    * **`params`** (optional): an array of arguments for the JSON-RPC method specified by **`method`**

    <Tabs>
      <Tab title="Example signature">
        ```tsx  theme={"system"}
        // Get address
        const accounts = await provider.request({
          method: 'eth_requestAccounts'
        });

        // Sign message
        const message = 'I hereby vote for foobar';
        const signature = await provider.request({
          method: 'personal_sign',
          params: [message, accounts[0]]
        });
        ```
      </Tab>

      <Tab title="Example transaction">
        ```tsx  theme={"system"}
        // Get address
        // Get an EIP-1193 Provider
        const provider = await wallet.getProvider();
        const accounts = await provider.request({
          method: 'eth_requestAccounts'
        });

        // Send transaction (will be signed and populated)
        const response = await provider.request({
          method: 'eth_sendTransaction',
          params: [
            {
              from: accounts[0],
              to: '0x0000000000000000000000000000000000000000',
              value: '1'
            }
          ]
        });
        ```
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Solana">
    ```ts  theme={"system"}
    import {useEmbeddedSolanaWallet} from '@privy-io/expo';
    // get a Solana provider
    const {wallets} = useEmbeddedSolanaWallet();
    const provider = await wallets[0].getProvider();
    ```

    Once you have the embedded wallet's Solana provider, you can use the provider's methods to interact with the Solana blockchain.

    <Tabs>
      <Tab title="Example signature">
        ```tsx  theme={"system"}
        // Sign message
        const message = 'Hello world';
        const {signature} = await provider.request({
          method: 'signMessage',
          params: {message}
        });
        ```
      </Tab>

      <Tab title="Example transaction">
        ```tsx  theme={"system"}
        // Create a connection to the Solana network
        const connection = new Connection('insert-your-rpc-url-here');

        // Create your transaction (either legacy Transaction or VersionedTransaction)
        // transaction = ...

        // Send the transaction
        const {signature} = await provider.request({
          method: 'signAndSendTransaction',
          params: {
            transaction: transaction,
            connection: connection
          }
        });
        ```
      </Tab>
    </Tabs>
  </Tab>
</Tabs>

<Tip>
  [Learn more](/wallets/using-wallets/ethereum/send-a-transaction) about sending transactions with
  the embedded wallet. Privy enables you to take many actions on the embedded wallet, including
  [sign a message](/wallets/using-wallets/ethereum/sign-a-message), [sign typed
  data](/wallets/using-wallets/ethereum/sign-typed-data), and [sign a
  transaction](/wallets/using-wallets/ethereum/sign-a-transaction).
</Tip>

Congratulations, you have successfully been able to integrate Privy authentication and wallet into your React Native application!


# null
Source: https://docs.privy.io/basics/react-native/setup



## Prerequisites

Before you begin, make sure you have [set up your Privy app and obtained your app ID](/basics/get-started/dashboard/create-new-app) and [client ID](/basics/get-started/dashboard/app-clients) from the Privy Dashboard.

<Warning>
  A properly set up app client is required for mobile apps and other non-web platforms to allow your
  app to interact with the Privy API. Please follow [this
  guide](/basics/get-started/dashboard/app-clients) to configure an app client.
</Warning>

## Initializing Privy

In your project, **import the `PrivyProvider` component and wrap your app with it**.
The `PrivyProvider` must wrap *any* component or page that will use the Privy React Native SDK, and it is generally recommended to render it as close to the root of your application as possible.

<Tabs>
  <Tab title="Using expo/router">
    Wrap your app with the `PrivyProvider` in the `app/_layout.tsx` file.

    ```tsx  theme={"system"}
    import {PrivyProvider} from '@privy-io/expo';

    import {Slot} from 'expo-router';

    export default function RootLayout() {
      return (
        <PrivyProvider appId="your-privy-app-id" clientId="your-privy-app-client-id">
          <Slot />
        </PrivyProvider>
      );
    }
    ```

    <Accordion title="Protect routes with `AuthBoundary`">
      ### Protect routes with `AuthBoundary`

      Setting up `PrivyProvider` is all you need to use the Privy React Native SDK throughout your app! But if you want to protect certain routes, we recommend you do so by using the `AuthBoundary` component, as follows:

      Start by setting up a [route group](https://docs.expo.dev/router/layouts/#groups), like `(app)/`, under your `app/` directory. Routes placed under this group will be protected by the `AuthBoundary` component, so only authenticated users can access them.

      ```text  theme={"system"}
      app
      ├── (app)
      │   ├── _layout.tsx
      │   └── index.tsx
      ├── _layout.tsx
      └── sign-in.tsx
      ```

      In the `(app)/_layout.tsx` file, wrap the `Stack` component with the `AuthBoundary` component:

      ```tsx  theme={"system"}
      import {Stack, Redirect} from 'expo-router';

      import {AuthBoundary} from '@privy-io/expo';

      export default function AppLayout() {
        return (
          <AuthBoundary
            loading={<FullScreenLoader />}
            error={(error) => <ErrorScreen error={error} />}
            unauthenticated={<Redirect href="/sign-in" />}
          >
            <Stack />
          </AuthBoundary>
        );
      }
      ```

      You must provide the following props to `AuthBoundary`:

      * `loading` and `error` are both custom components that you can define to show specific UIs during the loading and error states.
      * On `unauthenticated`, you should redirect the user to the sign in page, as defined above!

      If you want more details, or wish to take a manual approach without using `AuthBoundary`, take a look at [Expo Router's docs on Authentication](https://docs.expo.dev/router/reference/authentication/).
    </Accordion>
  </Tab>

  <Tab title="Without expo/router">
    Wrap your app with the `PrivyProvider` in the `App.tsx` file.

    ```tsx  theme={"system"}
    import {PrivyProvider} from '@privy-io/expo';

    import {HomeScreen} from './HomeScreen';

    export default function App() {
      return (
        <PrivyProvider appId="your-privy-app-id" clientId="your-privy-app-client-id">
          <HomeScreen />
        </PrivyProvider>
      );
    }
    ```
  </Tab>
</Tabs>

## Configuration

The `PrivyProvider` component accepts the following props:

<ParamField path="appId" type="string" required>
  Your Privy App ID. You can find this in the Privy Dashboard.
</ParamField>

<ParamField path="clientId" type="string" required>
  Your Privy Client ID. You can find this in the Privy Dashboard.
</ParamField>

## Waiting for Privy to be ready

When the `PrivyProvider` is first rendered, the Privy SDK will initialize some state about the current user. This might include checking if the user has a wallet connected, refreshing expired auth tokens, fetching up-to-date user data, and more.

**It's important to wait until the `PrivyProvider` has finished initializing *before* you consume Privy's state and interfaces**, to ensure that the state you consume is accurate and not stale.

To determine whether the Privy SDK has fully initialized, **check the `isReady` Boolean returned by the `usePrivy` hook.** When `isReady` is true, Privy has completed initialization, and your app can consume Privy's state and interfaces.

```tsx  theme={"system"}
import {usePrivy} from '@privy-io/expo';

function YourComponent() {
  const {isReady} = usePrivy();

  if (!isReady) {
    return <LoadingScreen />;
  }

  // Now it's safe to use other Privy hooks and state
  return <YourAuthenticatedContent />;
}
```

<CardGroup cols={2}>
  <Card title="Quickstart Guide" icon="rocket" href="/basics/react-native/quickstart">
    Learn how to [log users in](/authentication/user-authentication/login-methods/email) and
    [transact with embedded wallets](/wallets/wallets/create/create-a-wallet)
  </Card>

  <Card title="Example Repo" icon="code" href="https://github.com/privy-io/examples/tree/main/privy-expo-starter">
    Check out our [Expo starter
    repo](https://github.com/privy-io/examples/tree/main/privy-expo-starter) for a complete example
  </Card>
</CardGroup>


# null
Source: https://docs.privy.io/basics/react/advanced/automatic-wallet-creation



If your app uses embedded wallets, you can configure Privy to create wallets **automatically** for your users as part of their **login** flow.

<Warning>
  Automatic embedded wallet creation is currently not supported if your app uses Privy's whitelabel
  login interfaces. If this is the case for your app, you must [manually create embedded
  wallets](/wallets/wallets/create/create-a-wallet) for your users at the desired point in your
  onboarding flow.
</Warning>

<Note>
  Automatic wallet creation only applies to login via the Privy modal and not from whitelabel login
  methods. It does not trigger wallet creation for users who authenticate through direct login
  methods like loginWithCode, useLoginWithOAuth, or similar custom flows.
</Note>

<Tabs>
  <Tab title="Ethereum">
    To configure Privy to automatically create embedded wallets for your user when they login, **set the `config.embeddedWallets.ethereum.createOnLogin`** property of your `PrivyProvider`:

    ```tsx  theme={"system"}
    <PrivyProvider
        appId="your-privy-app-id"
        config={{
            embeddedWallets: {
                ethereum: {
                    createOnLogin: "users-without-wallets",
                },
            },
        }}
    >
        {children}
    </PrivyProvider>
    ```

    <ParamField path="createOnLogin" type="'all-users' | 'users-without-wallets' | 'off'" default="off">
      Determines when to create a wallet for the user.

      * `'all-users'`: Create a wallet for all users on login.
      * `'users-without-wallets'`: Create a wallet for users who do not have a wallet on login.
      * `'off'`: Do not create a wallet on login.
    </ParamField>
  </Tab>

  <Tab title="Solana">
    To configure Privy to automatically create embedded wallets for your user when they login, **set the `config.embeddedWallets.solana.createOnLogin`** property of your `PrivyProvider`:

    ```tsx  theme={"system"}
    <PrivyProvider
        appId="your-privy-app-id"
        config={{
            embeddedWallets: {
                solana: {
                    createOnLogin: 'users-without-wallets',
                },
            },
        }}
    >
        {children}
    </PrivyProvider>
    ```

    <ParamField path="createOnLogin" type="'all-users' | 'users-without-wallets' | 'off'" default="off">
      Determines when to create a wallet for the user.

      * `'all-users'`: Create a wallet for all users on login.
      * `'users-without-wallets'`: Create a wallet for users who do not have a wallet on login.
      * `'off'`: Do not create a wallet on login.
    </ParamField>
  </Tab>

  <Tab title="Ethereum & Solana">
    To configure Privy to automatically create embedded wallets for your user when they login, **set the `config.embeddedWallets.ethereum.createOnLogin`** and `config.embeddedWallets.solana.createOnLogin` properties of your `PrivyProvider`:

    ```tsx  theme={"system"}
    <PrivyProvider
        appId="your-privy-app-id"
        config={{
            embeddedWallets: {
                ethereum: {
                    createOnLogin: 'users-without-wallets',
                },
                solana: {
                    createOnLogin: 'users-without-wallets',
                },
            },
        }}
    >
        {children}
    </PrivyProvider>
    ```
  </Tab>
</Tabs>


# Configuring EVM networks
Source: https://docs.privy.io/basics/react/advanced/configuring-evm-networks



**Privy is compatible with any EVM-compatible chain, and makes it easy to configure networks for your users' wallets.**

You can seamlessly use Privy with Ethereum Mainnet, Base, Polygon, Arbitrum, Monad, Berachain, MegaETH, Mantle, Story, and any chain that supports EVM RPC requests.

Check out a [high-level overview](/basics/react/advanced/configuring-evm-networks#overview) of network configuration with Privy, or jump directly into [concrete instructions](/basics/react/advanced/configuring-evm-networks#configuration)!

<Tip>
  Privy is also compatible with app-specific chains, such as those deployed via a RaaS provider. See
  more [here](/basics/react/advanced/configuring-evm-networks#other-networks).
</Tip>

## Overview

Privy exposes two parameters to configure networks: a single [**default chain**](/basics/react/advanced/configuring-evm-networks#default-chain) and a list of [**supported chains**](/basics/react/advanced/configuring-evm-networks#supported-chains).

If you choose not to use these parameters in your app, you can instead use Privy's [default configuration and supported chains](/basics/react/advanced/configuring-evm-networks#default-configuration).

### Default Chain

The **default chain** should be the primary network that wallets should use in your app.

For **embedded wallets**, when a user logs in or creates a wallet in your app, Privy will initialize the embedded wallet's network to the default chain. Thereafter, the embedded wallet will by default use the **default chain**, unless you manually switch the wallet's network to another [**supported chain**](/basics/react/advanced/configuring-evm-networks#supported-chains).

For **external wallets**, when a user connects their wallet to your app, Privy will prompt the user to switch their network to the default chain, as long as the wallet supports the network. If the user declines to switch their network to the **default chain**, they will still be permitted to connect their wallet.

<Info>
  Not all wallets support all EVM networks. Please note that the following wallets may reject
  connection requests if you specify one of their unsupported networks as a `defaultChain`: -
  **Rainbow Wallet**'s [mobile app](https://rainbow.me/download) does not support testnets, and will
  reject connections if you specify a testnet as a `defaultChain`. - **Trust Wallet**'s
  [SWIFT](https://trustwallet.com/blog/introducing-trust-wallet-swift) (in beta) only supports BNB
  Smart Chain, Polygon, Avalanche C-Chain, Arbitrum, OP Mainnet, Base, and OpBNB. If you specify a
  `defaultChain` that is not one of these networks, the wallet will reject the connection request.
</Info>

### Supported Chains

The **supported chains** list should be a list of networks that wallets are *permitted* to use in your app. This is intended as a guardrail against accidentally taking actions on the wrong network.

For **embedded wallets**, attempting to send a transaction on or switch the wallet to a network *not* in the list of **supported chains** will throw an error.

For **external wallets**, attempting to programmatically switch the wallet to a network *not* in the list of **supported chains** will throw an error.

If a list of **supported chains** is set but no [**default chain**](/basics/react/advanced/configuring-evm-networks#default-chain) is set:

* Embedded wallets will be connected to the first entry of the **supported chains** list by default.
* External wallets will **not** be prompted to a particular default chain when connecting or logging in; they will be permitted to login on whatever chain they are on. If you'd like to prompt users to switch to a particular network, you should explicitly set a **default chain**.

<Info>
  For external wallets (e.g. MetaMask), users may switch their wallet's network *manually*,
  independent of both Privy and your application. There is no way to prevent this behavior; Privy
  will **not** throw an error, and you can only re-prompt the user to switch to a different network.
</Info>

## Configuration

**Privy embedded wallets can support *any* EVM-compatible chain**.

### `viem`-Supported Networks

<Tip>
  If your desired EVM network is supported by the
  [**`viem/chains`**](https://viem.sh/docs/chains/introduction#chains) package, continue with the
  instructions below. The package's supported networks are listed
  [here](https://github.com/wevm/viem/blob/main/src/chains/index.ts). Otherwise, skip to the
  [**Other Networks**](/basics/react/advanced/configuring-evm-networks#other-networks) section.
</Tip>

To configure [**`viem`**](https://viem.sh/docs/chains/introduction#chains)-supported networks for Privy, **first, install the [`viem`](https://viem.sh/docs/installation#installation) package**. This package contains JSON representations of several EVM networks, which will be used to initialize the Privy SDK.

```sh  theme={"system"}
npm i viem
```

Next, **import your default chain and/or supported chains from the [`viem/chains`](https://viem.sh/docs/chains/introduction#chains) package**:

```tsx  theme={"system"}
// Replace this with any of the networks listed at https://github.com/wevm/viem/blob/main/src/chains/index.ts
import {base, berachain, polygon, arbitrum, story, mantle} from 'viem/chains';
```

**Lastly, configure your `PrivyProvider` with these additional network(s).** In particular, the **`config`** property of the **`PrivyProvider`** contains the optional parameters:

* **`defaultChain`** field, where you should pass a *single* chain object for your desired default chain
* **`supportedChains`** field, where you should pass a *list* of chain objects for your desired supported chains

```tsx {6,8} theme={"system"}
<PrivyProvider
    appId='your-privy-app-id'
    config={{
        ...theRestOfYourConfig,
        // Replace this with your desired default chain
        defaultChain: base
        // Replace this with a list of your desired supported chains
        supportedChains: [base, berachain, polygon, arbitrum, story, mantle]
    }}
>
    {/* your app's content */}
</PrivyProvider>
```

The **`PrivyProvider`** will throw an error if:

* an empty array (`[]`) is passed into **`supportedChains`**
* a chain is passed into **`defaultChain`** that is *not* also included in **`supportedChains`** array

**That's it! You've successfully configured networks for external and embedded wallets in your app.** 🎉

### Other Networks

<Tip>
  If your desired EVM network is **not** supported by
  [**`viem/chains`**](https://viem.sh/docs/chains/introduction#chains), you can still use Privy with
  it per the steps below!
</Tip>

First, **import `viem` and use the package's [`defineChain`](https://viem.sh/docs/chains/introduction#custom-chains) method to build a JSON representation of your desired network.**

```tsx  theme={"system"}
import {defineChain} from 'viem';

export const myCustomChain = defineChain({
  id: 123456789, // Replace this with your chain's ID
  name: 'My Custom Chain',
  network: 'my-custom-chain',
  nativeCurrency: {
    decimals: 18, // Replace this with the number of decimals for your chain's native token
    name: 'My Native Currency Name',
    symbol: 'My Native Currency Symbol'
  },
  rpcUrls: {
    default: {
      http: ['https://my-custom-chain-https-rpc'],
      webSocket: ['wss://my-custom-chain-websocket-rpc']
    }
  },
  blockExplorers: {
    default: {name: 'Explorer', url: 'my-custom-chain-block-explorer'}
  }
});
```

At minimum, you must provide the network's name and chain ID, native currency, RPC URLs, and a blockexplorer URL.

Then, **pass the returned object (`myCustomChain` in the example above) to the `defaultChain` and `supportedChains` properties of the `PrivyProvider`.**

## Overriding a chain's RPC provider

**By default, transactions from the embedded wallet will be sent using Privy's default RPC providers.** Please note that Privy's default providers are subject to rate limits; these limits are sufficiently generous for developing your integration and moderate amounts of app usage.

**As your app's usage scales, we recommend that you setup your own RPC providers** (with [Alchemy](https://www.alchemy.com/), [QuickNode](https://www.quicknode.com/), [Blast](https://blastapi.io/), etc.) and configure Privy to use these providers per the instructions below. Setting up your own providers gives you maximum control over RPC throughput and rate limits, and offers you much more visibility into RPC analytics and common errors.

To configure Privy to use a custom RPC provider, first, **import the chain you want to override, and import the helper function `addRpcUrlOverrideToChain` from `@privy-io/chains` to override the RPC provider**

```ts  theme={"system"}
import {mainnet} from 'viem/chains';

import {addRpcUrlOverrideToChain} from '@privy-io/chains';

const mainnetOverride = addRpcUrlOverrideToChain(mainnet, 'INSERT_CUSTOM_RPC_URL');
```

Now, you can **add the chain returned by `addRpcUrlOverrideToChain` (e.g. `mainnetOverride`) to the `supportedChains` config option** like before.

## Default Configuration

If neither **`defaultChain`** nor **`supportedChains`** is explicitly set for your app, Privy will automatically default to the following list of EVM-compatible networks:

<Tip>
  **Want to use a chain not listed below?** Configure Privy with any EVM-compatible chain, like
  Berachain, Monad, or Story per the guidance
  [here](/basics/react/advanced/configuring-evm-networks#configuration).
</Tip>

<Expandable title="default networks">
  | Network           | [Chain ID](https://chainlist.org/) | Supported? | Privy RPC |
  | ----------------- | ---------------------------------- | ---------- | --------- |
  | Arbitrum          | 42161                              | ✅          | ✅         |
  | Arbitrum Sepolia  | 421614                             | ✅          | ✅         |
  | Avalanche C-Chain | 43114                              | ✅          |           |
  | Avalanche Fuji    | 43113                              | ✅          |           |
  | Base              | 8453                               | ✅          | ✅         |
  | Base Sepolia      | 84532                              | ✅          | ✅         |
  | Berachain Artio   | 80085                              | ✅          |           |
  | Celo              | 42220                              | ✅          |           |
  | Celo Alfajores    | 44787                              | ✅          |           |
  | Ethereum          | 1                                  | ✅          | ✅         |
  | Ethereum Sepolia  | 11155111                           | ✅          | ✅         |
  | Holesky           | 17000                              | ✅          |           |
  | Holesky Redstone  | 17001                              | ✅          |           |
  | Holesky Garnet    | 17069                              | ✅          |           |
  | Lukso             | 42                                 | ✅          |           |
  | Linea             | 59144                              | ✅          |           |
  | Linea Testnet     | 59140                              | ✅          |           |
  | Optimism          | 10                                 | ✅          | ✅         |
  | Optimism Sepolia  | 11155420                           | ✅          | ✅         |
  | Polygon           | 137                                | ✅          | ✅         |
  | Polygon Amoy      | 80002                              | ✅          | ✅         |
  | Redstone          | 690                                | ✅          |           |
  | Zora              | 7777777                            | ✅          |           |
  | Zora Sepolia      | 999999999                          | ✅          |           |
</Expandable>

* External wallets will **not** be prompted to switch networks when connecting to your app.
* Embedded wallets will initialize on **Ethereum mainnet** or the network used in the user's previous session on that device.

For both external and embedded wallets, you can switch a wallet to any of the following networks that are available from Privy out-of-the-box. As a reminder, **you can always [configure Privy with additional EVM networks](/basics/react/advanced/configuring-evm-networks#configuration).**

<Info>
  Security best practices [suggest maintaining a strict Content Security
  Policy](/security/implementation-guide/content-security-policy). In order to help with this, some
  chains are served by Privy out-of-the-box at `*.rpc.privy.systems`. For all other chains, Privy
  will pull from the Viem default RPC URL in its respective [chain
  definition](https://github.com/wevm/viem/tree/main/src/chains/definitions) if no override is
  specified.
</Info>


# Configuring Solana networks
Source: https://docs.privy.io/basics/react/advanced/configuring-solana-networks



Privy supports [Solana clusters](https://solana.com/docs/core/clusters) such as Mainnet Beta, Devnet, and Testnet.

To configure RPC endpoints for Solana when using the Privy embedded wallet UIs (UI `signTransaction` and `signAndSendTransaction`), set RPC clients under the `config.solana.rpcs` prop of the `PrivyProvider`:

```tsx  theme={"system"}
<PrivyProvider
  appId="your-privy-app-id"
  config={{
    ...theRestOfYourConfig,
    solana: {
      rpcs: {
        'solana:mainnet': {
          rpc: createSolanaRpc('https://api.mainnet-beta.solana.com'),
          rpcSubscriptions: createSolanaRpcSubscriptions('wss://api.mainnet-beta.solana.com')
        },
        'solana:devnet': {
          rpc: createSolanaRpc('https://api.devnet.solana.com'),
          rpcSubscriptions: createSolanaRpcSubscriptions('wss://api.devnet.solana.com')
        }
      }
    }
  }}
>
  {/* your app's content */}
</PrivyProvider>
```

<Info>
  The `config.solana.rpcs` configuration is only required for Privy's embedded wallet UIs. If you
  are using external Solana wallets (e.g., Phantom, Solflare) without embedded wallet UIs, you do
  not need to set `config.solana.rpcs`.
</Info>

# Custom Solana Virtual Machine (SVM) networks

In addition to supporting transactions on Solana mainnet, devnet, and testnet, Privy also supports sending transactions on any blockchain that implements the [Solana Virtual Machine (SVM)](https://squads.so/blog/solana-svm-sealevel-virtual-machine).

You can send a transaction on a custom SVM by initializing the `Connection` instance for your transaction with the RPC URL for the SVM, like so:

```tsx  theme={"system"}
// Initialize connection instance with custom SVM RPC URL
let connection = new Connection('insert-custom-SVM-rpc-url');

// Build out the transaction object for your desired program
// https://solana-foundation.github.io/solana-web3.js/classes/Transaction.html
let transaction = new Transaction();

// Send transaction on custom SVM
console.log(await wallet.sendTransaction!(transaction, connection));
```


# Migrating to 2.0
Source: https://docs.privy.io/basics/react/advanced/migrating-to-2.0



This guide will help you migrate your Privy React SDK from v1.x.x to v2.0.0.

To install the latest version, install the package from the `latest` tag:

```bash  theme={"system"}
npm i @privy-io/react-auth@latest
```

## New features and improvements 🎉

* Removed ethers v5 dependency, allowing developers to more easily use ethers v6
* Added support for submitting transactions without waiting for confirmation
* Added UIs for Ethereum signTransaction

For the full set of changes check out our [changelog](/changelogs/react-auth).

## Breaking changes

### Authentication

* Guaranteed that `user.wallet` is the first linked wallet on the user object. To maintain state of the latest connected wallet, interact with the wallets array directly.

* Removed the `forkSession` method. This feature was experimental and has been removed.

* Removed the `PrivyProvider`'s deprecated `onSuccess` prop - use the `onSuccess` callback registered via the `useLogin` hook instead.

### Embedded wallets

* Apps using [custom auth providers](/authentication/user-authentication/jwt-based-auth/overview) must now explicitly configure wallet UIs in the dashboard, or use the updated `showWalletUIs` option.

* Removed the `PrivyProvider`'s deprecated `createPrivyWalletOnLogin` prop. Use `config.embeddedWallets.createOnLogin` instead.

```tsx  theme={"system"}
<PrivyProvider
  createPrivyWalletOnLogin={true} // Remove
  config={{
    embeddedWallets: {createOnLogin: 'users-without-wallets'} // Add
  }}
>
  ...
</PrivyProvider>
```

* Removed the deprecated `additionalChains` and `rpcConfig` props from `PrivyProvider` config, please configure these via the `supportedChains`

```tsx  theme={"system"}
<PrivyProvider
  config={{
    additionalChains: [], // Remove
    rpcConfig: {}, // Remove
    supportedChains: [] // Add
  }}
>
  ...
</PrivyProvider>
```

* Removed the deprecated `noPromptOnSignature` configuration option. Configure wallet UIs in the dashboard, or use the updated `showWalletUIs` option.

```tsx  theme={"system"}
<PrivyProvider
  config={{
    embeddedWallets: {
      noPromptOnSignature: true, // Remove
      showWalletUIs: false // Add
    }
  }}
>
  ...
</PrivyProvider>
```

#### EVM

* Removed the deprecated `getEthersProvider` and `getWeb3jsProvider` from the `ConnectedWallet` class. Use `getEthereumProvider` instead.

```ts {skip-check} theme={"system"}
const provider = await wallet.getEthersProvider(); // [!code --]
const privyProvider = await wallet.getEthereumProvider(); // [!code ++]
const provider = new ethers.providers.Web3Provider(privyProvider); // [!code ++]

const provider = await wallet.getWeb3jsProvider(); // [!code --]
const privyProvider = await wallet.getEthereumProvider(); // [!code ++]
const provider = new Web3(privyProvider); // [!code ++]
```

* Ethereum `sendTransaction` method now returns a `Promise<{hash: string}>` instead of a `Promise<TransactionReceipt>`. To get the full details of the submitted transaction, use a library like [viem](https://viem.sh/docs/actions/public/getTransactionReceipt).

```tsx  theme={"system"}
const receipt = await sendTransaction({...}); // [!code --]
const {hash} = await sendTransaction({...}); // [!code ++]
const receipt = await publicClient.waitForTransactionReceipt({hash}); // [!code ++]
```

* Removed the experimental `waitForTransactionConfirmation` config option as it is the default behavior.

```tsx  theme={"system"}
<PrivyProvider
  config={{
    embeddedWallets: {
      waitForTransactionConfirmation: false // [!code --]
    }
  }}
>
  ...
</PrivyProvider>
```

* Updated `signMessage`, `signTypedData`, `sendTransaction`, and `signTransaction` methods:

<Tabs>
  <Tab title="signMessage">
    ```tsx  theme={"system"}
    const {signMessage} = usePrivy();
    // `uiOptions` and `address` are optional
    const signature = await signMessage(message, uiOptions, address); // [!code --]
    // the first argument should be formatted `{message: string}`
    const {signature} = await signMessage({message}, {uiOptions, address}); // [!code ++]
    ```
  </Tab>

  <Tab title="signTypedData">
    ```tsx  theme={"system"}
    const {signTypedData} = usePrivy();
    // `uiOptions` and `address` are optional
    const signature = await signTypedData(typedData, uiOptions, address); // [!code --]
    const {signature} = await signTypedData(typedData, {uiOptions, address}); // [!code ++]
    ```
  </Tab>

  <Tab title="sendTransaction">
    ```tsx  theme={"system"}
    const {sendTransaction} = usePrivy();
    // `uiOptions`, `fundWalletConfig`, and `address` are optional
    const receipt = await sendTransaction(transaction, uiOptions, fundWalletConfig, address); // [!code --]
    const {hash} = await sendTransaction(transaction, {uiOptions, fundWalletConfig, address}); // [!code ++]
    ```
  </Tab>

  <Tab title="signTransaction">
    ```tsx  theme={"system"}
    const {signTransaction} = usePrivy();
    // `uiOptions`, and `address` are optional
    const signature = await signTransaction(transaction, uiOptions, fundWalletConfig, address); // [!code --]
    const {signature} = await signTransaction(transaction, {uiOptions, address}); // [!code ++]
    ```
  </Tab>
</Tabs>

#### Smart Wallets

* Updated `signMessage`, `signTypedData`, and `sendTransaction` methods of the smart wallet client:

<Tabs>
  <Tab title="signMessage">
    ```tsx  theme={"system"}
    import {useSmartWallets} from '@privy-io/react-auth/smart-wallets';

    const {client} = useSmartWallets();
    // `uiOptions` and `address` are optional
    const signature = await client.signMessage({message}, uiOptions, address); // [!code --]
    const signature = await client.signMessage({message}, {uiOptions, address}); // [!code ++]
    ```
  </Tab>

  <Tab title="signTypedData">
    ```tsx  theme={"system"}
    import {useSmartWallets} from '@privy-io/react-auth/smart-wallets';

    const {client} = useSmartWallets();
    // `uiOptions` and `address` are optional
    const signature = await client.signTypedData(typedData, uiOptions, address); // [!code --]
    const signature = await client.signTypedData(typedData, {uiOptions, address}); // [!code ++]
    ```
  </Tab>

  <Tab title="sendTransaction">
    ```tsx  theme={"system"}
    import {useSmartWallets} from '@privy-io/react-auth/smart-wallets';

    const {client} = useSmartWallets();
    // `uiOptions`, `fundWalletConfig`, and `address` are optional
    const hash = await client.sendTransaction(transaction, uiOptions, fundWalletConfig, address); // [!code --]
    const hash = await client.sendTransaction(transaction, {uiOptions, fundWalletConfig, address}); // [!code ++]
    ```
  </Tab>
</Tabs>

#### Solana

* Migrated `useSendSolanaTransaction` from `@privy-io/react-auth` to `useSendTransaction` from `@privy-io/react-auth/solana` (Solana-specific export path)

```tsx  theme={"system"}
import {useSendSolanaTransaction} from '@privy-io/react-auth'; // [!code --]
import {useSendTransaction} from '@privy-io/react-auth/solana'; // [!code ++]

...

const {sendSolanaTransaction} = useSendSolanaTransaction(); // [!code --]
const {sendTransaction} = useSendTransaction(); // [!code ++]
```

* Removed `sendSolanaTransaction` from `usePrivy` in favor of exporting `sendTransaction` from `useSendTransaction` from `@privy-io/react-auth/solana`

```tsx  theme={"system"}
import {usePrivy} from '@privy-io/react-auth'; // [!code --]
import {useSendTransaction} from '@privy-io/react-auth/solana'; // [!code ++]

...

const {sendSolanaTransaction} = usePrivy(); // [!code --]
const {sendTransaction} = useSendTransaction(); // [!code ++]
```

* Removed `delegateWalletAction` from `useSolanaWallets`. Use `delegateWallet` from `useDelegatedActions` instead.

```tsx  theme={"system"}
import {useSolanaWallets} from '@privy-io/react-auth/solana'; // [!code --]
import {useDelegatedActions} from '@privy-io/react-auth'; // [!code ++]

...

const {delegateWalletAction} = useSolanaWallets(); // [!code --]
delegateWalletAction(); // [!code --]

const {delegateWallet} = useDelegatedActions(); // [!code ++]
await delegateWallet({  // [!code ++]
  address: '<wallet to delegate>', // [!code ++]
  chainType: 'solana', // [!code ++]
}); // [!code ++]
```

* Removed rpcUrl from `fundWallet` from `useSolanaWallets`. Set rpcUrl in `config.solanaClusters` prop of the `PrivyProvider` instead

```tsx  theme={"system"}
import {useSolanaWallets} from '@privy-io/react-auth/solana';

const {fundWallet} = useSolanaWallets();
fundWallet({
  address: '<wallet to fund>',
  cluster: {name: 'mainnet-beta', rpcUrl: 'https://api.mainnet-beta.solana.com'}, // [!code --]
  cluster: {name: 'mainnet-beta'} // [!code ++]
});

<PrivyProvider
  appId="your-privy-app-id"
  config={{
    ...theRestOfYourConfig,
    // Replace this with your required clusters and custom RPC URLs
    solanaClusters: [{name: 'mainnet-beta', rpcUrl: 'https://api.mainnet-beta.solana.com'}] // [!code ++]
  }}
>
  {/* your app's content */}
</PrivyProvider>;
```

### Connectors

* Removed the `setActiveWallet` method - use the `wallets` array directly to interact with wallets.

### Callbacks

* Updated all non-error [callbacks](/authentication/user-authentication/login-methods/email) to use named arguments instead of positional arguments.

```tsx  theme={"system"}
const {login} = useLogin({
  onComplete: (user, isNewUser, wasAlreadyAuthenticated, loginMethod, linkedAccount) => { // [!code --]
  onComplete: ({user, isNewUser, wasAlreadyAuthenticated, loginMethod, linkedAccount}) => { // [!code ++]

    console.log(user, isNewUser, wasAlreadyAuthenticated, loginMethod, linkedAccount);
    // Any logic you'd like to execute if the user is/becomes authenticated while this
    // component is mounted
  },
  ...
  onError: (error) => { // onError will continue to stay as a singular error argument
    console.log(error)
  }})

...
 const {reauthorize} = useOAuthTokens({
  onOAuthTokenGrant: (tokens: OAuthTokens, {user}: {user: User}) => {  // [!code --]
  onOAuthTokenGrant: ({tokens, user}) => {  // [!code ++]
    const oAuthToken = tokens.accessToken

  ...
  }})
```


# Migrating to 3.0
Source: https://docs.privy.io/basics/react/advanced/migrating-to-3.0



This guide will help you migrate your Privy React SDK from v2.x.x to v3.0.0.

To install the latest version:

```bash  theme={"system"}
npm i @privy-io/react-auth@3
```

## New features and improvements 🎉

* Simplified Solana integration with one wallet per account and direct method access
* Streamlined peer dependencies required for Solana
* Removal of deprecated fields and methods

For the full set of changes check out our [changelog](/changelogs/react-auth).

## Solana Updates

### Update Peer Dependencies

If your app uses Privy's Solana wallets, the required peer dependencies have changed in v3.0:

**Remove these peer dependencies:**

* `@solana/web3.js`
* `@solana/spl-token`

**Install these new peer dependencies:**

* `@solana/kit`
* `@solana-program/memo`
* `@solana-program/system`
* `@solana-program/token`

<Accordion title="Webpack configurations">
  Additionally, if you are using webpack, include the following configurations to add them to webpack's `externals` config. Note that these configurations are not needed if you are using Turbopack:

  ```js  theme={"system"}
  // webpack.config.js
  module.exports = {
    //...
    externals: {
      ['@solana/kit']: 'commonjs @solana/kit',
      ['@solana-program/memo']: 'commonjs @solana-program/memo',
      ['@solana-program/system']: 'commonjs @solana-program/system',
      ['@solana-program/token']: 'commonjs @solana-program/token'
    }
  };

  // next.config.js
  module.exports = {
    webpack: (config) => {
      // ...
      config.externals['@solana/kit'] = 'commonjs @solana/kit';
      config.externals['@solana-program/memo'] = 'commonjs @solana-program/memo';
      config.externals['@solana-program/system'] = 'commonjs @solana-program/system';
      config.externals['@solana-program/token'] = 'commonjs @solana-program/token';
      return config;
    }
  };
  ```
</Accordion>

### Solana RPC configuration

* For Privy embedded wallet flows only (UI `signTransaction` and `signAndSendTransaction`), set RPCs in `config.solana.rpcs`. This replaces `solanaClusters`.

```tsx  theme={"system"}
import {createSolanaRpc, createSolanaRpcSubscriptions} from '@solana/kit'; // [!code ++]

<PrivyProvider
  appId="your-privy-app-id"
  config={{
    ...theRestOfYourConfig,
    solanaClusters: [{name: 'mainnet-beta', rpcUrl: 'https://api.mainnet-beta.solana.com'}] // [!code --]
    solana: {  // [!code ++]
      rpcs: { // [!code ++]
        'solana:mainnet': { // [!code ++]
          rpc: createSolanaRpc('https://api.mainnet-beta.solana.com'), // [!code ++]
          rpcSubscriptions: createSolanaRpcSubscriptions('wss://api.mainnet-beta.solana.com') // [!code ++]
        }, // [!code ++]
      }
    }
  }}
>
  {/* your app's content */}
</PrivyProvider>;
```

### Replace `useSolanaWallets`

* Replace `useSolanaWallets` with `useWallets`, `useCreateWallet`, and `useExportWallet` from the Solana entrypoint. The new `useWallets` hook returns `ConnectedStandardSolanaWallet[]`.

```tsx  theme={"system"}
import {useSolanaWallets} from '@privy-io/react-auth/solana'; // [!code --]
import {useWallets, useCreateWallet, useExportWallet} from '@privy-io/react-auth/solana'; // [!code ++]

const {ready, wallets, createWallet, exportWallet} = useSolanaWallets(); // [!code --]
const {ready, wallets} = useWallets(); // [!code ++]
const {createWallet} = useCreateWallet(); // [!code ++]
const {exportWallet} = useExportWallet(); // [!code ++]
```

Key differences between `ConnectedSolanaWallet` and `ConnectedStandardSolanaWallet`:

* Each `wallet` represents a single connected account
* Methods are available directly on the wallet instance:
  * `wallet.signMessage({message})`
  * `wallet.signTransaction({transaction, chain})`
  * `wallet.signAndSendTransaction({transaction, chain})`
  * `wallet.signAndSendAllTransaction({transaction, chain}[])`
  * `wallet.disconnect()`
* The [Solana standard wallet](https://docs.phantom.com/developer-powertools/wallet-standard) is available at `wallet.standardWallet` (for icon/name/etc.)
* **Removed `wallet.loginOrLink()` method** - Use `useLoginWithSiws` and `useLinkWithSiws` instead:

```tsx  theme={"system"}
import {useLoginWithSiws, useLinkWithSiws} from '@privy-io/react-auth'; // [!code ++]

const {generateSiwsMessage, loginWithSiws} = useLoginWithSiws(); // [!code ++]
const {generateSiwsMessage, linkWithSiws} = useLinkWithSiws(); // [!code ++]

// Login flow
await wallets[0].loginOrLink(); // [!code --]
const message = await generateSiwsMessage({address: wallets[0].address}); // [!code ++]
const encodedMessage = new TextEncoder().encode(message); // [!code ++]
const results = await wallets[0].signMessage({message: encodedMessage}); // [!code ++]
await loginWithSiws({message: encodedMessage, signature: results.signature}); // [!code ++]

// Link flow (similar pattern with linkWithSiws)
const results = await wallets[0].signMessage({message: encodedMessage}); // [!code ++]
await linkWithSiws({message: encodedMessage, signature: results.signature}); // [!code ++]
```

### Rename `useSendTransaction`

* Update `useSendTransaction` from `@privy-io/react-auth/solana` to `useSignAndSendTransaction` from `@privy-io/react-auth/solana`

```tsx  theme={"system"}
import {useSendTransaction} from '@privy-io/react-auth/solana'; // [!code --]
import {useSignAndSendTransaction} from '@privy-io/react-auth/solana'; // [!code ++]

...

const {sendTransaction} = useSendTransaction(); // [!code --]
const {signAndSendTransaction} = useSignAndSendTransaction(); // [!code ++]
```

### Usage Examples

* All Solana RPCs now expect buffer inputs.

#### New solana wallet usage

```tsx  theme={"system"}
import {useWallets, type ConnectedStandardSolanaWallet} from '@privy-io/react-auth/solana';
import {TextEncoder} from '@solana/kit';

export function SolanaWallets() {
  const {ready, wallets} = useWallets();
  if (!ready) return <p>Loading...</p>;

  return (
    <div>
      {wallets.map((wallet: ConnectedStandardSolanaWallet) => (
        <div key={wallet.address}>
          <img src={wallet.standardWallet.icon} width={16} height={16} />
          <span>{wallet.standardWallet.name}</span>
          <code>{wallet.address}</code>
          <button
            onClick={async () => {
              const message = new TextEncoder().encode('Hello, world!');
              const {signature} = await wallet.signMessage({message});
              console.log('signature', signature);
            }}
          >
            Sign message
          </button>
        </div>
      ))}
    </div>
  );
}
```

#### Sign and send via hooks (with optional UI configuration)

```tsx  theme={"system"}
import {
  useWallets,
  useSignMessage,
  useSignTransaction,
  useSignAndSendTransaction
} from '@privy-io/react-auth/solana';

export function Actions() {
  const {wallets} = useWallets();
  const {signMessage} = useSignMessage();
  const {signTransaction} = useSignTransaction();
  const {signAndSendTransaction} = useSignAndSendTransaction();

  const wallet = wallets[0];
  if (!wallet) return null;

  return (
    <div>
      <button
        onClick={async () => {
          const message = new TextEncoder().encode('Hello from Privy');
          const {signature} = await signMessage({
            wallet,
            message,
            options: {uiOptions: {showWalletUIs: true}}
          });
          console.log(signature);
        }}
      >
        Sign message (hook)
      </button>

      <button
        onClick={async () => {
          // Create an encoded transaction using @solana/kit or @web3.js
          const transaction = tx; // type Uint8Array
          const {signedTransaction} = await signTransaction({
            wallet,
            transaction,
            chain: 'solana:devnet'
          });
          console.log(signedTransaction);
        }}
      >
        Sign transaction (hook)
      </button>

      <button
        onClick={async () => {
          // Create an encoded transaction using @solana/kit or @web3.js
          const transaction = tx; // type Uint8Array
          const {signature} = await signAndSendTransaction({
            wallet,
            transaction,
            chain: 'solana:devnet'
          });
          console.log(signature);
        }}
      >
        Sign & send (hook)
      </button>
    </div>
  );
}
```

## Other interface changes

### Funding

* **Updated `fundWallet` interface**

```tsx  theme={"system"}
import {useFundWallet: useFundSolanaWallet} from '@privy-io/react-auth/solana';
import {useFundWallet: useFundEthereumWallet} from '@privy-io/react-auth';

...

const {fundWallet} = useFundSolanaWallet();
await fundWallet('<solana address>', {amount: '1', asset: 'native-currency', chain: 'solana:devnet'}); // [!code --]
await fundWallet({ // [!code ++]
  address: '<solana address>', // [!code ++]
  options: {amount: '1', asset: 'SOL', chain: 'solana:devnet'} // [!code ++]
}); // [!code ++]

const {fundWallet} = useFundEthereumWallet();
await fundWallet('<ethereum address>', {amount: '1000', asset: 'native-currency', chain: {id: 1}}); // [!code --]
await fundWallet({ // [!code ++]
  address: '<ethereum address>', // [!code ++]
  options: {amount: '1000', asset: 'native-currency', chain: {id: 1}} // [!code ++]
}); // [!code ++]

```

## Removed/Deprecated Items

* **Removed `suggestedAddress` from `connectWallet` and `linkWallet`**

```tsx  theme={"system"}
connectWallet({suggestedAddress: '0x123...'}); // [!code --]
connectWallet({description: `Connect the wallet with address ${address}`}); // [!code ++]
```

* **Removed `detected_wallets` from wallet lists/configuration**

```tsx  theme={"system"}
<PrivyProvider
  config={{
    appearance: {
      walletList: [
        'detected_wallets', // [!code --]
        'detected_ethereum_wallets', // [!code ++]
        'detected_solana_wallets', // [!code ++]
        'metamask'
        // ...
      ]
    }
    // ...
  }}
>
  {/* your app's content */}
</PrivyProvider>
```

* **Removed deprecated Moonpay config and types, add config to `PrivyProviderConfig` instead**

```tsx  theme={"system"}
fundEvmWallet(address, {
  config: {
    // [!code --]
    currencyCode: 'ETH_ETHEREUM', // [!code --]
    quoteCurrencyAmount: 0.01 // [!code --]
    // [!code --]
  }, // [!code --]
  provider: 'moonpay' // [!code --]
});

<PrivyProvider
  config={{
    fundingMethodConfig: {moonpay: {useSandbox: true}} // [!code ++]
    // ...
  }}
>
  ...
</PrivyProvider>;

fundEvmWallet(address, {
  chain: mainnet, // [!code ++]
  amount: '0.01', // [!code ++]
  defaultFundingMethod: 'card' // [!code ++]
});
```

* **Removed deprecated `requireUserPasswordOnCreate` and related embedded wallet config fields**
* \*\*Removed `embeddedWallets` level `createOnLogin` field. Use `embeddedWallets.etherum.createOnLogin` or `embeddedWallets.solana.createOnLogin` instead. \*\*

```tsx  theme={"system"}
<PrivyProvider
  config={{
    embeddedWallets: {
      requireUserPasswordOnCreate: true, // [!code --]
      createOnLogin: 'all-users', // [!code --]
      ethereum: {createOnLogin: 'all-users'} // [!code ++]
      // ...
    }
    // ...
  }}
>
  {/* your app's content */}
</PrivyProvider>
```

* **Removed `useLoginToFrame` and replaced with `useLoginToMiniApp`**

```tsx  theme={"system"}
export {useLoginToFrame} from '@privy-io/react-auth'; // [!code --]
export {useLoginToMiniApp} from '@privy-io/react-auth'; // [!code ++]
```

* **Removed `useSignAuthorization()` - Use `useSign7702Authorization()` instead**

```tsx  theme={"system"}
import {useSignAuthorization} from '@privy-io/react-auth'; // [!code --]
import {useSign7702Authorization} from '@privy-io/react-auth'; // [!code ++]

const {signAuthorization} = useSignAuthorization(); // [!code --]
const {sign7702Authorization} = useSign7702Authorization(); // [!code ++]
```

* **Removed `useSetWalletPassword()` - Use `useSetWalletRecovery` instead**

```tsx  theme={"system"}
import {useSetWalletPassword} from '@privy-io/react-auth'; // [!code --]
import {useSetWalletRecovery} from '@privy-io/react-auth'; // [!code ++]

const {setWalletPassword} = useSetWalletPassword(); // [!code --]
const {setWalletRecovery} = useSetWalletRecovery(); // [!code ++]
```

### Updated Types

* **Removed `verifiedAt` from `LinkMetadata` and all linked accounts. Use `firstVerifiedAt` and `latestVerifiedAt` instead of the deprecated `verifiedAt`.**

```tsx  theme={"system"}
const verifiedDate = user.wallet.verifiedAt; // [!code --]
const verifiedDate = user.wallet.firstVerifiedA; // [!code ++]
```


# Features
Source: https://docs.privy.io/basics/react/features

Learn about the features supported by the React SDK

export const FeatureMatrix = ({sdk}) => {
  const sdks = sdk ? [sdk] : ['react', 'reactNative', 'swift', 'android', 'flutter', 'unity'];
  const sdkNames = {
    react: 'React',
    reactNative: 'React Native',
    swift: 'Swift',
    android: 'Android',
    flutter: 'Flutter',
    unity: 'Unity'
  };
  const matrix = [{
    name: 'Authentication',
    features: [{
      name: 'Email',
      react: true,
      reactNative: true,
      swift: true,
      android: true,
      flutter: true,
      unity: true
    }, {
      name: 'SMS',
      react: true,
      reactNative: true,
      swift: true,
      android: true,
      flutter: true
    }, {
      name: 'OAuth',
      react: true,
      reactNative: true,
      swift: 'Google, Apple, Twitter, Discord',
      android: 'Google, Discord, Twitter',
      flutter: 'Google, Apple, Twitter, Discord',
      unity: 'Google, Apple, Twitter, Discord'
    }, {
      name: 'SIWE (Sign In with Ethereum)',
      react: true,
      reactNative: true,
      swift: true
    }, {
      name: 'SIWS (Sign In with Solana)',
      react: true,
      reactNative: true
    }, {
      name: 'Farcaster',
      react: true,
      reactNative: true
    }, {
      name: 'Telegram',
      react: true
    }, {
      name: 'Custom Auth',
      react: true,
      reactNative: true,
      swift: true,
      android: true,
      flutter: true
    }, {
      name: 'Passkeys',
      react: true,
      reactNative: true
    }]
  }, {
    name: 'Farcaster',
    features: [{
      name: 'SIWF',
      react: true,
      reactNative: true
    }]
  }, {
    name: 'Embedded Wallets',
    features: [{
      name: 'Creating wallets manually',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum', 'solana'],
      android: ['ethereum', 'solana'],
      flutter: ['ethereum', 'solana'],
      unity: ['ethereum', 'solana']
    }, {
      name: 'Creating wallets automatically',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Pregenerating wallets',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum', 'solana'],
      android: ['ethereum', 'solana'],
      flutter: ['ethereum', 'solana']
    }, {
      name: 'Signing messages and transactions',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum', 'solana'],
      android: ['ethereum', 'solana'],
      flutter: ['ethereum', 'solana'],
      unity: ['ethereum', 'solana']
    }, {
      name: 'Broadcasting transactions',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum'],
      android: ['ethereum'],
      flutter: ['ethereum'],
      unity: ['ethereum']
    }, {
      name: 'Native smart wallets',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: 'Automatic recovery',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum', 'solana'],
      android: ['ethereum', 'solana'],
      flutter: ['ethereum', 'solana'],
      unity: ['ethereum']
    }, {
      name: 'User controlled recovery',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Transaction MFA',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Key Export',
      react: ['ethereum', 'solana']
    }, {
      name: 'Key Import',
      react: ['ethereum', 'solana']
    }, {
      name: 'HD wallets',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum'],
      android: ['ethereum'],
      flutter: ['ethereum'],
      unity: ['ethereum']
    }, {
      name: 'Session signers',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Global wallets (Cross App Accounts)',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: 'Custom EVM (Ethereum) network support',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: 'Custom SVM (Solana) network support',
      react: ['solana'],
      reactNative: ['solana']
    }]
  }, {
    name: 'Connectors',
    features: [{
      name: 'External wallets',
      react: ['ethereum', 'solana']
    }, {
      name: 'Wagmi',
      react: ['ethereum']
    }, {
      name: 'Viem',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: 'Ethers',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: '@solana/web3.js',
      react: ['solana']
    }, {
      name: 'web3swift',
      swift: ['ethereum']
    }]
  }, {
    name: 'Funding',
    features: [{
      name: 'Transfer or bridge from wallet',
      react: ['ethereum', 'solana']
    }, {
      name: 'Transfer from exchange',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Pay with card',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }]
  }];
  const filteredMatrix = matrix.map(section => {
    return {
      ...section,
      features: section.features.filter(featureItem => {
        if (sdk) {
          return featureItem[sdk] !== undefined;
        }
        return true;
      })
    };
  }).filter(section => {
    return section.features.length > 0;
  });
  return <table style={{
    display: 'table',
    width: '100%'
  }}>
      {sdk ? null : <thead>
          <tr>
            <th></th>
            {sdks.map(sdk => <th>{sdkNames[sdk]}</th>)}
          </tr>
        </thead>}
      <tbody>
        {filteredMatrix.map(section => <>
            <tr>
              <td>
                <strong>{section.name}</strong>
              </td>
              {sdks.map(() => <td></td>)}
            </tr>
            {section.features.map(feature => <tr>
                <td>
                  <em>{feature.name}</em>
                </td>
                {sdks.map(sdk => {
    const supported = feature[sdk];
    if (supported === true) {
      return <td>✅</td>;
    } else if (!supported) {
      return <td></td>;
    } else if (Array.isArray(supported)) {
      return <td>
                        {supported.map(item => item === 'ethereum' ? <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/ethereum.png" noZoom style={{
        display: 'inline',
        margin: '2px',
        width: '18px'
      }} /> : <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/solana.png" noZoom style={{
        display: 'inline',
        margin: '2px',
        width: '18px'
      }} />)}
                      </td>;
    } else {
      return <td>{supported}</td>;
    }
  })}
              </tr>)}
          </>)}
      </tbody>
    </table>;
};

## Supported features

<FeatureMatrix sdk="react" />


# null
Source: https://docs.privy.io/basics/react/installation



## Requirements

* React 18 or higher
* TypeScript 5 or higher

## Installation

Install the Privy React SDK using your package manager of choice:

<CodeGroup>
  ```bash npm theme={"system"}
  npm install @privy-io/react-auth@latest
  ```

  ```bash pnpm theme={"system"}
  pnpm install @privy-io/react-auth@latest
  ```

  ```bash yarn theme={"system"}
  yarn add @privy-io/react-auth@latest
  ```
</CodeGroup>

<Accordion title="Solana dependencies">
  If your app uses Privy's Solana wallets, install the following peer dependencies:

  * `@solana/kit`
  * `@solana-program/memo`
  * `@solana-program/system`
  * `@solana-program/token`

  Additionally, if you are using webpack, include the following configurations to add them to webpack's `externals` config. Note that these configurations are not needed if you are using Turbopack:

  ```js  theme={"system"}
  // webpack.config.js
  module.exports = {
    //...
    externals: {
      ['@solana/kit']: 'commonjs @solana/kit',
      ['@solana-program/memo']: 'commonjs @solana-program/memo',
      ['@solana-program/system']: 'commonjs @solana-program/system',
      ['@solana-program/token']: 'commonjs @solana-program/token'
    }
  };

  // next.config.js
  module.exports = {
    webpack: (config) => {
      // ...
      config.externals['@solana/kit'] = 'commonjs @solana/kit';
      config.externals['@solana-program/memo'] = 'commonjs @solana-program/memo';
      config.externals['@solana-program/system'] = 'commonjs @solana-program/system';
      config.externals['@solana-program/token'] = 'commonjs @solana-program/token';
      return config;
    }
  };
  ```
</Accordion>


# Quickstart
Source: https://docs.privy.io/basics/react/quickstart

Learn how to authenticate users, create embedded wallets, and send transactions in your React app

## 0. Prerequisites

This guide assumes that you have completed the [Setup](/basics/react/setup) guide.

## 1. Enable a user to log in via email

<Tip>
  This quickstart guide will demonstrate how to authenticate a user with a one time password as an
  example, but Privy supports many authentication methods. Explore our [Authentication
  docs](/authentication/overview) to learn about other methods such as socials, passkeys, and
  external wallets to authenticate users in your app.
</Tip>

**To authenticate a user via their email address, use the React SDK's `useLoginWithEmail` hook.**

```tsx  theme={"system"}
import {useLoginWithEmail} from '@privy-io/react-auth';
...
const {sendCode, loginWithCode} = useLoginWithEmail();
```

Ensure that this hook is mounted in a component that is wrapped by the [PrivyProvider](/basics/react/setup#initializing-privy).
You can use the returned methods **`sendCode`** and **`loginWithCode`** to authenticate your user per the instructions below.

### Send an OTP

Send a one-time passcode (OTP) to the user's **email** by passing their email address to the **`sendCode`** method returned from `useLoginWithEmail`:

```tsx  theme={"system"}
import {useState} from 'react';
import {useLoginWithEmail} from '@privy-io/react-auth';

export default function LoginWithEmail() {
  const [email, setEmail] = useState('');
  const [code, setCode] = useState('');
  const {sendCode, loginWithCode} = useLoginWithEmail();

  return (
    <div>
      <input onChange={(e) => setEmail(e.currentTarget.value)} value={email} />
      <button onClick={() => sendCode({email})}>Send Code</button>
      <input onChange={(e) => setCode(e.currentTarget.value)} value={code} />
      <button onClick={() => loginWithCode({code})}>Login</button>
    </div>
  );
}
```

## 2. Create an embedded wallet for the user

Your app can configure Privy to [**automatically** create wallets](/basics/react/advanced/automatic-wallet-creation) for your users as part of their **login** flow. The embedded wallet will be generated and linked to the user object upon authentication.

Alternatively your app can [**manually** create wallets](/wallets/wallets/create/create-a-wallet) for users when required.

<Info>Privy can provision wallets for your users on both **Ethereum** and **Solana**.</Info>

## 3. Send a transaction with the embedded wallet

<Tabs>
  <Tab title="EVM">
    With the users' embedded wallet, your application can now prompt the user to sign and send transactions.

    ```tsx  theme={"system"}
    import {useSendTransaction} from '@privy-io/react-auth';
    export default function SendTransactionButton() {
      const {sendTransaction} = useSendTransaction();
      const onSendTransaction = async () => {
        sendTransaction({
          to: '0xE3070d3e4309afA3bC9a6b057685743CF42da77C',
          value: 100000
        });
      };

      return <button onClick={onSendTransaction}>Send Transaction</button>;
    }
    ```

    <Tip>
      [Learn more](/wallets/using-wallets/ethereum/send-a-transaction) about sending transactions with
      the embedded wallet. Privy enables you to take many actions on the embedded wallet, including
      [sign a message](/wallets/using-wallets/ethereum/sign-a-message), [sign typed
      data](/wallets/using-wallets/ethereum/sign-typed-data), and [sign a
      transaction](/wallets/using-wallets/ethereum/sign-a-transaction).
    </Tip>
  </Tab>

  <Tab title="Solana">
    With the users' embedded wallet, your application can now prompt the user to sign and send transactions.

    ```tsx  theme={"system"}
    import {useSendTransaction} from '@privy-io/react-auth/solana';
    import {Connection, Transaction, VersionedTransaction, SystemProgram, LAMPORTS_PER_SOL} from '@solana/web3.js';

    export default function SendTransactionButton() {
      const {sendTransaction} = useSendTransaction();
      const connection = new Connection('https://api.mainnet-beta.solana.com');

      // Create a new transaction
      const transaction = new Transaction().add(
        SystemProgram.transfer({
          fromPubkey: wallet.publicKey,
          toPubkey: new PublicKey('RECIPIENT_ADDRESS_HERE'),
          lamports: 0.1 * LAMPORTS_PER_SOL
        })
      );

      const onSendTransaction = async () => {
        sendTransaction({
          transaction,
          connection
        });
      }

      return <button onClick={onSendTransaction}>Send Transaction</button>;

    }
    ```

    <Tip>
      [Learn more](/wallets/using-wallets/solana/send-a-transaction) about sending transactions with
      the embedded wallet. Privy enables you to take many actions on the embedded wallet, including [send a transaction](/wallets/using-wallets/solana/send-a-transaction), [sign a message](/wallets/using-wallets/solana/sign-a-message), and [sign a
      transaction](/wallets/using-wallets/solana/sign-a-transaction).
    </Tip>
  </Tab>
</Tabs>

Congratulations, you have successfully been able to integrate Privy authentication and wallet into your React application!


# null
Source: https://docs.privy.io/basics/react/setup



## Prerequisites

Before you begin, make sure you have [set up your Privy app and obtained your app ID](/basics/get-started/dashboard/create-new-app) from the Privy Dashboard.

<Tip>
  Deploying your app across multiple domains or environments? Learn how to use [app
  clients](/basics/get-started/dashboard/app-clients) to customize Privy's behavior for different
  environments.
</Tip>

## Initializing Privy

In your project, **import the `PrivyProvider` component and wrap your app with it**.
The `PrivyProvider` must wrap *any* component or page that will use the Privy React SDK, and it is generally recommended to render it as close to the root of your application as possible.

<Tip>
  If you're new to React and using contexts, check out
  [these](https://react.dev/learn/thinking-in-react)
  [resources](https://react.dev/learn/passing-data-deeply-with-context)!
</Tip>

<Tabs>
  <Tab title="Ethereum">
    <CodeGroup>
      ```tsx NextJS theme={"system"}
      'use client';

      import {PrivyProvider} from '@privy-io/react-auth';

      export default function Providers({children}: {children: React.ReactNode}) {
        return (
          <PrivyProvider
            appId="your-privy-app-id"
            clientId="your-app-client-id"
            config={{
              // Create embedded wallets for users who don't have a wallet
              embeddedWallets: {
                ethereum: {
                  createOnLogin: 'users-without-wallets'
                }
              }
            }}
          >
            {children}
          </PrivyProvider>
        );
      }
      ```

      ```tsx Create React App theme={"system"}
      import React from 'react';
      import ReactDOM from 'react-dom/client';

      import './index.css';

      import {PrivyProvider} from '@privy-io/react-auth';

      import App from './App';

      const root = ReactDOM.createRoot(document.getElementById('root'));

      root.render(
        <React.StrictMode>
          <PrivyProvider
            appId="your-privy-app-id"
            clientId="your-app-client-id"
            config={{
              // Create embedded wallets for users who don't have a wallet
              embeddedWallets: {
                ethereum: {
                  createOnLogin: 'users-without-wallets'
                }
              }
            }}
          >
            <App />
          </PrivyProvider>
        </React.StrictMode>
      );
      ```
    </CodeGroup>
  </Tab>

  <Tab title="Solana">
    <CodeGroup>
      ```tsx NextJS theme={"system"}
      'use client';

      import {PrivyProvider} from '@privy-io/react-auth';

      export default function Providers({children}: {children: React.ReactNode}) {
        return (
          <PrivyProvider
            appId="your-privy-app-id"
            clientId="your-app-client-id"
            config={{
              // Create embedded wallets for users who don't have a wallet
              embeddedWallets: {
                solana: {
                  createOnLogin: 'users-without-wallets'
                }
              }
            }}
          >
            {children}
          </PrivyProvider>
        );
      }
      ```

      ```tsx Create React App theme={"system"}
      import React from 'react';
      import ReactDOM from 'react-dom/client';

      import './index.css';

      import {PrivyProvider} from '@privy-io/react-auth';

      import App from './App';

      const root = ReactDOM.createRoot(document.getElementById('root'));

      root.render(
        <React.StrictMode>
          <PrivyProvider
            appId="your-privy-app-id"
            clientId="your-app-client-id"
            config={{
              // Create embedded wallets for users who don't have a wallet
              embeddedWallets: {
                solana: {
                  createOnLogin: 'users-without-wallets'
                }
              }
            }}
          >
            <App />
          </PrivyProvider>
        </React.StrictMode>
      );
      ```
    </CodeGroup>

    <Info>
      {' '}

      To use external Solana wallets, you must pass `toSolanaWalletConnectors()` to the
      `externalWallets` prop in your `PrivyProvider` config. Learn more
      [here](/wallets/connectors/setup/configuring-external-connector-chains).
    </Info>
  </Tab>
</Tabs>

## Configuration

The `PrivyProvider` component accepts the following props:

<ParamField path="appId" type="string" required>
  Your Privy App ID. You can find this in the Privy Dashboard.
</ParamField>

<ParamField path="clientId" type="string">
  (Optional) A client ID to be used for this app client. Learn more about app clients
  [here](/basics/get-started/dashboard/app-clients).
</ParamField>

<ParamField path="config" type="Object">
  Configuration options for the Privy SDK.
</ParamField>

<Info>
  For more information on the `config` object, look under **React > Advanced** for guides like
  [customizing appearance](/basics/react/advanced/configuring-appearance) for our UI components and
  [configuring networks](/basics/react/advanced/configuring-evm-networks).
</Info>

## Waiting for Privy to be ready

When the `PrivyProvider` is first rendered on your page, the Privy SDK will initialize some state about the current user. This might include checking if the user has a wallet connected, refreshing expired auth tokens, fetching up-to-date user data, and more.

**It's important to wait until the `PrivyProvider` has finished initializing *before* you consume Privy's state and interfaces**, to ensure that the state you consume is accurate and not stale.

To determine whether the Privy SDK has fully initialized on your page, **check the `ready` Boolean returned by the `usePrivy` hook.** When `ready` is true, Privy has completed initialization, and your app can consume Privy's state and interfaces.

```tsx  theme={"system"}
import {usePrivy} from '@privy-io/react-auth';

function YourComponent() {
  const {ready} = usePrivy();

  if (!ready) {
    return <div>Loading...</div>;
  }

  // Now it's safe to use other Privy hooks and state
  return <div>Privy is ready!</div>;
}
```

<Info>
  **Using wallets?** Use the [ready](/wallets/wallets/get-a-wallet/get-connected-wallet) indicator
  from the `useWallets` hook to wait for wallets to complete loading.
</Info>

<CardGroup cols={2}>
  <Card title="Quickstart Guide" icon="rocket" href="/basics/react/quickstart">
    Learn how to log users in and transact with embedded wallets
  </Card>

  <Card title="NextJS starter repo" icon="code" href="https://github.com/privy-io/examples/tree/main/privy-next-starter">
    Check out the NextJS app starter repo for a complete example integration
  </Card>

  <Card title="React starter repo" icon="code" href="https://github.com/privy-io/examples/tree/main/privy-react-starter">
    Check out the React app starter repo for a complete example integration
  </Card>

  <Card title="Whitelabel starter repo" icon="code" href="https://github.com/privy-io/examples/tree/main/privy-react-whitelabel-starter">
    Check out the whitelabel starter for a complete whitelabel example integration
  </Card>
</CardGroup>


# Quickstart
Source: https://docs.privy.io/basics/rest-api/quickstart

Creating a wallet and sending a transaction with Privy's REST API

## 0. Prerequisites

API credentials are required for this guide. If you have not already gone through the [API setup guide](/basics/rest-api/setup), go through those steps now.

## 1. Create a wallet

Let's create a simple Ethereum wallet:

<CodeGroup>
  ```bash cURL theme={"system"}
  curl --request POST \
    --url https://api.privy.io/v1/wallets \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "chain_type": "ethereum"
  }'
  ```
</CodeGroup>

<Note>
  [Authorization signatures](/api-reference/authorization-signatures) are an optional security
  improvement that requires all requests to be authorized by you.
</Note>

The response will include the wallet ID and public address:

```json  theme={"system"}
{
  "id": "jf4mev19seymsqulciv8on0c",
  "address": "0x7Ef5363308127128969618240eDcB9F8f61e90F6",
  "chain_type": "ethereum",
  "policy_ids": [],
  "created_at": 1741362961254
}
```

## 1b. User wallets

If you want the wallet to be owned by a user, you can first create a user and then create a wallet for that user, or create the user and wallet in the same API call as shown below.

<CodeGroup>
  ```bash cURL theme={"system"}
  curl --request POST \
    --url https://api.privy.io/v1/users \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "linked_accounts": [
      {"type": "email", "address": "batman@privy.io"}
    ],
    "wallets": [
      {"chain_type": "ethereum"}
    ]
  }'
  ```
</CodeGroup>

<Info>
  If your server initiates actions on user wallets, you may need to sign requests with an
  authorization key and include the `privy-authorization-signature` header. See [authorization
  signatures](/api-reference/authorization-signatures) and [using authorization
  keys](/controls/authorization-keys/using-owners/sign).
</Info>

<Note>
  To prevent duplicate operations in case of retries, include an [idempotency
  key](/api-reference/idempotency-keys).
</Note>

## 2. Sign a message

Now let's sign a message with our new wallet:

<CodeGroup>
  ```bash cURL theme={"system"}
  curl --request POST \
    --url https://api.privy.io/v1/wallets/{wallet_id}/rpc \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "method": "personal_sign",
    "params": {
      "message": "Hello from Privy!",
      "encoding": "utf-8"
    }
  }'
  ```
</CodeGroup>

The response will contain the signed message:

```json  theme={"system"}
{
  "method": "personal_sign",
  "data": {
    "signature": "0x292d67e9c5178447f1c5344b3122997dfba8f00e43102d0b746301e9b4afbbf67d952bf870878d92b8eb066da205840458c0a5fb3f53253dbe1adf9c143678311c",
    "encoding": "hex"
  }
}
```

## 3. Send a transaction

Finally, let's send a transaction on Ethereum's testnet, [Sepolia](https://sepolia.etherscan.io/):

<CodeGroup>
  ```bash cURL theme={"system"}
  curl --request POST \
    --url https://api.privy.io/v1/wallets/{wallet_id}/rpc \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "method": "eth_sendTransaction",
    "caip2": "eip155:11155111",
    "chain_type": "ethereum",
    "params": {
      "transaction": {
        "to": "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045",
        "value": 1000000000000000
      }
    }
  }'
  ```
</CodeGroup>

<Warning>
  You will need to fund your wallet with Sepolia ETH for this step. Use a [Sepolia
  faucet](https://cloud.google.com/application/web3/faucet/ethereum/sepolia) and send it to the
  public address.
</Warning>

The response will contain the transaction hash and a Privy transaction ID:

```json  theme={"system"}
{
  "method": "eth_sendTransaction",
  "data": {
    "hash": "0x7c91ba85d67ef92cc15f3e9c8d8c5788e982cf83fabe9bfcc66a747aa0bd3701",
    "caip2": "eip155:11155111",
    "transaction_id": "d2obiyxnblv7jzp73b8scqa8"
  }
}
```

## Next steps

Now that you've created a wallet and made your first transaction, you can explore:

1. Creating [policies](/controls/policies/overview) to control wallet spending and contract interaction
2. Setting up [webhooks](/wallets/gas-and-asset-management/assets/transaction-event-webhooks) for real-time transaction notifications
3. Using [idempotency keys](/api-reference/idempotency-keys) to prevent duplicate transactions
4. Setting up [quorum authorizations](/controls/quorum-approvals/overview#using-quorum-approvals) for sensitive wallets


# Setup
Source: https://docs.privy.io/basics/rest-api/setup



## Prerequisites

Before you begin, make sure you have [set up your Privy app and obtained your app ID](/basics/get-started/dashboard/create-new-app) from the Privy Dashboard.

## Base URL

All requests to the Privy API must be made to the following base URL:

```
https://api.privy.io
```

HTTPS is required for all requests. HTTP requests will be rejected.

## Authentication

All API endpoints require authentication using Basic Auth and a Privy App ID header. Include the following headers with every request:

<ParamField header="Authorization" type="string" example="Basic ouihv9248hosd9020oihj0v10d=" required>
  Basic Auth header with your app ID as the username and your app secret as the password.
</ParamField>

<ParamField header="privy-app-id" type="string" example="cla06f34x0001mh08l8nsr496" required>
  Your Privy app ID as a string.
</ParamField>

Requests missing either of these headers will be rejected by Privy's middleware.

<Info>
  Your Privy app ID and app secret can be found in the [**App settings** >
  **Basics**](https://dashboard.privy.io/apps?page=settings\&tab=basics) tab for your app.
</Info>

## Examples

<Tabs>
  <Tab title="JavaScript">
    ```javascript  theme={"system"}
    fetch('https://api.privy.io/v1/wallets', {
      method: 'GET',
      headers: {
        'Authorization': `Basic ${btoa('insert-your-app-id' + ':' + 'insert-your-app-secret')}`,
        'privy-app-id': 'insert-your-app-id',
        'Content-Type': 'application/json'
      }
    })
    .then(response => response.json())
    .then(data => console.log(data));
    ```
  </Tab>

  <Tab title="cURL">
    ```bash  theme={"system"}
    curl -X GET "https://api.privy.io/v1/wallets" \
      --user "insert-your-app-id:insert-your-app-secret" \
      -H "privy-app-id: insert-your-app-id" \
      -H "Content-Type: application/json"
    ```
  </Tab>

  <Tab title="Python">
    ```python  theme={"system"}
    import requests
    import base64

    app_id = "insert-your-app-id"
    app_secret = "insert-your-app-secret"

    auth_string = f"{app_id}:{app_secret}"
    encoded_auth = base64.b64encode(auth_string.encode()).decode()

    headers = {
        "Authorization": f"Basic {encoded_auth}",
        "privy-app-id": app_id,
        "Content-Type": "application/json"
    }

    response = requests.get("https://api.privy.io/v1/wallets", headers=headers)
    data = response.json()
    ```
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/basics/rust/installation



In a backend Rust environment, you can use the [**`privy-rs`**](https://crates.io/crates/privy-rs) crate to authorize requests and manage your application from your server. This library includes helpful utilities around verifying access tokens issued by Privy and interacting with Privy's API to query and import users, create wallets, manage invite lists, and more.

Add the Privy Rust SDK to your `Cargo.toml`:

```toml Cargo.toml theme={"system"}
[dependencies]
privy-rs = "X.Y.Z"
```

You can always get the latest version from [crates.io](https://crates.io/crates/privy-rs) or, alternatively, add it directly using cargo.

```bash  theme={"system"}
cargo add privy-rs
```

<Info>
  The Privy Rust SDK requires Rust 1.88 or later and uses `tokio` / `reqwest` as its async runtime
  and HTTP client.
</Info>


# Quickstart
Source: https://docs.privy.io/basics/rust/quickstart

Learn how to create users, embedded wallets, and send transactions in your Rust app

## 0. Prerequisites

This guide assumes that you have completed the [Setup](/basics/rust/setup) guide to get a Privy client instance.

## 1. Creating a wallet

First, we will create a wallet. You will use this wallet's `id` in future calls to sign messages and send transactions.

<Tabs>
  <Tab title="Ethereum">
    ```rust  theme={"system"}
    use privy_rs::{PrivyClient, generated::types::{CreateWalletBody, WalletChainType}};

    let wallet = client
        .wallets()
        .create(
            None, // idempotency_key (optional)
            &CreateWalletBody {
                chain_type: WalletChainType::Ethereum,
                additional_signers: None,
                owner: None,
                owner_id: None,
                policy_ids: vec![],
            },
        )
        .await?;

    let wallet_id = wallet.id;
    ```
  </Tab>

  <Tab title="Solana">
    ```rust  theme={"system"}
    use privy_rs::{PrivyClient, generated::types::{CreateWalletBody, WalletChainType}};

    let wallet = client
        .wallets()
        .create(
            None, // idempotency_key (optional)
            &CreateWalletBody {
                chain_type: WalletChainType::Solana,
                additional_signers: None,
                owner: None,
                owner_id: None,
                policy_ids: vec![],
            },
        )
        .await?;

    let wallet_id = wallet.id;
    ```
  </Tab>
</Tabs>

<Tip>[Learn more](/wallets/wallets/create/create-a-wallet) about creating wallets.</Tip>

<Note>
  When using the `PrivyClient` to work with the API, all errors thrown will be instances of
  `privy_rs::Error`. This error type implements `std::error::Error`, so you can use it with `?` to
  propagate errors or your favorite error handling library such as `anyhow`. You can see more
  examples in the [error handling](#5-error-handling) section below.
</Note>

## 2. Signing a message

Next, we'll sign a plaintext message with the wallet using chain-specific signing methods. Make sure to specify your wallet ID from creation in the input.

<Tabs>
  <Tab title="Ethereum">
    ```rust  theme={"system"}
    use privy_rs::AuthorizationContext;

    // Create empty authorization context for unowned wallet
    let ctx = AuthorizationContext::new();

    let message = "Hello, Privy!";
    let response = client
        .wallets()
        .ethereum()
        .sign_message(&wallet_id, message, &ctx, None)
        .await?;

    // Signature is hex-encoded for Ethereum
    let signature = response.signature;
    ```
  </Tab>

  <Tab title="Solana">
    ```rust  theme={"system"}
    use privy_rs::AuthorizationContext;
    use base64::{Engine as _, engine::general_purpose};

    // Create empty authorization context for unowned wallet
    let ctx = AuthorizationContext::new();

    let message = "Hello, Privy!";
    // Solana requires the message to be base64 encoded
    let base64_message = general_purpose::STANDARD.encode(message.as_bytes());

    let response = client
        .wallets()
        .solana()
        .sign_message(&wallet_id, &base64_message, &ctx, None)
        .await?;

    // Signature is base64-encoded for Solana
    let signature = response.signature;
    ```
  </Tab>
</Tabs>

<Tip>[Learn more](/wallets/using-wallets/ethereum/sign-a-message) about signing messages.</Tip>

## 3. Sending transactions

<Info>
  Your wallet must have some funds in order to send a transaction. You can use a testnet
  [faucet](https://console.optimism.io/faucet) to test transacting on a testnet (e.g. Base Sepolia)
  or send funds to the wallet on the network of your choice.
</Info>

To send a transaction from your wallet, use chain-specific transaction methods. The SDK will populate missing network-related values, sign your transaction, broadcast it to the network, and return the transaction hash to you.

In the request, make sure to specify your wallet `id` from your wallet creation above, as well as the `caip2` chain ID for the network you want to transact on.

<Tabs>
  <Tab title="Ethereum">
    ```rust  theme={"system"}
    use privy_rs::{AuthorizationContext, generated::types::*};

    // Create empty authorization context for unowned wallet
    let ctx = AuthorizationContext::new();

    let caip2 = "eip155:11155111"; // Sepolia testnet
    let recipient_address = "0x742d35Cc6635C0532925a3b8c17d6d1E9C2F7ca"; // Your recipient address

    let transaction = EthereumSendTransactionRpcInputParamsTransaction {
        to: Some(recipient_address.to_string()),
        value: Some("0x1".to_string()), // 1 wei
        gas_limit: None,
        max_fee_per_gas: None,
        max_priority_fee_per_gas: None,
        data: Some("0x".to_string()),
        chain_id: Some(11155111), // Sepolia testnet
        from: None,
        gas_price: None,
        nonce: None,
        type_: None,
    };

    let response = client
        .wallets()
        .ethereum()
        .send_transaction(&wallet_id, caip2, transaction, &ctx, None)
        .await?;

    let transaction_hash = response.hash;
    ```
  </Tab>

  <Tab title="Solana">
    ```rust  theme={"system"}
    use privy_rs::AuthorizationContext;

    // Create empty authorization context for unowned wallet
    let ctx = AuthorizationContext::new();

    let caip2 = "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp"; // Solana Mainnet

    // A base64 encoded serialized transaction to sign
    let transaction = "insert-base-64-encoded-serialized-transaction";

    let response = client
        .wallets()
        .solana()
        .sign_and_send_transaction(&wallet_id, caip2, transaction, &ctx, None)
        .await?;

    let transaction_hash = response.hash;
    ```
  </Tab>
</Tabs>

<Tip>
  [Learn more](/wallets/using-wallets/ethereum/send-a-transaction) about sending transactions.
</Tip>

<Tip>
  If you're interested in more control, you can prepare and broadcast the transaction yourself, and
  simply use raw signing methods to sign the transaction with a wallet.
</Tip>

## 4. Creating a user

To create a user for your application, you can use the `create` method, passing in linked accounts, custom metadata, and wallets that should be associated with said user.

```rust  theme={"system"}
use privy_rs::generated::types::{
    CreateUserBody, LinkedAccountEmailInput,
    LinkedAccountEmailInputType, LinkedAccountInput,
    LinkedAccountCustomAuthInput, LinkedAccountCustomAuthInputType,
};

let user = client
    .users()
    .create(&CreateUserBody {
        linked_accounts: vec![
            LinkedAccountInput::CustomAuthInput(LinkedAccountCustomAuthInput {
                custom_user_id: "your-subject-id".to_string(),
                type_: LinkedAccountCustomAuthInputType::CustomAuth,
            }),
            LinkedAccountInput::EmailInput(LinkedAccountEmailInput {
                address: "user@example.com".to_string(),
                type_: LinkedAccountEmailInputType::Email,
            }),
        ],
        create_embedded_wallet: Some(false),
        custom_metadata: None,
    })
    .await?;

let user_id = user.id;
```

<Tip>
  [Learn more](/user-management/migrating-users-to-privy/create-or-import-a-user) about creating
  users, and look at our [pregenerating wallets](/recipes/pregenerate-wallets) guide for linking
  wallets to your users before they even sign in.
</Tip>

## 5. Error handling

In the examples above we use `?` to propagate errors, however the Rust SDK provides comprehensive error handling through multiple specialized error types. All error types implement `std::error::Error`, allowing seamless integration with Rust's error handling ecosystem.

### Error types

The SDK provides the following main error categories:

#### PrivyApiError

The core generated client error type that represents all possible API communication failures:

| Error Variant            | Description                                 | When It Occurs                                    |
| ------------------------ | ------------------------------------------- | ------------------------------------------------- |
| `InvalidRequest`         | Request doesn't conform to API requirements | Missing required fields, invalid data formats     |
| `CommunicationError`     | Network or connection issues                | Network timeouts, DNS failures, connection drops  |
| `InvalidUpgrade`         | Connection upgrade failed                   | WebSocket or HTTP/2 upgrade errors                |
| `ErrorResponse`          | Documented API error response               | Authentication failures, insufficient permissions |
| `ResponseBodyError`      | Failed to read response body                | Corrupted response data                           |
| `InvalidResponsePayload` | Response deserialization failed             | Unexpected response format                        |
| `UnexpectedResponse`     | Undocumented response code                  | New API responses not yet supported               |
| `Custom`                 | Consumer-defined hook error                 | Custom validation or processing failures          |

#### PrivyCreateError

Client initialization errors that occur when creating a `PrivyClient` instance:

| Error Variant        | Description                        | When It Occurs               |
| -------------------- | ---------------------------------- | ---------------------------- |
| `InvalidHeaderValue` | Invalid HTTP header value provided | Malformed app credentials    |
| `Client`             | HTTP client creation failed        | Network configuration issues |

#### PrivySignedApiError

Errors for operations requiring cryptographic signatures (authorization keys):

| Error Variant         | Description                          | When It Occurs                       |
| --------------------- | ------------------------------------ | ------------------------------------ |
| `Api`                 | Privy API returned an error response | Authentication failures, rate limits |
| `SignatureGeneration` | Failed to generate request signature | Invalid private key, signing errors  |

#### PrivyExportError

Wallet export operation errors:

| Error Variant         | Description                          | When It Occurs                         |
| --------------------- | ------------------------------------ | -------------------------------------- |
| `Api`                 | Privy API returned an error response | Export permissions, wallet access      |
| `SignatureGeneration` | Failed to generate request signature | Invalid authorization key              |
| `Key`                 | Decryption or key handling failed    | Invalid encryption key, corrupted data |

#### CryptoError

General cryptographic operation errors:

| Error Variant | Description                        | When It Occurs                          |
| ------------- | ---------------------------------- | --------------------------------------- |
| `Signing`     | Digital signature operation failed | Invalid key, signature algorithm issues |
| `Key`         | Key handling operation failed      | Key parsing, loading, or format errors  |

#### KeyError

Cryptographic key management errors:

| Error Variant    | Description                | When It Occurs                          |
| ---------------- | -------------------------- | --------------------------------------- |
| `Io`             | File I/O error reading key | Missing key file, permission denied     |
| `InvalidFormat`  | Key data is malformed      | Invalid PEM/DER format, corrupted data  |
| `HpkeDecryption` | HPKE decryption failed     | Wrong decryption key, corrupted payload |
| `Other`          | Unknown error occurred     | Unexpected system errors                |

#### SigningError

Digital signature creation errors:

| Error Variant | Description                  | When It Occurs                     |
| ------------- | ---------------------------- | ---------------------------------- |
| `Key`         | Invalid signing key          | Wrong key type, corrupted key data |
| `Signature`   | Cryptographic signing failed | Algorithm errors, hardware issues  |
| `Other`       | Unknown signing error        | Unexpected cryptographic errors    |

#### SignatureGenerationError

Authorization signature generation errors:

| Error Variant   | Description                  | When It Occurs                     |
| --------------- | ---------------------------- | ---------------------------------- |
| `Serialization` | Request serialization failed | Invalid request data structure     |
| `Signing`       | Signing process failed       | Key errors, cryptographic failures |

### Basic error handling

```rust  theme={"system"}
use privy_rs::{PrivyClient, PrivyCreateError, PrivyApiError, generated::types::*};

// Using the ? operator for error propagation
async fn create_wallet_with_basic_handling() -> Result<String, Box<dyn std::error::Error>> {
    let client = PrivyClient::new("your-app-id", "your-app-secret")?;

    let wallet = client
        .wallets()
        .create(
            None,
            &CreateWalletBody {
                chain_type: WalletChainType::Ethereum,
                additional_signers: None,
                owner: None,
                owner_id: None,
                policy_ids: vec![],
            },
        )
        .await?;

    Ok(wallet.id)
}
```

### Advanced error handling

```rust  theme={"system"}
use privy_rs::{PrivyClient, PrivyCreateError, PrivySignedApiError, generated::types::*};

async fn create_wallet_with_detailed_handling() -> Result<String, String> {
    // Handle client creation errors
    let client = match PrivyClient::new("your-app-id", "your-app-secret") {
        Ok(client) => client,
        Err(PrivyCreateError::InvalidHeaderValue(e)) => {
            return Err(format!("Invalid credentials format: {}", e));
        }
        Err(PrivyCreateError::Client(e)) => {
            return Err(format!("HTTP client creation failed: {}", e));
        }
    };

    // Handle wallet creation errors
    match client
        .wallets()
        .create(
            None,
            &CreateWalletBody {
                chain_type: WalletChainType::Ethereum,
                additional_signers: None,
                owner: None,
                owner_id: None,
                policy_ids: vec![],
            },
        )
        .await
    {
        Ok(wallet) => Ok(wallet.id),
        Err(e) => {
            // e is of type PrivyApiError here
            match e {
                PrivyApiError::InvalidRequest(msg) => {
                    Err(format!("Invalid request: {}", msg))
                }
                PrivyApiError::CommunicationError(req_err) => {
                    Err(format!("Network error: {}", req_err))
                }
                PrivyApiError::ErrorResponse(response) => {
                    Err(format!("API error response: {:?}", response))
                }
                _ => Err(format!("Unexpected error: {}", e)),
            }
        }
    }
}

// Example with authorization key signing
async fn sign_with_auth_key() -> Result<String, String> {
    use privy_rs::{AuthorizationContext, PrivateKey};

    let client = PrivyClient::new("your-app-id", "your-app-secret")
        .map_err(|e| format!("Client creation failed: {}", e))?;

    let key = PrivateKey("authorization-key".to_string());
    let ctx = AuthorizationContext::new().push(key);

    let wallet_id = "wallet-id";
    let message = "Hello, Privy!";

    match client
        .wallets()
        .ethereum()
        .sign_message(wallet_id, message, &ctx, None)
        .await
    {
        Ok(response) => Ok(response.signature),
        Err(PrivySignedApiError::Api(api_err)) => {
            Err(format!("API error: {}", api_err))
        }
        Err(PrivySignedApiError::SignatureGeneration(sig_err)) => {
            Err(format!("Signature generation failed: {}", sig_err))
        }
    }
}
```

### Integration with error handling libraries

The SDK works seamlessly with popular Rust error handling libraries:

<Tabs>
  <Tab title="anyhow">
    ```rust  theme={"system"}
    use anyhow::Result;
    use privy_rs::PrivyClient;

    async fn create_wallet() -> Result<String> {
        let client = PrivyClient::new("your-app-id", "your-app-secret")?;

        let wallet = client
            .wallets()
            .create(None, &create_wallet_body)
            .await?;

        Ok(wallet.id)
    }
    ```
  </Tab>

  <Tab title="thiserror">
    ```rust  theme={"system"}
    use thiserror::Error;
    use privy_rs::{PrivyCreateError, PrivySignedApiError, PrivyExportError, CryptoError, PrivyApiError};

    #[derive(Error, Debug)]
    pub enum AppError {
        #[error("Client creation failed: {0}")]
        ClientCreation(#[from] PrivyCreateError),

        #[error("API communication failed: {0}")]
        Api(#[from] PrivyApiError),

        #[error("API operation with signing failed: {0}")]
        SignedApi(#[from] PrivySignedApiError),

        #[error("Wallet export failed: {0}")]
        Export(#[from] PrivyExportError),

        #[error("Cryptographic operation failed: {0}")]
        Crypto(#[from] CryptoError),

        #[error("Configuration error: {0}")]
        ConfigError(String),
    }

    async fn create_wallet() -> Result<String, AppError> {
        let client = PrivyClient::new("your-app-id", "your-app-secret")?;

        let wallet = client
            .wallets()
            .create(None, &create_wallet_body)
            .await?;

        Ok(wallet.id)
    }
    ```
  </Tab>
</Tabs>

<Tip>
  We also implement logging via the [tracing](https://crates.io/crates/tracing) crate, which is a
  popular and well-supported logging facade for Rust.
</Tip>

## Next steps & advanced topics

* For an additional layer of security, you can choose to sign your requests with [authorization keys](/controls/authorization-keys/overview).
* To restrict what wallets can do, you can set up [policies](/controls/policies/overview).
* To prevent double sending the same transaction, take a look at our support for [idempotency](/api-reference/idempotency-keys) keys.
* If you want to require multiple parties to sign off before sending a transaction for a wallet, you can accomplish this through the use of [quorum approvals](/controls/quorum-approvals/overview).


# null
Source: https://docs.privy.io/basics/rust/setup



## Prerequisites

Before you begin:

* Get your [Privy app ID and app secret](/basics/get-started/dashboard/create-new-app) from the Privy Dashboard
* Rust 1.88 or later
* A `tokio` async runtime

## Instantiating the `PrivyClient`

Import the **`PrivyClient`** struct and create an instance by passing your Privy **app ID** and **app secret** as parameters.

```rust  theme={"system"}
use privy_rs::PrivyClient;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let client = PrivyClient::new(
        "insert-your-app-id".to_string(),
        "insert-your-app-secret".to_string()
    )?;

    Ok(())
}
```

<Tip>
  You can also store your credentials as environment variables for security:

  ```rust  theme={"system"}
  let app_id = std::env::var("PRIVY_APP_ID")
      .expect("PRIVY_APP_ID environment variable not set");
  let app_secret = std::env::var("PRIVY_APP_SECRET")
      .expect("PRIVY_APP_SECRET environment variable not set");

  let client = PrivyClient::new_from_env()?;
  ```
</Tip>

This `client` **`PrivyClient`** is now your entry point to manage Privy from your server. With the `PrivyClient` you can interact with wallets with methods for creating wallets, signing and sending transactions. You can also manage users with methods for getting a user object, verifying an auth token, and importing new users.

## Authorization

If a resource (i.e. wallet, policy, key quorum) has an [owner](/controls/authorization-keys/using-owners/overview),
[authorization signatures](/api-reference/authorization-signatures) from the owner are required.
Use the [authorization context](/controls/authorization-keys/using-owners/sign/signing-on-the-server) to specify authorization private keys
and user JWTs of the wallet's owners, and the Rust SDK will generate signatures and sign requests
under the hood.

<Tip>
  We strongly recommend reading [this
  guide](/controls/authorization-keys/using-owners/sign/signing-on-the-server) before using the Rust
  SDK for the best development experience.
</Tip>

```rust  theme={"system"}
use privy_rs::{AuthorizationContext, PrivateKey, JwtUser};

let client = PrivyClient::new(app_id, app_secret)?;

let ctx = AuthorizationContext::new()
    .push(JwtUser(client.clone(), "jwt1".to_string()))
    .push(JwtUser(client.clone(), "jwt2".to_string()))
    .push(PrivateKey("authorization-key".to_string()));
```

## Rate limits

Privy rate limits REST API endpoints that you may call from your server. If you suspect your team will require an increased rate limit, please reach out to support!

<Tip>
  Learn more about optimizing your setup in our [optimizing](/recipes/dashboard/optimizing) guide!
</Tip>


# Migrating to 2.0
Source: https://docs.privy.io/basics/swift/advanced/migrating-to-2.0



## Overview

If your app previously used Privy's Swift `1.Y.Z` SDK, follow the migration guide below to upgrade to `2.0`.

Privy's 2.Y.Z Swift SDK is Swift 6 compliant and adhere's to the new [strict concurrency standards](https://developer.apple.com/documentation/swift/adoptingswift6).
We've taken this opportunity to also introduce some major API changes, which are outlined below in logical sections.

## Initialization

### 1. App client ID required at initialization

Previously, apps were only required to pass in an `appId` when initializing the Privy SDK. Now, `appClientId` is required too. You can retrieve more information on how to retrieve your appClientId [here](/basics/get-started/dashboard/app-clients).

```swift Initializing the Privy SDK theme={"system"}
let config = PrivyConfig(appId: "<your-app-id>") // Remove
let config = PrivyConfig(appId: "<your-app-id>", appClientId: "<client-id>") // Add
let privy: Privy = PrivySdk.initialize(config: config)
```

### 2. PrivySdk.initialize can only be called once

It's important to use a single instance of Privy across the lifetime of your application. Calling PrivySdk.initialize multiple times will result in a fatal error.

### 3. Privy.awaitReady()

When the Privy SDK is first initialized, the user's authentication state will be set to `notReady` until Privy finishes initialization. We've added an async `privy.awaitReady()` function that allows you to await initialization completion. During this time, we suggest you show a loading state to your user.

<Info>
  Calling PrivySDK functions before calling `privy.awaitReady()` might result in unexpected
  functionality.
</Info>

Here's an example with some pseudocode:

```swift  theme={"system"}
Task {
  // Show loading UI
  uiState = .loading

  // Await ready
  await privy.awaitReady()

  if let case let .authenticated(privyUser) = privy.authState {
    // user is authenticated - show authenticated screen
  } else {
    // user not authenticated - show login screen
  }
}
```

## Authentication

### AuthState

The `AuthState` represents the authentication state of your user.

```swift  theme={"system"}
public enum AuthState {
    /// Auth state has not been determined yet. Call `privy.awaitReady` to ensure auth state is set.
    case notReady

    /// Auth state cannot be determined while no network connectivity is available, but session tokens exist in cache.
    case authenticatedUnverified(AuthenticatedUnverifiedContext)

    /// The user is unauthenticated
    case unauthenticated

    /// The user is authenticated, and can be accessed via the associated value
    case authenticated(PrivyUser)
}
```

#### Accessing AuthState

The current auth state can be accessed any time via `privy.authState`.

#### Subscribing to AuthState updates

Auth state updates are exposed via `privy.authStateStream`, which is an AsyncStream.

```swift  theme={"system"}
func subscribeToAuthStateUpdates() {
  let task = Task {
      for await authState in privy.authStateStream {
          print("New auth state from Privy: \(authState)")
      }
  }

  // Cancel the task at some point in the future
  // task.cancel()
}
```

### The PrivyUser

After authenticating a user via any login method, you will receive the `PrivyUser` object. The `PrivyUser` represents an authenticated user. All user specific actions, such as creating a wallet or retrieving the user's access token, are accessed via the `PrivyUser`.

You may retrieve the `PrivyUser` anytime by calling `privy.user`. If this value is non-null, there is an authenticated user. If the value is null, there is no authenticated user.

The `PrivyUser` can also be retrieved via the associated type of the "authenticated" auth state:

```swift  theme={"system"}
if case .authenticated(let privyUser) = privy.authState {
  // user is authenticated
}
```

Use the `PrivyUser` object to:

* Get the user's ID
* Get the user's identity token
* Get the user's access token
* Get the user's linked accounts
* Get the user's embedded Ethereum wallets
* Get the user's embedded Solana wallets
* Create an embedded Ethereum wallet
* Create an embedded Solana wallet
* Refresh the user
* Log the user out

### Miscellaneous

#### Errors

We've significantly enhanced our error handling. When an SDK function throws an error, it will be a `PrivyError`, which contains an `errorCode` and a `localizedDescription`.

#### AuthSession

The `AuthSession` is no longer exposed. Values previously available in AuthSession are now available through different methods:

* `PrivyUser`: can be accessed via `privy.user` as described above.
* `accessToken`: can be accessed via `privy.user.getAccessToken()`. This method will return the user's access token, refreshing the session if needed.

#### Session Refresh

To refresh / update a `PrivyUser`, you'd previously call `privy.refreshSession`. Now, trigger the refresh via the `PrivyUser`, specifically, `privyUser.refresh`.

#### Logout

To logout an authenticated user, call `await privyUser.logout()` instead of `privy.logout()`. Once calling logout, the `PrivyUser` instance is no longer valid.

#### Linked Accounts

* `LinkedAccount` and its associated types are no longer `Codable`, `Hashable`, `Identifiable` or `Equatable`.
* `LinkedAccount.embeddedWallet` is now split into chain specific values - `LinkedAccount.embeddedEthereumWallet` and `LinkedAccount.embeddedSolanaWallet`
* The `chainId` property on the embedded wallet linked accounts is removed.
* `firstVerifiedAt` and `latestVerifiedAt` fields are now optional values.

#### Other type changes

* `firstVerifiedAt`, `latestVerifiedAt`, and `createdAt` fields now have type `Date` instead of `TimeInterval` or `Int`
* `verifiedAt` fields now replaced with `firstVerifiedAt` and `latestVerifiedAt`
* `LoginMethod` is no longer `Equatable`

### Login with SMS

* The `OtpFlowState` enum is no longer exposed. You should manually handle state management based on function results. For example, if `LoginWithSms.loginWithCode` throws an error, you can catch the error and update your UI accordingly.
* `LoginWithSms.sendCode` now throws an error if sending code is unsuccessful, instead of returning false
* `LoginWithSms.loginWithCode` now returns `PrivyUser`
* `LoginWithSms.loginWithCode` now requires phone number to be passed in as a parameter (previously was optional)

### Login with email

* The `OtpFlowState` enum is no longer exposed. You should manually handle state management based on function results. For example, if `LoginWithEmail.loginWithCode` throws an error, you can catch the error and update your UI accordingly.
* `LoginWithEmail.sendCode` now throws an error if sending code is unsuccessful, instead of returning false
* `LoginWithEmail.linkWithCode` no longer returns anything, and throws an error if linking fails
* `LoginWithEmail.loginWithCode` now returns `PrivyUser`
* `LoginWithEmail.loginWithCode` now requires email to be passed in (no longer optional)

### Login with custom auth

* `LoginWithCustomAccessToken.loginWithCustomAccessToken` now returns `PrivyUser`
* When initializing the PrivySDK, you should now pass the `TokenProvider` through the `PrivyLoginWithCustomAuthConfig` field in the `PrivyConfig` object. This allows Privy to access your user's access token at initialization while attempting to restore the Privy user's session.

### Login with SIWE

* `SiweFlowState` enum is no longer exposed. You should manually handle state management based on function results. For example, if `LoginWithSiwe.loginWithSiwe` throws an error, you can catch the error and update your UI accordingly.
* `LoginWithSiwe.loginWithSiwe` now returns `PrivyUser`
* `LoginWithSiwe.loginWithSiwe` now requires message and params to be passed in (no longer optional)
* `LoginWithSiwe.linkWithSiwe` no long returns anything, and throws an error if linking fails
* `LoginWithSiwe.linkWithSiwe` now requires message and params to be passed in (no longer optional)

### Login with OAuth

* LoginWithOAuth.login now returns `PrivyUser`

## Embedded wallets

### Overview

Previously, all embedded wallet APIs were accessible directly from the `privy.embeddedWallet` object, which is no longer available.

All embedded wallet APIs are now available via the `PrivyUser` instead. This is because all embedded wallet actions require an authenticated user, so adding the methods inside the authenticated `PrivyUser` was the most logical.

As an example, when creating an Ethereum wallet:

```swift  theme={"system"}
try await privy.embeddedWallet.createWallet(chainType: .ethereum) // Remove
try await privy.user.createEthereumWallet() // Add
```

### Connecting the wallet

In SDK 1.Y.Z, you had to ensure wallets were connected prior to accessing them by calling `privy.connectWallet()`. This method is now removed as **we handle connected state internally!** You may access the user's embedded wallets at anytime, without ensuring "wallet connected" state.

Because you no longer need to manage wallet state, `EmbeddedWalletState` has been removed.

### Ethereum vs Solana

Now, all embedded wallet APIs are chain specific and available via the `PrivyUser`.

#### Creating a wallet

Ethereum:

```swift  theme={"system"}
try await privy.embeddedWallet.createWallet(chainType: .ethereum) // Remove
let ethereumWallet = try await privy.user.createEthereumWallet() // Add
```

Solana:

```swift  theme={"system"}
try await privy.embeddedWallet.createWallet(chainType: .solana) // Remove
let solanaWallet = try await privy.user.createSolanaWallet() // Add
```

#### Retrieving a wallet

Ethereum:

```swift  theme={"system"}
// Ensure wallets are connected // Remove
guard case .connected(let wallets) = privy.embeddedWallet.embeddedWalletState else { // Remove
    print("Wallet not connected") // Remove
    return // Remove
} // Remove

// Grab first ethereum wallet from connected wallets // Remove
guard let wallet = wallets.first, wallet.chainType == .ethereum else { // Remove
    print("No Ethereum wallets available") // Remove
    return // Remove
} // Remove

// Directly grab ethereum wallets, without worrying about connected state // Add
let ethereumWallets: [EmbeddedEthereumWallet] = privy.user.embeddedEthereumWallets // Add
```

Solana:

```swift  theme={"system"}
// Ensure wallets are connected // Remove
guard case .connected(let wallets) = privy.embeddedWallet.embeddedWalletState else { // Remove
    print("Wallet not connected") // Remove
    return // Remove
} // Remove

// Grab first ethereum wallet from connected wallets // Remove
guard let wallet = wallets.first, wallet.chainType == .solana else { // Remove
    print("No Solana wallets available") // Remove
    return // Remove
} // Remove

// Directly grab ethereum wallets, without worrying about connected state // Add
let solanaWallets: [EmbeddedSolanaWallet] = privy.user.embeddedSolanaWallets // Add
```

#### Using a wallet / rpc providers

Instead of grabbing the wallet's provider via `try privy.embeddedWallet.getEthereumProvider(for: wallet.address)`, the provider is now available directly on the wallet instance. For example:

Ethereum:

```swift  theme={"system"}
// Create or retrieve the embedded Ethereum wallet
let ethereumWallet: EmbeddedEthereumWallet = privy.user.createEthereumWallet()

try await ethereumWallet.provider.request(
    // Note: RpcRequest was renamed to EthereumRpcRequest
    EthereumRpcRequest(...)
)
```

Further, switching and retrieving the EVM chain is now an async operation:

```swift  theme={"system"}
// retrieve current chain
let currentChain = await ethereumWallet.provider.chainId

// set chain to Sepolia
await ethereumWallet.provider.switchChain(chainId: 11155111, rpcUrl: nil)
```

Solana:

```swift  theme={"system"}
// Create or retrieve the embedded Ethereum wallet
let solanaWallet: EmbeddedSolanaWallet = privy.user.createSolanaWallet()

try await solanaWallet.provider.signMessage(...)
```

#### Changing the EVM chain

When utilizing the `EmbeddedEthereumWalletProvider`, you may specify the EVM Chain by calling `provider.switchChain`. This was previously named `provider.configure`.


# Features
Source: https://docs.privy.io/basics/swift/features

Learn about the features supported by the Swift SDK

export const FeatureMatrix = ({sdk}) => {
  const sdks = sdk ? [sdk] : ['react', 'reactNative', 'swift', 'android', 'flutter', 'unity'];
  const sdkNames = {
    react: 'React',
    reactNative: 'React Native',
    swift: 'Swift',
    android: 'Android',
    flutter: 'Flutter',
    unity: 'Unity'
  };
  const matrix = [{
    name: 'Authentication',
    features: [{
      name: 'Email',
      react: true,
      reactNative: true,
      swift: true,
      android: true,
      flutter: true,
      unity: true
    }, {
      name: 'SMS',
      react: true,
      reactNative: true,
      swift: true,
      android: true,
      flutter: true
    }, {
      name: 'OAuth',
      react: true,
      reactNative: true,
      swift: 'Google, Apple, Twitter, Discord',
      android: 'Google, Discord, Twitter',
      flutter: 'Google, Apple, Twitter, Discord',
      unity: 'Google, Apple, Twitter, Discord'
    }, {
      name: 'SIWE (Sign In with Ethereum)',
      react: true,
      reactNative: true,
      swift: true
    }, {
      name: 'SIWS (Sign In with Solana)',
      react: true,
      reactNative: true
    }, {
      name: 'Farcaster',
      react: true,
      reactNative: true
    }, {
      name: 'Telegram',
      react: true
    }, {
      name: 'Custom Auth',
      react: true,
      reactNative: true,
      swift: true,
      android: true,
      flutter: true
    }, {
      name: 'Passkeys',
      react: true,
      reactNative: true
    }]
  }, {
    name: 'Farcaster',
    features: [{
      name: 'SIWF',
      react: true,
      reactNative: true
    }]
  }, {
    name: 'Embedded Wallets',
    features: [{
      name: 'Creating wallets manually',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum', 'solana'],
      android: ['ethereum', 'solana'],
      flutter: ['ethereum', 'solana'],
      unity: ['ethereum', 'solana']
    }, {
      name: 'Creating wallets automatically',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Pregenerating wallets',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum', 'solana'],
      android: ['ethereum', 'solana'],
      flutter: ['ethereum', 'solana']
    }, {
      name: 'Signing messages and transactions',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum', 'solana'],
      android: ['ethereum', 'solana'],
      flutter: ['ethereum', 'solana'],
      unity: ['ethereum', 'solana']
    }, {
      name: 'Broadcasting transactions',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum'],
      android: ['ethereum'],
      flutter: ['ethereum'],
      unity: ['ethereum']
    }, {
      name: 'Native smart wallets',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: 'Automatic recovery',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum', 'solana'],
      android: ['ethereum', 'solana'],
      flutter: ['ethereum', 'solana'],
      unity: ['ethereum']
    }, {
      name: 'User controlled recovery',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Transaction MFA',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Key Export',
      react: ['ethereum', 'solana']
    }, {
      name: 'Key Import',
      react: ['ethereum', 'solana']
    }, {
      name: 'HD wallets',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum'],
      android: ['ethereum'],
      flutter: ['ethereum'],
      unity: ['ethereum']
    }, {
      name: 'Session signers',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Global wallets (Cross App Accounts)',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: 'Custom EVM (Ethereum) network support',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: 'Custom SVM (Solana) network support',
      react: ['solana'],
      reactNative: ['solana']
    }]
  }, {
    name: 'Connectors',
    features: [{
      name: 'External wallets',
      react: ['ethereum', 'solana']
    }, {
      name: 'Wagmi',
      react: ['ethereum']
    }, {
      name: 'Viem',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: 'Ethers',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: '@solana/web3.js',
      react: ['solana']
    }, {
      name: 'web3swift',
      swift: ['ethereum']
    }]
  }, {
    name: 'Funding',
    features: [{
      name: 'Transfer or bridge from wallet',
      react: ['ethereum', 'solana']
    }, {
      name: 'Transfer from exchange',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Pay with card',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }]
  }];
  const filteredMatrix = matrix.map(section => {
    return {
      ...section,
      features: section.features.filter(featureItem => {
        if (sdk) {
          return featureItem[sdk] !== undefined;
        }
        return true;
      })
    };
  }).filter(section => {
    return section.features.length > 0;
  });
  return <table style={{
    display: 'table',
    width: '100%'
  }}>
      {sdk ? null : <thead>
          <tr>
            <th></th>
            {sdks.map(sdk => <th>{sdkNames[sdk]}</th>)}
          </tr>
        </thead>}
      <tbody>
        {filteredMatrix.map(section => <>
            <tr>
              <td>
                <strong>{section.name}</strong>
              </td>
              {sdks.map(() => <td></td>)}
            </tr>
            {section.features.map(feature => <tr>
                <td>
                  <em>{feature.name}</em>
                </td>
                {sdks.map(sdk => {
    const supported = feature[sdk];
    if (supported === true) {
      return <td>✅</td>;
    } else if (!supported) {
      return <td></td>;
    } else if (Array.isArray(supported)) {
      return <td>
                        {supported.map(item => item === 'ethereum' ? <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/ethereum.png" noZoom style={{
        display: 'inline',
        margin: '2px',
        width: '18px'
      }} /> : <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/solana.png" noZoom style={{
        display: 'inline',
        margin: '2px',
        width: '18px'
      }} />)}
                      </td>;
    } else {
      return <td>{supported}</td>;
    }
  })}
              </tr>)}
          </>)}
      </tbody>
    </table>;
};

## Supported features

<FeatureMatrix sdk="swift" />


# null
Source: https://docs.privy.io/basics/swift/installation



## Requirements

* iOS 16+

## SDK 2.0

All of our documentation reflects the APIs of our 2.Y.Z SDK, which is still in beta. It is highly recommended to integrate 2.Y.Z into your application, as we are close to GA. To find the latest SDK version, see our [Github Releases page](https://github.com/privy-io/privy-ios/releases).

## Installation

Install the Privy Swift SDK via the Swift Package Manager:

1. In Xcode, navigate to File > Add Package Dependencies
2. In the "Search or Enter Package URL" search box enter:
   ```
   https://github.com/privy-io/privy-ios
   ```
3. Select the appropriate version and click Add Package


# Quickstart
Source: https://docs.privy.io/basics/swift/quickstart

Learn how to authenticate users, create embedded wallets, and send transactions in your Swift app.

## Prerequisites

This guide assumes that you have completed the [setup](/basics/swift/setup) guide.

## Check user's authentication state

```swift  theme={"system"}
// Grab current auth state
let authState = await privy.getAuthState()

switch authState {
    case .authenticated(let user):
        // User is authenticated. Grab the user's linked accounts
        let linkedAccounts = user.linkedAccounts
    case .notReady:
        // Privy was just initialized and has not determined auth state yet
        // authState will never be this case after calling getAuthState()
    case .authenticatedUnverified:
        // Prior user session exists, but can't be verified due to no network connectivity.
        // Privy will automatically attempt to verify authenticated state when network is restored.
    case .unauthenticated:
        // User in not authenticated.
}
```

## Authenticate your user

<Tip>
  This quickstart guide will demonstrate how to authenticate a user with a one time password as an
  example, but Privy supports many authentication methods. Explore our [Authentication
  docs](/authentication/overview) to learn about other methods such as socials, passkeys, and
  external wallets to authenticate users in your app.
</Tip>

Privy offers a variety of authentication mechanisms. The example below showcases authenticating a user via SMS.

This is a two step process:

1. Send an OTP to the user provided phone number.
2. Verify the OTP sent to the user.

<Note>
  Please be sure to configure SMS as a login method on the [**Privy Developer
  Dashboard**](https://dashboard.privy.io) under User Management > Authentication.
</Note>

#### 1. Send an OTP to the user's phone number via SMS

After collecting and validating your users phone number, send an OTP by calling the **`sendCode`** method.
Note: you must provide the phone number in [E.164 format](https://www.twilio.com/docs/glossary/what-e164).

```swift  theme={"system"}
do {
    let phoneNumber = "+14155552671"
    try await privy.sms.sendCode(to: phoneNumber)
    // OTP sent successfully - prompt user for OTP
} catch {
    // OTP could fail if the network request fails
    print("Error sending code: \(error))
}
```

If the OTP is sent successfully, `sendCode` will not throw an error.
If the provided phone number is invalid, or sending the OTP fails, **`sendCode`** will throw an error.

#### 2. Authenticate with OTP

The user will then receive an SMS with a 6-digit OTP. Prompt for this OTP within your application, then authenticate the user with the `loginWithCode` method. Pass the following parameters to this method:

<ParamField name="code" type="String">
  OTP code inputted by the user in your app.
</ParamField>

<ParamField name="phoneNumber" type="String">
  The user's phone number.
</ParamField>

```swift  theme={"system"}
do {
    let phoneNumber = "+14155552671"
    let inputtedOtp = "123456"
    let privyUser = try await privy.sms.loginWithCode(inputtedOtp, sentTo: phoneNumber)
    print("Logged in with sms! User: \(privyUser.id)")
} catch {
    print("Error logging user in: \(error)")
}
```

If the OTP/phone number combination is valid, Privy will successfully authenticate your user and `loginWithCode` will return the `PrivyUser`.
If the provided OTP/phone number combination is invalid, `loginWithCode` will throw an error that speicfies the error reason.

## The embedded wallet

Privy's embedded wallets are compatible with the Ethereum and Solana blockchains.

<Tabs>
  <Tab title="Ethereum">
    ### Creating the embedded wallet

    To create an EVM embedded wallet for your user, call `PrivyUser.createEthereumWallet`.

    ```swift  theme={"system"}
    public protocol PrivyUser {
        // Other privy user methods

        func createEthereumWallet(allowAdditional: Bool) async throws -> EmbeddedEthereumWallet
    }
    ```

    <ParamField name="allowAdditional" type="Bool" optional default="false">
      Ethereum embedded wallets are [hierarchical deterministic (HD)
      wallets](https://www.ledger.com/academy/crypto/what-are-hierarchical-deterministic-hd-wallets),
      and a user's seed entropy can support multiple separate embedded wallets. If a user already has a
      wallet and you'd like to create additional HD wallets for them, pass in `true` for the
      `allowAdditional` parameter.
    </ParamField>

    If a wallet is successfully created for the user, the newly created EmbeddedEthereumWallet is returned.

    The method will throw an error if

    * The user is not authenticated
    * If a user already has 9 or more wallets
    * If the network call to create the wallet fails
    * If a user already has an embedded wallet and allowAdditional is not set to true.

    #### Example

    ```swift  theme={"system"}
    if let user = privy.user {
        // If user not null, user is authenticated
        do {
            let ethereumWallet = try await user.createEthereumWallet()
            print("Created wallet with address: \(ethereumWallet.address)")
        } catch {
            print("Error creating embedded wallet: \(error.localizedDescription)")
        }
    }
    ```

    ### Using the embedded wallet

    To enable your app to request signatures and transactions from the embedded wallet, Privy Ethereum embedded wallets expose a provider *inspired by* the [**EIP-1193 provider**](https://eips.ethereum.org/EIPS/eip-1193) standard. This allows you request signatures and transactions from the wallet via a familiar [**JSON-RPC API**](https://ethereum.org/en/developers/docs/apis/json-rpc/) (e.g. [`personal_sign`](https://docs.metamask.io/wallet/reference/personal_sign/)).

    Once you have an instance of an `EmbeddedEthereumWallet`, you can make RPC requests by using the `provider: EmbeddedEthereumWalletProvider` hook and using its `request` method. For example, `wallet.provider.request(request: rpcRequest)`.

    ```swift  theme={"system"}
    public protocol EmbeddedEthereumWallet: EmbeddedWalletBehavior {
        var provider: EmbeddedEthereumWalletProvider { get }
    }
    ```

    As a parameter to this method, to this method, pass an `EthereumRpcRequest` object that contains:

    * **method**: the name of the JSON-RPC method for the wallet to execute (e.g. `personal_sign`)
    * **params**: an array of parameters required by your specified method

    By default, embedded wallets are connected to the Ethereum mainnet. To send a transaction on a different network, simply set the wallet's chainId in the transaction request.

    #### Example

    ```swift  theme={"system"}
    if let user = privy.user {
        // If user not null, user is authenticated
        do {
            // Retrieve list of user's embedded Ethereum wallets
            let ethereumWallets = user.embeddedEthereumWallets

            // Grab the desired wallet. Here, we retrieve the first wallet
            if let wallet = ethereumWallets.first {
                let data = EthereumRpcRequest(method: "personal_sign", params: ["A message to sign", wallet.address])
                let signature = try await wallet.provider.request(data)
                print("Result signature: \(signature)")
            }
        } catch {
            print("personal_sign error: \(error.localizedDescription)")
        }
    }
    ```
  </Tab>

  <Tab title="Solana">
    ### Creating the embedded wallet

    To create a Solana embedded wallet for your user, call `PrivyUser.createSolanaWallet`.

    If a wallet is successfully created for the user, the newly created EmbeddedSolanaWallet is returned.

    The method will throw an error if

    * The user is not authenticated
    * If a user already has a Solana wallet
    * If the network call to create the wallet fails

    #### Example

    ```swift  theme={"system"}
    if let user = privy.user {
        // If user not null, user is authenticated
        do {
            let solanaWallet = try await user.createSolanaWallet()
            print("Created wallet with address: \(solanaWallet.address)")
        } catch {
            print("Error creating embedded wallet: \(error)")
        }
    }
    ```

    ### Using the embedded wallet

    Privy supports requesting signatures on messages and transactions from a user's Solana embedded wallet using the `signMessage` RPC. To request a signature, get the Solana embedded wallet provider and call the `signMessage` method on it with a base-64 encoded message to sign. If the signature is computed successfully, `signMessage` will return it as a base64-encoded string.

    ```swift  theme={"system"}
    public protocol EmbeddedSolanaWalletProvider {
        /// Request a signature on a Base64 encoded message or transaction
        /// - Parameters:
        ///     - message: Base64 encoded message or transaction
        ///
        /// - Returns: The Base64 encoded computed signature
        ///
        /// - Throws: an error if signing the message is unsuccessful
        func signMessage(message: String) async throws -> String
    }
    ```

    #### Example

    ```swift  theme={"system"}
    if let user = privy.user {
        // If user not null, user is authenticated
        do {
            // Retrieve list of user's embedded Solana wallets
            let solanaWallets = user.embeddedSolanaWallets

            // Grab the desired wallet. Here, we retrieve the first wallet
            if let wallet = solanaWallets.first {
                // Base 64 encoded: "Hello! I am the base64 encoded message to be signed."
                let message = "SGVsbG8hIEkgYW0gdGhlIGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2UgdG8gYmUgc2lnbmVkLg=="
                let signature = try await solanaProvider.signMessage(message: message)
                print("Result signature: \(signature)")
            }
        } catch {
            print("Error creating embedded wallet: \(error.localizedDescription)")
        }
    }
    ```
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/basics/swift/setup



## Prerequisites

Before you begin, make sure you have [set up your Privy app and obtained your app ID](/basics/get-started/dashboard/create-new-app) and [client ID](/basics/get-started/dashboard/app-clients) from the Privy Dashboard.

<Warning>
  A properly set up app client is required for mobile apps and other non-web platforms to allow your
  app to interact with the Privy API. Please follow [this
  guide](/basics/get-started/dashboard/app-clients) to configure an app client.
</Warning>

## Initializing Privy

First, import the **Privy SDK** at the top of the file:

```swift  theme={"system"}
import PrivySDK
```

Initialize a **Privy** instance with a **`PrivyConfig`** object:

```swift  theme={"system"}
let config = PrivyConfig(
    appId: "YOUR_APP_ID",
    appClientId: "YOUR_APP_CLIENT_ID",
    loggingConfig: .init(
        logLevel: .verbose
    )
)

let privy: Privy = PrivySdk.initialize(config: config)
```

## Configuration

The configuration fields for the PrivyConfig are:

<ParamField body="appId" type="String" required>
  Your Privy application ID, which can be obtained from the [**Privy Developer
  Dashboard**](https://dashboard.privy.io), under App Settings > Basics
</ParamField>

<ParamField body="appClientId" type="String" required>
  Your app client ID, which can be obtained from the [**Privy Developer
  Dashboard**](https://dashboard.privy.io), under App Settings > Clients
</ParamField>

<ParamField body="loggingConfig" type="PrivyLoggingConfig" optional>
  (Optional) Your preferred log level and logging method. If no log level is specified, it will
  default to `PrivyLogLevel.NONE`.
</ParamField>

<ParamField body="customAuthConfig" type="LoginWithCustomAuthConfig" optional>
  (Optional) Only use this if you plan to use custom authentication. Find more information
  [here](/authentication/user-authentication/jwt-based-auth/overview).
</ParamField>

<Tip>
  Be sure to maintain a single instance of Privy across the lifetime of your application.
  Initializing multiple instances of Privy will result in unexpected errors.
</Tip>


# Analytics CORS Errors
Source: https://docs.privy.io/basics/troubleshooting/analytics-cors



You may occasionally see CORS errors in your browser console that look like this:

```
Access to fetch at 'https://auth.privy.io/api/v1/analytics_events' from origin has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
```

These CORS errors are related to background analytics requests and **do not impact your application's functionality**. They are benign errors that can safely be ignored.

The Privy SDK sends anonymous usage analytics in the background, and these requests occasionally trigger CORS warnings in your browser's developer console. While they appear as errors, they do not affect your application's performance or user experience.

<Info>
  Still have questions? Reach out to our [support team](https://privy.io/slack) - we're here to
  help!
</Info>


# API error codes
Source: https://docs.privy.io/basics/troubleshooting/error-handling/api-errors



This page lists common error codes you may encounter when using the Privy API, along with their descriptions and troubleshooting steps.

<Tip>
  Encountering an error code that's not listed here? Tell us what you'd like added in
  [Slack](https://privy.io/slack).
</Tip>

| Error Code                                                                                          | Description                                                              |
| --------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------ |
| [`policy_violation`](#policy-violation)                                                             | RPC request denied due to policy violation                               |
| [`insufficient_funds`](#insufficient-funds)                                                         | Wallet has insufficient funds to complete the transaction                |
| [`transaction_broadcast_failure`](#transaction-broadcast-failure)                                   | Transaction failed to broadcast to the network                           |
| [`missing_or_empty_authorization_header`](#missing-or-empty-authorization-header)                   | Missing `privy-authorization-signature` header or no signatures provided |
| [`zero_correct_authorization_signatures`](#zero-correct-authorization-signatures)                   | No valid authorization signatures were provided                          |
| [`insufficient_correct_authorization_signatures`](#insufficient-correct-authorization-signatures)   | Not enough valid authorization signatures provided                       |
| [`incorrect_quantity_of_authorization_signatures`](#incorrect-quantity-of-authorization-signatures) | Number of signatures does not match the wallet's authorization threshold |
| [`no_valid_user_session_keys`](#no-valid-user-session-keys)                                         | No valid user signing keys available                                     |
| [`user_session_keys_expired`](#user-session-keys-expired)                                           | User signing key is expired                                              |

## Transaction errors

### `policy_violation`

**Description:** RPC request denied due to policy violation

This error occurs when an RPC request is blocked by a policy configured on the wallet. While this is intended behavior to enforce security controls, it may indicate that your policy configuration needs adjustment or that the transaction needs to be modified to comply with the policy.

**Common causes:**

* Transaction exceeds spending limits configured in the policy.
* Transaction is sent to an address that is not allowlisted.
* One or more Solana instructions may not be explicitly allowed.

**Troubleshooting:**

* **Review the policy configuration:** Navigate to the [Wallets dashboard](https://dashboard.privy.io/apps?page=wallets) to find the wallet and view the policy applied to this wallet
* **Retrieve the wallet's policy via API:** Use the [Get Wallet](/api-reference/wallets/get) endpoint to check which policy is applied, then use the [Get Policy](/api-reference/policies/get) endpoint to review its rules
* **Verify transaction details:** Ensure the transaction amount, recipient address, and contract interactions align with your policy requirements
* **Check policy conditions:** Review specific conditions like spending limits, allowlisted addresses, and restricted operations
* **Adjust policy or transaction:** Either modify the policy to accommodate legitimate use cases or adjust the transaction to comply with existing rules

***

### `insufficient_funds`

**Description:** Wallet has insufficient funds to complete the transaction

This error can appear in two forms:

* "Wallet has insufficient funds for this transaction" - The wallet doesn't have enough tokens to cover the transaction and gas fees
* "Insufficient gas credits balance" - Your app's gas sponsorship credits are depleted

**Common causes:**

* Wallet balance is too low to cover transaction value and gas fees
* Gas credits have been exhausted (when using gas sponsorship)
* Gas price spike causing higher than expected fees
* Complex transaction requiring more gas than available
* Incorrect gas estimation leaving insufficient buffer

**Troubleshooting:**

* **For gas credits depletion:**
  * Check your gas credits balance in the [Gas Sponsorship](https://dashboard.privy.io/billing?tab=gas-sponsorship) page of the Privy dashboard.
  * Add more credits to continue sponsoring transactions
  * Enable **Automated credit refill** to avoid this in the future, and make sure **Low credit notifications** are enabled.
* **For wallet balance issues:**
  * Check the wallet's native token balance (ETH, MATIC, SOL, etc.) on a block explorer. Make sure to check the balance on the same chain you are sending the transaction on.
  * Fund the wallet with sufficient native tokens to cover gas fees
  * Consider implementing [wallet funding flows](/wallets/funding/prompting-users-to-fund/evm) in your app
  * Use gas sponsorship to eliminate the need for users to hold native tokens for gas

***

### `transaction_broadcast_failure`

**Description:** Transaction failed to broadcast to the network

This error indicates that the transaction could not be broadcasted to the blockchain. The transaction was **not** broadcasted, meaning it's safe to retry without risk of duplicate transactions.

**Common causes:**

* Invalid transaction parameters (malformed data, incorrect format)
* Network congestion or chain outages
* RPC node connectivity issues
* Nonce conflicts or sequencing errors

**Troubleshooting:**

* **Verify transaction inputs:** Double-check all transaction parameters including recipient address, amount, data field, and gas settings
* **Retry the transaction:** Since the transaction was not broadcast, it's safe to retry with the same or corrected parameters
* **Check network status:**
  * Visit the [Privy Status Page](https://status.privy.io) to check for known issues
  * Check the blockchain network's status page or block explorer for chain-wide issues
* **Review error details:** Examine any additional error messages returned with the failure for specific validation issues

***

## Authorization signature errors

The following errors occur when there is a failure validating [authorization signatures](/api-reference/authorization-signatures) for API requests. Certain API endpoints require authorization signatures from the resource owner to authorize the request.

### `missing_or_empty_authorization_header`

**Description:** Missing `privy-authorization-signature` header or no signatures provided

This error occurs when an API request requires authorization signatures but the `privy-authorization-signature` header is either missing entirely or contains no signatures.

**Common causes:**

* Making a request to an endpoint that requires authorization without including the required header
* Header is present but contains an empty value
* Missing `AuthorizationContext` when using Privy SDKs

**Troubleshooting:**

* **Implement proper signing:** Follow the [signing requests guide](/controls/authorization-keys/using-owners/sign/overview) to properly sign your API requests
* **Verify SDK configuration:** If using a Privy SDK, ensure you've configured the [`AuthorizationContext`](/controls/authorization-keys/using-owners/sign/signing-on-the-server#using-the-authorization-context) correctly
* **Check request headers:** Confirm the `privy-authorization-signature` header is being included in your request

***

### `zero_correct_authorization_signatures`

**Description:** No valid authorization signatures were provided

This error indicates that while authorization signatures were provided, none of them are valid. The signature payload may be malformed or the signing keys may be incorrect or expired.

**Common causes:**

* Signing the wrong payload (e.g., incorrect request body, URL, or headers)
* Malformed signature format
* Signing with a key that is not able to authorize the request

**Troubleshooting:**

* **Verify signature payload:** Ensure you're signing the correct payload according to the [authorization signatures specification](/controls/authorization-keys/using-owners/sign/overview#signature-payload)
* **Check signing keys:** Verify that the keys you're using for signing are correct and have proper permissions
* **Review signing implementation:** Follow the [signing requests guide](/controls/authorization-keys/using-owners/sign/overview) to ensure proper implementation

***

### `insufficient_correct_authorization_signatures`

**Description:** Not enough valid authorization signatures provided

This error occurs when some valid signatures were provided, but the number of valid signatures is less than the required authorization threshold for the resource.

**Common causes:**

* Wallet requires multiple signatures (based on the authorization threshold of the key quorum) but only one was provided
* Some provided signatures are valid but others are malformed or expired
* Authorization threshold was recently increased but request still uses old signature count
* Missing signatures from required signers

**Troubleshooting:**

* **Check authorization threshold:** Navigate to the [Wallets dashboard](https://dashboard.privy.io/apps?page=wallets) to find the wallet and view the owner or signer applied to this wallet
* **Provide all required signatures:** Ensure you're collecting and including signatures from all required owners or signers

***

### `incorrect_quantity_of_authorization_signatures`

**Description:** Number of signatures does not match the wallet's authorization threshold

This error occurs when the exact number of signatures provided in the `privy-authorization-signature` header doesn't match the wallet's required authorization threshold.

**Common causes:**

* Providing too few signatures
* Incorrectly parsing or concatenating multiple signatures in the header

**Troubleshooting:**

* **Check authorization threshold:** Navigate to the [Wallets dashboard](https://dashboard.privy.io/apps?page=wallets) to find the wallet and view the owner or signer applied to this wallet
* **Match signature count:** Ensure you're providing exactly the number of signatures required by the authorization threshold
* **Check signature format:** When providing multiple signatures, ensure they're properly formatted in the header (comma-separated)

***

### `no_valid_user_session_keys`

**Description:** No valid user signing keys available

This error occurs when attempting to authorize a request using user signing keys, but no valid keys are available for the user.

**Common causes:**

* User signing key was never requested or generated
* /wallets/authenticate request was never completed or returned key was not properly decrypted. This happens automatically for Server SDKs using AuthorizationContext
* User JWT is invalid or expired

**Troubleshooting:**

* **Request a user signing key:** Follow the [user signers guide](/controls/authorization-keys/keys/create/user/request) to properly request and use user signing keys
* **Check authentication flow:** Verify the /wallets/authenticate request is returning correctly and the updated key is being used.
* **Validate user JWT:** Ensure the user's JWT is valid and not expired

***

### `user_session_keys_expired`

**Description:** User signing key is expired

This error occurs when the user signing key being used to authorize the request has expired. User signing keys are time-bound for security purposes.

**Common causes:**

* User signing key has exceeded its validity period
* Long delay between requesting the session key and making the API call
* Using a cached session key that has expired

**Troubleshooting:**

* **Request a fresh session key:** Follow the [user signers guide](/controls/authorization-keys/keys/create/user/request) to request a new user signing key
* **Use provided Server-side SDK AuthorizationContext:** AuthorizationContext will automatically retrieve a fresh user key and construct an authorization signature before making the RPC call.


# Client-side error codes
Source: https://docs.privy.io/basics/troubleshooting/error-handling/client-errors



This page lists common error codes you may encounter when using Privy, along with their descriptions and troubleshooting steps.

<Tip>
  Encountering an error code that's not listed here? Tell us what you'd like added in
  [Slack](https://privy.io/slack).
</Tip>

## `invalid_native_app_id`

**Description:** Invalid or missing native app identifier for mobile clients

**Common Causes:**

* Using wrong client ID in your application
* Native app identifiers not configured in Privy dashboard
* Using Expo Go without allowlisting `host.exp.Exponent`
* Web clients accidentally sending `privy-native-app-id` header

**Troubleshooting:**

* **Verify client ID:** Double-check that you're using the correct client ID from your Privy dashboard
* **Configure app client:** Ensure you have an [app client configured in your Privy dashboard](/basics/get-started/dashboard/app-clients)
  * **For Expo Go development:** Add `host.exp.Exponent` to your allowed application identifiers in the dashboard

***

## `invalid_origin`

**Description:** The origin that your requests are coming from has not been allowlisted in your Privy dashboard

**Common Causes:**

* You are using an `appClient` (and therefore setting `clientId` in your PrivyProvider) that is overriding the allowed origins for your application.
* You haven't added the origin to your allowed origins in the dashboard.
* Your request is coming from an iFrame whose parent origin is not allowlisted.

**Troubleshooting:**

* If you are using an `appClient`:
  * Set the allowed origins for your application in the dashboard [here](https://dashboard.privy.io/apps?setting=domains\&page=settings).
* If you are not using an `appClient`, you can set the allowed origins for your application in the dashboard [here](https://dashboard.privy.io/apps?setting=domains\&page=settings).
* Make sure to add all parent origins of your application to the allowed origins list [here](https://dashboard.privy.io/apps?setting=domains\&page=settings).

***

## `linked_to_another_user`

**Description:** There is a conflict between the current user and an existing user.

**Common Causes:**

* User previously signed up with Google/Apple OAuth using this email, then tries passwordless email login
* User tries to update their linked\_account to one that's already taken
* Importing users with duplicate linked\_account

> **Use case:**
>
> 1. A user creates an account with one email ([email1@privy.io](mailto:email1@privy.io))
> 2. This user links a different email via OAuth ([email2@privy.io](mailto:email2@privy.io))
> 3. This user then tries to log in with the linked oauth account ([email2@privy.io](mailto:email2@privy.io)) using passwordless login, this will fail because this email is not associated with a passwordless login method.

**Troubleshooting:**

* Enable login method transfer to allow users to migrate their accounts. Learn more [here](/recipes/dashboard/account-transfer).
* Make sure the user is using the correct email address for the login method they are trying to use.

***

## `failed_to_fetch_jwks_uri_document`

**Description:** Failed to fetch JWKS URI document when configuring JWT authentication

**Common Causes:**

* Cloudflare or similar security measures blocking Privy from accessing your JWKS endpoint
* JWKS endpoint not publicly accessible
* Incorrect JWKS.json structure
* Firewall or security rules restricting external access to your endpoint

**Troubleshooting:**

* **Check security configurations:** Review your Cloudflare settings or other security configurations that might be blocking external access to your JWKS endpoint
* **Validate JWKS structure:** Verify your JWKS.json follows the required structure:

```json  theme={"system"}
{
  "keys": [
    {
      "kty": "RSA",
      "n": "your-n-value",
      "e": "AQAB",
      "alg": "RS256",
      "kid": "your-key-id",
      "use": "sig"
    }
  ]
}
```

***

## `Wallet proxy not initialized`

**Description:** Privy was not able to initialize the wallet proxy to interact with embedded wallets.

**Common Causes:**

* The application's origin is not allowlisted
* The app is not waiting for Privy to reach the `ready` state
* The app is not waiting for the wallet to be fully initialized before interacting with it

**Troubleshooting:**

* Confirm that the origin is allowlisted in the dashboard [here](https://dashboard.privy.io/apps?setting=domains\&page=settings).
* Ensure that you are waiting for `ready` [here](/basics/react-native/setup#waiting-for-privy-to-be-ready) and potentially `ready` from `useWallets` [here](/wallets/wallets/get-a-wallet/get-connected-wallet#waiting-for-wallets-to-be-ready)


# Multiple dialogs
Source: https://docs.privy.io/basics/troubleshooting/multiple-dialogs



The Privy modal is an [HTML `<dialog>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dialog) element that will appear in the foreground of your app when opened.

If your app makes use of dialog components (most commonly, for modals and pop-ups), you may encounter issues with the Privy dialog interfering with those from your app.

When using other non-Privy dialog elements within your app, we generally recommend:

* **Avoid UIs that involve a modal overlaying another modal.** This can be a confusing and visually jarring experience for users, especially since users can only interact with a single modal at a time.
* **Use the [`Dialog`](https://headlessui.com/react/dialog) component from [`headless-ui`](https://headlessui.com)**, as it has the best compatibility with UI components and HTML elements from third-party libraries like Privy.

## Radix UI dialogs

If your app uses the [**`Dialog`**](https://www.radix-ui.com/primitives/docs/components/dialog) component from [**Radix UI**](https://www.radix-ui.com), we suggest making the following modifications to the default [**`Dialog`**](https://www.radix-ui.com/primitives/docs/components/dialog) component:

1. Prevent the default behavior of the Radix dialog closing when the user clicks outside of it, via the [**`onPointerDownOutside`**](https://www.radix-ui.com/primitives/docs/components/dialog#content) prop of the [**`Dialog.Content`**](https://www.radix-ui.com/primitives/docs/components/dialog#content) component.
2. Prevent the default behavior of the Radix dialog always trapping the browser's focus (even if other dialogs are opened), by wrapping your[ **`Dialog.Content`**](https://www.radix-ui.com/primitives/docs/components/dialog#content) with the **`FocusScope`** component from the [**`@radix-ui/react-focus-scope`**](https://www.npmjs.com/package/@radix-ui/react-focus-scope) library. In this **`FocusScope`** component, you should set the prop **`trapped`** to `false`. See this [GitHub discussion](https://github.com/radix-ui/primitives/issues/2544) for more info!

Altogether, the modifications to a [**`Dialog`**](https://www.radix-ui.com/primitives/docs/components/dialog) component might look as follows:

```tsx  theme={"system"}

import * as Dialog from '@radix-ui/react-dialog';
import {FocusScope} from '@radix-ui/react-focus-scope';

<Dialog.Root>
  ...
  <Dialog.Portal>
    <Dialog.Overlay />
    {/* This wrapper prevents the Radix dialog from stealing focus away from other dialogs in the page. */}
    <FocusScope trapped={false}>
        {/* The `onPointerDownOutside` handler prevents Radix from closing the dialog when the user clicks outside. */}
      <Dialog.Content
        onPointerDownOutside={(e) => e.preventDefault()}
      />
        ...
      </Dialog.Content>
    </FocusScope>
  </Dialog.Portal>
<Dialog.Root>
```


# Common framework errors
Source: https://docs.privy.io/basics/troubleshooting/react-frameworks



If you're running into build errors with your framework, check out the following troubleshooting steps:

<Tabs>
  <Tab title="Gatsby">
    If you're using a framework like [Gatsby](https://www.gatsbyjs.com/) and are running into build errors, check out some common errors below, and how to resolve them.

    ## iframe not initialized

    If you encounter an error like the one below:

    ```
    iframe not initialized
    ```

    There is likely an issue with how you are rendering the **`PrivyProvider`** component within your app.

    Namely, **if you are using Gatsby's [`wrapRootElement`](https://www.gatsbyjs.com/docs/reference/config-files/gatsby-browser/#wrapRootElement) to wrap your app with the `PrivyProvider`, you should use [`wrapPageElement`](https://www.gatsbyjs.com/docs/reference/config-files/gatsby-browser/#wrapPageElement) instead**, like below:

    ```tsx gatsby-browser.tsx theme={"system"}
    import React from 'react';

    import {PrivyProvider} from '@privy-io/react-auth';

    export const wrapPageElement = ({element}) => {
      return <PrivyProvider appId={'insert-your-app-id'}>{element}</PrivyProvider>;
    };
    ```

    Though Gatsby typically recommends using [**`wrapRootElement`**](https://www.gatsbyjs.com/docs/reference/config-files/gatsby-browser/#wrapRootElement) for React Contexts, the **`PrivyProvider`** component contains UI (HTML) elements as well, including a dialog (the Privy modal) and an iframe (the Privy iframe, used for embedded wallets). Given these UI elements, [**`wrapPageElement`**](https://www.gatsbyjs.com/docs/reference/config-files/gatsby-browser/#wrapPageElement) must be used instead of **`wrapRootElement`**.

    <Info>
      Still have questions? Reach out to our [support team](https://privy.io/slack) – we're here to help!
    </Info>
  </Tab>

  <Tab title="NextJS">
    If you're using a framework like [NextJS](https://nextjs.org/) and are running into build errors, check out some common errors below, and how to resolve them.

    ## App router

    If you are using the new [app router](https://nextjs.org/docs/app), you may encounter issues when attempting to wrap your app with the **`PrivyProvider`**. If so, follow the instructions below to set up your app with Privy:

    #### 1. Create a wrapper component for the **`PrivyProvider`**

    Since the **`PrivyProvider`** is a third-party React Context, it can only be used client-side, with the [**`'use client';`**](https://react.dev/reference/react/use-client) directive. Check out [these docs from NextJS](https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns#using-context-providers) for more information.

    First, create a new component file and add [**`'use client';`**](https://react.dev/reference/react/use-client) as the first line. Then, within this same file, create a custom component (e.g. **`Providers`**) that accepts React [**`children`**](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children) as props, and renders these [**`children`**](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children), wrapped by the **`PrivyProvider`**:

    ```tsx  theme={"system"}
    // components/providers.tsx
    'use client';

    import {PrivyProvider} from '@privy-io/react-auth';

    export default function Providers({children}: {children: React.ReactNode}) {
      return <PrivyProvider appId="insert-your-privy-app-id">{children}</PrivyProvider>;
    }
    ```

    This wrapper component ensures that the **`PrivyProvider`** is only ever rendered client-side, as required by NextJS.

    #### 2. Wrap your app with the providers component in your **`RootLayout`**

    Next, in your app's [Root Layout](https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts#root-layout-required), wrap the layout's [**`children`**](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children) with your providers component, like so:

    ```tsx  theme={"system"}
    import Providers from '../components/providers';

    export default function RootLayout({children}: {children: React.ReactNode}) {
      return (
        <html lang="en">
          <body>
            <Providers>{children}</Providers>
          </body>
        </html>
      );
    }
    ```

    Within your [**`RootLayout`**](https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts#root-layout-required), make sure you are using the wrapper component you created in step (1), *not* the raw **`PrivyProvider`** exported by the SDK.

    **That's it!** You can check out a complete example of Privy integrated into a NextJS app using the App Router [here](https://github.com/privy-io/examples/tree/main/privy-next-starter).

    <Info>
      Still have questions? Reach out to our [support team](https://privy.io/slack) – we're here to help!
    </Info>
  </Tab>

  <Tab title="Create React App">
    If you're using a framework like [Create React App](https://create-react-app.dev/) and are running into build errors, check out some common errors and how to resolve them.

    ## Missing Polyfills (Webpack 5)

    Since Create React App uses [Webpack 5](https://webpack.js.org/blog/2020-10-10-webpack-5-release/), you may encounter errors like the one below:

    ```
    BREAKING CHANGE: webpack < 5 used to include polyfills for node.js core modules by default.
    This is no longer the case. Verify if you need this module and configure a polyfill for it.
    ```

    This is because many standard web3 libraries, such as [`ethers.js`](https://docs.ethers.io/v5/), have dependencies that need to be polyfilled into your build environment. Webpack 5 no longer automatically handles these polyfills, which triggers this error.

    You can work past these issues by explicitly adding in these dependencies and overriding some configurations, as outlined below:

    #### 1. Install dependencies

    Run the following command in your project to install the necessary dependencies:

    ```sh  theme={"system"}
    npm i --save-dev react-app-rewired assert buffer process stream-browserify url
    ```

    #### 2. Configure your project with `react-app-rewired`

    In your `package.json`, in your start, build, and test scripts, update `react-scripts` to `react-app-rewired`. The "scripts" object should look like the following:

    ```json package.json theme={"system"}
    {
        ...,
        "scripts": {
            "start": "react-app-rewired start",
            "build": "react-app-rewired build",
            "test": "react-app-rewired test",
            "eject": "react-scripts eject"
        },
        ...
    }

    ```

    This allows you to bypass the default webpack configurations from `create-react-app`.

    #### 3. Add `config-overrides.js` to your project

    Lastly, at the root of your project, create a file called `config-overrides.js` and paste in the following:

    ```js config-overrides.js theme={"system"}
    const webpack = require('webpack');
    module.exports = function override(config) {
      config.resolve.fallback = {
        assert: require.resolve('assert'),
        buffer: require.resolve('buffer'),
        'process/browser': require.resolve('process/browser'),
        stream: require.resolve('stream-browserify'),
        url: require.resolve('url'),
        http: false,
        https: false,
        os: false
      };
      config.plugins.push(
        new webpack.ProvidePlugin({
          process: 'process/browser',
          Buffer: ['buffer', 'Buffer']
        })
      );
      config.ignoreWarnings = [/Failed to parse source map/];
      return config;
    };
    ```

    This tells your browser where to look for the dependencies that you've now added.

    **That's it!**

    <Info>
      Still have questions? Reach out to our [support team](https://privy.io/slack) – we're here to help!
    </Info>
  </Tab>

  <Tab title="Vite">
    If you're using a framework like [Vite](https://vitejs.dev/) and are running into build errors, check out some common errors below, and how to resolve them.

    ## `process` is not defined

    If you encounter an error like the one below:

    ```
    Uncaught (in promise) ReferenceError: process is not defined at ../../../node_modules/@coinbase/wallet-sdk/dist/CoinbaseWalletSDK.js
    ```

    This is due to an issue in one of Privy's necessary dependencies, the [Coinbase Wallet SDK](https://github.com/coinbase/coinbase-wallet-sdk). You can read more about the issue [here](https://github.com/coinbase/coinbase-wallet-sdk/issues/967).

    **To resolve the issue, we recommend using the [`vite-plugin-node-polyfills`](https://www.npmjs.com/package/vite-plugin-node-polyfills) package, which will polyfill the `process` dependency that Coinbase requires.**

    #### 1. Install **`vite-plugin-node-polyfills`**

    First, install [**`vite-plugin-node-polyfills`**](https://www.npmjs.com/package/vite-plugin-node-polyfills) as a dev dependency:

    ```sh  theme={"system"}
    npm i --save-dev vite-plugin-node-polyfills
    ```

    #### 2. Update your **`vite.config.ts`**

    Then, update your [**`vite.config.ts`**](https://vitejs.dev/config/) file to include the following to use the plugin:

    ```ts  theme={"system"}
    import {defineConfig} from 'vite';
    import {nodePolyfills} from 'vite-plugin-node-polyfills';

    // https://vitejs.dev/config/
    export default defineConfig({
      plugins: [nodePolyfills()]
    });
    ```

    **That's it!**

    <Info>
      Still have questions? Reach out to our [support team](https://privy.io/slack) - we're here to help!
    </Info>
  </Tab>
</Tabs>


# Styles
Source: https://docs.privy.io/basics/troubleshooting/styles



If you're running into issues with the styles of Privy's UIs in your app, check out some common errors below, and how to resolve them.

### Corrupted styles with Sentry

If your application uses [**Sentry**](https://sentry.io/welcome/) for monitoring, and you are seeing corrupted styles in Privy's UIs, it may be due to a bug with certain versions of Sentry's JavaScript libraries (e.g. [**`@sentry/react`**](https://www.npmjs.com/package/@sentry/react) and [**`@sentry/nextjs`**](https://www.npmjs.com/package/@sentry/nextjs)). **See this [GitHub issue](https://github.com/getsentry/sentry-javascript/issues/9170#issuecomment-1761391585) for more information.**

To resolve this issue, try upgrading your **`@sentry/*`** package to a **version higher than `7.74.0`**.


# Embedded wallets
Source: https://docs.privy.io/basics/troubleshooting/troubleshooting-embedded-wallets



**If you're running into issues with creating and using embedded wallets in your app, check out some common errors below, and how to resolve them.**

## Embedded wallets created on `localhost`, but not on deployment

If you are able to successfully create embedded wallets for your users on **`localhost`**, but not in a deployed environment, **double-check that the protocol for your deployment URL is `https://` (secure), and *not* `http://`**. Privy embedded wallets use the browser's native [WebCrypto API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API), which is only available in secure contexts like **`https://`**.

**In kind, you *must* use a secure context (`https://`) for your deployment.** Embedded wallets will *not* be created or work in insecure contexts like **`http://`**, except **`localhost`**, which is a special case and treated by the browser as a secure context.

## Access to the Base RPC URL has been blocked by CORS

If you're using embedded wallets on Base or Base Goerli, and see the following error:

```
Access to fetch at 'https://base-mainnet.blastapi.io/insert-api-key' from origin 'insert-your-origin' has been blocked by CORS policy...
```

**This likely indicates that your IP address has been rate limited by the Blast RPC URL for making too many requests within a short time window.**

Though this may appear to be a CORS violation, the initial error sent by Blast should indicate this rate limit (with a 429 status code). Successive errors due to the rate limit may not include the required CORS headers, which is why the overall error message appears as a CORS violation.

**If you are seeing this issue, please try again shortly.** If it still does not resolve, please [reach out](https://privy.io/slack) and we can help debug!


# Using LLMs
Source: https://docs.privy.io/basics/troubleshooting/using-llms



Privy's docs are LLM-friendly to help developers integrate with Privy faster.

## Use the Privy docs llms-full.txt file

You can provide your code editor with a `llms-full.txt` file to use Privy's docs as a context for your code. The following steps show how to do this for [Cursor](https://www.cursor.com/).

1. Navigate to **Cursor Settings** > **Features** > **Docs**

2. Select "Add new doc" and paste the following URL:

   ```
   https://docs.privy.io/llms-full.txt
   ```

3. Use `@docs -> Privy` to reference Privy's docs in your code.


# Features
Source: https://docs.privy.io/basics/unity/features

Learn about the features supported by the Unity SDK

export const FeatureMatrix = ({sdk}) => {
  const sdks = sdk ? [sdk] : ['react', 'reactNative', 'swift', 'android', 'flutter', 'unity'];
  const sdkNames = {
    react: 'React',
    reactNative: 'React Native',
    swift: 'Swift',
    android: 'Android',
    flutter: 'Flutter',
    unity: 'Unity'
  };
  const matrix = [{
    name: 'Authentication',
    features: [{
      name: 'Email',
      react: true,
      reactNative: true,
      swift: true,
      android: true,
      flutter: true,
      unity: true
    }, {
      name: 'SMS',
      react: true,
      reactNative: true,
      swift: true,
      android: true,
      flutter: true
    }, {
      name: 'OAuth',
      react: true,
      reactNative: true,
      swift: 'Google, Apple, Twitter, Discord',
      android: 'Google, Discord, Twitter',
      flutter: 'Google, Apple, Twitter, Discord',
      unity: 'Google, Apple, Twitter, Discord'
    }, {
      name: 'SIWE (Sign In with Ethereum)',
      react: true,
      reactNative: true,
      swift: true
    }, {
      name: 'SIWS (Sign In with Solana)',
      react: true,
      reactNative: true
    }, {
      name: 'Farcaster',
      react: true,
      reactNative: true
    }, {
      name: 'Telegram',
      react: true
    }, {
      name: 'Custom Auth',
      react: true,
      reactNative: true,
      swift: true,
      android: true,
      flutter: true
    }, {
      name: 'Passkeys',
      react: true,
      reactNative: true
    }]
  }, {
    name: 'Farcaster',
    features: [{
      name: 'SIWF',
      react: true,
      reactNative: true
    }]
  }, {
    name: 'Embedded Wallets',
    features: [{
      name: 'Creating wallets manually',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum', 'solana'],
      android: ['ethereum', 'solana'],
      flutter: ['ethereum', 'solana'],
      unity: ['ethereum', 'solana']
    }, {
      name: 'Creating wallets automatically',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Pregenerating wallets',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum', 'solana'],
      android: ['ethereum', 'solana'],
      flutter: ['ethereum', 'solana']
    }, {
      name: 'Signing messages and transactions',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum', 'solana'],
      android: ['ethereum', 'solana'],
      flutter: ['ethereum', 'solana'],
      unity: ['ethereum', 'solana']
    }, {
      name: 'Broadcasting transactions',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum'],
      android: ['ethereum'],
      flutter: ['ethereum'],
      unity: ['ethereum']
    }, {
      name: 'Native smart wallets',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: 'Automatic recovery',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum', 'solana'],
      android: ['ethereum', 'solana'],
      flutter: ['ethereum', 'solana'],
      unity: ['ethereum']
    }, {
      name: 'User controlled recovery',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Transaction MFA',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Key Export',
      react: ['ethereum', 'solana']
    }, {
      name: 'Key Import',
      react: ['ethereum', 'solana']
    }, {
      name: 'HD wallets',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana'],
      swift: ['ethereum'],
      android: ['ethereum'],
      flutter: ['ethereum'],
      unity: ['ethereum']
    }, {
      name: 'Session signers',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Global wallets (Cross App Accounts)',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: 'Custom EVM (Ethereum) network support',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: 'Custom SVM (Solana) network support',
      react: ['solana'],
      reactNative: ['solana']
    }]
  }, {
    name: 'Connectors',
    features: [{
      name: 'External wallets',
      react: ['ethereum', 'solana']
    }, {
      name: 'Wagmi',
      react: ['ethereum']
    }, {
      name: 'Viem',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: 'Ethers',
      react: ['ethereum'],
      reactNative: ['ethereum']
    }, {
      name: '@solana/web3.js',
      react: ['solana']
    }, {
      name: 'web3swift',
      swift: ['ethereum']
    }]
  }, {
    name: 'Funding',
    features: [{
      name: 'Transfer or bridge from wallet',
      react: ['ethereum', 'solana']
    }, {
      name: 'Transfer from exchange',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }, {
      name: 'Pay with card',
      react: ['ethereum', 'solana'],
      reactNative: ['ethereum', 'solana']
    }]
  }];
  const filteredMatrix = matrix.map(section => {
    return {
      ...section,
      features: section.features.filter(featureItem => {
        if (sdk) {
          return featureItem[sdk] !== undefined;
        }
        return true;
      })
    };
  }).filter(section => {
    return section.features.length > 0;
  });
  return <table style={{
    display: 'table',
    width: '100%'
  }}>
      {sdk ? null : <thead>
          <tr>
            <th></th>
            {sdks.map(sdk => <th>{sdkNames[sdk]}</th>)}
          </tr>
        </thead>}
      <tbody>
        {filteredMatrix.map(section => <>
            <tr>
              <td>
                <strong>{section.name}</strong>
              </td>
              {sdks.map(() => <td></td>)}
            </tr>
            {section.features.map(feature => <tr>
                <td>
                  <em>{feature.name}</em>
                </td>
                {sdks.map(sdk => {
    const supported = feature[sdk];
    if (supported === true) {
      return <td>✅</td>;
    } else if (!supported) {
      return <td></td>;
    } else if (Array.isArray(supported)) {
      return <td>
                        {supported.map(item => item === 'ethereum' ? <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/ethereum.png" noZoom style={{
        display: 'inline',
        margin: '2px',
        width: '18px'
      }} /> : <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/solana.png" noZoom style={{
        display: 'inline',
        margin: '2px',
        width: '18px'
      }} />)}
                      </td>;
    } else {
      return <td>{supported}</td>;
    }
  })}
              </tr>)}
          </>)}
      </tbody>
    </table>;
};

## Supported features

<FeatureMatrix sdk="unity" />


# null
Source: https://docs.privy.io/basics/unity/installation



## Supported Platforms

* ✅ MacOS / iOS
* ✅ Android
* ✅ WebGL
* ❌ Windows
* ❌ Linux

## Installation

Privy's Unity SDK is distributed as a `.unitypackage` file, and is not yet available in Unity's package manager. To import the SDK:

1. Download the latest `.unitypackage` file [here](https://drive.google.com/drive/folders/1Aw9TCxLYM3Tc6wJx0iTJXPzj-UJzwApQ)
2. Open your project in the Unity editor
3. Select Assets → Import Package → Custom Package:

<img src="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/unity-setup/installing-unity-package.png?fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=d29e1741ee670461de779ba8bbc32365" alt="installing-unity-package" data-og-width="848" width="848" data-og-height="646" height="646" data-path="images/unity-setup/installing-unity-package.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/unity-setup/installing-unity-package.png?w=280&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=ed6ff203b565bf77bcae8bd40f1dac23 280w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/unity-setup/installing-unity-package.png?w=560&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=d7dd52119d1bc2c9bd460f0e246e916a 560w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/unity-setup/installing-unity-package.png?w=840&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=5650250caaefa7ed559b2498dbec10d2 840w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/unity-setup/installing-unity-package.png?w=1100&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=d28ad976838ad8f9b4a6a64a443c1a55 1100w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/unity-setup/installing-unity-package.png?w=1650&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=8a4af24e9250283fa7ab7d8efae4a383 1650w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/unity-setup/installing-unity-package.png?w=2500&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=bb6ffc1a03c79e741f7821884a1735ed 2500w" />

4. Confirm the import of the custom package. A window will pop up listing all the assets included in the package; click **Import** to add all the assets to your project.

<Note>
  Privy's Unity package includes dependencies such as `Newtonsoft.Json` and `unity-webview`. If your
  project already includes these packages, the Unity Editor should automatically detect them and
  uncheck them by default. However, if this doesn't happen, you should manually deselect these
  packages during the import process to avoid potential duplicate instances, which could lead to
  errors.
</Note>

## Using the Privy Namespace

All Privy classes in Unity live in the `Privy` namespace. At the top of each file that uses Privy, you must add the `using Privy` directive:

```csharp  theme={"system"}
using Privy;
```

## WebGL Setup

Privy's Unity SDK leverages an iframe to [secure the key material]() for a user's embedded wallet. Given the use of an iframe, we recommend testing builds with Privy's Unity SDK in the **browser**, or on a **non-WebGL platform** in the Unity editor.

<Tip>
  Watch this [demo](https://www.loom.com/share/0bac8322368c44059dff51e2dfc548e8) of setting up the
  Privy SDK in a Unity Project!
</Tip>

To configure settings for your WebGL build to work with Privy, go to your **Project Settings** in the Unity editor. Next, select **Player** and navigate to **WebGL**. Set the following values:

* In **Resolution and Presentation**, select `unity-webview`, or `unity-webview-2020` as the template if you are using a Unity editor version newer than 2020.

<img src="https://mintcdn.com/privy-c2af3412/Ih_Fo3QYM486gzWq/images/unity-setup/webview-template.png?fit=max&auto=format&n=Ih_Fo3QYM486gzWq&q=85&s=0b6d2f19f9457b42eca83ff790b483bb" alt="webview-template" data-og-width="670" width="670" data-og-height="478" height="478" data-path="images/unity-setup/webview-template.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/Ih_Fo3QYM486gzWq/images/unity-setup/webview-template.png?w=280&fit=max&auto=format&n=Ih_Fo3QYM486gzWq&q=85&s=570f0047d759f98b65f1d3fb9db76e72 280w, https://mintcdn.com/privy-c2af3412/Ih_Fo3QYM486gzWq/images/unity-setup/webview-template.png?w=560&fit=max&auto=format&n=Ih_Fo3QYM486gzWq&q=85&s=ddbfeed8b9031b6e242f4a8179d17d97 560w, https://mintcdn.com/privy-c2af3412/Ih_Fo3QYM486gzWq/images/unity-setup/webview-template.png?w=840&fit=max&auto=format&n=Ih_Fo3QYM486gzWq&q=85&s=193a95bab34a6a887018a252a745dc83 840w, https://mintcdn.com/privy-c2af3412/Ih_Fo3QYM486gzWq/images/unity-setup/webview-template.png?w=1100&fit=max&auto=format&n=Ih_Fo3QYM486gzWq&q=85&s=5ed6042f62af8a245920abfd55fd859b 1100w, https://mintcdn.com/privy-c2af3412/Ih_Fo3QYM486gzWq/images/unity-setup/webview-template.png?w=1650&fit=max&auto=format&n=Ih_Fo3QYM486gzWq&q=85&s=95e742717889a66af1171a74a09b187c 1650w, https://mintcdn.com/privy-c2af3412/Ih_Fo3QYM486gzWq/images/unity-setup/webview-template.png?w=2500&fit=max&auto=format&n=Ih_Fo3QYM486gzWq&q=85&s=116cd3e2283529e7ef65f8ed55c9e1f1 2500w" />

* In **Other Settings/Optimization**, **managed stripping level** to **minimal**

<img src="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/unity-setup/webview-stripping-settings.png?fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=96b832009a26bc0408c7b526f793561a" alt="webview-stripping-settings" data-og-width="1256" width="1256" data-og-height="240" height="240" data-path="images/unity-setup/webview-stripping-settings.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/unity-setup/webview-stripping-settings.png?w=280&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=1c88cc7c7f80a744aa67ead7902cd588 280w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/unity-setup/webview-stripping-settings.png?w=560&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=394550f6e4f08157d8457f90a3bab1e0 560w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/unity-setup/webview-stripping-settings.png?w=840&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=4efdccace21e9212cd16749818757966 840w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/unity-setup/webview-stripping-settings.png?w=1100&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=6868aae579c673d68960d8b960e6f7c4 1100w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/unity-setup/webview-stripping-settings.png?w=1650&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=ad495e6a528b45a6196f92c2877c1ad3 1650w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/unity-setup/webview-stripping-settings.png?w=2500&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=66e7977c57955d67fd4c52616b521649 2500w" />

<Note>
  The following versions of the Unity editor are not supported, due to [this
  bug](https://issuetracker.unity3d.com/issues/webgl-cross-origin-embedder-policy-require-corp-http-header-is-included-when-multithreading-is-off):
  `2022.3.20f1`, `2022.3.40f1`, `2023.2.12f1`, `6000.0.0b11`.
</Note>


# Quickstart
Source: https://docs.privy.io/basics/unity/quickstart

Learn how to authenticate users, create embedded wallets, and send transactions in your Unity app

## Prerequisites

This guide assumes that you have completed the [setup](/basics/unity/setup) guide.

## Check user's authentication state

```csharp  theme={"system"}
var authState = await PrivyManager.Instance.GetAuthState();

switch (authState) {
    case AuthState.Authenticated:
        // User is authenticated. Grab the user's linked accounts
        var privyUser = await PrivyManager.Instance.GetUser();
        var linkedAccounts = privyUser.LinkedAccounts;
    case AuthState.Unauthenticated:
        // User is not authenticated.
}
```

## Authenticate your user

<Tip>
  This quickstart guide will demonstrate how to authenticate a user with a one time password as an
  example, but Privy supports many authentication methods. Explore our [Authentication
  docs](/authentication/overview) to learn about other methods such as socials, passkeys, and
  external wallets to authenticate users in your app.
</Tip>

Privy offers a variety of authentication mechanisms. The example below showcases authenticating a user via email.

This is a two step process:

1. Send an OTP to the user provided email address.
2. Verify the OTP sent to the user.

### 1. Send an OTP to the user's email address

After collecting and validating your users email, send an OTP by calling the **`SendCode`** method.

```csharp  theme={"system"}
bool success = await PrivyManager.Instance.Email.SendCode(email);

if (success)
{
    // Prompt user to enter the OTP they received at their email address through your UI
}
else
{
  // There was an error sending an OTP to your user's email
}
```

### 2. Authenticate with OTP

The user will then receive an email with a 6-digit OTP. Prompt the user for this OTP within your application, then authenticate the user with the **`loginWithCode`** method. As a parameter to this method, pass an object with the following fields:

<ParamField name="email" type="String">
  The user's email address.
</ParamField>

<ParamField name="code" type="String">
  OTP code inputted by the user in your app.
</ParamField>

```csharp  theme={"system"}
try
{
    // User will be authenticated if this call is successful
    await PrivyManager.Instance.Email.LoginWithCode(email, code);
}
catch
{
    // If "LoginWithCode" throws an exception, user login was unsuccessful.
    Debug.Log("Error logging user in.");
}
```

This method will throw an error if:

* the incorrect OTP code is inputted
* the network call to authenticate the user fails

## The embedded wallet

<Tabs>
  <Tab title="Ethereum">
    ### Create an embedded wallet

    To create an embedded Ethereum wallet for your user, call the `CreateWallet` method on the `PrivyUser`.

    ```csharp  theme={"system"}
    try
    {
        PrivyUser privyUser = PrivyManager.Instance.User;

        if (privyUser != null)
        {
            IEmbeddedEthereumWallet wallet = await PrivyManager.Instance.User.CreateWallet();
            Debug.Log("New wallet created with address: " + wallet.Address);
        }
    }
    catch
    {
        Debug.Log("Error creating embedded wallet.");
    }
    ```

    This method will throw an error if:

    * the user is not authenticated
    * the user already has an embedded wallet
    * wallet creation fails on the user's device

    To use embedded wallets, Privy implements an `RpcProvider` on the `EmbeddedWallet` class of the Unity SDK. This is an EIP1193 provider is responsible for managing RPC requests to a user's embedded wallet.

    Currently, Privy's `RpcProvider` only supports the `personal_sign` and `eth_signTypedData_v4` RPCs. We are actively adding support for other methods.

    #### 1. Get the user's wallet

    To make an RPC request to a user's wallet, first get the user's embedded wallet like so:

    ```csharp  theme={"system"}
    // Ensure user is authenticated / non null

    PrivyUser privyUser = PrivyManager.Instance.User;

    if ( privyUser != null )
    {
        // Grab the embedded wallet from the embedded wallet list
        // For demonstration purposes we're just grabbing the first one.
        IEmbeddedEthereumWallet embeddedWallet = PrivyManager.Instance.User.EmbeddedWallets[0];

        //Ensure the Wallet is not null
        if ( embeddedWallet != null )
        {
            //wallet operations
        }
    }

    ```

    #### 2. Construct your RPC request

    Next, construct the RPC request using the `RpcRequest` class from Privy. The class follows the interface below:

    ```csharp  theme={"system"}
    public class RpcRequest
    {
        public string Method { get; set; }
        public string[] Params { get; set; }

    }
    ```

    As an example, you can construct a new RPC request like so.

    ```csharp  theme={"system"}
    var rpcRequest = new RpcRequest
    {
        Method = "personal_sign", //a supported method
        Params = new string[] { "A message to sign", embeddedWallet.Address } //an array of strings, with the message + address
    };
    ```

    #### 3. Execute the RPC request

    Now, simply pass the `rpcRequest` you constructed to the `RpcProvider`'s `Request` method to execute the request:

    ```csharp  theme={"system"}
    try
    {
        //Now that the response has been constructed, we try to execute the request
        RpcResponse personalSignResponse = await embeddedWallet.RpcProvider.Request(rpcRequest);

        //If response is successful, we can parse out the data
        Debug.Log(personalSignResponse.Data)
    }
    catch (PrivyException.EmbeddedWalletException ex)
    {
        //If the request method fails, we catch it here
        Debug.LogError($"Could not sign message due to error: {ex.Error} {ex.Message}");
    }
    catch (Exception ex)
    {
        //If there's some other error, unrelated to the request, catch this here
        Debug.LogError($"Could not sign message exception {ex.Message}");
    }
    ```

    This will return an `RpcResponse`, which implements the interface below:

    ```csharp  theme={"system"}
    public class RpcResponse
    {
        public string Method { get; set; }
        public string Data { get; set; }

    }
    ```

    #### Handling errors

    The provider's `Request` method may error if:

    * the user is not authenticated
    * the user's wallet does not exist or has not loaded on their device
    * there is an issue with the RPC request that was sent to the wallet

    These errors can be caught through a generic exception, or Privy's custom `AuthenticationException` or `EmbeddedWalletException`:

    ```csharp  theme={"system"}
    catch (PrivyException.AuthenticationException ex)
    {
        Debug.LogError($"Error signing message, Type:{ex.Error}, Message:{ex.Message}");
    }
    catch (PrivyException.EmbeddedWalletException ex)
    {
        Debug.LogError($"Could not sign message due to error: {ex.Error} {ex.Message}");
    }
    catch
    {
        Debug.LogError("Error signing message");
    }

    ```

    ### Full example

    As a complete example, you can send an RPC request to a wallet and handle corresponding errors like so:

    ```csharp  theme={"system"}
    try {
        IEmbeddedEthereumWallet embeddedWallet = PrivyManager.Instance.User.EmbeddedWallets[0];

        var rpcRequest = new RpcRequest
        {
            Method = "personal_sign",
            Params = new string[] { "A message to sign", embeddedWallet.Address }  // Use the 'new' keyword here
        };

        RpcResponse personalSignResponse = await embeddedWallet.RpcProvider.Request(rpcRequest);

        Debug.Log(personalSignResponse.Data);
    } catch (PrivyException.EmbeddedWalletException ex){
        Debug.LogError($"Could not sign message due to error: {ex.Error} {ex.Message}");
    } catch (Exception ex) {
        Debug.LogError($"Could not sign message exception {ex.Message}");
    }
    ```
  </Tab>

  <Tab title="Solana">
    ### Create an embedded Solana wallet

    To create an embedded Solana wallet for your user, call the `CreateSolanaWallet` method on the `PrivyUser`.

    ```csharp  theme={"system"}
    try {
        var solanaWallet = await PrivyManager.Instance.User.CreateSolanaWallet();
        Debug.Log("New Solana wallet created with address: " + solanaWallet.Address);
    } catch {
        Debug.Log("Error creating embedded wallet.");
    }
    ```

    This method will throw an error if:

    * the user is not authenticated
    * the user already has an embedded wallet
    * wallet creation fails on the user's device

    ### Signing a message with an embedded Solana wallet

    To use embedded wallets, Privy implements a provider on the `EmbeddedSolanaWallet` class of the Unity SDK.
    This is responsible for managing requests to a user's embedded Solana wallet, via the `SignMessage` method.

    <Steps>
      <Step title="Get the user's wallet">
        To make an RPC request to a user's wallet, first get the user's embedded wallet like so:

        ```csharp  theme={"system"}
        PrivyUser privyUser = PrivyManager.Instance.User;

        // Grab the embedded wallet from the embedded wallet list
        // For demonstration purposes we're just grabbing the first one.
        var embeddedWallet = PrivyManager.Instance.User.EmbeddedSolanaWallets[0];

        //Ensure the Wallet is not null
        if (embeddedWallet != null) {
            //wallet operations
        }
        ```
      </Step>

      <Step title="Encode the message for signature">
        Signatures using the embedded Solana wallet are performed on a **base64-encoded message**.

        This means you can sign arbitrary strings by encoding their utf-8 bytes to base64,
        but it also means you can **sign any transaction by serializing it** to a base64 encoded string.

        ```csharp  theme={"system"}
        // Preparing an arbitrary string for signing
        string message = "A message to sign";
        string base64Message = Convert.ToBase64String(Encoding.UTF8.GetBytes(message));

        // Preparing a transaction for signing (using a custom class of your own for building the transaction)
        byte[] tx = new TransactionBuilder()
           // Add instructions to the transaction
           .CompileMessage();
        string base64Tx = Convert.ToBase64String(tx);
        ```
      </Step>

      <Step title="Execute the signature request">
        Now, simply pass the message you want signed to the provider's `SignMessage` method to execute the signature request:

        ```csharp  theme={"system"}
        try
        {
            var provider = embeddedWallet.EmbeddedSolanaWalletProvider;
            string signature = await provider.SignMessage(base64Message);

            Debug.Log(signature);
        }
        catch (PrivyException.EmbeddedWalletException ex)
        {
            //If the request method fails, we catch it here
            Debug.LogError($"Could not sign message due to error: {ex.Error} {ex.Message}");
        }
        catch (Exception ex)
        {
            //If there's some other error, unrelated to the request, catch this here
            Debug.LogError($"Could not sign message exception {ex.Message}");
        }
        ```
      </Step>
    </Steps>

    #### Handling errors

    The provider's `SignMessage` method may error if:

    * the user is not authenticated
    * the user's wallet does not exist or has not loaded on their device
    * there is an issue with the signature request that was sent to the wallet

    These errors can be caught through a generic exception, or Privy's custom `AuthenticationException` or `EmbeddedWalletException`:

    ```csharp  theme={"system"}
    catch (PrivyException.AuthenticationException ex)
    {
        Debug.LogError($"Error signing message, Type:{ex.Error}, Message:{ex.Message}");
    }
    catch (PrivyException.EmbeddedWalletException ex)
    {
        Debug.LogError($"Could not sign message due to error: {ex.Error} {ex.Message}");
    }
    catch (Exception ex)
    {
        Debug.LogError($"Could not sign message exception {ex.Message}");
    }
    ```
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/basics/unity/setup



## Prerequisites

Before you begin, make sure you have [set up your Privy app and obtained your app ID](/basics/get-started/dashboard/create-new-app) and [client ID](/basics/get-started/dashboard/app-clients) from the Privy Dashboard.

<Warning>
  A properly set up app client is required for mobile apps and other non-web platforms to allow your
  app to interact with the Privy API. Please follow [this
  guide](/basics/get-started/dashboard/app-clients) to configure an app client.
</Warning>

## Initializing Privy

Initialize Privy as early as possible in your game's lifecycle by calling `PrivyManager.Initialize(PrivyConfig config)`:

```csharp  theme={"system"}
var config = new PrivyConfig{
    AppId = "YOUR_APP_ID",
    ClientId = "YOUR_CLIENT_ID"
};

PrivyManager.Initialize(config);
```

## Configuration

The configuration fields for the PrivyConfig are:

<ParamField name="AppId" type="String" required>
  Your Privy application ID, which can be obtained from the [**Privy Developer
  Dashboard**](https://dashboard.privy.io), under App Settings > Basics
</ParamField>

<ParamField name="ClientId" type="String" required>
  Your app client ID, which can be obtained from the [**Privy Developer
  Dashboard**](https://dashboard.privy.io), under App Settings > Clients
</ParamField>

<Tip>
  Be sure to initialize Privy only once at the start of your game. Initializing multiple instances
  of Privy will result in unexpected errors.
</Tip>


# Authorization keys
Source: https://docs.privy.io/controls/authorization-keys/keys/create/key



Authorization keys allow the party that controls the key to execute actions on wallets and policies by signing requests to the Privy API. Examples of authorization keys include a key controlled by your app's server or a passkey controlled by a user.

You can create authorization keys for your application via the **Privy Dashboard** or via the **REST API**.

<Tabs>
  <Tab title="Dashboard">
    To create a new authorization key in the Dashboard, visit the [**Authorization keys**](https://dashboard.privy.io/apps?page=authorization-keys) page of the **Wallets** section for your app.

    Click the **New key** button and copy and save the generated **Private key**. Privy does not save this key and cannot help you recover it later. You can also set a human-readable **Key name**.

    In this process, Privy generates a keypair for your app directly on your device, and shows you the private key.

    * The private key (e.g. the key you copy) is generated on your device, and is only ever known to your app. Neither Privy nor the secure enclave ever sees the private key, and cannot sign payloads with it. **Make sure you save this key.**
    * The public key is registered with the secure enclave that secures your wallets, and is used to verify signatures produced by your app.

    <Warning>
      Privy does not store the private key and cannot help you retrieve it.
    </Warning>
  </Tab>

  <Tab title="REST API">
    Authorization keys are [P-256](https://neuromancer.sk/std/nist/P-256) public-private keypairs. **Make sure to save the private key, as Privy does not store this and cannot help you recover it.**

    You can create a keypair with the following command:

    ```sh  theme={"system"}
    openssl ecparam -name prime256v1 -genkey -noout -out private.pem && \
    openssl ec -in private.pem -pubout -out public.pem
    ```

    This creates PEM-formatted files in your working directory for local storage. When registering the public key with the Privy API, you'll need to convert it to base64-encoded DER format:

    ```sh  theme={"system"}
    openssl ec -pubin -in public.pem -outform DER | base64
    ```

    Next, follow [this guide](/controls/key-quorum/create) to register your public key with the Privy API.

    <Tip>
      If you locally generate an authorization key and register it with the Privy API, make sure to note down the `id` in the response. You will use this value as the `owner_id` when specifying owners elsewhere (e.g. creating or updating wallets) or `signer_id` when specifying additional signers.
    </Tip>
  </Tab>

  <Tab title="Passkeys">
    Passkeys can be registered as authorization keys via either the Privy Dashboard or REST API. Simply follow the instructions in the Dashboard or REST API section to register the key, and pass the passkey's public key into the public key field of the request.
  </Tab>
</Tabs>


# Key quorums
Source: https://docs.privy.io/controls/authorization-keys/keys/create/key-quorum



An owner or a signer can also be composed of a mix of [users](/controls/authorization-keys/keys/create/user/overview) and [authorization keys](/controls/authorization-keys/keys/create/key). This is known as a key quorum.

Key quorums have an authorization threshold that defines how many keys in the quorum must sign a request for the aggregated signature to be valid. You can use key quorums to implement use cases such as:

* Allowing users *or* apps to sign requests from user wallets
* Requiring both users *and* apps to sign requests from user wallets
* Requiring a distributed set of authorization keys to sign requests from a wallet

Learn more about key quorums in the [**Key quorums**](/controls/key-quorum/overview) section.

<Tip>
  Key quorums are an advanced integration. To determine if key quorums are right for your use case,
  please [reach out](https://privy.io/slack).
</Tip>


# Configure authentication settings
Source: https://docs.privy.io/controls/authorization-keys/keys/create/user/authentication



<Tip>If your app uses Privy as your authentication provider, you can skip this step.</Tip>

In order to issue user keys for users, the Privy API must verify the user's access token to ensure that the authenticated user is the party making the request for the user key.

To verify a user's access token, Privy requires that your app register details of your authentication setup in the Privy Dashboard. Namely:

1. Get your **JWKS.json** endpoint from your authentication provider (e.g. Auth0, Firebase, Stytch). Privy will use this endpoint to verify access tokens for your users.
2. In the **Authentication** page of the **Configuration** section of the Privy Dashboard, enable **JWT-based authentication**.
3. Once JWT-based authentication has been enabled:
   1. Determine whether your app will be authenticating requests that contain your provider's JWTs from a **server side or client side environment**.
      {/* prettier-ignore */}
   2. Register the **JWKS.json** endpoint from your authentication provider and the name of the **JWT claim** that specifies the user's ID (typically `sub`).
      Privy can now verify access tokens issued by your authentication provider to authenticate users, and issue user keys for users.


# Users
Source: https://docs.privy.io/controls/authorization-keys/keys/create/user/overview



Users can be owners and/or signers in Privy.

<Tip>
  You can create user self-custodial wallets by setting a user as the owner of the wallet, whether
  you use your own existing authentication provider or Privy as your authentication provider.
</Tip>

When you make a request to the Privy API with a valid **access token** for a user, Privy returns a **user key** for the user. Requests to the Privy API to update or take actions with a resource owned by this user must be signed by the user key.

To ensure the security of user keys:

* User keys are **time-bound**, meaning they can only sign requests for a limited window before they expire, and a new user key must be requested.
* When returning a user's key, Privy encrypts the key under a public-private keypair that your app generates. This ensures that only your server can decrypt the user's key.

At a high-level, the flow to request user authentication keys is as follows:

<Steps>
  <Step title="Configure authentication settings">
    In the [Privy Dashboard](/controls/authorization-keys/keys/create/user/authentication), configure your authentication settings from your authentication provider. In particular, register the JWKS.json endpoint that will be used to verify your user's access token.

    <Tip>
      If you are using Privy as your authentication provider, you can skip this step.
    </Tip>
  </Step>

  <Step title="Generate a keypair to encrypt user  keys">
    Generate a public-private keypair (ECH P-256) that will be used to encrypt the user key. Make sure to save both the public and private keys.
  </Step>

  <Step title="Request a user key from the Privy API">
    Make a request to the Privy API with the user's access token and the public key you generated. Privy will return a user key for the user, encrypted under the public key you provided, which you can decrypt with the corresponding private key.
  </Step>
</Steps>


# Using user owners & signers
Source: https://docs.privy.io/controls/authorization-keys/keys/create/user/request



Once your application has successfully configured authentication settings, users can update and take actions with resources they own per the following flow.

<Steps>
  <Step title="Request a user key for a user">
    Make a request to the Privy API with the user's access token to request a user key. If the token
    is valid per your configured authentication settings, Privy will return a time-bound user key
    that can be used to sign requests.
  </Step>

  <Step title="Sign the request with the user key">
    Given the returned user key, [sign the request](/controls/authorization-keys/using-owners/sign)
    to update or take actions with a resource the user owns.
  </Step>

  <Step title="Pass the signature in request headers">
    Lastly, [pass the signature](/controls/authorization-keys/using-owners/action) from the user key
    in a `privy-authorization-signature` header for the request. Privy will verify the signature and
    execute the request only if the signature is valid.
  </Step>
</Steps>

Follow the guide below to learn how to request and use user keys from the Privy API.

<Tabs>
  <Tab title="NodeJS">
    ### Set the authorization context to use the user's keypair

    Given the user's access token, the NodeJS SDK handles requesting the user key via the Privy API under
    the hood. Use the [authorization context](/controls/authorization-keys/using-owners/sign/signing-on-the-server) builder to set the user
    JWT, and pass it into wallet API functions that require owner's authorization, by setting the
    `user_jwts` property.

    ```ts  theme={"system"}
    import {AuthorizationContext} from '@privy-io/node';

    const authorizationContext: AuthorizationContext = {
      user_jwts: ['insert-user-jwt']
    };
    ```

    Wallet requests on the wallets owned by the user can now be made by passing in this newly created
    authorization context on the call to the `PrivyClient`.

    ```ts title="Example: Sign a message with the user's wallet" highlight={15-17} theme={"system"}
    import {PrivyClient} from '@privy-io/node';

    const privyClient = new PrivyClient({
      appId: 'insert-your-app-id',
      appSecret: 'insert-your-app-secret'
    });

    try {
      // With the authorization context, this method automatically signs the request.
      const response = await privyClient
        .wallets()
        .ethereum()
        .signMessage('insert-user-wallet-id', {
          message: 'Hello, Ethereum.',
          authorization_context: {
            user_jwts: ['insert-user-jwt']
          }
        });

      const signature = response.signature;
    } catch (error) {
      console.error(error);
    }
    ```
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    #### 1. Request a user key for a user

    To request a user key with the NodeJS SDK, use the `generateUserSigner` method of the Privy client.

    ```ts  theme={"system"}
    import {PrivyClient} from '@privy-io/server-auth';

    const privy = new PrivyClient('insert-your-app-id', 'insert-your-app-secret');

    const {authorizationKey} = await privy.walletApi.generateUserSigner({
      userJwt: 'insert-user-jwt'
    });
    ```

    As a parameter to the method, pass an object containing the following.

    <ParamField path="userJwt" type="string" required>
      The user's JWT, to authenticate the user.

      If your app is using your own authentication provider, the user's JWT should verify against the JWKS.json endpoint you registered in the Dashboard.

      If your app is using Privy as your authentication provider, the user's JWT should be the access token issued by Privy.
    </ParamField>

    <Tip>
      Under the hood, the `generateUserSigner` method handles the encryption and decryption of the user
      key returned by the Privy API. This means your application does not need to handle the encryption
      of the user key.
    </Tip>

    #### 2. Update the Privy client to use the user's keypair

    Once you've generated a user authorization key for the user, update the Privy client to use the user authorization key via the `updateAuthorizationKey` method. This will configure the Privy client to sign requests with the provided key.

    ```ts  theme={"system"}
    import {PrivyClient} from '@privy-io/server-auth';

    const privy = new PrivyClient('insert-your-app-id', 'insert-your-app-secret');

    privy.walletApi.updateAuthorizationKey('insert-user-authorization-key');
    ```

    As a parameter to this method, pass the user authorization key returned by the `generateUserSigner` method as a `string`.

    #### 3. Execute requests with the user's authorization key

    Once the Privy client has been updated with a specific user's authorization key, the client will automatically sign requests made by the [`privy.walletApi.ethereum.*`](/wallets/using-wallets/ethereum/send-a-transaction) and [`privy.walletApi.solana.*`](/wallets/using-wallets/solana/send-a-transaction) methods. You do not need to take any extra steps to sign requests.
  </Tab>

  <Tab title="Java">
    ### Set the authorization context to use the user's keypair

    Given the user's access token, the Java SDK handles requesting the user key via the Privy API under
    the hood. Use the [authorization context](/controls/authorization-keys/using-owners/sign/signing-on-the-server) builder to set the user
    JWT, and pass it into wallet API functions that require owner's authorization, by using
    `.addUserJwt()`.

    ```java  theme={"system"}
        AuthorizationContext authorizationContext = AuthorizationContext.builder()
            .addUserJwt("insert-user-jwt")
            .build();
    ```

    Wallet requests on the wallets owned by the user can now be made by passing in this newly created
    authorization context on the call to the `PrivyClient`.

    ```java title="Example: Sign a message with the user's wallet" highlight={4-6,14} theme={"system"}
    try {
        String message = "Hello, Ethereum.";

        AuthorizationContext authorizationContext = AuthorizationContext.builder()
            .addUserJwt("insert-user-jwt")
            .build();

        // With the authorization context, this method automatically signs the request.
        EthereumPersonalSignRpcResponseData response = privyClient
            .wallets()
            .ethereum()
            .signMessage(
                walletId,
                message.getBytes(StandardCharsets.UTF_8),
                authorizationContext
            );

        String signature = response.signature();
    } catch (APIException e) {
        String errorBody = e.bodyAsString();
        System.err.println(errorBody);
    } catch (Exception e) {
        System.err.println(e.getMessage());
    }
    ```
  </Tab>

  <Tab title="REST API">
    <Info>
      Directly managing user authorization keys via the REST API is an advanced integration. If you are
      using a Privy SDK, you do not need to directly manage the user's authorization key or manually
      generate authorization signatures.
    </Info>

    <Tip>
      For security, Privy encrypts user authorization keys under a public key you provide to ensure that only your app can decrypt them. If you are just getting started with your integration, you can test the flow without encryption by following the **Without encryption** sections of the guide below.

      In production environments, we strongly recommend requesting user authorization keys **with encryption** as a security best practice.
    </Tip>

    #### 1. Generate an ECH P-256 keypair

    <Tabs>
      <Tab title="With encryption">
        To begin, create an [ECH P-256](https://csrc.nist.gov/csrc/media/events/workshop-on-elliptic-curve-cryptography-standards/documents/papers/session6-adalier-mehmet.pdf) public-private keypair to encrypt and decrypt your user's authorization key. Privy will encrypt the authorization under the public key for your keypair, and your server can decrypt the authorization key using the keypair's corresponding private key.

        When interacting with the Privy API, your ECH P-256 public-private keypair must be in the [SPKI](https://en.wikipedia.org/wiki/Simple_public-key_infrastructure) format.

        As an example, you can create an ECH P-256 keypair like so.

        <Accordion title="Show code examples of creating ECH P-256 keypairs">
          <Tabs>
            <Tab title="TypeScript">
              ```typescript  theme={"system"}
              import * as crypto from 'crypto';

              async function generateEcdhP256KeyPair(): Promise<{
                privateKey: CryptoKey;
                recipientPublicKey: string;
              }> {
                // Generate a P-256 key pair
                const keyPair = await crypto.subtle.generateKey(
                  {
                    name: 'ECDH',
                    namedCurve: 'P-256'
                  },
                  true,
                  ['deriveBits']
                );

                // The privateKey will be used later to decrypt the encapsulatedKey data returned from the /v1/user_signers/authenticate endpoint.
                const privateKey = keyPair.privateKey;

                // The publicKey will be used to encrypt the session key and will be sent to the /v1/user_signers/authenticate endpoint.
                // The publicKey must be a base64-encoded, SPKI-format string
                const publicKeyInSpkiFormat = await crypto.subtle.exportKey('spki', keyPair.publicKey);
                const recipientPublicKey = Buffer.from(publicKeyInSpkiFormat).toString('base64');

                return {privateKey, recipientPublicKey};
              }
              ```
            </Tab>

            <Tab title="Python">
              ```python  theme={"system"}
              import base64
              from cryptography.hazmat.primitives import serialization
              from cryptography.hazmat.primitives.asymmetric import ec
              from typing import Tuple

              def generate_ecdh_p256_key_pair() -> Tuple[ec.EllipticCurvePrivateKey, str]:
                  # Generate a P-256 key pair
                  private_key = ec.generate_private_key(ec.SECP256R1())
                  public_key = private_key.public_key()

                  # Export the public key in SPKI format
                  public_key_spki = public_key.public_key_bytes(
                      encoding=serialization.Encoding.DER,
                      format=serialization.PublicFormat.SubjectPublicKeyInfo
                  )

                  # Convert to base64 string
                  recipient_public_key = base64.b64encode(public_key_spki).decode('utf-8')

                  return private_key, recipient_public_key
              ```
            </Tab>
          </Tabs>
        </Accordion>
      </Tab>

      <Tab title="Without encryption">
        If you are requesting user authorization keys without encryption, you can skip this step.
      </Tab>
    </Tabs>

    #### 2. Request a user's authorization key

    <Tip>
      If you are just getting started with your integration and skipped step 1, you should omit the
      `encryption_type` and `recipient_public_key` parameters of the request body blank.
    </Tip>

    Next, use the user's access token to request a user authorization key for the user. If you generated a P256 keypair in step 1, you will also use the public key you generated to request the user authorization key.

    Make a request to:

    ```sh  theme={"system"}
    https://api.privy.io/v1/wallets/authenticate
    ```

    In the request body, pass the following parameters.

    <Accordion title="Show request body">
      <Tabs>
        <Tab title="With encryption">
          <ParamField path="user_jwt" type="string" required>
            The user's JWT, to be used to authenticate the user.

            If your app is using your own authentication provider, the user's JWT should verify against the JWKS.json endpoint you registered in the Dashboard.

            If your app is using Privy as your authentication provider, the user's JWT should be the access token issued by Privy.
          </ParamField>

          <ParamField path="encryption_type" type="'HPKE" required>
            The encryption type for the authentication response. Currently only supports HPKE. Omit this field
            if you are requesting the authorization key unencrypted.
          </ParamField>

          <ParamField path="recipient_public_key" type="string" required>
            The public key of your ECDH keypair, in base64-encoded, SPKI-format, whose private key will be
            able to decrypt the session key. This keypair must be generated securely and the private key must
            be kept confidential. The public key sent should be in base64-encoded DER format.
          </ParamField>
        </Tab>

        <Tab title="Without encryption">
          <ParamField path="user_jwt" type="string" required>
            The user's JWT, to be used to authenticate the user.

            If your app is using your own authentication provider, the user's JWT should verify against the JWKS.json endpoint you registered in the Dashboard.

            If your app is using Privy as your authentication provider, the user's JWT should be the access token issued by Privy.
          </ParamField>
        </Tab>
      </Tabs>
    </Accordion>

    In the response, Privy will return the following. Make sure to save the `encrypted_authorization_key.encapsulated_key` and `encrypted._authorization_key.ciphertext` fields to use later.

    <Accordion title="Show response body">
      <Tabs>
        <Tab title="With encryption">
          <ResponseField name="encrypted_authorization_key" type="object">
            The encrypted authorization key, once decrypted, can be used to sign transactions on the wallet, acting as a temporary AuthorizationPrivateKey.
            Once decrypted, you will need to generate an [authorization signature](/api-reference/authorization-signatures) and pass it as a header under `privy-authorization-signature`.

            <Expandable defaultOpen="true">
              <ResponseField name="encryption_type" type="'HPKE'">
                The encryption type used. Currently only supports HPKE.
              </ResponseField>

              <ResponseField name="encapsulated_key" type="string">
                Base64-encoded ephemeral public key used in the HPKE encryption process. Required for decryption.
              </ResponseField>

              <ResponseField name="ciphertext" type="string">
                The encrypted authorization key corresponding to the user's current authentication session.
              </ResponseField>
            </Expandable>
          </ResponseField>

          <ResponseField name="expires_at" type="number">
            The expiration time of the authorization key in seconds since the epoch.
          </ResponseField>

          <ResponseField name="wallets" type="object[]">
            The wallets that the signer has access to.
          </ResponseField>
        </Tab>

        <Tab title="Without encryption">
          <ResponseField name="authorization_key" type="string">
            The raw authorization key. Using this key, you will need to generate an [authorization signature](/api-reference/authorization-signatures) and pass it as a header under `privy-authorization-signature`.
          </ResponseField>

          <ResponseField name="expires_at" type="number">
            The expiration time of the authorization key in seconds since the epoch.
          </ResponseField>

          <ResponseField name="wallets" type="object[]">
            The wallets that the signer has access to.
          </ResponseField>
        </Tab>
      </Tabs>
    </Accordion>

    See an example request and successful response below.

    <Accordion title="Show example request and response">
      <Tabs>
        <Tab title="With encryption">
          An example request for an authorization key with encryption might look like the following:

          ```sh  theme={"system"}
          curl -X POST "https://api.privy.io/v1/wallets/authenticate" \
            -H "Authorization: Basic <insert-basic-auth-header>" \
            -H "Content-Type: application/json" \
            -H "privy-app-id: <insert-your-app-id>" \
            -d '{
              "user_jwt": <insert-user-jwt>,
              "encryption_type": "HPKE",
              "recipient_public_key": <insert-your-p256-public-key>
            }'
          ```

          A successful sample response will look like the following:

          ```json  theme={"system"}
          {
            "encrypted_authorization_key": {
              "encryption_type": "HPKE",
              "encapsulated_key": "<encapsulated-key>",
              "ciphertext": "<ciphertext>"
            },
            "expires_at": 1715270400,
            "wallets": [
              {
                "id": "<wallet-id>",
                "chain_type": "ethereum",
                "address": "<wallet-address>"
              }
            ]
          }
          ```
        </Tab>

        <Tab title="Without encryption">
          An example request for an authorization key without encryption might look like the following:

          ```sh  theme={"system"}
          curl -X POST "https://api.privy.io/v1/wallets/authenticate" \
            -H "Authorization: Basic <insert-basic-auth-header>" \
            -H "Content-Type: application/json" \
            -H "privy-app-id: <insert-your-app-id>" \
            -d '{
              "user_jwt": <insert-user-jwt>
            }'
          ```

          A successful sample response will look like the following:

          ```json  theme={"system"}
          {
            "authorization_key": "<authorization-key>",
            "expires_at": 1715270400,
            "wallets": [
              {
                "id": "<wallet-id>",
                "chain_type": "ethereum",
                "address": "<wallet-address>"
              }
            ]
          }
          ```
        </Tab>
      </Tabs>
    </Accordion>

    ### 3. Decrypt the authorization key

    <Tabs>
      <Tab title="With encryption">
        Finally, decrypt the authorization key using the returned `encrypted_authorization_key.encapsulated_key` and `encrypted_authorization_key.ciphertext` fields, as well as the private key you generated in step 1.

        <Accordion title="Show code examples for decrypting the authorization key">
          <Tabs>
            <Tab title="TypeScript">
              ```ts  theme={"system"}
              import {Chacha20Poly1305} from '@hpke/chacha20poly1305';
              import {CipherSuite, DhkemP256HkdfSha256, HkdfSha256} from '@hpke/core';

              // Initialize the cipher suite
              const suite = new CipherSuite({
                  kem: new DhkemP256HkdfSha256(),
                  kdf: new HkdfSha256(),
                  aead: new Chacha20Poly1305(),
              });

              // Convert base64 to ArrayBuffer using browser APIs
              const base64ToBuffer = (base64: string) => Uint8Array.from(atob(base64), (c) => c.charCodeAt(0)).buffer;

              // Import private key using WebCrypto
              const privateKey = await crypto.subtle.importKey(
                  'pkcs8',
                  base64ToBuffer('insert-base64-encoded-private-key'),
                  {
                  name: 'ECDH',
                  namedCurve: 'P-256',
                  },
                  true,
                  ['deriveKey', 'deriveBits'],
              );

              // Create recipient context and decrypt
              const recipient = await suite.createRecipientContext({
                  recipientKey: privateKey,
                  enc: base64ToBuffer('insert-encapsulated-key-from-api-response'),
              });

              return new TextDecoder().decode(await recipient.open(base64ToBuffer('insert-ciphertext-from-api-response')));
              ```
            </Tab>

            <Tab title="Python">
              ```python  theme={"system"}
              import base64
              from pyhpke import CipherSuite, KEM, KDF, AEAD
              from cryptography.hazmat.primitives import serialization

              def decrypt_hpke_message() -> str:
                  # Initialize the cipher suite with P-256, HKDF-SHA256, and ChaCha20Poly1305
                  suite = CipherSuite.new(
                      kem=KEM.DHKEM_P256_HKDF_SHA256,
                      kdf=KDF.HKDF_SHA256,
                      aead=AEAD.CHACHA20_POLY1305
                  )

                  # Decode base64 inputs
                  private_key_bytes = base64.b64decode('insert-your-base64-encoded-private-key')
                  encapsulated_key = base64.b64decode('insert-encapsulated-key-from-api-response')
                  ciphertext = base64.b64decode('insert-ciphertext-from-api-response')

                  # Load the private key from PKCS#8 format
                  private_key = serialization.load_der_private_key(private_key_bytes, password=None)

                  # Create recipient context and decrypt
                  recipient = suite.create_recipient_context(
                      enc=encapsulated_key,
                      recipient_key=private_key
                  )

                  # Decrypt and return as string
                  plaintext = recipient.open(ciphertext)
                  return plaintext.decode('utf-8')
              ```
            </Tab>
          </Tabs>
        </Accordion>
      </Tab>

      <Tab title="Without encryption">
        If you did not provide a public key with which Privy encrypted the authorization key, you can skip this step. You can simply used the returned user `authorization_key` to sign requests.
      </Tab>
    </Tabs>

    ### 4. Sign requests with the authorization key

    Now that you have successfully retrieved the authorization key for your user, continue to [this guide](/controls/authorization-keys/using-owners/sign) to learn how to sign requests to the Privy API.
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/controls/authorization-keys/owners/configuration/overview



At a high-level, you should determine the minimal permissions your users, your app, and any third parties require for your wallets. Then, **configure each wallet with appropriate owners and additional signers to reflect your desired permissions**.

## Permissions

Owners and signers differ in the permissions over wallets as outlined below.

|                                 | Owners | Signers |
| ------------------------------- | ------ | ------- |
| Sign messages                   | ✅      | ✅       |
| Send transactions               | ✅      | ✅       |
| Update policies                 | ✅      | ❌       |
| Update owners                   | ✅      | ❌       |
| Update signers                  | ✅      | ❌       |
| Export wallet                   | ✅      | ❌       |
| Can be configured with policies | ✅      | ✅       |

View common use cases around configuring owners and signers for wallets in the following guides.

<CardGroup cols={2}>
  <Card title="Self-custodial user wallets" icon="user" href="/controls/authorization-keys/owners/configuration/user">
    Create self-custodial user wallets and enable offline actions, server-side transactions, and
    more.
  </Card>

  <Card title="Programmable controls" icon="server" href="/controls/authorization-keys/owners/configuration/programmable">
    Create wallets with custom approval configurations and give scoped controls to third-parties.
  </Card>
</CardGroup>


# Programmable controls
Source: https://docs.privy.io/controls/authorization-keys/owners/configuration/programmable



Privy supports creating **wallets** that can be associated with your app, a third-party, or your own notion of a user. Common configurations of wallets are listed below.

### Single party can unilaterally approve actions

If you'd like a single party to be able to unilaterally approve all actions, such as updating a wallet's owner or executing transactions with the wallet, simply **create the wallet with an authorization key controlled by the party as the owner**.

The party can use this authorization key to update the wallet it controls and execute actions with it.

### Multiple parties can unilaterally approve actions

If you'd like one of many parties to be able to unilaterally approve actions, such as updating a wallet's owner or policies, or executing transactions with the wallet, simply **create the wallet with a *1-of-k* key quorum**, whose elements are authorization keys associated with your different parties.

Each party can use its associated authorization key to unilaterally update the wallet and execute actions with it.

### Multiple parties must collectively approve actions

If you'd like authorization from multiple parties to update or take actions with a wallet, **create the wallet with an *m-of-k* key quorum**, where:

* the key quorum is composed of authorization keys, associated with each party that can approve actions
* *m* is defined such that your desired threshold of parties must approve the action

Then, *m* of the *k* parties can use their associated authorization keys to sign requests to update the wallet and execute actions with it. Privy will only execute requests if *m* valid signatures are provided in the request.

### Scoping wallet policies to specific parties

If you'd like multiple parties to be subject to different policies when taking action with a wallet, create the wallet with an "administrator" party as the owner and an additional signers array consisting of each of the parties. For each entry in the additional signer array,

* Set the signer to the party that the policies should be subject to.
* Set the signer's override policies to the policies that should apply to the signer.

Each signer is then subject to the policies associated with them in the additional signers field of the wallet.

### Giving permissions to third parties

If you'd like to give certain signature and transaction permissions to a third-party, create the wallet with:

* an authorization key associated with the primary party as the **owner**
* authorization keys associated with each of the third parties as additional **signers** with any necessary policies

This ensures that the primary party is the only entity that can update the wallet, execute all actions with it, and export private keys, while third-parties can execute actions with the wallet within the scope of their associated policy.


# Requiring user and server approvals
Source: https://docs.privy.io/controls/authorization-keys/owners/configuration/user/dual-approval



Many apps require *both* users and servers to approve transactions, which can be used to enhance the security of your application. For example, if a user's account is compromised, attackers cannot unilaterally take actions with the user's wallets without the server's approval.

To enable a configuration where both users and servers must approve transactions, Privy recommends the following:

<Steps>
  <Step title="Create a wallet owned by an m-of-k key quorum">
    Create a wallet owned by an *m-of-k* key quorum (m ≥ 2) whose elements include at least a
    **user** and an **authorization key** controlled by your server. You can do this via Privy's
    [REST API](/wallets/wallets/create/create-a-wallet).
  </Step>

  <Step title="Have users and server(s) both sign transaction requests">
    Next, construct your transaction request and have
    [users](/controls/authorization-keys/owners/configuration/user#sending-transactions-from-your-server)
    *and* [servers](/controls/authorization-keys/using-owners/sign) sign the transaction request.
  </Step>

  <Step title="Execute your transaction request with the user and server signatures">
    Finally, [execute the transaction request](/wallets/using-wallets/ethereum/send-a-transaction)
    with both signatures.
  </Step>
</Steps>


# Enabling offline actions
Source: https://docs.privy.io/controls/authorization-keys/owners/configuration/user/offline



Many apps require taking specified actions with a user's wallets, even when the user is offline. This includes use cases like **limit orders, agentic trading on behalf of users (e.g. with a Telegram bot), or portfolio rebalancing.**

For offline actions, Privy generally recommends:

<Steps>
  <Step title="Create a wallet with a user owner">
    To ensure the wallet can only be updated by the user, create the wallet with a user owner. If
    you use one of Privy's client-side SDKs to create wallets, wallets are created with a user owner
    by default.
  </Step>

  <Step title="Add an authorization key as an additional signer">
    Next, add an authorization key controlled by your server as an additional signer on the wallet.
    You can also configure the additional signer to have a specific set of policies associated with
    it, restricting the actions it can take. You can do this via one of Privy's [client-side
    SDKs](/wallets/using-wallets/session-signers/overview) or [REST
    API](/wallets/wallets/create/create-a-wallet)
  </Step>

  <Step title="Execute scoped transactions with your additional signer">
    Your additional signer can now execute actions, such as signing messages or sending
    transactions, subject to its policies. These actions can occur while the user is offline.
  </Step>
</Steps>


# Overview
Source: https://docs.privy.io/controls/authorization-keys/owners/configuration/user/overview



Common flows to create self-custodial user wallets include:

* **Creating wallets with a user owner.** This configures wallets such that users are the only entity that can update policies, add additional signers, export the wallet, or change the wallet's owner. If you create wallets via one of Privy's client-side SDKs, your app's wallets are automatically created with user owners.
* **Creating wallets with a *1-of-n* key quorum, where one member of the key quorum is the user**. This gives users full permissions over their wallet, while enabling other parties to easily update wallets (e.g. policies and signers) and take actions with them.

You can extend self-custodial user wallets to support various use cases, as outlined below.

<CardGroup cols={3}>
  <Card title="Offline actions" icon="signal" href="/controls/authorization-keys/owners/configuration/user/offline">
    Take actions with wallets while users are offline, such as limit orders, agentic trading, and
    portfolio rebalancing.
  </Card>

  <Card title="Multi-party approvals" icon="lock" href="/controls/authorization-keys/owners/configuration/user/dual-approval">
    Require that both users and servers sign transaction requests.
  </Card>

  <Card title="Send transactions from your server" icon="money-bill-1" href="/controls/authorization-keys/owners/configuration/user/server-transactions">
    Send transactions from your server for increased control over transaction flows.
  </Card>

  <Card title="Update wallets from your server" icon="wallet" href="/controls/authorization-keys/owners/configuration/user/server-updates">
    Update the policies and signers assigned to wallets from your server, even when users are
    offline.
  </Card>

  <Card title="Export wallets from your server" icon="key" href="/controls/authorization-keys/owners/configuration/user/server-export">
    Export wallets from your server to enable users to recover their account outside of your core
    application.
  </Card>
</CardGroup>


# Exporting wallets from your server
Source: https://docs.privy.io/controls/authorization-keys/owners/configuration/user/server-export



Many apps want the server to to have the ability to export the private key for a user's wallet. This can be used to self-host a recovery site where users can export their private key outside of your core application.

To enable this, Privy generally recommends:

<Steps>
  <Step title="Create a wallet with a 1-of-k key quorum">
    Create your wallet with a *1-of-k* key quorum, whose members include at least a **user** and an
    **authorization key** controlled by your server. You can do this via Privy's [REST
    API](/wallets/wallets/create/create-a-wallet).
  </Step>

  <Step title="Export the wallet from your server">
    As a satisfying member of the key quorum that owns the wallet, **your server's authorization key
    can unilaterally export the wallet**. Follow [this guide](/wallets/wallets/export) to export the
    private key for your user's wallet from the server.
  </Step>
</Steps>


# Sending transactions from your server
Source: https://docs.privy.io/controls/authorization-keys/owners/configuration/user/server-transactions



Many apps would like users to explicitly authorize transactions, but to send transaction requests from their server for increased reliability, retries, and various other use cases.

To send transactions from your server by default:

<Tabs>
  <Tab title="Using Privy as your authentication provider">
    <Steps>
      <Step title="Create wallets with a user owner">
        To ensure the wallet can only be controlled by the user, create the wallet with a user
        owner. If you use one of Privy's client-side SDKs to create wallets, wallets are created
        with a user owner by default.
      </Step>

      <Step title="Request a signature over your transaction request">
        [Construct your transaction request](/controls/authorization-keys/using-owners/sign) and use
        Privy's [client-side SDKs'
        methods](/controls/authorization-keys/using-owners/sign#react%2C-expo) to have the user sign
        the transaction request.
      </Step>

      <Step title="Execute the transaction request from your server">
        Send your user's authorization signature from your client to your server, and [send your
        transaction request](/controls/authorization-keys/using-owners/action) with the user's
        signature to Privy's API.
      </Step>
    </Steps>
  </Tab>

  <Tab title="Using your own authentication provider">
    <Steps>
      <Step title="Create wallets with a user owner">
        To ensure the wallet can only be controlled by the user, create the wallet with a user
        owner. If you use one of Privy's client-side SDKs to create wallets, wallets are created
        with a user owner by default.
      </Step>

      <Step title="Request a user key">
        Next, given a user's access token from your authentication provider, [request a user
        key](/controls/authorization-keys/keys/create/user/request) from Privy's API. You will use
        this key to sign transaction requests to Privy's aPI.
      </Step>

      <Step title="Sign the request with your user key">
        Next, [construct your transaction request](/controls/authorization-keys/using-owners/sign)
        and [sign the transaction request](/controls/authorization-keys/using-owners/sign) with the
        user key
      </Step>

      <Step title="Execute the transaction request from your server">
        Send your user's authorization signature from your client to your server, and [send your
        transaction request](/controls/authorization-keys/using-owners/action) with the user's
        signature to Privy's API.
      </Step>
    </Steps>
  </Tab>
</Tabs>


# Updating wallets from your server
Source: https://docs.privy.io/controls/authorization-keys/owners/configuration/user/server-updates



Many apps want the server to be able to update a wallet. For example, an app might want to update the policies or signers on a wallet, even with the user offline.

For server-side wallet updates, Privy generally recommends:

<Steps>
  <Step title="Create a wallet with a 1-of-k key quorum">
    Create your wallet with a *1-of-k* key quorum, whose members include at least a **user** and an
    **authorization key** controlled by your server. You can do this via Privy's [REST
    API](/wallets/wallets/create/create-a-wallet).
  </Step>

  <Step title="Update the wallet with your authorization key">
    As a satisfying member of the key quorum that owns the wallet, **your server's authorization key
    can unilaterally update the policies and additional signers assigned to the wallet**. This
    enables your app to update wallet configurations, even when users are offline.
  </Step>
</Steps>


# Overview
Source: https://docs.privy.io/controls/authorization-keys/owners/overview



Privy resources, such as wallets and policies, are controlled or managed by a [**user**](/controls/authorization-keys/owners/types#users), an [**authorization key**](/controls/authorization-keys/owners/types#authorization-key), or a [**key quorum**](/controls/authorization-keys/owners/types#key-quorum). These are known as **owners** and **signers**.

At a high-level, **owners** control wallets and the policies applied to them, while **additional signers** can take actions with a wallet within the scope of certain policies applied to them.

Privy also enables custom configurations of owners and signers, so that you can configure different parties to have different permissions over resources. You can additionally update these configurations over time, given authorization from an existing owner, allowing you to update controls over resources as needed.

Learn more about the differences betweens [**owners**](/controls/authorization-keys/owners/overview#owners) and [**signers**](/controls/authorization-keys/owners/overview#signers) and the [**three types**](/controls/authorization-keys/owners/overview#types) of owners and signers.

## Owners

Generally, owners have full control over a resource in the Privy API. Once assigned to a resource, owners have the ability to **update that resource**. Owners can also **update the owner** for a resource they control, enabling transfer of control over resources.

With wallets, owners have the ability to:

* sign and transact with the wallet (within the scope of the wallet's policies)

* update the policies assigned to a wallet

* update the additional signers assigned to the wallet, and the policies assigned to each signer

* update the owner of the wallet

* export the wallet's private key

* delete the wallet

With policies, owners have the ability to:

* update the rules of the policy
* update the owner of the policy
* delete the policy

## Signers

**Signers**, or **additional signers**, are parties that are given scoped permissions to take actions with a wallet. Signers on a wallet enable use cases like:

* Scoping the permissions for a wallet by a signing authorization key, user, or key quorum
* Taking offline actions on behalf of a user, such as limit orders, agentic trading, and portfolio rebalancing
* Giving scoped permissions to a third-party to take actions on behalf of a wallet

A wallet's owner can add or remove signers on the wallet, and assign policies to each signer to restrict the actions they can take. Signers **cannot update a wallet's owner, signers, or policies** and **cannot export the wallet's private key**. They can only take actions (signatures tand transactions) with the wallet subject to their policies.

## Types

Learn more about three types of owners and signers: [**users**](/controls/authorization-keys/owners/types#users), [**authorization keys**](/controls/authorization-keys/owners/types#authorization-key), and [**key quorums**](/controls/authorization-keys/owners/types#key-quorum).

## Permissions

Owners and signers have different permissions over wallets, as outlined below.

|                                 | Owners | Signers |
| ------------------------------- | ------ | ------- |
| Sign messages                   | ✅      | ✅       |
| Send transactions               | ✅      | ✅       |
| Update policies                 | ✅      | ❌       |
| Update owners                   | ✅      | ❌       |
| Update signers                  | ✅      | ❌       |
| Export wallet                   | ✅      | ❌       |
| Can be configured with policies | ✅      | ✅       |


# Types of owners & signers
Source: https://docs.privy.io/controls/authorization-keys/owners/types



There are three types of owners & signers: [**users**](/controls/authorization-keys/owners/types#users), [**authorization keys**](/controls/authorization-keys/owners/types#authorization-key), and [**key quorums**](/controls/authorization-keys/owners/types#key-quorum)

### Users

**Users** of your application can own and take actions with wallets and are represented by the Privy user ID. Users can be assigned to resources or can take actions with wallets by including their user ID in the API request.

<Tip>
  You can create user self-custodial wallets by setting a user as the owner of the wallet, whether
  you use your own existing authentication provider or Privy as your authentication provider.
</Tip>

### Authorization keys

**Authorization keys** are P256 cryptographic keys that allow any party that controls the key to take actions with associated wallets. You can assign authorization keys to a resource or execute actions with authorization keys by signing the request with the respective private key.

Common examples of authorization keys include:

* app keys, which are controlled by your app's server, allowing your app to execute requests
* a biometric key or passkey, following the [WebAuthn](https://webauthn.io/) standard, which allow users to easily sign and execute requests with a P256 key

### Key quorums

Owners and signers can also be composed of a mix of users and authorization keys. This is known as a **key quorum**.

Key quorums have an authorization threshold that defines how members of the quorum must sign a request for the aggregated signature to be valid. You can use key quorums to implement use cases such as:

* Allowing users *or* apps to sign requests from user wallets
* Requiring both users *and* apps to sign requests from user wallets
* Requiring a distributed set of authorization keys to sign requests from a wallet

<Tip>
  Key quorums are an advanced integration. To determine if key quorums are right for your use case,
  please [reach out](https://privy.io/slack).
</Tip>


# Owning resources with owners
Source: https://docs.privy.io/controls/authorization-keys/using-owners/assign



To have an owner own a resource, you can pass an identifier for the owner in the `owner` field of the request to create or update a resource.

<Tabs>
  <Tab title="Users">
    To assign a user as the owner of a resource, in the request to create or update the resource, pass `{user_id: 'insert-user-id-of-owner'}` object in the `owner` field of your request.

    Refer to the following guides for:

    * [Creating a wallet with a user owner](/wallets/wallets/create/create-a-wallet#rest-api)
    * [Updating a wallet to have a user owner](/wallets/wallets/update-a-wallet#rest-api)
  </Tab>

  <Tab title="Authorization key">
    To assign an authorization key as the owner of a resource, in the request to create or update the resource, pass a `{public_key: 'insert-public-key'}` object in the `owner` field of your request.

    Refer to the following guides for:

    * [Creating a wallet with a authorization key owner](/wallets/wallets/create/create-a-wallet#rest-api)
    * [Updating a wallet to have an authorization key owner](/wallets/wallets/update-a-wallet#rest-api)
    * [Creating a policy with an authorization key owner](/controls/policies/create-a-policy#rest-api)
    * [Updating a policy to have an authorization key owner](/controls/policies/update-a-policy#rest-api)
  </Tab>

  <Tab title="Key quorums">
    To assign a key quorum as the owner a resource, in the request to create or update the resource, pass your key quorum ID in the `owner_id` field of your request.

    Refer to the following guides for:

    * [Creating a wallet with a key quorum owner](/wallets/wallets/create/create-a-wallet#rest-api)
    * [Updating a wallet to have a key quorum owner](/wallets/wallets/update-a-wallet#rest-api)
    * [Creating a policy with a key quorum owner](/controls/policies/create-a-policy#rest-api)
    * [Updating a policy to have a key quorum owner](/controls/policies/update-a-policy#rest-api)
  </Tab>
</Tabs>


# Using owners
Source: https://docs.privy.io/controls/authorization-keys/using-owners/overview



Owners control resources in the Privy API, allowing them to modify or take actions with resources, such as updating a policy or sending a transaction with a wallet. Signers have the ability to send transactions from a given wallet within the scope of certain policies.

Learn more about using owners and signers below.

### Owners

To assign an owner to a resource, pass the owner's identifier (authorization key, user ID, or key quorum ID) in the `owner` field of the resource. If the resource is a wallet, set the wallet's `policy_ids` to set the policy that the `owner` should be subject to.

Once an owner is set on a resource:

* The owner must sign all updates or deletions of the resource.
* If the resource is a wallet, the owner must sign signature or transaction requests to the Privy API and is subject to the policies set on the wallet.

### Signers

Signers enable setting different permissions that different parties can take with a given wallet. To attach a signer to a resource, add a new entry in the `additional_signers` array with the key quorum ID of your signer. You can then set `override_policy_ids` that apply to this specific signer. This enables you to set specific policies for certain key quorums over the same wallet.


# Implementing signing directly
Source: https://docs.privy.io/controls/authorization-keys/using-owners/sign/direct-implementation



If you are unable to use Privy's SDKs for signing, you can implement request signing directly in your service.

<Warning>
  Implementing request signing directly is an advanced integration. Wherever possible, we suggest
  [using Privy's SDKs to handle request
  signing.](/controls/authorization-keys/using-owners/sign/signing-on-the-server)
</Warning>

## Steps

At a high-level, directly implementing request signing requires the following steps:

<Steps>
  <Step title="Build signature payload">
    Generate a JSON payload containing the following fields. All fields are required unless otherwise specified.

    | Field                              | Type                                                                                                                                                                                                                                                  | Description                                                                                                                                                                                                       |   |   |   |
    | ---------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | - | - | - |
    | `version`                          | `1`                                                                                                                                                                                                                                                   | Authorization signature version. Currently, `1` is the only version.                                                                                                                                              |   |   |   |
    | `method`                           | `'POST'  \| 'PUT'                                                                                                                                                                                                             \| 'PATCH' \| 'DELETE'` | HTTP method for the request. Signatures are not required on `'GET'` requests.                                                                                                                                     |   |   |   |
    | `url`                              | `string`                                                                                                                                                                                                                                              | The full URL for the request. Should not include a trailing slash.                                                                                                                                                |   |   |   |
    | `body`                             | `JSON`                                                                                                                                                                                                                                                | JSON body for the request.                                                                                                                                                                                        |   |   |   |
    | `headers`                          | `JSON`                                                                                                                                                                                                                                                | JSON object containing any Privy-specific headers, e.g. those that are prefixed with `'privy-'`. This should **not** include any other headers, such as authentication headers, `content-type`, or trace headers. |   |   |   |
    | `headers['privy-app-id']`          | `string`                                                                                                                                                                                                                                              | Privy app ID header (required).                                                                                                                                                                                   |   |   |   |
    | `headers['privy-idempotency-key']` | `string`                                                                                                                                                                                                                                              | Privy idempotency key header (optional). If the request does not contain an idempotency key, leave this field out of the payload.                                                                                 |   |   |   |
  </Step>

  <Step title="Canonicalize signature payload">
    Next, canonicalize the payload per [RFC 8785](https://www.rfc-editor.org/rfc/rfc8785) and serialize it to a string. [This GitHub repository](https://github.com/cyberphone/json-canonicalization) links to various libraries for JSON canonicalization in different languages.
  </Step>

  <Step title="Sign signature payload">
    Sign the serialized JSON with ECDSA P-256 using the private key of your user key or authorization key and serialize it to a base64-encoded string.
  </Step>

  <Step title="Include the signature in request headers">
    Lastly, include the base64-encoded signature over the payload in the `privy-authorization-signature` header of your request to the Privy API.
  </Step>
</Steps>

## Code examples

View code examples for signing requests in various languages below.

<Tip>
  If the desired resource requires a user owner or user signer, make sure to [request the user
  key](/controls/authorization-keys/keys/create/user/request) before signing requests with it.
</Tip>

<Tabs>
  <Tab title="Vanilla TypeScript">
    ```typescript  theme={"system"}
    import canonicalize from 'canonicalize'; // Support JSON canonicalization
    import crypto from 'crypto'; // Support P-256 signing

    // Replace this with your private key from the Dashboard
    const PRIVY_AUTHORIZATION_KEY = 'wallet-auth:insert-your-private-key-here';
    // ...

    function getAuthorizationSignature({url, body}: {url: string; body: object}) {
      const payload = {
        version: 1,
        method: 'POST',
        url,
        body,
        headers: {
        'privy-app-id': 'insert-your-app-id'
        // If your request includes an idempotency key, include that header here as well
        }
      };

      // JSON-canonicalize the payload and convert it to a buffer
      const serializedPayload = canonicalize(payload) as string;
      const serializedPayloadBuffer = Buffer.from(serializedPayload);

      // Replace this with your user or authorization key. We remove the 'wallet-auth:' prefix
      // from authorization keys before using it to sign requests
      const privateKeyAsString = PRIVY_AUTHORIZATION_KEY.replace('wallet-auth:', '');

      // Convert your private key to PEM format, and instantiate a node crypto KeyObject for it
      const privateKeyAsPem = `-----BEGIN PRIVATE KEY-----\n${privateKeyAsString}\n-----END PRIVATE KEY-----`;
      const privateKey = crypto.createPrivateKey({
        key: privateKeyAsPem,
        format: 'pem'
      });

      // Sign the payload buffer with your private key and serialize the signature to a base64 string
      const signatureBuffer = crypto.sign('sha256', serializedPayloadBuffer, privateKey);
      const signature = signatureBuffer.toString('base64');
      return signature;
    }

    const authorizationSignature = getAuthorizationSignature({
      // Replace with your desired path
      url: 'https://api.privy.io/v1/wallets/<wallet_id>/rpc',
      // Replace with your desired body
      body: {
        method: 'personal_sign',
        params: {
        message: 'Hello world',
          // ...
        },
      }
    });
    ```
  </Tab>

  <Tab title="Python">
    ```python  theme={"system"}
    import json
    import base64
    from cryptography.hazmat.primitives import hashes, serialization
    from cryptography.hazmat.primitives.asymmetric import ec, utils

    # Replace this with your private key from the Dashboard

    PRIVY_AUTHORIZATION_KEY = "wallet-auth:your-authorization-private-key"

    def canonicalize(obj):
      """
      Simple JSON canonicalization function.
      Sorts dictionary keys and ensures consistent formatting.
      """
      return json.dumps(obj, sort_keys=True, separators=(",", ":"))

    def get_authorization_signature(url, body):
      """
      Generate authorization signature for Privy API requests using ECDSA and hashlib.
      """
      # Construct the payload
      payload = {
        "version": 1,
        "method": "POST",
        "url": url,
        "body": body,
        "headers": {"privy-app-id": "insert-your-app-id"},
      }

      # Serialize the payload to JSON
      serialized_payload = canonicalize(payload)

      # Create ECDSA P-256 signing key from private key
      private_key_string = PRIVY_AUTHORIZATION_KEY.replace("wallet-auth:", "")
      private_key_pem = (
        f"-----BEGIN PRIVATE KEY-----\n{private_key_string}\n-----END PRIVATE KEY-----"
      )

      # Load the private key from PEM format
      private_key = serialization.load_pem_private_key(
        private_key_pem.encode("utf-8"), password=None
      )

      # Sign the message using ECDSA with SHA-256
      signature = private_key.sign(
        serialized_payload.encode("utf-8"), ec.ECDSA(hashes.SHA256())
      )

      # Convert the signature to base64 for easy transmission
      return base64.b64encode(signature).decode("utf-8")

    authorization_signature = get_authorization_signature(
      url="https://api.privy.io/v1/wallets",
      body={
        "chain_type": "ethereum",
      },
    )
    ```
  </Tab>

  <Tab title="Rust">
    <CodeGroup>
      ```rust signature.rs theme={"system"}
      use anyhow::{anyhow, Result};
      use p256::ecdsa::{signature::Signer, Signature, SigningKey};
      use base64::{engine::general_purpose::STANDARD, Engine as _};
      use serde_json::json;

      /// Signs the canonicalized JSON payload using ECDSA (P-256 + SHA-256).
      ///
      /// - `private_key_string` - A string containing your user or authorization key.
      /// For authorization keys, remove the "wallet-api:" prefix.
      /// - `payload` - JSON payload to sign, serialized to a string
      ///
      fn sign_payload(private_key_string: &str, payload: &str) -> Result<String> {
        let bytes = extract_32_byte_key_from_pkcs8_base64(private_key_string)?;
        let signing_key = SigningKey::from_slice(bytes.as_slice())?;

        // Sign the payload (SHA-256 is implied by ECDSA in P256's default)
        let signature: Signature = signing_key.sign(payload.as_bytes());

        // base64 encode the signature
        let signature_b64 = STANDARD.encode(signature.to_der());

        Ok(signature_b64)
      }

      /// Extracts the raw 32-byte private key from a base64-encoded PKCS#8 blob.
      /// Returns an error if `0x04 0x20` cannot be found or if the data is too short.
      fn extract_32_byte_key_from_pkcs8_base64(pkcs8_b64: &str) -> Result<[u8; 32]> {
        // 1. Decode base64
        let pkcs8_bytes = STANDARD.decode(pkcs8_b64)?;

        // 2. Search for the 2-byte pattern [0x04, 0x20]
        let pattern = [0x04, 0x20];
        let private_key_start = pkcs8_bytes
          .windows(pattern.len())
          .position(|window| window == pattern)
          .ok_or(anyhow!(
            "Invalid wallet authorization private key: marker not found"
          ))?;

        // 3. Extract the 32 bytes following 0x04, 0x20
        let start = private_key_start + 2;
        let end = start + 32;
        if end > pkcs8_bytes.len() {
          return Err(anyhow!(
            "Invalid wallet authorization private key: data too short"
          ));
        }

        let mut private_key_bytes = [0u8; 32];
        private_key_bytes.copy_from_slice(&pkcs8_bytes[start..end]);
        Ok(private_key_bytes)
      }

      /// Main function to generate the authorization signature.
      fn main() -> Result<()> {
        let privy_authorization_key = "wallet-auth:your-authorization-private-key";

        let private_key_string = privy_authorization_key.replace("wallet-auth:", "");

        let url = "https://api.privy.io/v1/wallets";
        let body = json!({
          "chain_type": "ethereum"
        });

        // --- Build the payload to sign ---
        let mut payload = json!({
          "version": 1,
          "method": "POST",
          "url": url,
          "body": body,
          "headers": {
            "privy-app-id": "insert-your-app-id"
          }
        });

        // --- Canonicalize (sort keys, minimal separators) and serialize ---
        payload.sort_all_objects();
        let serialized_payload = serde_json::to_string(&payload)?;
        println!("{}", serialized_payload);

        // --- Sign the serialized payload using P-256 ECDSA ---
        let authorization_signature = sign_payload(&private_key_string, &serialized_payload)?;
        println!("{}", authorization_signature);

        Ok(())
      }
      ```

      ```rust Cargo.toml theme={"system"}
      [dependencies]
      serde_json = {version = "1.0", features = ["preserve_order"]}
      p256 = "0.13"
      base64 = "0.22"
      anyhow = "1.0"
      ```
    </CodeGroup>
  </Tab>

  <Tab title="Go">
    ```go  theme={"system"}
    import (
      "crypto/ecdsa"
      "crypto/elliptic"
      "crypto/rand"
      "crypto/x509"
      "encoding/base64"
      "encoding/json"
      "fmt"
      "hash/fnv"
      "strings"
      "crypto/sha256"
    )

    // SignPayload signs the canonicalized JSON payload using ECDSA (P-256 + SHA-256).
    //
    // privyAuthorizationKey - A string containing your user key or authorization key.
    // payload - JSON payload to sign, serialized to a string
    //
    // Returns the base64-encoded DER signature or an error.
    func SignPayload(privyAuthorizationKey string, payload string) (string, error) {
      privateKey, err := parsePrivateKeyFromAuthorizationKey(privyAuthorizationKey)
      if err != nil {
        return "", fmt.Errorf("failed to parse private key: %w", err)
      }

      // Hash the payload using SHA-256
      hash := sha256.Sum256([]byte(payload))

      // Sign the hash
      signature, err := ecdsa.SignASN1(rand.Reader, privateKey, hash[:])
      if err != nil {
        return "", fmt.Errorf("failed to sign payload: %w", err)
      }

      // Base64 encode the signature
      signatureB64 := base64.StdEncoding.EncodeToString(signature)
      return signatureB64, nil
    }

    // We parse the ecdsa key from the user or authorization key here
    func parsePrivateKeyFromAuthorizationKey(privyAuthorizationKey string) (*ecdsa.PrivateKey, error) {
      pkcs8B64 := strings.TrimPrefix(privyAuthorizationKey, "wallet-auth:")
      pkcs8Bytes, err := base64.StdEncoding.DecodeString(pkcs8B64)
      if err != nil {
        return nil, err
      }

      // This handles PKCS#8 parsing automatically
      key, err := x509.ParsePKCS8PrivateKey(pkcs8Bytes)
      if err != nil {
        return nil, err
      }

      // Type assert to ECDSA private key
      ecdsaKey, ok := key.(*ecdsa.PrivateKey)
      if !ok {
        return nil, fmt.Errorf("key provided is not an ECDSA private key")
      }

      return ecdsaKey, nil
    }

    // Utility function to verify the signature (for testing purposes)
    func VerifySignature(publicKey *ecdsa.PublicKey, payload, signatureB64 string) (bool, error) {
      // Decode the base64 signature
      signature, err := base64.StdEncoding.DecodeString(signatureB64)
      if err != nil {
        return false, fmt.Errorf("failed to decode signature: %w", err)
      }
      // Hash the payload
      hash := sha256.Sum256([]byte(payload))

      // Verify the signature
      valid := ecdsa.VerifyASN1(publicKey, hash[:], signature)
      return valid, nil
    }
    ```
  </Tab>
</Tabs>


# Signing requests
Source: https://docs.privy.io/controls/authorization-keys/using-owners/sign/overview



When updating resources like wallets, policies, or key quorums in the Privy API, requests must be signed by the resource owner in order to be authorized.

When signing messages or sending transactions with a wallet, requests must be signed by the wallet owner or an additional signer whose policies allow for the signature or transaction.

Learn more about the [abstractions](/controls/authorization-keys/using-owners/sign/overview#abstractions) that Privy offers to for request signing and the underlying [steps](/controls/authorization-keys/using-owners/sign/overview#steps) involved.

## Abstractions

Privy offers several level of abstractions through SDKs to simplify the implementation of request signing.

In order of highest-level to lowest-level, these abstractions are **automatic signing**, **utility functions**, and **direct implementation**.

<Tip>
  Wherever possible, we strongly recommend using a Privy SDKs' **automatic signing** functionality
  or **utility functions** to sign requests. Implementing request signing directly is an advanced
  integration.
</Tip>

### Automatic signing

With automatic signing, Privy SDKs automatically handles producing signatures when making requests to the Privy API. This means your application does not directly need to handle any signing logic.

<Note>
  Learn how to [use automatic
  signing](/controls/authorization-keys/using-owners/sign/signing-on-the-server) in your
  application.
</Note>

### Utility functions

If your application is unable to use automatic signing as part of Privy's SDKs, Privy's SDKs also offer utility functions for signature payload preparation and in-line signing.

Using utility functions over automatic signing may be preferred if your authorization keys are secured in a separate service (e.g. KMS) and signing can only be executed within that service.

<Note>
  Learn how to [use these utility
  functions](/controls/authorization-keys/using-owners/sign/utility-functions) in your application.
</Note>

Privy SDKs typically offer two utilities:

* **Formatting requests for authorization signatures.** This accepts a request you intend to make to the Privy API and constructs the required payload for signing.
* **Generating authorization signatures.** Given a formatted signature payload, this method accepts the private key for an authorization key or an authorization context generally and produces the corresponding signature over the payload.

You can combine these utility functions with your own direct implementation of signing or a call out to an external signing service (e.g. AWS KMS) to generate your authorization signature. As an example, you might:

1. Construct your request payload
2. Use the Privy SDK's formatting requests function to generate your signature payload
3. Make a call out to your external signing service to sign the payload from step (2)
4. Include the signature in a `privy-authorization-signature` header for the request.

### Direct implementation

<Note>
  Learn how to implement [direct
  signing](/controls/authorization-keys/using-owners/sign/direct-implementation) in your
  application.
</Note>

If your application cannot integrate one of Privy's SDKs, you can also directly implement request signing in your stack. This is an advanced integration; wherever possible, we recommend using Privy SDKs for request signing.

## Signature payload

When signing a request to the Privy API, the payload to sign must be a JSON object containing the following fields:

| Field                              | Type                                                                                                                                                                                                                                                  | Description                                                                                                                                                                                                       |   |   |   |
| ---------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | - | - | - |
| `version`                          | `1`                                                                                                                                                                                                                                                   | Authorization signature version. Currently, `1` is the only version.                                                                                                                                              |   |   |   |
| `method`                           | `'POST'  \| 'PUT'                                                                                                                                                                                                             \| 'PATCH' \| 'DELETE'` | HTTP method for the request. Signatures are not required on `'GET'` requests.                                                                                                                                     |   |   |   |
| `url`                              | `string`                                                                                                                                                                                                                                              | The full URL for the request. Should not include a trailing slash.                                                                                                                                                |   |   |   |
| `body`                             | `JSON`                                                                                                                                                                                                                                                | JSON body for the request.                                                                                                                                                                                        |   |   |   |
| `headers`                          | `JSON`                                                                                                                                                                                                                                                | JSON object containing any Privy-specific headers, e.g. those that are prefixed with `'privy-'`. This should **not** include any other headers, such as authentication headers, `content-type`, or trace headers. |   |   |   |
| `headers['privy-app-id']`          | `string`                                                                                                                                                                                                                                              | Privy app ID header (required).                                                                                                                                                                                   |   |   |   |
| `headers['privy-idempotency-key']` | `string`                                                                                                                                                                                                                                              | Privy idempotency key header (optional). If the request does not contain an idempotency key, leave this field out of the payload.                                                                                 |   |   |   |


# Signing on the client
Source: https://docs.privy.io/controls/authorization-keys/using-owners/sign/signing-on-the-client



Privy's client-side SDKs offer abstractions that allow you to automatically sign requests to the Privy API when invoking SDK methods. With this level of abstraction, your application does not need to handle directly signing requests or including the signature in request headers.

For user-owned wallets, Privy's client-side SDKs (React, React Native, iOS, etc.) automatically sign requests to the Privy API when invoking SDK methods.

Under the hood, Privy's SDK will fetch an ephemeral user signing key, sign the request with it, and include the signature in the request headers when you invoke an SDK method.

**When using Privy's client-side SDKs, you do not need to implement any additional logic to sign requests to the Privy API.**


# Signing on the server
Source: https://docs.privy.io/controls/authorization-keys/using-owners/sign/signing-on-the-server



Privy's server-side SDKs offer an abstraction called the [authorization context](/controls/authorization-keys/using-owners/sign/signing-on-the-server) to enable automatic request signing.

When an SDK method may require request signing (e.g. sending a transaction), your application can pass the authorization context to the SDK method with relevant inputs needed to sign the request.

Concretely, this includes:

* **Authorization private keys.** For authorization key-based signatures, the SDK will directly use these keys to compute P256 signatures over the request
* **User JWTs.** For user-based signatures, the SDK will request user signing keys given the provided JWTs and compute P256 signatures over the request.
* **Custom signing function.** If your application logic requires signing to occur in a separate service (e.g. KMS), you can pass a custom signing function that the SDK will invoke to sign requests.
* **Signatures.** If you compute signatures in your application separately from calling Privy's SDK, you can pass these signatures directly into the authorization context.

The SDK will compute all signatures given the parameters passed in the authorization context, and include all signatures in the underlying request to Privy's API.

## Using the authorization context

At a high-level, there are two steps to using the authorization context.

<Steps>
  <Step title="Build the authorization context">
    [Build the authorization
    context](/controls/authorization-keys/using-owners/sign/signing-on-the-server#1-build-the-authorization-context)
    with the private key(s), user(s), custom sign function that you'd like to sign your request.
    Include any signatures that you have already computed in the context as well.
  </Step>

  <Step title="Pass the authorization context to SDK methods">
    Once you've built the authorization context, [pass the populated context to SDK
    methods](/controls/authorization-keys/using-owners/sign/signing-on-the-server#2-pass-the-authorization-context-to-sdk-methods)
    that may require signatures, such as updating wallets or policies or sending transactions.
  </Step>
</Steps>

### 1. Build the authorization context

To build the authorization context with your signing inputs, follow the instructions below depending on your setup.

<AccordionGroup>
  <Accordion title="Signing with authorization keys">
    To sign a request with an authorization key, get the private key(s) that you saved locally when creating your signer in the Privy API or Dashboard.

    See the guide on [authorization keys](/controls/authorization-keys/keys/create/key) for more details.

    Then, add the private key(s) to the authorization context to automatically have them sign requests to the Privy API.

    <CodeGroup>
      ```java Java highlight={2} theme={"system"}
      AuthorizationContext authorizationContext = AuthorizationContext.builder()
          .addAuthorizationPrivateKey("authorization-key")
          .build();
      ```

      ```ts @privy-io/node highlight={2} theme={"system"}
      import {AuthorizationContext} from '@privy-io/node';

      const authorizationContext: AuthorizationContext = {
      authorization_private_keys: ['authorization-key']
      };
      ```

      ```rust Rust highlight={4} theme={"system"}
      use privy_rs::{AuthorizationContext, PrivateKey};

      let ctx = AuthorizationContext::new().push(
          PrivateKey("authorization-key".to_string())
      );
      ```
    </CodeGroup>
  </Accordion>

  <Accordion title="Signing with users">
    To sign requests with a user, add the user's valid JWT to the authorization context. The SDK will automatically request a signing key for the user given the JWT and sign the request with it.

    See the guide on [user owners and signers](/controls/authorization-keys/keys/create/user/request)
    for more details.

    <CodeGroup>
      ```java Java highlight={2} theme={"system"}
      AuthorizationContext authorizationContext = AuthorizationContext.builder()
          .addUserJwt("user-jwt")
          .build();
      ```

      ```ts @privy-io/node highlight={2} theme={"system"}
      import {AuthorizationContext} from '@privy-io/node';

      const authorizationContext: AuthorizationContext = {
      user_jwts: ['user-jwt']
      };
      ```

      ```rust Rust highlight={4} theme={"system"}
      use privy_rs::{AuthorizationContext, JwtUser, PrivyClient};

      let client = PrivyClient::new(app_id, app_secret)?;
      let jwt_user = JwtUser(client.clone(), "user-jwt".to_string());

      let ctx = AuthorizationContext::new().push(jwt_user);
      ```
    </CodeGroup>
  </Accordion>

  <Accordion title="Signing with a custom sign function">
    In case you are not able to pass an authorization private key or user JWT to the authorization context directly, you can instead pass a custom signing function that the SDK will invoke to automatically sign requests. As an example, you might implement a custom signing function that calls out to a KMS where your authorization keys are secured and returns the necessary signature.

    The sign functions should perform an ECDSA P-256 signature on the payload received, and return the
    base64-encoded signature.

    <CodeGroup>
      ```java Java theme={"system"}
      // This feature is not yet supported in the Java SDK.
      ```

      ```ts @privy-io/node highlight={1,9} {skip-check} theme={"system"}
      async function mySignFunction(payload: Uint8Array): Promise<string> {
        // Perform an ECDSA P-256 signature on the payload
        // This is an example using a fictitious KMS API call.
        const signature = await kms.sign(payload);
        return signature; // This should be a base64-encoded string
      }

      const authorizationContext: AuthorizationContext = {
        sign_functions: [mySignFunction]
      };
      ```

      ```rust Rust theme={"system"}
      //! This newtype is just a convenience blanket implementation.
      //! You can of course just implement the trait for your own types.
      //!
      //! See the API reference for details:
      //! https://docs.rs/privy_rs/latest/privy_rs/trait.IntoSignature.html
      //! https://docs.rs/privy_rs/latest/privy_rs/trait.IntoKey.html

      use privy_rs::{AuthorizationContext, FnSigner};

      // Create a custom signer using a closure with FnSigner wrapper
      let custom_signer = FnSigner(|message: &[u8]| async move {
          // Perform an ECDSA P-256 signature on the payload
          // This is an example using a fictitious KMS API call.
          let signature_bytes = kms_sign(message).await?;
          let signature_b64 = general_purpose::STANDARD.encode(&signature_bytes);
          Ok(Signature {
              signature: signature_b64,
              key_id: "custom-key".to_string()
          })
      });

      let ctx = AuthorizationContext::new().push(custom_signer);
      ```
    </CodeGroup>

    <Info>
      The binary payload received by the sign function is already formatted and ready to be signed.
      There is no need to canonicalize or serialize the payload before signing when using this method.
    </Info>
  </Accordion>

  <Accordion title="Signing with key quorums">
    You may combine the different signing mechanisms in the authorization context to produce a fully
    customizable key quorum.

    For instance:

    * You may want to keep a wallet under control of both a user and an authorization key,
      requiring both signatures to authorize an action. This would be a 2-of-2 key quorum, and can be
      built by combining both the "user jwt" and "authorization private key" properties, as shown below.
    * You may want to keep a wallet under control of several authorization keys. You can build the required authorization context by passing all authorization private keys into the "authorization private key" property.

    <CodeGroup>
      ```java Java theme={"system"}
      // Example: A 2-of-2 key quorum, of a user and an authorization private key
      AuthorizationContext authorizationContext = AuthorizationContext.builder()
          .addUserJwt("user-jwt")
          .addAuthorizationPrivateKey("authorization-key")
          .build();
      ```

      ```ts @privy-io/node theme={"system"}
      import {AuthorizationContext} from '@privy-io/node';

      // Example: A 2-of-2 key quorum, of a user and an authorization private key
      const authorizationContext: AuthorizationContext = {
        user_jwts: ['user-jwt'],
        authorization_private_keys: ['authorization-key']
      };
      ```

      ```rust Rust theme={"system"}
      // Example: A 2-of-2 key quorum, of a user and an authorization private key
      use privy_rs::{AuthorizationContext, JwtUser, PrivateKey, PrivyClient};

      let client = PrivyClient::new(app_id, app_secret)?;

      // Add user JWT for user-based authorization
      let jwt_user = JwtUser(client.clone(), "user-jwt".to_string());

      // Add private key for authorization key-based signing
      let auth_key = PrivateKey("authorization-key".to_string());

      let ctx = AuthorizationContext::new()
          .push(jwt_user)
          .push(auth_key);
      ```
    </CodeGroup>
  </Accordion>

  <Accordion title="Adding signatures directly">
    If your application computes the signature directly separately from the SDK, you can pass signatures directly into the authorization context.

    <CodeGroup>
      ```java Java highlight={2} theme={"system"}
      AuthorizationContext authorizationContext = AuthorizationContext.builder()
          .addSignature("signature-you-produced")
          .build();
      ```

      ```ts @privy-io/node highlight={3,5} theme={"system"}
      import {AuthorizationContext} from '@privy-io/node';

      const authorizationContext: AuthorizationContext = {
        signatures: ['signature-you-produced']
      };
      ```

      ```rust Rust highlight={3,13,18} theme={"system"}
      //! `p256::ecdsa::Signature` implements `IntoSignature`, so
      //! you can push it directly to the authorization context.

      use privy_rs::AuthorizationContext;
      use p256::{ecdsa::Signature, generic_array::GenericArray};
      use base64::{Engine as _, engine::general_purpose};

      let ctx = AuthorizationContext::new();

      // Option 1: Add a pre-computed signature from bytes
      let signature_bytes = general_purpose::STANDARD.decode("your-base64-signature")?;
      let signature = Signature::from_bytes(GenericArray::from_slice(&signature_bytes))?;
      let ctx = ctx.push(signature);

      // Option 2: Add a signature from DER format
      let der_bytes = &[/* your DER encoded signature bytes */];
      let signature = Signature::from_der(der_bytes)?;
      let ctx = ctx.push(signature);
      ```
    </CodeGroup>
  </Accordion>
</AccordionGroup>

### 2. Pass the authorization context to SDK methods

Once you have built your authorization context, pass the context as a parameter to the SDK method that requires request signing. As an example, to send a request to sign a message that needs to be signed by an authorization context:

<CodeGroup>
  ```java Java theme={"system"}
  String message = "Hello, Ethereum.";

  // Example: If wallet's owner is an authorization private key
  AuthorizationContext authorizationContext = AuthorizationContext.builder()
      .addAuthorizationPrivateKey("authorization-key")
      .build();

  EthereumPersonalSignRpcResponseData response = privyClient
      .wallets()
      .ethereum()
      .signMessage(
          walletId,
          message.getBytes(StandardCharsets.UTF_8),
          authorizationContext
      );

  String signature = response.signature();
  ```

  ```ts @privy-io/node theme={"system"}
  import {PrivyClient, type AuthorizationContext} from '@privy-io/node';

  const privy = new PrivyClient({
    appId: 'insert-your-app-id',
    appSecret: 'insert-your-app-secret'
  });

  // Build your authorization context per step (1) above
  const authorizationContext: AuthorizationContext = {
    authorization_private_keys: ['authorization-key']
  };

  // Pass the authorization context to the SDK method as the `authorization_context` parameter
  const response = await privy.wallets().ethereum().signMessage('insert-wallet-id', {
    message: 'Hello, world!',
    authorization_context: authorizationContext
  });
  ```

  ```rust Rust theme={"system"}
  let ethereum_service = client.wallets().ethereum();
  let auth_ctx = AuthorizationContext::new();

  let signature = ethereum_service
      .sign_message(
          &wallet_id,
          "Hello, Ethereum!",
          &auth_ctx,
          Some("unique-request-id-123"),
      )
      .await?;

  println!("Message signed successfully");
  ```
</CodeGroup>

The SDK will sign the request given the authorization context and automatically include the signature in the underlying request to the Privy API.


# Signing with utility functions
Source: https://docs.privy.io/controls/authorization-keys/using-owners/sign/utility-functions



If your integration cannot leverage the [automatic signing](/controls/authorization-keys/using-owners/sign/signing-on-the-server) capabilities of Privy's SDKs, Privy also offers utility functions for formatting and signing requests.

You can use these functions to sign requests, even without initializing an instance of the Privy SDK, and then can manually include the returned signature in requests to the Privy API.

## Client-side SDKs

At a high-level, you can use Privy's client-side SDKs' utility functions to sign requests like so:

<Steps>
  <Step title="Construct your signature payload">
    Determine the request you intend to make to the Privy API and format it into the required
    signature payload, including request headers, method, body, URL, etc.
  </Step>

  <Step title="Sign the request">
    Next, sign the payload using the SDK's `generateAuthorizationSignature` method.
  </Step>

  <Step title="Send the request payload and signature to your backend">
    Make a request to your server, including both the request payload and signature from step (1).
    Your backend will proxy this request with the signature to Privy's REST API.
  </Step>

  <Step title="Send the request to the Privy API">
    From your server, make a request to Privy's REST API with your desired request payload. Include
    the signature in the `privy-authorization-signature` header of the request.
  </Step>
</Steps>

### 1. Construct and sign your request

Given your desired request to the Privy API, build a JSON payload with the following fields. Your application will sign this entire payload to authorize the request to the Privy API.

| Field                              | Type                                                                                                                                                                                                                                                  | Description                                                                                                                                                                                                       |   |   |   |
| ---------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | - | - | - |
| `version`                          | `1`                                                                                                                                                                                                                                                   | Authorization signature version. Currently, `1` is the only version.                                                                                                                                              |   |   |   |
| `method`                           | `'POST'  \| 'PUT'                                                                                                                                                                                                             \| 'PATCH' \| 'DELETE'` | HTTP method for the request. Signatures are not required on `'GET'` requests.                                                                                                                                     |   |   |   |
| `url`                              | `string`                                                                                                                                                                                                                                              | The full URL for the request. Should not include a trailing slash.                                                                                                                                                |   |   |   |
| `body`                             | `JSON`                                                                                                                                                                                                                                                | JSON body for the request.                                                                                                                                                                                        |   |   |   |
| `headers`                          | `JSON`                                                                                                                                                                                                                                                | JSON object containing any Privy-specific headers, e.g. those that are prefixed with `'privy-'`. This should **not** include any other headers, such as authentication headers, `content-type`, or trace headers. |   |   |   |
| `headers['privy-app-id']`          | `string`                                                                                                                                                                                                                                              | Privy app ID header (required).                                                                                                                                                                                   |   |   |   |
| `headers['privy-idempotency-key']` | `string`                                                                                                                                                                                                                                              | Privy idempotency key header (optional). If the request does not contain an idempotency key, leave this field out of the payload.                                                                                 |   |   |   |

As an example, you might build a payload for an Ethereum `personal_sign` RPC request like so:

```ts  theme={"system"}
const signaturePayload = {
  version: 1,
  url: 'https://api.privy.io/v1/wallets/<insert-wallet-id>/rpc',
  method: 'POST',
  headers: {
    'privy-app-id': '<insert-app-id>'
  },
  body: {
    method: 'personal_sign',
    params: {
      message: 'Hello from Privy!',
      encoding: 'utf-8'
    }
  }
} as const;
```

### 2. Sign your request

Next, use the React or React Native SDKs' `generateAuthorizationSignature` method from the `useAuthorizationSignature` hook to sign the request. Pass the payload from step (1) as a parameter to this method.

The method will sign the request with the current authenticated user's signing key, and return a `Promise` for the base64-encoded signature.

<CodeGroup>
  ```tsx React theme={"system"}
  import {useAuthorizationSignature} from '@privy-io/react-auth';

  const {generateAuthorizationSignature} = useAuthorizationSignature();

  // Sign the request using the current authenticated user's signing key.
  // The `signaturePayload` here refers to the JSON payload constructed in step (1).
  const authorizationSignature = await generateAuthorizationSignature(signaturePayload);
  ```

  ```tsx React Native theme={"system"}
  import {useAuthorizationSignature} from '@privy-io/expo';

  const {generateAuthorizationSignature} = useAuthorizationSignature();

  // Sign the request using the current authenticated user's signing key.
  // The `signaturePayload` here refers to the JSON payload constructed in step (1).
  const authorizationSignature = await generateAuthorizationSignature(signaturePayload);
  ```
</CodeGroup>

### 3. Send the request and signature to your backend

Next, make a request from your frontend to your backend including the request you intend to make to the Privy API and the corresponding signature from step (2). Your backend will proxy this request to the Privy API.

### 4. Send the request to the Privy API

Finally, make your request to the Privy API and include the signature in the `privy-authorization-signature` header for your request. As an example, in NodeJS, you can make the request like so:

```ts  theme={"system"}
fetch('https://api.privy.io/v1/wallets/<insert-wallet-id>/rpc', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    Authorization: `Basic ${btoa('<insert-app-id>:<insert-app-secret>')}`,
    'privy-app-id': '<insert-app-id>',
    'privy-authorization-signature': '<insert-base64-encoded-signature>'
  },
  body: JSON.stringify({
    method: 'personal_sign',
    params: {
      message: 'Hello from Privy!',
      encoding: 'utf-8'
    }
  })
})
  .then((res) => console.log(res))
  .catch((err) => console.error(err));
```

## Server-side SDKs

Privy's server SDKs offer two utilities for signing requests:

* **Formatting requests for authorization signatures.** This accepts your desired request to the Privy API and formats it into the required signature payload to be signed.
  * This utility is particularly helpful if your application signs requests via a separate service, e.g. an isolated KMS. Your primary server can format your request and generate the signature payload and call out to your signing service with the payload.
* **Generating authorization signatures.** This accepts a formatted signature payload and signs it with your provided signing key.
  * This utility is particularly useful within a specific signing service. Within your signing service, you can import this function and use it to sign requests, and return the signature to your primary service.

### Constructing your input

Both the formatting and signing functions of Privy's SDKs require a JSON input with the following fields:

| Field                              | Type                                                                                                                                                                                                                                                  | Description                                                                                                                                                                                                       |   |   |   |
| ---------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | - | - | - |
| `version`                          | `1`                                                                                                                                                                                                                                                   | Authorization signature version. Currently, `1` is the only version.                                                                                                                                              |   |   |   |
| `method`                           | `'POST'  \| 'PUT'                                                                                                                                                                                                             \| 'PATCH' \| 'DELETE'` | HTTP method for the request. Signatures are not required on `'GET'` requests.                                                                                                                                     |   |   |   |
| `url`                              | `string`                                                                                                                                                                                                                                              | The full URL for the request. Should not include a trailing slash.                                                                                                                                                |   |   |   |
| `body`                             | `JSON`                                                                                                                                                                                                                                                | JSON body for the request.                                                                                                                                                                                        |   |   |   |
| `headers`                          | `JSON`                                                                                                                                                                                                                                                | JSON object containing any Privy-specific headers, e.g. those that are prefixed with `'privy-'`. This should **not** include any other headers, such as authentication headers, `content-type`, or trace headers. |   |   |   |
| `headers['privy-app-id']`          | `string`                                                                                                                                                                                                                                              | Privy app ID header (required).                                                                                                                                                                                   |   |   |   |
| `headers['privy-idempotency-key']` | `string`                                                                                                                                                                                                                                              | Privy idempotency key header (optional). If the request does not contain an idempotency key, leave this field out of the payload.                                                                                 |   |   |   |

### Formatting requests

Use the SDK's formatting function to generate your signature payload. As a parameter to this function, pass the JSON object as defined above.

<CodeGroup>
  ```ts NodeJS theme={"system"}
  import {
    formatRequestForAuthorizationSignature,
    type WalletApiRequestSignatureInput
  } from '@privy-io/node';

  // Replace this with your desired request to the Privy API, including
  // url, method, headers, and body.
  const input: WalletApiRequestSignatureInput = {
    version: 1,
    url: 'https://api.privy.io/v1/wallets/<insert-wallet-id>/rpc',
    method: 'POST',
    headers: {
      'privy-app-id': '<insert-app-id>'
    },
    body: {
      method: 'personal_sign',
      params: {
        message: 'Hello from Privy!',
        encoding: 'utf-8'
      }
    }
  };
  const serializedPayload = formatRequestForAuthorizationSignature(input);
  ```

  ```ts NodeJS (@privy-io/server-auth) theme={"system"}
  import {formatRequestForAuthorizationSignature} from '@privy-io/server-auth/wallet-api';

  // Replace this with your desired request to the Privy API, including
  // url, method, headers, and body.
  const input = {
    version: 1,
    url: 'https://api.privy.io/v1/wallets/<insert-wallet-id>/rpc',
    method: 'POST',
    headers: {
      'privy-app-id': '<insert-app-id>'
    },
    body: {
      method: 'personal_sign',
      params: {
        message: 'Hello from Privy!',
        encoding: 'utf-8'
      }
    }
  } as const;
  const serializedPayload = formatRequestForAuthorizationSignature({input});
  ```

  ```java Java theme={"system"}
  // Build the request, in this case an ethereum personal_sign request
  EthereumPersonalSignRpcInputParams params = EthereumPersonalSignRpcInputParams.builder()
      .message(message)
      .encoding(Encoding.of(EncodingUtf8.UTF8))
      .build();

  EthereumPersonalSignRpcInput request = EthereumPersonalSignRpcInput.builder()
      .method(EthereumPersonalSignRpcInputMethod.PERSONAL_SIGN)
      .params(params)
      .build();

  byte[] serializedPayload = privyClient.utils()
      .requestFormatter()
      .formatRequestForAuthorizationSignature(
          new WalletApiRequestSignatureInput(
              1,
              request,
              HttpMethod.POST,
              "https://api.privy.io/wallets/<insert-wallet-id>/rpc",
              null
          )
      );
  ```

  ```rust Rust theme={"system"}
  use privy_rs::format_request_for_authorization_signature;
  use privy_rs::generated::types::*;

  // Build the request, in this case an ethereum personal_sign request
  let params = EthereumPersonalSignRpcInputParams {
      message: "Hello from Privy!".to_string(),
      encoding: Some(EthereumPersonalSignRpcInputParamsEncoding::Utf8),
  };

  let request = EthereumPersonalSignRpcInput {
      method: EthereumPersonalSignRpcInputMethod::PersonalSign,
      params,
  };

  let encoded_request_payload = format_request_for_authorization_signature(
      &app_id,
      crate::Method::POST,
      "https://api.privy.io/wallets/<insert-wallet-id>/rpc".to_string(),
      &request,
      None,
  )?;
  ```
</CodeGroup>

You can then take the returned serialized payload and call out to a signing service to generate a P256 signature over the payload.

### Signing requests

To directly produce a signature over a request, use the SDK's generate authorization signature method. As a parameter to this method, pass the JSON object as defined above.

<CodeGroup>
  ```ts Node theme={"system"}
  import {generateAuthorizationSignature, type WalletApiRequestSignatureInput} from '@privy-io/node';

  // Replace this with your desired request to the Privy API, including
  // url, method, headers, and body.
  const input: WalletApiRequestSignatureInput = {
    version: 1,
    url: 'https://api.privy.io/v1/wallets/<insert-wallet-id>/rpc',
    method: 'POST',
    headers: {
      'privy-app-id': '<insert-app-id>'
    },
    body: {
      method: 'personal_sign',
      params: {
        message: 'Hello from Privy!',
        encoding: 'utf-8'
      }
    }
  };
  // Pass your base64 encoded authorization private key as `authorizationPrivateKey`
  const signature = generateAuthorizationSignature({
    input,
    authorizationPrivateKey: 'insert-private-key'
  });
  ```

  ```ts Node (@privy-io/server-auth) theme={"system"}
  import {generateAuthorizationSignature, type WalletApiRequestSignatureInput} from '@privy-io/node';

  // Replace this with your desired request to the Privy API, including
  // url, method, headers, and body.
  const input: WalletApiRequestSignatureInput = {
    version: 1,
    url: 'https://api.privy.io/v1/wallets/<insert-wallet-id>/rpc',
    method: 'POST',
    headers: {
      'privy-app-id': '<insert-app-id>'
    },
    body: {
      method: 'personal_sign',
      params: {
        message: 'Hello from Privy!',
        encoding: 'utf-8'
      }
    }
  };
  // Pass your base64 encoded authorization private key as `authorizationPrivateKey`
  const signature = generateAuthorizationSignature({
    input,
    authorizationPrivateKey: 'insert-private-key'
  });
  ```

  ```java Java theme={"system"}
  // Build the request, in this case an ethereum personal_sign request
  EthereumPersonalSignRpcInputParams params = EthereumPersonalSignRpcInputParams.builder()
      .message(message)
      .encoding(Encoding.of(EncodingUtf8.UTF8))
      .build();

  EthereumPersonalSignRpcInput request = EthereumPersonalSignRpcInput.builder()
      .method(EthereumPersonalSignRpcInputMethod.PERSONAL_SIGN)
      .params(params)
      .build();


  String signature = privyClient.utils()
    .requestSigner()
    .generateAuthorizationSignature(
        "authorization-key",
        new WalletApiRequestSignatureInput(
            1,
            request,
            HttpMethod.POST,
            "https://api.privy.io/wallets/<insert-wallet-id>/rpc",
            null
        )
    );
  ```

  ```rust Rust theme={"system"}
  use privy_rs::generate_authorization_signatures;

  let ctx = AuthorizationContext::new().push(key);
  let body = serde_json::json!({"test": "data"});

  // Returns a list of signatures given the authorization context
  let sig = generate_authorization_signatures(
        ctx,
        &self.app_id,
        crate::Method::PATCH,
        format!("{}/v1/policies/{}", self.base_url, policy_id.as_str()),
        body,
        "idempotency_key".to_string(),
    )
    .await?;
  ```
</CodeGroup>

This will return a base64-encoded signature over the payload you defined. Include this signature as the `privy-authorization-signature` header when making the request to the Privy API.


# Approve intents for execution
Source: https://docs.privy.io/controls/dashboard/approvals



Once you've created intents to execute an action, team members in the corresponding key quorum can approve the intent via the Privy Dashboard.

To see intents for your application, visit the [Approvals](https://dashboard.privy.io/apps?page=approvals) of the Dashboard. From here, you can see a list of all intents, their type and corresponding resource, as well as the progress of their approval.

### Approving intents

View the **Pending your approval** section to find active intents that you can approve.

Select a given intent to view it. You can see details on who proposed the intent, what resource it affects, when it expires, and how many approvals have been collected from the respective key quorum.

You will also see a preview of the action for the intent:

* For wallet and policy updates, view a difference of the current state of the wallet/policy and the proposed state of the wallet/policy.
* For signatures and transactions, view a preview of the message being signed or the transaction being signed and/or broadcasted.

Once you've previewed the intent and have confirmed the changes, click the **Approve** button and complete MFA to approve the intent.

<Warning>
  Make sure to review an intent carefully before approving it. You cannot revoke approvals for
  intents after submitting them.
</Warning>

<Info>
  Under the hood, when a team member approves an action in the Dashboard, they provide an
  [authorization signature](/api-reference/authorization-signatures) over the request. Privy
  accumulates these signatures and executes the intent once the threshold is met.
</Info>

#### Intent execution

If your approval will satisfy the authorization threshold for the intent, **Privy will automatically execute the intent once you provide your approval.**

For example, if you create an intent to execute a transaction with a wallet, and the key quorum for the wallet has an authorization threshold of 3, if 2 approvals have already been provided, Privy will automatically execute the transaction upon the 3rd approval.

The final approver will be required to confirm that providing their approval will execute the intent.

### Rejecting intents

For intents created via the Privy Dashboard, the creator of the intent can reject the intent by selecting it from the [Approvals](https://dashboard.privy.io/apps?page=approvals) page and selecting **Cancel proposal**.

This will prevent other team members from being able to approve the intent going forward.

### Viewing intents

From the [Approvals](https://dashboard.privy.io/apps?page=approvals) page, you can also see all intents created for your application, not just those that are pending your approval.

<Tip>
  When viewing a particular intent, click the link icon at the top of the intent modal to copy a
  deeplink to the intent to your clipboard. You can share this link with other team members to
  easily share intents for viewing.
</Tip>

**Executed intents**

Intents with a status of **Executed** have received sufficient approvals and have been executed by the Privy API. Click into an **Executed** intent to see the action that was executed and its result.

**Pending intents**

Intents with a status of **Pending** still require more approvals in order to be authorized. Click into a **Pending** intent to see a preview of the proposed action and the progress of approvals.

**Expired intents**

Intents with a status of **Expired** can no longer be executed and expired after insufficient approvals were provided within 72 hours of intent creation.

**Rejected intents**

Intents with a status of **Rejected** can no longer be executed due to cancellation by the intent creator.


# Get intent status and execution results
Source: https://docs.privy.io/controls/dashboard/intent-status



Once an intent has been created, you can get the intent's status from the Privy API via the intent's ID. If the intent has been executed, you can also get the result of execution.

To get the status of an intent, make a `GET` request to:

```sh  theme={"system"}
https://api.privy.io/v1/apps/{app_id}/intents/{intent_id}
```

using the intent ID returned from the Privy API or displayed in the Privy Dashboard.

From the response, you can extract key information such as:

| Field                     | Description                                                                                                                                                                           |
| ------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `created_by_display_name` | The email address of the creator of the intent.                                                                                                                                       |
| `authorizations`          | A list of team members that have submitted approvals for the intent.                                                                                                                  |
| `status`                  | The status of the intent (`'pending'`, `'granted'`, `'executed'`, `'rejected'`, `'expired'`).                                                                                         |
| `expires_at`              | UNIX timestamp for when the intent expires.                                                                                                                                           |
| `request_details`         | The request body corresponding to the action for the intent (e.g., the request body to update a wallet, update a policy, or execute a signature or transaction).                      |
| `action_result`           | If the intent was executed, the response body corresponding to intent execution (e.g., the response body to update a wallet, update a policy, or execute a signature or transaction). |

### Consuming the result of intent execution

Use the `action_result` field to consume the result of intent execution. For example, if you created an intent to sign a message or send a transaction, you can consume the signature or transaction hash from the `action_result` field of the response.

### API reference

View the full API reference for this endpoint below.

<Card title="Get intent" icon="arrow-right" horizontal href="/api-reference/intents/get">
  View API reference for getting the status of an intent and the result of its execution.
</Card>


# Create intents to execute actions
Source: https://docs.privy.io/controls/dashboard/intents



Next, for resources owned by your key quorum of team members, create **intents** to execute actions like wallet updates, policy updates, signatures, or transactions.

**Intents** are a resource in the Privy API that represent an intent to execute an action that will be **asynchronously** authorized by team members submitting approvals in the Privy Dashboard. Once a sufficient number of approvals is collected, the intent will be authorized and executed.

At a high-level, there are two ways to create intents in Privy:

* **Via the Dashboard:** From the **Wallets** and **Policies** pages of the Privy Dashboard, you can create an intent to update an existing wallet or policy that is owned by a key quorum of your team members.
* **Via the REST API:** From the REST API, you can create an intent to update a wallet, update a policy, or execute a signature or transaction.

<Info>
  Intents expire 72 hours after creation, and must be [approved](/controls/dashboard/approvals)
  within this window.
</Info>

Learn more below on creating intents for the following flows.

<Columns cols={3}>
  <Card title="Update wallet" icon="wallet" href="/controls/dashboard/intents#update-wallet">
    Create an intent to update a wallet
  </Card>

  <Card title="Update policy" icon="file" href="/controls/dashboard/intents#update-policy">
    Create an intent to update a policy
  </Card>

  <Card title="Execute signature or transaction" icon="key" href="/controls/dashboard/intents#execute-signature-or-transaction">
    Create an intent to execute a signature or transaction
  </Card>
</Columns>

***

## Update wallet

Create intents to update a wallet via the Privy Dashboard or REST API.

### Via the Dashboard

To create an intent to update a wallet via the Dashboard, visit the [**Wallets**](https://dashboard.privy.io/apps?page=wallets) page of the Dashboard and select your desired wallet.

Click **Update wallet** and make the changes you'd like to make. Finally, select **Propose changes** to create your intent to update the wallet.

### Via the REST API

To create an intent to update a wallet via the REST API, make a `PATCH` request to

```sh  theme={"system"}
https://api.privy.io/v1/apps/{app_id}/intents/wallets/{wallet_id}
```

This endpoint accepts the same request body as Privy's synchronous [**Update wallet**](/api-reference/wallets/update) endpoint, but does **not** require authorization signatures to be provided in the request. Instead, the intent will be authorized asyncrhonously and executed when sufficient authorizations have been met.

From the response, note the returned `intent_id`. You can use this ID later to view the status of the intent, how many authorizations have been collected, and what the execution status is.

View the full API reference for this endpoint below.

<Card title="Create an intent to update a wallet" icon="arrow-right" horizontal href="/api-reference/wallets/update-intent">
  View API reference for creating an intent to update a wallet.
</Card>

***

## Update policy

Create intents to update a policy via the Privy Dashboard or REST API.

### Via the Dashboard

To create an intent to update a wallet via the Dashboard, visit the [**Policies**](https://dashboard.privy.io/apps?page=policies) page of the Dashboard and select your desired policy.

Make your desired changes to the policy and click **Propose changes** to create your intent to update the policy.

### Via the REST API

To create an intent to update a policy via the REST API, make a `PATCH` request to

```sh  theme={"system"}
https://api.privy.io/v1/apps/{app_id}/intents/policies/{policy_id}
```

This endpoint accepts the same request body as Privy's synchronous [**Update policy**](/api-reference/policies/update) endpoint, but does **not** require authorization signatures to be provided in the request. Instead, the intent will be authorized asyncrhonously and executed when sufficient authorizations have been met.

From the response, note the returned `intent_id`. You can use this ID later to view the status of the intent, how many authorizations have been collected, and what the execution status is.

View the full API reference for this endpoint below.

<Card title="Create an intent to update a policy" icon="arrow-right" horizontal href="/api-reference/policies/update-intent">
  View API reference for creating an intent to update a policy.
</Card>

***

## Execute signature or transaction

Create intents to execute a signature or transaction via the REST API. Executing signatures and transactions currently cannot be initiated from the Privy Dashboard.

### Via the REST API

To create an intent to update a policy via the REST API, make a `POST` request to

```sh  theme={"system"}
https://api.privy.io/v1/apps/{app_id}/intents/wallets/{wallet_id}/rpc
```

This endpoint accepts the same request body as Privy's synchronous [**RPC**](/api-reference/wallets/ethereum/eth-send-transaction) endpoint, but does **not** require authorization signatures to be provided in the request. Instead, the intent will be authorized asynchronously and executed when sufficient authorizations have been met.

From the response, note the returned `intent_id`. You can use this ID later to view the status of the intent, how many authorizations have been collected, and what the execution status is.

View the full API reference for this endpoint below.

<Card title="Create an intent to execute a signature or transaction" icon="arrow-right" horizontal href="/api-reference/wallets/rpc-intent">
  View API reference for creating an intent to execute a signature or transaction
</Card>

***

## Update key quorum

You can also create an intent to update the key quorum of team members you initially created, to update the quorum's name, members, or authorization threshold.

This intent must be authorized by a sufficient number of members of the existing quorum in order to be executed.

### Via the Dashboard

To create an intent to update a key quorum via the Dashboard, visit the [**Authorization**](https://dashboard.privy.io/apps?page=authorization-keys) page of the Dashboard and select your desired key quorum.

Select **Update key quorum**, make your desired changes, and select **propose changes** to create your intent.

### Via the REST API

To create an intent to update a policy via the REST API, make a `PATCH` request to

```sh  theme={"system"}
https://api.privy.io/v1/apps/{app_id}/intents/key_quorums/{key_quorum_id}
```

This endpoint accepts the same request body as Privy's synchronous [**Update key quorum**](/api-reference/key-quorums/update) endpoint, but does **not** require authorization signatures to be provided in the request. Instead, the intent will be authorized asyncrhonously and executed when sufficient authorizations have been met.

From the response, note the returned `intent_id`. You can use this ID later to view the status of the intent, how many authorizations have been collected, and what the execution status is.

View the full API reference for this endpoint below.

<Card title="Create an intent to update a key quorum" icon="arrow-right" horizontal href="/api-reference/key-quorums/update-intent">
  View API reference for creating an intent to update a key quorum.
</Card>


# Create a key quorum
Source: https://docs.privy.io/controls/dashboard/key-quorum



To authorize actions like wallet updates, policy updates, signatures, and transactions via the Privy Dashboard, first create a [key quorum](/controls/key-quorum/overview) of team members to authorize actions. This quorum represents a group of "approvers" that can be assigned to authorize actions.

### Invite team members to your Privy account

To start, invite the team members that you'd like to include in your quorum to your Privy account from the [Team](https://dashboard.privy.io/team) page of the Dashboard. Make sure to give them either the **Developer** or **Admin** role to be enrolled in a key quorum.

### Enroll team members in MFA

To enroll in a key quorum, a team member in the Privy Dashboard **must** set up biometric or TOTP MFA for their account.

Have your team members enroll in MFA by clicking the profile icon at the bottom left corner of the Dashboard, selecting **Account preferences**, and then clicking **MFA enrollment**. Here, they will be prompted to enroll or update their MFA methods.

### Create a key quorum of team members

Finally, to create your key quorum, visit the [Authorization](https://dashboard.privy.io/apps?page=authorization-keys) page of the Privy Dashboard and click the **New key** button. In the modal that opens, select **Register key quorum**.

Set a **Name** for a quorum and select the team members you'd like to include in the quorum from the **Team members** dropdown. Only team members who have enrolled in MFA will be available as options to select.

Additionally, set the **Authorization threshold** for the quorum. This represents the number of members of the quorum that must approve an action to reach consensus.

### Assign the quorum as the owner of resources

Once your key quorum is created, note down the **ID** of the quorum.

When creating resources like wallets or policies that you'd like to manage via the Privy Dashboard, set this ID as the `owner_id` field of the resource creation request. This will set this key quorum as the resource's owner, and require it to approve actions like resource updates or wallet signatures and transactions.

<Columns cols={2}>
  <Card title="Create a wallet" icon="wallet" href="/api-reference/wallets/create">
    Create a wallet with your key quorum ID as the `owner_id`
  </Card>

  <Card title="Create a policy" icon="file" href="/api-reference/policies/create">
    Create a policy with your key quorum ID as the `owner_id`
  </Card>
</Columns>


# Dashboard controls
Source: https://docs.privy.io/controls/dashboard/overview



Privy enables you to securely manage resources like wallets and policies from the Privy Dashboard. You can set granular controls on these resources to require team members of your Privy account to explicitly authorize actions like wallet updates, policy updates, signatures, and transactions via the Dashboard.

<Tip>
  All authorizations performed through the Privy Dashboard are secured by biometric and/or TOTP MFA.
</Tip>

<img src="https://mintcdn.com/privy-c2af3412/wzqLpH4VYhrb0ndO/images/dashboard-approvals-splash.png?fit=max&auto=format&n=wzqLpH4VYhrb0ndO&q=85&s=33b7968e481ed22460e5eea696b162b0" alt="images/dashboard-approvals-splash.png" data-og-width="4500" width="4500" data-og-height="3000" height="3000" data-path="images/dashboard-approvals-splash.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/wzqLpH4VYhrb0ndO/images/dashboard-approvals-splash.png?w=280&fit=max&auto=format&n=wzqLpH4VYhrb0ndO&q=85&s=8206148f75f7671786cfdef42bc3e743 280w, https://mintcdn.com/privy-c2af3412/wzqLpH4VYhrb0ndO/images/dashboard-approvals-splash.png?w=560&fit=max&auto=format&n=wzqLpH4VYhrb0ndO&q=85&s=0da635ba2c8932f4e26c94c2735f68cc 560w, https://mintcdn.com/privy-c2af3412/wzqLpH4VYhrb0ndO/images/dashboard-approvals-splash.png?w=840&fit=max&auto=format&n=wzqLpH4VYhrb0ndO&q=85&s=001b95609525cbe9184611690ff6ed2b 840w, https://mintcdn.com/privy-c2af3412/wzqLpH4VYhrb0ndO/images/dashboard-approvals-splash.png?w=1100&fit=max&auto=format&n=wzqLpH4VYhrb0ndO&q=85&s=5bd130eb0629e032e6226cfef6634940 1100w, https://mintcdn.com/privy-c2af3412/wzqLpH4VYhrb0ndO/images/dashboard-approvals-splash.png?w=1650&fit=max&auto=format&n=wzqLpH4VYhrb0ndO&q=85&s=9e20a31b308a6531e7b95d36868e55f5 1650w, https://mintcdn.com/privy-c2af3412/wzqLpH4VYhrb0ndO/images/dashboard-approvals-splash.png?w=2500&fit=max&auto=format&n=wzqLpH4VYhrb0ndO&q=85&s=21e2301dc07559a8108e800880cf1afb 2500w" />

<Info>
  Dashboard controls over wallets and policies is a gated feature. Reach out to
  [sales@privy.io](mailto:sales@privy.io) to request access for your app.
</Info>

## Overview

At a high-level, to configure Privy resources by wallets and policies to be managed via the Dashboard:

<Steps>
  <Step title="Create a key quorum of team members">
    In the Privy Dashboard, create a [key quorum](/controls/key-quorum/overview) consisting of team members of your Privy account. Configure the members of the quorum and the threshold of members required for the quorum to reach consensus.

    This quorum can later approve actions like wallet updates, policy updates, signatures, and transactions via the Dashboard. A sufficient number of members of the quorum must approve the action to authorize its execution in the Privy API.
  </Step>

  <Step title="Assign the key quorum as the owner of the resource or a signer">
    When creating a resource like a [wallet](/api-reference/wallets/create) or a [policy](/api-reference/policies/create) in the Privy API, assign the key quorum as the [owner](/controls/authorization-keys/owners/overview) of the resource. As owner, the key quorum will be required to authorize any updates to the wallet or the policy.

    For wallets, the key quorum will also be required to authorize any signatures or transactions executed by the wallet. You can alternatively add the key quorum as a [signer](/controls/authorization-keys/owners/overview) on the wallet to give it permission to authorize certain signatures and transactions without the ability to update the wallet itself.
  </Step>

  <Step title="Create an intent to execute an action">
    Next, via the Privy API or Dashboard, create an **intent** to execute an action, like updating wallets, updating policies, or executing signatures or transactions.

    Once the intent is created, the intent will be queued for approval in the Privy Dashboard for the team members that own the resource.
  </Step>

  <Step title="Approve the intent to authorize execution">
    Finally, team members can approve the intent via the **Approvals** page of the Privy Dashboard. Approvals are secured by biometric or TOTP MFA.

    Once a sufficient number of team members approve the intent, based on the threshold set for your key quorum, the intent will be executed via the Privy API – the wallet will be updated, the policy will be updated, or the signature or transaction will be executed.
  </Step>
</Steps>

## Get started

Get started with Dashboard controls with the guides below.

<Columns cols={2}>
  <Card title="Create key quorums" icon="users" href="/controls/dashboard/key-quorum">
    Create key quorums of your team members in the Privy Dashboard.
  </Card>

  <Card title="Create intents for execution" icon="shield" href="/controls/dashboard/key-quorum">
    Create intents to update a wallet, update a policy, or execute a signature or transaction.
  </Card>

  <Card title="Approve intents" icon="fingerprint" href="/controls/dashboard/key-quorum">
    Approve intents to authorize their execution
  </Card>

  <Card title="Get intent status" icon="code" href="/controls/dashboard/key-quorum">
    Get the status of an intent and the result of their execution
  </Card>
</Columns>


# Creating key quorums
Source: https://docs.privy.io/controls/key-quorum/create



To create a key quorum, first [create the authorization keys](/controls/authorization-keys/keys/create/key) and/or [get the user IDs](/controls/authorization-keys/keys/create/user/overview) of the users that will constitute the key quorum.

Once you have the user ID(s) and/or authorization key(s) you would like in your key quorum, you can then register the key quorum with Privy via the Dashboard or the REST API.

<Tabs>
  <Tab title="Dashboard">
    Visit the [**Authorization keys**](https://dashboard.privy.io/apps?page=authorization-keys) page of the **Wallets** section for your app, click **New key**, and select **Register key quorum instead**.

    Specify the public keys you'd like to add to the quorum and an authorization threshold.

    <Info>
      Key quorums containing both user IDs and authorization keys must be created via the REST API.
    </Info>

        <img src="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/authkeys.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=e9705db989c192fe5f754f9171182807" alt="Dashboard" data-og-width="1843" width="1843" data-og-height="1317" height="1317" data-path="images/authkeys.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/authkeys.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=f1c68142fd64fde65070c49350f621f3 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/authkeys.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=dc8e1fdc596c3a4241b7d9550aedd7be 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/authkeys.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=fc125e38e7114ef1e7b2d4c052fc4d67 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/authkeys.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=8dd4658d33a8963176fb50fff56e5550 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/authkeys.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=938fd2d2863c2256c0cfb08985cc6ac9 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/authkeys.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=3e898804c565170c9e3983131cf0944c 2500w" />
  </Tab>

  <Tab title="NodeJS">
    <Info>
      This guide is for the **`@privy-io/node`** library only, as the feature is not available in the
      **`@privy-io/server-auth`** library.
    </Info>

    You can create a key quorum using the Node SDK by using the `keyQuorums().create()` method.

    ### Usage

    <Tip>
      The returned `id` for the key quorum is used as the `owner_id` field when creating or updating resources (e.g. wallets or policies) in the Privy API.
    </Tip>

    ```ts title="Example: Create a 2-of-2 key quorum with an authorization key and a user" theme={"system"}
    try {
      const keyQuorum = await privyClient.keyQuorums().create({
        public_keys: ['authorization-key'],
        user_ids: ['user-id'],
        display_name: '2 of 2 Test Key Quorum',
        authorization_threshold: 2, // Require 2 signatures (both keys)
      });

      const keyQuorumId = keyQuorum.id;
    } catch (error) {
      console.error(error);
    }
    ```

    Refer to the [API reference](/api-reference/key-quorums/create) for more details on the available parameters and returns.
  </Tab>

  <Tab title="Java">
    You can create a key quorum using the Java SDK by using the `keyQuorums().create()` method.

    ### Usage

    <Tip>
      The returned `id` for the key quorum is used as the `ownerId` field when creating or updating resources (e.g. wallets or policies) in the Privy API.
    </Tip>

    ```java title="Example: Create a 2-of-2 key quorum with an authorization key and a user" theme={"system"}
    try {
      KeyQuorumCreateRequestBody keyQuorumRequest = KeyQuorumCreateRequestBody.builder()
          .publicKeys(List.of("authorization-key"))
          .userIds(List.of("user-id"))
          .displayName("2 of 2 Test Key Quorum")
          .authorizationThreshold(2.0) // Require 2 signatures (both keys)
          .build();

      KeyQuorumCreateResponse keyQuorumResponse = privyClient
          .keyQuorums()
          .create(keyQuorumRequest);

      if (keyQuorumResponse.keyQuorum().isPresent()) {
          KeyQuorum keyQuorum = keyQuorumResponse.keyQuorum().get();
          String keyQuorumId = keyQuorum.id();
      }
    } catch (APIException e) {
      String errorBody = e.bodyAsString();
      System.err.println(errorBody);
    } catch (Exception e) {
      System.err.println(e.getMessage());
    }
    ```

    ### Parameters

    When creating a key quorum, you can specify the following values on the `KeyQuorumCreateRequestBody` builder:

    <ParamField path="publicKeys" type="List<String>">
      A list of base64-encoded, DER-formatted P-256 public keys to register.
    </ParamField>

    <ParamField path="userIds" type="List<String>">
      A list of user IDs to include in the key quorum.
    </ParamField>

    <ParamField path="authorizationThreshold" type="Double">
      The minimum number of signatures required to authorize an action. If left unset, the default is all keys.
    </ParamField>

    <ParamField path="displayName" type="String">
      Human readable display name to attach to the key.
    </ParamField>

    ### Returns

    The `KeyQuorumCreateResponse` object contains an optional `keyQuorum()` field, present if the key quorum was created successfully.

    <ResponseField name="keyQuorum()" type="Optional<KeyQuorum>">
      The created `KeyQuorum` object.

      <Expandable title="KeyQuorum" defaultOpen="true">
        <ResponseField name="id" type="String">
          Unique ID for the key quorum, used to assign the `owner_id` to a resource.
        </ResponseField>

        <ResponseField name="authorizationKeys" type="List<AuthorizationKey>">
          The list of authorization keys included in the key quorum.

          <Expandable title="AuthorizationKey">
            <ResponseField name="publicKey" type="String">
              The public key of the authorization key.
            </ResponseField>

            <ResponseField name="displayName" type="String">
              The display name of the authorization key.
            </ResponseField>
          </Expandable>
        </ResponseField>

        <ResponseField name="userIds" type="List<String>">
          The list of user IDs included in the key quorum.
        </ResponseField>

        <ResponseField name="authorizationThreshold" type="Double">
          The minimum number of signatures required to authorize an action. If left unset, the default is all keys.
        </ResponseField>

        <ResponseField name="displayName" type="String">
          Human readable display name to attach to the key.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="Rust">
    You can create a key quorum using the Rust SDK by using the `key_quorums().create()` method.

    ### Usage

    <Tip>
      The returned `id` for the key quorum is used as the `owner_id` field when creating or updating resources (e.g. wallets or policies) in the Privy API.
    </Tip>

    ```rust title="Example: Create a 2-of-2 key quorum with an authorization key and a user" theme={"system"}
    use privy_rs::{PrivyClient, generated::types::*};

    let client = PrivyClient::new(app_id, app_secret)?;

    let request = CreateKeyQuorumBody {
        public_keys: Some(vec!["authorization-key".to_string()]),
        user_ids: Some(vec!["user-id".to_string()]),
        display_name: Some("2 of 2 Test Key Quorum".to_string()),
        authorization_threshold: Some(2.0), // Require 2 signatures (both keys)
    };

    let key_quorum = client
        .key_quorums()
        .create(request)
        .await?;

    let key_quorum_id = key_quorum.id;
    println!("Created key quorum: {}", key_quorum_id);
    ```

    ### Parameters and Returns

    See the Rust SDK documentation for detailed parameter and return types, including embedded examples:

    * [KeyQuorumsClient::create](https://docs.rs/privy-rs/latest/privy_rs/subclients/struct.KeyQuorumsClient.html#method.create)

    For REST API details, see the [API reference](/api-reference/key-quorums/create).
  </Tab>

  <Tab title="REST API">
    Register the key quorum with Privy by making a `POST` request to:

    ```sh  theme={"system"}
    https://api.privy.io/v1/key_quorums
    ```

    In the request body, include the following.

    <Accordion title="Show request body parameters">
      <ParamField path="public_keys" type="string[]">
        A list of base64-encoded, DER-formatted P-256 public keys to register.
      </ParamField>

      <ParamField path="user_ids" type="string[]">
        A list of user IDs to include in the key quorum.
      </ParamField>

      <ParamField path="authorization_threshold" type="number">
        The minimum number of signatures required to authorize an action. If left unset, the default is all keys.
      </ParamField>

      <ParamField path="display_name" type="string">
        Human readable display name to attach to the key.
      </ParamField>
    </Accordion>

    If the request is successful, Privy will return the following fields in the response.

    <Accordion title="Show response body fields">
      <ResponseField name="id" type="string">
        Unique ID for the key quorum, used to assign the `owner_id` to a resource.
      </ResponseField>

      <ResponseField name="authorization_keys" type="{public_key: string, display_name: string | null}[]">
        The list of public keys and their display names.
      </ResponseField>

      <ResponseField name="user_ids" type="string[]">
        The list of user IDs included in the key quorum.
      </ResponseField>

      <ResponseField path="authorization_threshold" type="number | null">
        The minimum number of signatures required to authorize an action. If left unset, the default is all keys.
      </ResponseField>

      <ResponseField name="display_name" type="string">
        Human readable display name to attach to the key.
      </ResponseField>
    </Accordion>

    <Tip>
      The returned `id` for the key quorum is used as the `owner_id` field when creating or updating resources (e.g. wallets or policies) in the Privy API.
    </Tip>

    See an example request for creating a key quorum below.

    <Accordion title="Show example request to create a key quorum">
      As an example, a request to register a 2 of 2 key quorum might look like the following:

      ```bash  theme={"system"}
      $ curl --request POST https://api.privy.io/v1/key_quorums \
      -u "<your-privy-app-id>:<your-privy-app-secret>" \
      -H "privy-app-id: <your-privy-app-id>" \
      -H 'Content-Type: application/json' \
      -d '{
          "display_name": "Sample key",
          "public_keys": [
              "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEx4aoeD72yykviK+f/ckqE2CItVIG\n1rCnvC3/XZ1HgpOcMEMialRmTrqIK4oZlYd1RfxU3za/C9yjhboIuoPD3g==",
              "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAErzZtQr/bMIh3Y8f9ZqseB9i/AfjQ\nhu+agbNqXcJy/TfoNqvc/Y3Mh7gIZ8ZLXQEykycx4mYSpqrxp1lBKqsZDQ=="
          ],
          "authorization_threshold": 2
      }'
      ```

      An example successful response would look like:

      ```json  theme={"system"}
      {
          "id": "<insert-owner-id>",
          "display_name": "Sample key",
          "public_keys": [
              {
                "public_key": "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEx4aoeD72yykviK+f/ckqE2CItVIG\n1rCnvC3/XZ1HgpOcMEMialRmTrqIK4oZlYd1RfxU3za/C9yjhboIuoPD3g=="
              },
              {
                "public_key": "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAErzZtQr/bMIh3Y8f9ZqseB9i/AfjQ\nhu+agbNqXcJy/TfoNqvc/Y3Mh7gIZ8ZLXQEykycx4mYSpqrxp1lBKqsZDQ=="
              }
          ],
          "authorization_threshold": 2
      }
      ```
    </Accordion>
  </Tab>
</Tabs>


# Overview
Source: https://docs.privy.io/controls/key-quorum/overview



<Tip>
  Key quorums are an advanced feature. [Reach out](https://privy.io/slack)) to discuss whether this
  setup is right for your integration.
</Tip>

Key quorums are a **set** of authorization keys and/or users that can own a resource (e.g. wallets or policies) in the Privy API.

Key quorums can be configured such that a **quorum** of *m*-of-*n* of the keys in the set must sign requests to the Privy API. This is known as the key quorum's **authorization threshold**. This allows for customizable owner configurations such as:

* Customizing which transactions must be signed by a user, an authorization key, or both
* Requiring a set of authorization keys distributed across multiple servers to sign requests, allowing for multi-signature setups

Learn more about how to create key quorums and sign requests with the guides below.

<CardGroup cols={2}>
  <Card title="Create key quorums" href="/controls/key-quorum/create">
    Create key quorums from authorization keys.
  </Card>

  <Card title="Sign requests" href="/controls/key-quorum/sign">
    Sign requests with a quorum of *m*-of-*n* keys.
  </Card>
</CardGroup>


# Signing requests with key quorums
Source: https://docs.privy.io/controls/key-quorum/sign



To sign a request with a key quorum:

1. Collect the private keys for a threshold of authorization keys in the key quorum. For example, if your key quorum is configured with an *m*-of-*n* authorization threshold, you must have the private keys for at least *m* of the authorization keys in the key quorum. For users in your key quorum, request the user key per [this guide](/controls/authorization-keys/keys/create/user/request).
2. [Sign the request](/controls/authorization-keys/using-owners/sign) with each authorization key individually.
3. Pass the signatures as a comma-delimited string in the `privy-authorization-signature` header for your requests to the Privy API.

An example request signed by a *2*-of-*n* key quorum might look as follows

<Tabs>
  <Tab title="REST API">
    ```bash  theme={"system"}
    curl --request POST https://api.privy.io/v1/wallets/y5ofctvacjiv53u4hmnqi0e5/rpc \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H "privy-authorization-signature: <insert-authorization-sig1>,<insert-authorization-sig2>" \
    -H 'Content-Type: application/json' \
    -d '{
      "caip2": "eip155:1",
      "method": "eth_sendTransaction",
      "params": {
        "transaction": {
          "to": "0xE3070d3e4309afA3bC9a6b057685743CF42da77C",
          "value": "0x2386f26fc10000",
          "data": "0x"
        }
      }
    }'
    ```
  </Tab>

  <Tab title="NodeJS">
    <Info>
      This guide is for the **`@privy-io/node`** library only, as the feature is not available in the
      **`@privy-io/server-auth`** library.
    </Info>

    Use the [`AuthorizationContext`](/controls/authorization-keys/using-owners/sign/signing-on-the-server) to set the authorization key(s) in the quorum to use for signing the request.

    ```ts title="Example: Using ethereum eth_sendTransaction" focus={22-27} theme={"system"}
    import {PrivyClient} from '@privy-io/node';

    const privyClient = new PrivyClient({
      appId: 'insert-your-app-id',
      appSecret: 'insert-your-app-secret'
    });

    try {
      const caip2 = 'eip155:1'; // Ethereum mainnet
      const response = await privyClient
        .wallets()
        .ethereum()
        .sendTransaction('insert-user-wallet-id', {
          caip2,
          params: {
            transaction: {
              to: '0xE3070d3e4309afA3bC9a6b057685743CF42da77C',
              value: '0x2386f26fc10000',
              data: '0x'
            }
          },
          authorization_context: {
            // Example: building an authorization context for a 2-of-2 key quorum,
            // consisting of a user and authorization key
            authorization_private_keys: ['authorization-key'],
            user_jwts: ['user-jwt']
          }
        });

      const transactionHash = response.hash;
    } catch (error) {
      console.error(error);
    }
    ```
  </Tab>

  <Tab title="Java">
    Use the [`AuthorizationContext` builder](/controls/authorization-keys/using-owners/sign/signing-on-the-server) to set the authorization key(s) in the quorum to use for signing the request.

    ```java title="Example: Using ethereum eth_sendTransaction" focus={9-13,15,23} theme={"system"}
    try {
        String caip2 = "eip155:1"; // Ethereum mainnet
        EthereumSendTransactionRpcInputTransaction txn = EthereumSendTransactionRpcInputTransaction.builder()
            .to("0xE3070d3e4309afA3bC9a6b057685743CF42da77C")
            .value(EthereumSendTransactionRpcInputValue.of("0x2386f26fc10000"))
            .data("0x")
            .build();

        // Example: Building an authorization context for a 2-of-2 key quorum, consisting of a user and authorization key
        AuthorizationContext authorizationContext = AuthorizationContext.builder()
            .addUserJwt("user-jwt")
            .addAuthorizationPrivateKey("authorization-key")
            .build();

        // Pass the authorization context to the method to have the SDK automatically sign the request
        EthereumSendTransactionRpcResponseData response = privyClient
            .wallets()
            .ethereum()
            .sendTransaction(
                walletId,
                caip2,
                txn,
                authorizationContext
            );

        String transactionHash = response.hash();
    } catch (APIException e) {
        String errorBody = e.bodyAsString();
        System.err.println(errorBody);
    } catch (Exception e) {
        System.err.println(e.getMessage());
    }
    ```
  </Tab>

  <Tab title="Rust">
    Use the [`AuthorizationContext`](/controls/authorization-keys/using-owners/sign/signing-on-the-server) to set the authorization key(s) in the quorum to use for signing the request.

    ```rust title="Example: Using ethereum eth_sendTransaction" focus={7-10} theme={"system"}
    use privy_rs::{PrivyClient, AuthorizationContext, JwtUser, PrivateKey, generated::types::*};

    let client = PrivyClient::new(app_id, app_secret)?;

    // Example: Building an authorization context for a 2-of-2 key quorum,
    // consisting of a user and authorization key
    let auth_ctx = AuthorizationContext::new()
        .push(JwtUser(client.clone(), "user-jwt".to_string()))
        .push(PrivateKey("authorization-key".to_string()));

    let request = EthereumSendTransactionRpcInput {
        method: "eth_sendTransaction".to_string(),
        caip2: "eip155:1".to_string(), // Ethereum mainnet
        sponsor: None,
        params: EthereumSendTransactionRpcInputParams {
            transaction: EthereumSendTransactionRpcInputParamsTransaction {
                to: Some("0xE3070d3e4309afA3bC9a6b057685743CF42da77C".to_string()),
                value: Some("0x2386f26fc10000".to_string()),
                data: Some("0x".to_string()),
                gas: None,
                gas_price: None,
                nonce: None,
            }
        }
    };

    let response = client
        .wallets()
        .ethereum()
        .send_transaction("wallet-id", request, &auth_ctx, None)
        .await?;

    let transaction_hash = response.data.transaction_hash;
    println!("Transaction hash: {}", transaction_hash);
    ```

    ### Parameters and Returns

    See the Rust SDK documentation for detailed parameter and return types, including embedded examples:

    * [EthereumService::send\_transaction](https://docs.rs/privy-rs/latest/privy_rs/ethereum/struct.EthereumService.html#method.send_transaction)

    For more details on AuthorizationContext, see the [authorization context guide](/controls/authorization-keys/using-owners/sign/signing-on-the-server#rust).
  </Tab>
</Tabs>

When the API receives the request, Privy validates that:

1. The required number of signatures are provided.
2. All signatures are valid for the request payload.
3. All signatures come from authorization keys in the key quorum for the wallet.

If any validation fails, the request is rejected.


# Policies & controls
Source: https://docs.privy.io/controls/overview



Privy's wallet system offers powerful yet flexible control options that determine who can access and use wallets. These controls serve as the foundation for wallet security while ensuring a seamless user experience.

## Security without compromise

Privy wallets are designed with security at their core. Our approach uses a combination of key splitting (Shamir's secret sharing) and private key reconstitution in secure execution environments to ensure that only authorized parties can access their wallets. Wallets remain fully non-custodial and users ultimately have full control over their assets.

## Flexible owner configurations

Whether you want users to have complete control of their wallets or your application needs to manage certain aspects, Privy's control model can be configured to match your exact requirements. This enables setups like:

* **User self-custody**: Give users full control over their wallets.
* **Session signers**: Users can allow apps to take certain actions on their behalf.
* **Application-managed wallets**: Maintain certain controls at the service level.
* **Shared control**: Require a quorum of parties are required to approve certain actions.

## Robust policies

Policies are rules that govern what actions can be taken with a wallet. Think of them as guardrails that ensure wallets are only used for intended purposes.

* **Transaction limits**: Set maximum amounts that can be transferred.
* **Approved destinations**: Specify recipients where funds can be sent.
* **Contract interactions**: Control which smart contracts can be used.
* **Action parameters**: Define what specific operations are permitted.

Policies help protect users and applications by preventing unauthorized or unintended actions, making them essential for features like payment subscriptions, trading limits, or scheduled transactions.

<img src="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Policies.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=1b18efd9275a116faa8528c2f71c8053" alt="images/Policies.png" data-og-width="1843" width="1843" data-og-height="1317" height="1317" data-path="images/Policies.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Policies.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=da3c4ecb0eaf50dedabc51bbeb65f0db 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Policies.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=016ba7fcbf190bdcc0af2695c8b71fc7 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Policies.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=0f443e1eb1d86d47f2bfe81709560135 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Policies.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=2492f54d29bc68b3350bd2b71fc9fdae 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Policies.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=2198e2cc51916cef64ae09e87b778a77 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Policies.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=aa21bb868b92bdef945cc9d35b004f16 2500w" />

## Enhanced security options

Privy supports additional security measures for sensitive wallet operations include:

* Multi-factor authentication using TOTP, passkeys, and SMS
* Biometric verification
* Hardware security key support
* And more

## Getting started

To learn more about implementing specific controls and policies for your application, explore our detailed documentation on wallet [policies](/controls/policies/overview) and [controls](/controls/authorization-keys/overview).


# Condition sets
Source: https://docs.privy.io/controls/policies/condition-sets



# Overview

Condition sets provide a flexible way to define reusable lists of values that can be referenced in policy conditions.
Instead of hardcoding values directly in policy rules, you can create a named condition set (e.g., "Approved Recipients") and reference it using the `in_condition_set` operator.

This approach offers several benefits:

* **Maintainability**: Update the list of values in one place without modifying policy rules
* **Reusability**: Reference the same condition set across multiple policies and rules
* **Scalability**: Manage large lists of values efficiently
* **Dynamic Updates**: Add or remove values without redeploying policies

## Concepts

Condition sets are defined by three core primitives: condition sets, condition set items, and policy conditions. At a high-level:

* Condition sets are lists of values that can be referenced in policy conditions.
* Condition set items are individual items that belong to a condition set, whose values are directly evaluated against.
* Policy conditions are boolean statements that the policy engine can evaluate RPC requests against (see [Conditions section](/controls/policies/overview#conditions))

## The `in_condition_set` Operator

The `in_condition_set` operator allows you to check if the value of a transaction field exists in a condition set.
This is particularly useful for maintaining allowlists or denylists of addresses, contracts, or other string values.

The `in_condition_set` operator can be configured with a variety of fields and field sources, including `ethereum_transaction.to`, `solana_system_program_instruction.Transfer.to`, etc.

## Create condition sets and items

Refer to the [API reference](/api-reference/condition-sets/create) for creating condition sets and items.

<Tip>
  * Creating a condition set requires an [owner](/controls/authorization-keys/using-owners/overview).
  * Updating condition sets or condition set items with the following endpoints requires
    [authorization signature](/api-reference/authorization-signatures#usage).
    * [`PATCH /v1/condition_sets/{condition_set_id}`](/api-reference/condition-sets/update)
    * [`DELETE /v1/condition_sets/{condition_set_id}`](/api-reference/condition-sets/delete)
    * [`POST /v1/condition_sets/{condition_set_id}/condition_set_items`](/api-reference/condition-sets/condition-set-items/create)
    * [`PUT /v1/condition_sets/{condition_set_id}/condition_set_items`](/api-reference/condition-sets/condition-set-items/update)
    * [`DELETE /v1/condition_sets/{condition_set_id}/condition_set_items/{condition_set_item_id}`](/api-reference/condition-sets/condition-set-items/delete)
  * Deleting a condition set will delete all condition set items that have the same condition set id.
</Tip>

## Condition sets evaluation

When the rules that are associated with the requested RPC method is evaluated:

1. The policy engine extracts the value of the corresponding field from the transaction.
2. If a `ConditionSetItem` item is found with `conditionSetId` and the `value` (the value from the previous step), the condition evaluates to `true`.
3. If all conditions in the rule pass, the rule evaluates to `ALLOW` action.

<Tip>
  The policy engine evaluates the raw value from the transaction directly against values of
  condition set items without any conversion. All `ConditionSetItem`s must be *exactly* the value of
  the field, and is case sensitive.
</Tip>

<Warning>
  If a condition set is deleted, all conditions that evaluate against that condition set will
  evaluate to `false`.
</Warning>

## Example: Allowlist of recipient addresses

This example demonstrates how to create a policy that only allows transactions to approved recipient addresses using a condition set.

### Step 1: Create a condition set

```json  theme={"system"}
POST /v1/condition_sets
{
  "name": "Approved Recipients",
  "owner_id": "asgkan0r7gi0wdbvf9cw8qio"
}
```

Response:

```json  theme={"system"}
{
  "id": "qvah5m2hmp9abqlxdmfiht95",
  "name": "Approved Recipients",
  "owner_id": "asgkan0r7gi0wdbvf9cw8qio",
  "created_at": 1761271537642
}
```

### Step 2: Add approved addresses to the condition set

```json  theme={"system"}
POST /v1/condition_sets/qvah5m2hmp9abqlxdmfiht95/condition_set_items
[
  { "value": "0x5B8b13e8f3E6Ec888e88C77cf039EB6281F21D93" },
  { "value": "0xB00F0759DbeeF5E543Cc3E3B07A6442F5f3928a2" }
]
```

### Step 3: Create a policy rule using the condition set

```json  theme={"system"}
{
  "version": "1.0",
  "name": "example of in_condition_set operator",
  "chain_type": "ethereum",
  "rules": [
    {
      "name": "allow if recipient is in allow_list",
      "action": "ALLOW",
      "method": "eth_sendTransaction",
      "conditions": [
        {
          "field_source": "ethereum_transaction",
          "field": "to",
          "operator": "in_condition_set",
          "value": "qvah5m2hmp9abqlxdmfiht95"
        }
      ]
    }
  ]
}
```

The following transaction is allowed because `0x5B8b13e8f3E6Ec888e88C77cf039EB6281F21D93` is in the condition set.

```json  theme={"system"}
{
  "method": "eth_sendTransaction",
  "params": {
    "transaction": {
      "to": "0x5B8b13e8f3E6Ec888e88C77cf039EB6281F21D93",
      "value": "0x1000000000000000"
    }
  }
}
```

The following transaction denied because `0x0000000000000000000000000000000000000000` is not in the condition set.

```json  theme={"system"}
{
  "method": "eth_sendTransaction",
  "params": {
    "transaction": {
      "to": "0x0000000000000000000000000000000000000000",
      "value": "0x1000000000000000"
    }
  }
}
```

## Example: Denylist of recipient addresses

The example `Allowlist of recipient addresses` functions as a denylist of recipient addresses if the `action` is set to to `DENY` at [step 3](#step-3%3A-create-a-policy-rule-using-the-condition-set).


# null
Source: https://docs.privy.io/controls/policies/create-a-policy



You can create a policy using the Privy Dashboard, the NodeJS SDK, or the REST API.

Policies optionally have owners, which represent the signatures required to modify the policy after creation, see [setting authorization signatures](/api-reference/authorization-signatures).

<Tip>
  We highly recommend specifying owners for your policies to further restrict the parties that can
  modify them. Without an owner, the policies can be updated by your app secret alone.
</Tip>

<Tabs>
  <Tab title="NodeJS">
    Use the **`PrivyClient`**'s **`create`** method from the `policies()` interface to create a new policy.

    ```tsx  theme={"system"}
    const policy = await privy.policies().create({
      name: 'Allow list certain smart contracts',
      version: '1.0',
      chain_type: 'ethereum',
      rules: [
        {
          name: 'Allow list USDC',
          method: 'eth_sendTransaction',
          action: 'ALLOW',
          conditions: [
            {
              field_source: 'ethereum_transaction',
              field: 'to',
              operator: 'eq',
              value: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'
            }
          ]
        }
      ],
      owner_id: 'fmfdj6yqly31huorjqzq38zc'
    });
    ```
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    Use the **`PrivyClient`**'s **`createPolicy`** method to create a new policy.

    ```tsx  theme={"system"}
    const policy = await privy.walletApi.createPolicy({
      name: 'Allowlist certain smart contracts',
      version: '1.0',
      chainType: 'ethereum',
      rules: [
        {
          name: 'Allowlist USDC',
          method: 'eth_sendTransaction',
          action: 'ALLOW',
          conditions: [
            {
              fieldSource: 'ethereum_transaction',
              field: 'to',
              operator: 'eq',
              value: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'
            }
          ]
        }
      ],
      ownerId: 'fmfdj6yqly31huorjqzq38zc'
    });
    ```
  </Tab>

  <Tab title="Java">
    You can create a policy using the Java SDK by using the `policies().create()` method.

    ```java  theme={"system"}
    try {
        // Create a policy rule to allow USDC transfers
        PolicyRule allowUsdc = PolicyRule.builder()
            .name("Allowlist USDC")
            .method(PolicyRuleMethod.ETH_SEND_TRANSACTION)
            .action(Action.ALLOW)
            .conditions(List.of(
                EthereumTransactionCondition.builder()
                    .fieldSource(EthereumTransactionConditionFieldSource.ETHEREUM_TRANSACTION)
                    .field(EthereumTransactionConditionField.TO)
                    .operator(ConditionOperator.EQ)
                    .value(ConditionValue.of("0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"))
                    .build()
            ))
            .build();

        // Create a policy that contains your rules
        PolicyCreateRequestBody policy = PolicyCreateRequestBody.builder()
          .version(Version.ONE_DOT0)
          .name("Allowlist certain smart contracts")
          .chainType(PolicyChainType.ETHEREUM)
          .rules(List.of(
              allowUsdc
          ))
          .build();

        PolicyCreateResponse response = privyClient
            .policies()
            .create(policy);

        if (response.policy().isPresent()) {
          Policy policy = response.policy().get();
          String policyId = policy.id();
        }
    } catch (APIException e) {
        String errorBody = e.bodyAsString();
        System.err.println(errorBody);
    } catch (Exception e) {
        System.err.println(e.getMessage());
    }
    ```

    ### Parameters

    When defining a policy, you may specify the following values on the `PolicyCreateRequestBody` builder:

    <Expandable title="parameters" defaultOpen="true">
      <ParamField path="version" type="Version">
        Version of the policy.
      </ParamField>

      <ParamField path="name" type="String">
        Name to assign to policy.
      </ParamField>

      <ParamField path="chainType" type="PolicyChainType">
        Chain type for wallets that the policy will be applied to.
      </ParamField>

      <ParamField path="rules" type="List<PolicyRule>">
        A list of `Rule` objects describing what rules to apply to each RPC method (e.g.
        `'eth_sendTransaction'`) that the wallet can take. [Learn more about
        `Rules`](/controls/policies/overview#rules).
      </ParamField>

      <ParamField path="owner" type="OwnerInput">
        The owner of the policy. You should specify either an `owner` or an `ownerId`, but not both.
      </ParamField>

      <ParamField path="ownerId" type="String">
        The key quorum ID of the owner of the policy. You should specify either an `owner` or an
        `ownerId`, but not both.
      </ParamField>
    </Expandable>

    ### Returns

    The `PolicyCreateResponse` object contains an optional `policy()` field that contains the created
    policy if the policy was created successfully.

    <ResponseField name="policy()" type="Optional<Policy>">
      The created policy.

      <Expandable title="Policy" defaultOpen="true">
        <ResponseField name="version" type="Version">
          Version of the policy.
        </ResponseField>

        <ResponseField name="name" type="String">
          Name of the policy.
        </ResponseField>

        <ResponseField name="chainType" type="PolicyChainType">
          Chain type of the wallets that the policy will be applied to.
        </ResponseField>

        <ResponseField name="id" type="String">
          Unique ID of the policy.
        </ResponseField>

        <ResponseField name="ownerId" type="String">
          The key quorum ID of the owner of the policy.
        </ResponseField>

        <ResponseField name="createdAt" type="Double">
          The Unix time of when the policy was created.
        </ResponseField>

        <ResponseField name="rules" type="List<PolicyRule>">
          A list of `Rule` objects describing what rules to apply to each RPC method (e.g.
          `'eth_sendTransaction'`) that the wallet can take. [Learn more about
          `Rules`](/controls/policies/overview#rules).
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="Rust">
    Use the **`PrivyClient`**'s **`create`** method from the `policies()` interface to create a new policy.

    ```rust  theme={"system"}
    use privy_rs::{PrivyClient, generated::types::*};

    let client = PrivyClient::new(app_id, app_secret)?;

    // Create policy rules
    let usdc_condition = PolicyRuleCondition {
        field_source: "ethereum_transaction".to_string(),
        field: "to".to_string(),
        operator: "eq".to_string(),
        value: serde_json::Value::String("0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913".to_string()),
    };

    let allow_usdc_rule = PolicyRule {
        name: "Allow list USDC".to_string(),
        method: "eth_sendTransaction".to_string(),
        action: PolicyRuleAction::Allow,
        conditions: vec![usdc_condition],
    };

    let request = CreatePolicyBody {
        name: "Allow list certain smart contracts".to_string(),
        version: "1.0".to_string(),
        chain_type: "ethereum".to_string(),
        rules: vec![allow_usdc_rule],
        owner_id: Some("fmfdj6yqly31huorjqzq38zc".to_string()),
        owner: None,
    };

    let policy = client
        .policies()
        .create(request, &authorization_context)
        .await?;

    println!("Created policy: {}", policy.id);
    ```

    ### Parameters and Returns

    See the Rust SDK documentation for detailed parameter and return types, including embedded examples:

    * [PoliciesClient::create](https://docs.rs/privy-rs/latest/privy_rs/subclients/struct.PoliciesClient.html#method.create)

    For REST API details, see the [API reference](/api-reference/policies/create).
  </Tab>

  <Tab title="REST API">
    To create a new policy, make a `POST` request to:

    ```sh  theme={"system"}
    https://api.privy.io/v1/policies
    ```

    <Tip>
      In the request headers, make sure to include Privy's [required authentication
      headers](/basics/rest-api/setup#authentication) and [headers that may be required for your app's
      wallet API setup](/basics/rest-api/quickstart#2-sign-a-message). You can also include an
      [idempotency key](/api-reference/idempotency-keys) header.
    </Tip>

    ## **Body**

    In the request body, include the following:

    <Expandable title="body attributes" defaultOpen="true">
      <ParamField path="version" type="'1.0'">
        Version of the policy. Currently, 1.0 is the only version.
      </ParamField>

      <ParamField path="name" type="string">
        Name to assign to policy.
      </ParamField>

      <ParamField path="chain_type" type="'ethereum'">
        Chain type for wallets that the policy will be applied to.
      </ParamField>

      <ParamField path="rules" type="Rule">
        A list of `Rule` objects describing what rules to apply to each RPC method (e.g.
        `'eth_sendTransaction'`) that the wallet can take. [Learn more about
        `Rules`](/controls/policies/overview#rules).
      </ParamField>

      <ParamField type="{public_key: string} | null" path="owner">
        The P-256 public key of the owner of the policy. If you provide this, do not specify an owner\_id
        as it will be generated automatically.

        View [this guide](/controls/authorization-keys/owners/overview) to learn more about owners.
      </ParamField>

      <ParamField type="string | null" path="owner_id">
        The key quorum ID of the owner of the policy. If you provide this, do not specify an owner.

        View [this guide](/controls/authorization-keys/owners/overview) to learn more about owners.
      </ParamField>
    </Expandable>

    Once you have successfully created a policy, you can assign that policy to a wallet at [creation](/wallets/wallets/create/create-a-wallet#param-policy-ids).

    ## **Response**

    If the policy is created successfully, the response will include the request body as well as an additional unique `id` field for the policy.

    <Expandable title="response" defaultOpen="true">
      <ResponseField name="id" type="string">
        Unique ID for the policy.
      </ResponseField>

      <ResponseField name="version" type="'1.0'">
        Version of the policy. Currently, 1.0 is the only version.
      </ResponseField>

      <ResponseField name="name" type="string">
        Name to assign to policy.
      </ResponseField>

      <ResponseField name="chain_type" type="'ethereum'">
        Chain type for wallets that the policy will be applied to.
      </ResponseField>

      <ResponseField name="rules" type="Rule[]">
        A list of `Rule` objects describing what rules to apply to each RPC method (e.g.
        `'eth_sendTransaction'`) that the wallet can take. [Learn more about
        `Rules`](/controls/policies/overview#rules).
      </ResponseField>

      <ResponseField type="string | null" name="owner_id">
        The key quorum ID of the owner of the policy, whose signature is required to modify the policy.
      </ResponseField>
    </Expandable>

    ## Example

    As an example, a sample request to create a new `eth_sendTransaction` policy might look like the following:

    ```bash  theme={"system"}
    $ curl --request POST https://api.privy.io/v1/policies \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H "privy-authorization-signature: <authorization-signature-for-request>" \
    -H 'Content-Type: application/json' \
    -d '{
        "version": "1.0",
        "name": "Allowlist certain smart contracts",
        "chain_type": "ethereum",
        "rules": [{
          "name": "Allowlist USDC",
          "method": "eth_sendTransaction",
          "conditions": [
              {
                  "field_source": "ethereum_transaction",
                  "field": "to",
                  "operator": "eq",
                  "value": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"
              }
          ],
          "action": "ALLOW"
        }],
        "owner": {
          "public_key": "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEx4aoeD72yykviK+f/ckqE2CItVIG1rCnvC3/XZ1HgpOcMEMialRmTrqIK4oZlYd1RfxU3za/C9yjhboIuoPD3g=="
        }
    }'
    ```

    A successful response will look like the following:

    ```json  theme={"system"}
    {
      "id": "fmfdj6yqly31huorjqzq38zc",
      "name": "Allowlist certain smart contracts",
      "version": "1.0",
      "chain_type": "ethereum",
      "rules": [
        {
          "name": "Allowlist USDC",
          "method": "eth_sendTransaction",
          "conditions": [
            {
              "field_source": "ethereum_transaction",
              "field": "to",
              "operator": "eq",
              "value": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"
            }
          ],
          "action": "ALLOW"
        }
      ],
      "owner_id": "fmfdj6yqly31huorjqzq38zc"
    }
    ```
  </Tab>
</Tabs>


# Ethereum examples
Source: https://docs.privy.io/controls/policies/example-policies/ethereum



## Allowlist a specific smart contract

```ts {skip-check} theme={"system"}
{
    version: '1.0',
    name: 'Allowlisted contracts',
    chain_type: 'ethereum',
    rules: [
        {
            name: 'Allowlist the USDC address',
            method: 'eth_sendTransaction',
            action: 'ALLOW',
            conditions: [
                {
                    field_source: 'ethereum_transaction',
                    field: 'to',
                    operator: 'eq',
                    value: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'
                },
            ]
        },
        {
            name: 'Allowlist for Base specifically',
            method: 'eth_signTypedData_v4',
            action: 'ALLOW',
            conditions: [
                {
                    field_source: 'ethereum_typed_data_domain',
                    field: 'chainId',
                    operator: 'eq',
                    value: '8453'
                }
            ]
        }
    ],
}
```

## Configure a max transfer value of ETH

```ts {skip-check} theme={"system"}
{
    version: '1.0',
    name: 'Native token transfer maximums',
    chain_type: 'ethereum',
    rules: [{
        name: 'Restrict ETH transfers to a maximum value',
        method: 'eth_sendTransaction',
        conditions: [
            {
                field_source: 'ethereum_transaction',
                field: 'value',
                operator: 'lte',
                value: '0x2386F26FC10000',
            },
        ],
        action: 'ALLOW'
    }]
}
```

## Configure a max transfer value of an ERC20 token

```ts {skip-check} theme={"system"}
{
    version: '1.0',
    name: 'ERC20 maximums',
    chain_type: 'ethereum',
    rules: [
        {
            name: 'Restrict USDC transfers on Base to be less than or equal to some value',
            method: 'eth_sendTransaction',
            conditions: [
                {
                    field_source: 'ethereum_transaction',
                    field: 'to',
                    operator: 'eq',
                    value: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'
                },
                {
                    field_source: 'ethereum_calldata',
                    // 'transfer' must match the function name, 'amount' must match an input name.
                    field: 'transfer.amount',
                    abi: [{
                        "inputs": [
                            {
                                "internalType": "address",
                                "name": "recipient",
                                "type": "address"
                            },
                            {
                                "internalType": "uint256",
                                "name": "amount",
                                "type": "uint256"
                            }
                        ],
                        "name": "transfer",
                        "outputs": [
                            {
                                "internalType": "bool",
                                "name": "",
                                "type": "bool"
                            }
                        ],
                        "stateMutability": "nonpayable",
                        "type": "function"
                    }],
                    operator: 'lte',
                    value: '0x2386F26FC10000',
                }
            ],
            action: 'ALLOW'
        },
        {
            name: 'Specify chain',
            method: 'eth_signTypedData_v4',
            conditions: [{
                field_source: 'ethereum_typed_data_domain',
                field: 'chainId',
                operator: 'eq',
                value: '8453'
            }],
            action: 'ALLOW'
        }
    ]
}
```

## Only allow transfers after a certain start date

```ts {skip-check} theme={"system"}
{
    version: '1.0',
    name: 'Only allow transfers after a certain start date',
    chain_type: 'ethereum',
    rules: [{
        name: 'Only allow transfers after a certain start date',
        method: 'eth_sendTransaction',
        conditions: [{
            field_source: 'system',
            field: 'current_unix_timestamp',
            operator: 'gte',
            value: '1757304000' // 2025-09-08 00:00:00 UTC in seconds since epoch
        }],
        action: 'ALLOW'
    }]
}
```

## Denylist recipients of a transaction

```ts {skip-check} theme={"system"}
{
    version: '1.0',
    name: 'Denylisted addresses',
    chain_type: 'ethereum',
    rules: [{
        name: 'Deny interactions with the USDC contract',
        method: 'eth_sendTransaction',
        conditions: [
            {
                field_source: 'ethereum_transaction',
                field: 'to',
                operator: 'eq',
                value: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'
            },
        ],
        action: 'DENY'
    }]
}
```

## Denylist recipients of a transaction with condition sets

```ts {skip-check} theme={"system"}
{
    version: '1.0',
    name: 'Denylisted addresses with condition set',
    chain_type: 'ethereum',
    rules: [{
        name: 'Deny interactions with the USDC contract',
        method: 'eth_sendTransaction',
        conditions: [
            {
                field_source: 'ethereum_transaction',
                field: 'to',
                operator: 'in_condition_set',
                value: 'a2p4etpcbj2dltbjfigybi8j'
            },
        ],
        action: 'DENY' // Note: setting the action to 'ALLOW' makes this an allowlist
    }]
}
```

## Enforce policies across multiple RPC methods

```ts {skip-check} theme={"system"}
{
    version: '1.0',
    name: 'Example policy with multiple RPC methods',
    chain_type: 'ethereum',
    rules: [{
        name: 'Deny interactions with the USDC contract',
        method: 'eth_sendTransaction',
        conditions: [
            {
                field_source: 'ethereum_transaction',
                field: 'to',
                operator: 'eq',
                value: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'
            },
        ],
        action: 'DENY'
    }, {
        name: 'Only allow certain messages to be signed',
        method: 'personal_sign',
        conditions: [
            {
                field_source: 'ethereum_message',
                field: 'value',
                operator: 'eq',
                value: 'Hello world'
            },
        ],
        action: 'ALLOW'
    }]
}
```

## Deny all requests

```ts {skip-check} theme={"system"}
{
    version: '1.0',
    name: 'Example policy to deny all requests',
    chain_type: 'ethereum',
    rules: [{
        name: 'Deny all requests',
        method: '*',
        conditions: [],
        action: 'DENY'
    }]
}
```

## Restrict typed data domains to a specific chain ID and verifying contract

```ts {skip-check} theme={"system"}
{
    version: '1.0',
    name: 'Example policy to allow a specific signing domain',
    chain_type: 'ethereum',
    rules: [{
        name: 'Allow specific domain to sign messages',
        method: 'eth_signTypedData_v4',
        conditions: [
            {
                field_source: 'ethereum_typed_data_domain',
                field: 'chainId',
                operator: 'eq',
                value: '8453'
            },
            {
                field_source: 'ethereum_typed_data_domain',
                field: 'verifyingContract',
                operator: 'eq',
                value: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'
            }
        ],
        action: 'ALLOW'
    }],
}
```

## Restrict parameters of a typed data message

```ts {skip-check} theme={"system"}
{
    version: '1.0',
    name: 'Allow ERC20 Permits for known owners, max value',
    chain_type: 'ethereum',
    rules: [{
        name: 'Allow specific owner addresses and a max value',
        method: 'eth_signTypedData_v4',
        conditions: [
            {
                field_source: 'ethereum_typed_data_message',
                typed_data: {
                    types: {
                        Person: [
                            {name: 'name', type: 'string'},
                            {name: 'wallet', type: 'address'},
                        ],
                        Permit: [
                            {name: 'owner', type: 'Person'},
                            {name: 'spender', type: 'Person'},
                            {name: 'value', type: 'uint256'},
                            {name: 'deadline', type: 'uint256'},
                            {name: 'v', type: 'uint8'},
                            {name: 'r', type: 'bytes32'},
                            {name: 's', type: 'bytes32'},
                        ],
                    },
                    primary_type: 'Permit',
                },
                field: 'owner.wallet', // dot-separated path to primitive 'address' type that 'value' will be compared against.
                operator: 'in',
                value: ['0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', '0x123589fCD6eDb6E08f4c7C32D4f71b54bdA02911'],
            },
            {
                field_source: 'ethereum_typed_data_message',
                typed_data: {
                    types: {
                        Person: [
                            {name: 'name', type: 'string'},
                            {name: 'wallet', type: 'address'},
                        ],
                        Permit: [
                            {name: 'owner', type: 'Person'},
                            {name: 'spender', type: 'Person'},
                            {name: 'value', type: 'uint256'},
                            {name: 'deadline', type: 'uint256'},
                            {name: 'v', type: 'uint8'},
                            {name: 'r', type: 'bytes32'},
                            {name: 's', type: 'bytes32'},
                        ],
                    },
                    primary_type: 'Permit',
                },
                field: 'value',
                operator: 'lte',
                value: '0x2386F26FC10000',
            },
        ],
        action: 'ALLOW'
    }],
}
```

## Restrict the delegation contract for EIP-7702

```ts {skip-check} theme={"system"}
{
    version: '1.0',
    name: 'Restrict EIP-7702 delegation contracts',
    chain_type: 'ethereum',
    rules: [{
        name: 'Allow only specific delegation contracts',
        method: 'eth_sign7702Authorization',
        conditions: [
            {
                field_source: 'ethereum_7702_authorization',
                field: 'contract',
                operator: 'in',
                value: ['0xf5De540DabE85ecA73D61C4004cF2c243bbf4a5B']
            }
        ],
        action: 'ALLOW'
    }]
}
```

## Prevent private key exports while allowing other actions

```ts {skip-check} theme={"system"}
{
    version: '1.0',
    name: 'Prevent private key exports',
    chain_type: 'ethereum',
    rules: [
        {
            name: 'Block private key exports',
            method: 'exportPrivateKey',
            conditions: [],
            action: 'DENY'
        },
        {
            name: 'Allow all other actions',
            method: '*',
            conditions: [],
            action: 'ALLOW'
        }
    ]
}
```

## Only permit private key exports

```ts {skip-check} theme={"system"}
{
    version: '1.0',
    name: 'Only allow private key exports',
    chain_type: 'ethereum',
    rules: [
        {
            name: 'Allow private key exports',
            method: 'exportPrivateKey',
            conditions: [],
            action: 'ALLOW'
        },
        {
            name: 'Block all other actions',
            method: '*',
            conditions: [],
            action: 'DENY'
        }
    ]
}
```

## Anti patterns

### Avoid adding rules that may override other rules

```ts {skip-check} theme={"system"}
{
    version: '1.0',
    name: 'Restrict the maximum value of ETH transfers',
    chain_type: 'ethereum',
    rules: [
        {
            // This rule restricts the value of ETH transfers.
            name: 'Restrict ETH transfers to 1',
            method: 'eth_sendTransaction',
            conditions: [
                {
                    field_source: 'ethereum_transaction',
                    field: 'value',
                    operator: 'lte',
                    value: '1'
                }
            ],
            action: 'ALLOW'
        },
        {
            name: 'Restrict ETH transfers to 5',
            method: 'eth_sendTransaction',
            conditions: [
                // This rule will override the previous rule by allowing a 5 ETH transfer.
                {
                    field_source: 'ethereum_transaction',
                    field: 'value',
                    operator: 'lte',
                    value: '5'
                }
            ],
            action: 'ALLOW'
        }
    ]
}
```


# Solana examples
Source: https://docs.privy.io/controls/policies/example-policies/solana



## Allowlist specific Solana Programs

```ts {skip-check} theme={"system"}
{
    version: '1.0',
    name: 'Allowlisted programs',
    chain_type: 'solana',
    rules: [{
        name: 'Allowlist the Compute Budget Program and System Program',
        method: 'signAndSendTransaction',
        conditions: [
            {
                // This field_source is used only to allowlist Solana Programs.
                field_source: 'solana_program_instruction',
                field: 'programId',
                operator: 'in',
                value: ['ComputeBudget111111111111111111111111111111', '11111111111111111111111111111111']
            }
        ],
        action: 'ALLOW'
    }]
}
```

## Allow a SOL Transfer instruction with a max value

```ts {skip-check} theme={"system"}
{
    version: '1.0',
    name: 'SOL transfer maximums',
    chain_type: 'solana',
    rules: [{
        name: 'Restrict SOL transfers to a maximum value',
        method: 'signAndSendTransaction',
        conditions: [
            {
                // This field_source is used for all System Program instructions.
                field_source: 'solana_system_program_instruction',
                field: 'Transfer.lamports',
                operator: 'lte',
                value: '1000000000' // 1 SOL
            },
        ],
        action: 'ALLOW'
    }]
}
```

## Allow sending Solana transactions within a time window

```ts {skip-check} theme={"system"}
{
    version: '1.0',
    name: 'Time-bound Solana transactions policy',
    chain_type: 'solana',
    rules: [{
        name: 'Allow Solana transactions only during the month of September 2025',
        method: 'signAndSendTransaction',
        conditions: [{
            field_source: 'system',
            field: 'current_unix_timestamp',
            operator: 'gte',
            value: '1756699200' // 2025-09-01 00:00:00 UTC in seconds since epoch
        }, {
            field_source: 'system',
            field: 'current_unix_timestamp',
            operator: 'lt',
            value: '1759291200' // 2025-10-01 00:00:00 UTC in seconds since epoch
        }],
        action: 'ALLOW'
    }]
}
```

### Allow a SOL Transfer instruction with a max value to allowlisted recipients

```ts {skip-check} theme={"system"}
{
    version: '1.0',
    name: 'Restrict SOL transfers to a specific recipient',
    chain_type: 'solana',
    rules: [{
        name: 'Restrict SOL transfers to a maximum value to a specific recipient',
        method: 'signAndSendTransaction',
        conditions: [
            {
                // This condition restricts the value of all SOL transfers to <= 1 SOL.
                // This field_source is used for all System Program instructions.
                field_source: 'solana_system_program_instruction',
                field: 'Transfer.lamports',
                operator: 'lte',
                value: '1000000000' // 1 SOL
            },
            {
                // This additional condition restricts Transfer recipients to a list of allowed addresses.
                // This field_source is used for all System Program instructions.
                field_source: 'solana_system_program_instruction',
                field: 'Transfer.to',
                operator: 'in',
                value: ['4tFqt2qzaNsnZqcpjPiyqYw9LdRzxaZdX2ewPncYEWLA', '4tFqt2qzaNsnZqcpjPiyqYw9LdRzxaZdX2ewPncYEWLA']
            }
        ],
        action: 'ALLOW'
    }]
}
```

### Allow a Solana Transaction that has a Create and Transfer instruction, while limiting Transfers to 1 SOL

```ts {skip-check} theme={"system"}
{
    version: '1.0',
    name: 'SOL transfer maximums',
    chain_type: 'solana',
    rules: [
        {
            // This rule restricts the value of all SOL transfer instructions to <= 1 SOL.
            name: 'Restrict SOL transfers to a maximum value',
            method: 'signAndSendTransaction',
            conditions: [{
                // This field_source is used for all System Program instructions.
                field_source: 'solana_system_program_instruction',
                field: 'Transfer.lamports',
                operator: 'lte',
                value: '1000000000' // 1 SOL
            }],
            action: 'ALLOW'
        },
        {
            // This rule allows the Create instruction to be present in the transaction.
            name: 'Allow the Create instruction',
            method: 'signAndSendTransaction',
            conditions: [
                {
                    // This field_source is used for all System Program instructions.
                    field_source: 'solana_system_program_instruction',
                    field: 'instructionName',
                    operator: 'eq',
                    value: 'Create'
                }
            ],
            action: 'ALLOW'
        }
    ]
}
```

## Allow a TransferChecked instruction with a max value of a USDC token

```ts {skip-check} theme={"system"}
{
    version: '1.0',
    name: 'Restrict USDC transfers to a maximum value',
    chain_type: 'solana',
    rules: [{
        name: 'Restrict transfers to be less than or equal to 5 USDC',
        method: 'signAndSendTransaction',
        conditions: [
            {
                // This field_source is used for all Token Program instructions.
                field_source: 'solana_token_program_instruction',
                field: 'TransferChecked.mint',
                operator: 'eq',
                // This is the USDC mint address on the Solana mainnet.
                value: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'
            },
            {
                // This field_source is used for all Token Program instructions.
                field_source: 'solana_token_program_instruction',
                field: 'TransferChecked.amount',
                operator: 'lte',
                value: '5000000' // 5 USDC assuming 6 decimals
            },
        ],
        action: 'ALLOW'
    }]
}
```

## Denylist recipients of a transaction

```ts {skip-check} theme={"system"}
{
    version: '1.0',
    name: 'Denylist recipients of SOL transfer',
    chain_type: 'solana',
    rules: [{
        name: 'Deny SOL transfers to a list of addresses',
        method: 'signAndSendTransaction',
        conditions: [
            {
                // This field_source is used for all System Program instructions.
                field_source: 'solana_system_program_instruction',
                field: 'Transfer.to',
                operator: 'in',
                value: ['4tFqt2qzaNsnZqcpjPiyqYw9LdRzxaZdX2ewPncYEWLA', '4tFqt2qzaNsnZqcpjPiyqYw9LdRzxaZdX2ewPncYEWLA']
            },
        ],
        action: 'DENY'
    }]
}
```

## Allowlist some System Program instructions and some Token Program instructions

```ts {skip-check} theme={"system"}
{
    version: '1.0',
    name: 'Allowlist all System Program instructions and some Token Program instructions',
    chain_type: 'solana',
    rules: [
        {
            name: 'Allowlist System Program instructions',
            method: 'signAndSendTransaction',
            conditions: [
                {
                    // This field_source is used for all System Program instructions.
                    field_source: 'solana_system_program_instruction',
                    field: 'instructionName',
                    operator: 'in',
                    value: ['Create', 'Transfer']
                }
            ],
            action: 'ALLOW'
        },
        {
            name: 'Allowlist Token Program instructions',
            method: 'signAndSendTransaction',
            conditions: [
                {
                    // This field_source is used for all Token Program instructions.
                    field_source: 'solana_token_program_instruction',
                    field: 'instructionName',
                    operator: 'in',
                    value: ['TransferChecked', 'CloseAccount']
                }
            ],
            action: 'ALLOW'
        }
    ]
}
```

## Allowlist some Solana Programs and restrict SOL transfers

```ts {skip-check} theme={"system"}
{
    version: '1.0',
    name: 'Allowlist some Solana Programs and restrict SOL transfers',
    chain_type: 'solana',
    rules: [
        {
            name: 'Allowlist Programs',
            method: 'signAndSendTransaction',
            conditions: [
                {
                    field_source: 'solana_program_instruction',
                    field: 'programId',
                    operator: 'in',
                    value: [
                        'ComputeBudget111111111111111111111111111111', // Compute Budget Program
                        'JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4' // Jupiter v6 Swap Program
                    ]
                }
            ],
            action: 'ALLOW'
        },
        {
            name: 'Restrict SOL transfers',
            method: 'signAndSendTransaction',
            conditions: [
                {
                    field_source: 'solana_system_program_instruction',
                    field: 'Transfer.lamports',
                    operator: 'lte',
                    value: '1000000000' // 1 SOL
                }
            ],
            action: 'ALLOW'
        }
    ]
}
```

## Prevent private key exports while allowing other actions

```ts {skip-check} theme={"system"}
{
    version: '1.0',
    name: 'Prevent private key exports',
    chain_type: 'solana',
    rules: [
        {
            name: 'Block private key exports',
            method: 'exportPrivateKey',
            conditions: [],
            action: 'DENY'
        },
        {
            name: 'Allow all other actions',
            method: '*',
            conditions: [],
            action: 'ALLOW'
        }
    ]
}
```

## Only permit private key exports

```ts {skip-check} theme={"system"}
{
    version: '1.0',
    name: 'Only allow private key exports',
    chain_type: 'solana',
    rules: [
        {
            name: 'Allow private key exports',
            method: 'exportPrivateKey',
            conditions: [],
            action: 'ALLOW'
        },
        {
            name: 'Block all other actions',
            method: '*',
            conditions: [],
            action: 'DENY'
        }
    ]
}
```

## Anti patterns

### Avoid adding rules that may override other rules

```ts {skip-check} theme={"system"}
{
    version: '1.0',
    name: 'Allowlist the System Program Transfer instruction and restrict SOL transfers',
    chain_type: 'solana',
    rules: [
        {
            // This rule restricts the value of all SOL transfers.
            name: 'Restrict SOL transfers',
            method: 'signAndSendTransaction',
            conditions: [
                {
                    field_source: 'solana_system_program_instruction',
                    field: 'Transfer.lamports',
                    operator: 'lte',
                    value: '1000000000' // 1 SOL
                }
            ],
            action: 'ALLOW'
        },
        {
            name: 'Allowlist System Program Transfer instruction',
            method: 'signAndSendTransaction',
            conditions: [
                // This rule will override the previous rule by allowing all Transfer instructions via the System Program.
                {
                    field_source: 'solana_system_program_instruction',
                    field: 'instructionName',
                    operator: 'eq',
                    value: 'Transfer'
                }
            ],
            action: 'ALLOW'
        }
    ]
}
```


# Time-bound examples
Source: https://docs.privy.io/controls/policies/example-policies/timebound



## Enable a signer to take any wallet action until a certain date

```ts {skip-check} theme={"system"}
{
    version: '1.0',
    name: 'Time-bound session signer policy', // to be set as override_policy for the session signer
    chain_type: 'ethereum',
    rules: [{
        name: 'Allow all actions before 9/8/2026',
        method: '*',
        conditions: [{
            field_source: 'system',
            field: 'current_unix_timestamp',
            operator: 'lt',
            value: '1788840000' // 2026-09-08 00:00:00 UTC in seconds since epoch
        }],
        action: 'ALLOW'
    }]
}
```

## Only permit private key exports within a time window

```ts {skip-check} theme={"system"}
{
    version: '1.0',
    name: 'Only allow private key exports within a time window',
    chain_type: 'solana',
    rules: [
        {
            name: 'Allow private key exports between 9/8/2025 and 10/8/2025',
            method: 'exportPrivateKey',
            conditions: [
                {
                    field_source: 'system',
                    field: 'current_unix_timestamp',
                    operator: 'gte',
                    value: '1757304000' // 2025-09-08 00:00:00 UTC in seconds since epoch
                },
                {
                    field_source: 'system',
                    field: 'current_unix_timestamp',
                    operator: 'lte',
                    value: '1759896000' // 2025-10-08 00:00:00 UTC in seconds since epoch
                }
            ],
            action: 'ALLOW'
        },
        {
            name: 'Block all other actions',
            method: '*',
            conditions: [],
            action: 'DENY'
        }
    ]
}
```


# null
Source: https://docs.privy.io/controls/policies/get-a-policy



<Tabs>
  <Tab title="NodeJS">
    Use the **`PrivyClient`**'s **`get`** method from the `policies()` interface to get a policy by its ID.

    ```tsx  theme={"system"}
    const policy = await privy.policies().get('fmfdj6yqly31huorjqzq38zc');
    ```
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    Use the **`PrivyClient`**'s **`getPolicy`** method to get a policy by its ID.

    ```tsx  theme={"system"}
    const policy = await privy.getPolicy({
      id: 'fmfdj6yqly31huorjqzq38zc'
    });
    ```
  </Tab>

  <Tab title="Java">
    You can get a policy using the Java SDK by using the `policies().retrieve()` method.

    ```java  theme={"system"}
    try {
        PolicyRetrieveResponse response = privyClient
            .policies()
            .retrieve("fmfdj6yqly31huorjqzq38zc");

        if (response.policy().isPresent()) {
          Policy policy = response.policy().get();
          String policyId = policy.id();
        }
    } catch (APIException e) {
        String errorBody = e.bodyAsString();
        System.err.println(errorBody);
    } catch (Exception e) {
        System.err.println(e.getMessage());
    }
    ```

    ### Parameters

    <ParamField path="id" type="String">
      The ID of the policy to retrieve.
    </ParamField>

    ### Returns

    The `PolicyRetrieveResponse` object contains an optional `policy()` field that contains the retrieved
    policy if the policy was retrieved successfully.

    <ResponseField name="policy()" type="Optional<Policy>">
      The retrieved policy.

      <Expandable title="Policy">
        <ResponseField name="version" type="Version">
          Version of the policy.
        </ResponseField>

        <ResponseField name="name" type="String">
          Name of the policy.
        </ResponseField>

        <ResponseField name="chainType" type="PolicyChainType">
          Chain type of the wallets that the policy will be applied to.
        </ResponseField>

        <ResponseField name="id" type="String">
          Unique ID of the policy.
        </ResponseField>

        <ResponseField name="ownerId" type="String">
          The key quorum ID of the owner of the policy.
        </ResponseField>

        <ResponseField name="createdAt" type="Double">
          The Unix time of when the policy was created.
        </ResponseField>

        <ResponseField name="rules" type="List<PolicyRule>">
          A list of `Rule` objects describing what rules to apply to each RPC method (e.g.
          `'eth_sendTransaction'`) that the wallet can take. [Learn more about
          `Rules`](/controls/policies/overview#rules).
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="Rust">
    Use the **`PrivyClient`**'s **`get`** method from the `policies()` interface to get a policy by its ID.

    ```rust  theme={"system"}
    use privy_rs::PrivyClient;

    let client = PrivyClient::new(app_id, app_secret)?;

    let policy = client
        .policies()
        .get("fmfdj6yqly31huorjqzq38zc")
        .await?;

    println!("Policy: {}", policy.name);
    println!("Rules: {:?}", policy.rules);
    ```

    ### Parameters and Returns

    See the Rust SDK documentation for detailed parameter and return types, including embedded examples:

    * [PoliciesClient::get](https://docs.rs/privy-rs/latest/privy_rs/subclients/struct.PoliciesClient.html#method.get)

    For REST API details, see the [API reference](/api-reference/policies/get).
  </Tab>

  <Tab title="REST API">
    To get a policy by its ID, make a `GET` request to:

    ```bash  theme={"system"}
    https://api.privy.io/v1/policies/<policy_id>
    ```

    Replacing `<policy_id>` with the ID of your desired policy.

    ## **Response**

    A successful response will return the following fields:

    <ResponseField name="id" type="string">
      Unique ID for the policy.
    </ResponseField>

    <ResponseField name="version" type="'1.0'">
      Version of the policy. Currently, 1.0 is the only version.
    </ResponseField>

    <ResponseField name="name" type="string">
      Name to assign to policy.
    </ResponseField>

    <ResponseField name="chain_type" type="'ethereum'">
      Chain type for wallets that the policy will be applied to.
    </ResponseField>

    <ResponseField name="rules" type="Rule[]">
      A list of `Rule` objects describing what rules to apply to each RPC method (e.g.
      `'eth_sendTransaction'`) that the wallet can take. [Learn more about
      `Rules`](/controls/policies/overview#rules).
    </ResponseField>

    <ResponseField type="string | null" name="owner_id">
      The key quorum ID of the owner of the policy, whose signature is required to modify the policy.
    </ResponseField>

    ## Example

    A sample request to fetch a policy with ID `fmfdj6yqly31huorjqzq38zc` looks like:

    ```bash  theme={"system"}
    curl --request GET https://api.privy.io/v1/policies/fmfdj6yqly31huorjqzq38zc \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>"
    ```

    ## Response

    A successful response will look like the following:

    ```json  theme={"system"}
    {
      "id": "fmfdj6yqly31huorjqzq38zc",
      "name": "Allowlist certain smart contracts",
      "version": "1.0",
      "chain_type": "ethereum",
      "rules": [
        {
          "name": "Allowlist USDC",
          "method": "eth_sendTransaction",
          "conditions": [
            {
              "field_source": "ethereum_transaction",
              "field": "to",
              "operator": "eq",
              "value": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"
            }
          ],
          "action": "ALLOW"
        }
      ],
      "owner_id": "fmfdj6yqly31huorjqzq38zc"
    }
    ```
  </Tab>
</Tabs>


# Overview
Source: https://docs.privy.io/controls/policies/overview



Privy's **policy engine** allows your application to restrict the actions that can be taken with wallets.

Policies enable you to configure:

* Transfer limits
* Time-bound signers
* Allowlists and denylists of transfer recipients
* Allowlists and denylists of smart contracts and programs
* Allowlists and denylists of networks
* Allowed time window for key export
* Granular constraints around calldata and parameters that can be passed to smart contracts
* Restrictions around signatures needed for transactions, such as EVM typed data (EIP712)

This ensures that wallets can only ever be used to take actions your application intends to take.

<img src="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/policy-splash.png?fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=989f6a61de268b5e232a8b8401d77737" alt="Managing policies in the Privy Dashboard" data-og-width="1192" width="1192" data-og-height="852" height="852" data-path="images/policy-splash.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/policy-splash.png?w=280&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=7bf0ceb9a0d4646bb7f0478f6788e68c 280w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/policy-splash.png?w=560&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=7de15091f47ede52324d91ffe9ae796e 560w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/policy-splash.png?w=840&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=771e517bf3b5814336a0b8917bdbe51d 840w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/policy-splash.png?w=1100&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=94d10f809f89f639e2258aec613aca7f 1100w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/policy-splash.png?w=1650&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=be5ff30c16cc8eed4860351d903e81d1 1650w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/policy-splash.png?w=2500&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=57d63fe2e9f470ca977ecb1a0634488b 2500w" />

# Concepts

Policies are defined by three core primitives: **policies**, **rules**, and **conditions**. At a high-level:

* **Policies** are a list of rules that define the total set of actions that are allowed or denied for a wallet.
* **Rules** are a set of conditions, such that if a request satisfies all of the conditions in a rule, the policy engine executes the action (`ALLOW` or `DENY`) prescribed by the rule.
* **Conditions** are boolean statements that the policy engine can evaluate RPC requests against.

You can create and manage policies through the [Privy Dashboard](https://dashboard.privy.io), `nodeJS` [SDK](/controls/policies/create-a-policy), or via the [REST API](/controls/policies/create-a-policy).

## Policies

A **policy** is composed from a **list of rules for each RPC method that a wallet can execute** that define what actions are allowed or denied for the wallet. `DENY` actions take precedence over `ALLOW` actions. If no rules resolve, the policy will default to `DENY`.

Policy objects have the following properties:

<Expandable title="child attributes" defaultOpen="true">
  <ResponseField name="version" type="'1.0'">
    Version of the policy. Currently, 1.0 is the only version.
  </ResponseField>

  <ResponseField name="name" type="string">
    Name to assign to policy.
  </ResponseField>

  <ResponseField name="chain_type" type="'ethereum' | 'solana'">
    Chain type for wallets that the policy will be applied to.
  </ResponseField>

  <ResponseField name="rules" type="Rule[]">
    A list of `Rule` objects describing what rules to apply to each RPC method (e.g.
    `'eth_sendTransaction'`) that the wallet can take.
  </ResponseField>
</Expandable>

### Policy evaluation

When your application makes an RPC request on a wallet that has a policy, the policy engine evaluates the `rules` that are associated with the requested RPC method.

For instance, if your application makes an `'eth_signTransaction'` request, the policy engine will only evalaute rules associated with the `'eth_signTransaction'` method in the policy.

The rules are evaluated as follows:

1. If **any** rule evaluates to a `DENY` action, the policy engine will `DENY` the request.
2. If **any** rule evaluates to an `ALLOW` action, and **no** rules evaluate to `DENY`, then the policy engine will `ALLOW` the request.

If the request does not satisfy *any* of the rules for the policy, the policy engine defaults to `DENY` the request.

This also applies to Solana transactions such that every Instruction in a Solana transaction is evaluated against the rules of the policy. Every instruction must evaluate to an `ALLOW` action for the transaction to be allowed.

<Info>
  If your application makes a request to a wallet with RPC method `X`, and the policy's `rules`
  contains no entry with a `method` corresponding to `X`, the engine will deny the request by
  default. If you'd like the policy engine to instead allow requests for RPC method `X` by default,
  we recommend setting up an "Allow all" `Rule` for that RPC method [like
  so](/controls/policies/example-policies/ethereum#allow-all-requests-for-a-given-rpc-method).
</Info>

## Rules

The nested `Rule` object within the policy's `rules` array. A **rule** is composed of an set of boolean **conditions** and an **action** (`ALLOW` or `DENY`) that is taken if an RPC request satisfies all of the conditions in the rule.
Rule objects have the following fields:

<Expandable title="child attributes" defaultOpen="true">
  <ResponseField name="name" type="string">
    Name to assign to the rule.
  </ResponseField>

  <ResponseField name="method" type="'personal_sign' | 'eth_signTypedData_v4' | 'eth_signTransaction' | 'eth_sendTransaction' | 'eth_sign7702Authorization' | 'signTransaction' | 'signAndSendTransaction' | 'exportPrivateKey' | '*'">
    Method to apply the `conditions` to. If an RPC method, must correspond to the `chain_type` of the
    parent policy.
  </ResponseField>

  <ResponseField name="conditions" type="Condition[]">
    A set of boolean conditions that define the action the rule allows or denies. For
    `exportPrivateKey`, leave `conditions` empty.
  </ResponseField>

  <ResponseField name="action" type="'ALLOW' | 'DENY'">
    Whether the rule should allow or deny a wallet request if it satisfies all of the rule's
    `conditions`.
  </ResponseField>
</Expandable>

Each rule corresponds to an individual action that should be allowed or denied by a wallet. For example, you might configure rules for a policy to:

* `ALLOW` transfers of the native token to a set of allowlisted recipient addresses
* `DENY` interactions with specific Ethereum smart contracts or Solana programs

## Conditions

A **condition** is a boolean statement about a wallet request. When evaluating a wallet request against a rule, the policy engine checks whether the wallet request satisfies each of the boolean conditions in the rule. If all of the conditions are satisfied, the engine executes the action associated with the rule.

Conditions allow you to define specific action types that should be allowed or denied for a wallet.

<Expandable title="child attributes" defaultOpen="true">
  <ResponseField name="field_source" type="'ethereum_transaction' | 'ethereum_calldata' | 'ethereum_typed_data_domain' | 'ethereum_typed_data_message' | 'ethereum_7702_authorization' | 'solana_program_instruction' | 'solana_system_program_instruction' | 'solana_token_program_instruction' | 'system'">
    Data source from which to derive the `field` for the condition.
  </ResponseField>

  <ResponseField name="field" type="string">
    The attribute to evaluate for a wallet request. As an example, the field for the recipient of an
    EVM transaction is `'to'`.
  </ResponseField>

  <ResponseField name="abi" type="JSON">
    Contract ABI to decode Ethereum calldata against. Should only be set for `'ethereum_calldata'`
    policies. Must strictly be formatted as JSON.
  </ResponseField>

  <ResponseField name="operator" type="'eq' | 'neq' | 'lt' | 'lte' | 'gt' | 'gte' | 'in' | 'in_condition_set'">
    Boolean operator used to compare a `field` with a `value`
  </ResponseField>

  <ResponseField name="value" type="string | number | string[]">
    Static value to compare a `field` to.
  </ResponseField>
</Expandable>

Conditions for certain sources may have additional parameters. For instance, `ethereum_calldata` conditions also require an `abi` parameter used to decode the calldata, and `ethereum_typed_data_message` conditions require a `typed_data` parameter to define the schema for the typed data message.

### Field

**Fields** are attributes of a wallet request that can be parsed or interpreted from the wallet request. Examples of fields include the `to` parameter of an EVM transaction, the `fee_payer` parameter of a Solana transaction, or an `spl_transfer_recipient` field that is populated when the policy engine interprets a transaction.

Fields are derived from **field sources**, which surface data from the wallet request. Possible field sources are listed below.

| Field source                          | Description                                                                                                                                                                                                             | Example fields                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| ------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `'ethereum_transaction'`              | The verbatim Ethereum transaction object in an `eth_signTransaction` or `eth_sendTransaction` request.                                                                                                                  | `to`, `value`.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| `'ethereum_calldata'`                 | The decoded calldata in a smart contract interaction as the smart contract method's parameters. Note that that `'ethereum_calldata'` conditions must contain an `abi` parameter with the JSON ABI of the smart contract | `function_name`, `_to`, `_value` (for a ERC20 interaction)                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| `'ethereum_typed_data_domain'`        | Attributes from the signing domain that will verify the signature.                                                                                                                                                      | `chainId`, `verifyingContract`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| `'ethereum_typed_data_message'`       | `types` and `primary_type` attributes of the TypedData JSON object defined in [EIP-712](https://eips.ethereum.org/EIPS/eip-712#specification-of-the-eth_signtypeddata-json-rpc).                                        | dot-separated path to value in `message` object, i.e. `to.wallet`                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| `'ethereum_7702_authorization'`       | EIP-7702 authorization data from an `eth_sign7702Authorization` request.                                                                                                                                                | `contract`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| `'solana_program_instruction'`        | Solana program instruction from a `signTransaction` or `signAndSendTransaction` request.                                                                                                                                | `programId`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `'solana_system_program_instruction'` | Fields relevant to the Solana System Program and its Transfer instruction.                                                                                                                                              | `instructionName`, `Transfer.to`, `Transfer.from`, `Transfer.lamports`                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| `'solana_token_program_instruction'`  | Fields relevant to the SPL Token Program and its supported instructions: Transfer, TransferChecked, Burn, MintTo, CloseAccount, and InitializeAccount3.                                                                 | `instructionName`, `Transfer.source`, `Transfer.destination`, `Transfer.authority`, `Transfer.amount`, `TransferChecked.source`, `TransferChecked.destination`, `TransferChecked.authority`, `TransferChecked.amount`, `Burn.account`, `Burn.mint`, `Burn.authority`, `Burn.amount`, `MintTo.mint`, `MintTo.account`, `MintTo.authority`, `MintTo.amount`, `CloseAccount.account`, `CloseAccount.destination`, `CloseAccount.authority`, `InitializeAccount3.account`, `InitializeAccount3.mint`, `InitializeAccount3.authority` |
| `'system'`                            | Chain-agnostic system fields, such as the current timestamp at the time of the request.                                                                                                                                 | `current_unix_timestamp`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |

### Operator

**Operators** are boolean operators used to compare fields and values. Operators include `eq`, `neq`, `lt`, `lte`, `gt`, `gte`, `in`, and `in_condition_set`.

<Tip>
  The `in` operator can be configured with up to 100 values. Consider `in_condition_set` operator if
  you need more.
</Tip>

### Values

A condition compares a field using its boolean operator to a static **value**. As an example, if a condition determines whether an Ethereum transaction has specific recipient address `X`, the value for the condition is `X`.


# Update a policy
Source: https://docs.privy.io/controls/policies/update-a-policy



You can update a policy by updating rules one at a time, or by updating the whole policy at once. You can do this using the Privy Dashboard, the NodeJS SDK, or the REST API.

If a policy has an owner, the owner's signature is required to modify the policy, see [setting authorization signatures](/api-reference/authorization-signatures).

## Updating policy rules individually

You can create, get, update, and delete individual rules in a policy. We recommend this over updating the whole policy at once, especially if you find yourself updating the same policy over time. This way, you can ensure there would be no race conditions when updating the policy.

### Add a rule to a policy

<Tabs>
  <Tab title="NodeJS">
    Use the **`PrivyClient`**'s **`createRule`** method in the `policies()` interface to add a rule to a policy.

    ```tsx  theme={"system"}
    const rule = await client.policies().createRule('insert-policy-id', {
      name: 'Allow list USDT',
      method: 'eth_sendTransaction',
      conditions: [
        {
          field_source: 'ethereum_transaction',
          field: 'to',
          operator: 'eq',
          value: '0xdAC17F958D2ee523a2206206994597C13D831ec7'
        }
      ],
      action: 'ALLOW'
    });
    ```
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    Use the **`PrivyClient`**'s **`addRuleToPolicy`** method to add a rule to a policy.

    ```tsx  theme={"system"}
    const rule = await client.walletApi.addRuleToPolicy({
      policyId: 'fmfdj6yqly31huorjqzq38zc',
      name: 'Allowlist USDT',
      method: 'eth_sendTransaction',
      conditions: [
        {
          fieldSource: 'ethereum_transaction',
          field: 'to',
          operator: 'eq',
          value: '0xdAC17F958D2ee523a2206206994597C13D831ec7'
        }
      ],
      action: 'ALLOW'
    });
    ```
  </Tab>

  <Tab title="Rust">
    Use the **`PrivyClient`**'s **`create_rule`** method in the `policies()` interface to add a rule to a policy.

    ```rust  theme={"system"}
    use privy_rs::{PrivyClient, generated::types::*};

    let client = PrivyClient::new(app_id, app_secret)?;

    let usdt_condition = PolicyRuleCondition {
        field_source: "ethereum_transaction".to_string(),
        field: "to".to_string(),
        operator: "eq".to_string(),
        value: serde_json::Value::String("0xdAC17F958D2ee523a2206206994597C13D831ec7".to_string()),
    };

    let request = CreatePolicyRuleBody {
        name: "Allow list USDT".to_string(),
        method: "eth_sendTransaction".to_string(),
        action: PolicyRuleAction::Allow,
        conditions: vec![usdt_condition],
    };

    let rule = client
        .policies()
        .create_rule("insert-policy-id", request, &authorization_context)
        .await?;

    println!("Created rule: {}", rule.id);
    ```

    ### Parameters and Returns

    See the Rust SDK documentation for detailed parameter and return types, including embedded examples:

    * [PoliciesClient::create\_rule](https://docs.rs/privy-rs/latest/privy_rs/subclients/struct.PoliciesClient.html#method.create_rule)

    For REST API details, see the [API reference](/api-reference/policies/rules/create).
  </Tab>

  <Tab title="REST API">
    To add a rule to a policy, make a `POST` request to:

    ```sh  theme={"system"}
    https://api.privy.io/v1/policies/<policy_id>/rules
    ```

    Replacing `<policy_id>` with the ID of your desired policy.

    In the request body, include the following fields:

    <Expandable title="body attributes" defaultOpen="true">
      <ParamField path="name" type="string">
        Name to assign to the rule.
      </ParamField>

      <ParamField path="method" type="'personal_sign' | 'eth_signTypedData_v4' | 'eth_signTransaction' | 'eth_sendTransaction' | 'signTransaction' | 'signAndSendTransaction' | '*'">
        RPC method to apply the `conditions` to. Must correspond to the `chain_type` of the parent policy.
      </ParamField>

      <ParamField path="conditions" type="Condition[]">
        A set of boolean conditions that define the action the rule allows or denies.
      </ParamField>

      <ParamField path="action" type="'ALLOW' | 'DENY'">
        Whether the rule should allow or deny a wallet request if it satisfies all of the rule's
        `conditions`.
      </ParamField>
    </Expandable>

    **Body**

    Here is an example of a request body:

    ```bash  theme={"system"}
    $ curl --request POST https://api.privy.io/v1/policies/fmfdj6yqly31huorjqzq38zc/rules \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H "privy-authorization-signature: <authorization-signature-for-request>" \
    -H 'Content-Type: application/json' \
    -d '{
          "name": "Allowlist USDT",
          "method": "eth_sendTransaction",
          "conditions": [
              {
                  "field_source": "ethereum_transaction",
                  "field": "to",
                  "operator": "eq",
                  "value": "0xdAC17F958D2ee523a2206206994597C13D831ec7"
              }
          ],
          "action": "ALLOW"
    }'
    ```

    **Response**

    If the rule is added successfully, the response will include the full rule object, like below:

    ```json  theme={"system"}
    {
      "name": "Allowlist USDT",
      "method": "eth_sendTransaction",
      "conditions": [
        {
          "field_source": "ethereum_transaction",
          "field": "to",
          "operator": "eq",
          "value": "0xdAC17F958D2ee523a2206206994597C13D831ec7"
        }
      ],
      "action": "ALLOW",
      "id": "allow-list-usdt-18381838"
    }
    ```
  </Tab>
</Tabs>

### Edit a rule in a policy

<Tabs>
  <Tab title="NodeJS">
    Use the **`PrivyClient`**'s **`updateRule`** method in the `policies()` interface to update a rule in a policy.

    ```tsx  theme={"system"}
    const rule = await client.policies().updateRule('insert-rule-id', {
      policy_id: 'insert-policy-id',
      name: 'Allow list USDT',
      method: 'eth_sendTransaction',
      conditions: [
        {
          field_source: 'ethereum_transaction',
          field: 'to',
          operator: 'eq',
          value: '0xdAC17F958D2ee523a2206206994597C13D831ec7'
        }
      ],
      action: 'ALLOW'
    });
    ```
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    Use the **`PrivyClient`**'s **`updateRuleInPolicy`** method to update a rule in a policy.

    ```tsx  theme={"system"}
    const rule = await client.walletApi.updateRuleInPolicy({
      policyId: 'fmfdj6yqly31huorjqzq38zc',
      ruleId: 'allow-list-usdt-18381838',
      name: 'Allowlist USDT',
      method: 'eth_sendTransaction',
      conditions: [
        {
          fieldSource: 'ethereum_transaction',
          field: 'to',
          operator: 'eq',
          value: '0xdAC17F958D2ee523a2206206994597C13D831ec7'
        }
      ],
      action: 'ALLOW'
    });
    ```
  </Tab>

  <Tab title="Rust">
    Use the **`PrivyClient`**'s **`update_rule`** method in the `policies()` interface to update a rule in a policy.

    ```rust  theme={"system"}
    use privy_rs::{PrivyClient, generated::types::*};

    let client = PrivyClient::new(app_id, app_secret)?;

    let usdt_condition = PolicyRuleCondition {
        field_source: "ethereum_transaction".to_string(),
        field: "to".to_string(),
        operator: "eq".to_string(),
        value: serde_json::Value::String("0xdAC17F958D2ee523a2206206994597C13D831ec7".to_string()),
    };

    let request = UpdatePolicyRuleBody {
        policy_id: "insert-policy-id".to_string(),
        name: "Allow list USDT".to_string(),
        method: "eth_sendTransaction".to_string(),
        action: PolicyRuleAction::Allow,
        conditions: vec![usdt_condition],
    };

    let rule = client
        .policies()
        .update_rule("insert-rule-id", request, &authorization_context)
        .await?;

    println!("Updated rule: {}", rule.id);
    ```

    ### Parameters and Returns

    See the Rust SDK documentation for detailed parameter and return types, including embedded examples:

    * [PoliciesClient::update\_rule](https://docs.rs/privy-rs/latest/privy_rs/subclients/struct.PoliciesClient.html#method.update_rule)

    For REST API details, see the [API reference](/api-reference/policies/rules/update).
  </Tab>

  <Tab title="REST API">
    To add a rule to a policy, make a `PATCH` request to:

    ```sh  theme={"system"}
    https://api.privy.io/v1/policies/<policy_id>/rules/<rule_id>
    ```

    Replacing `<policy_id>` with the ID of your desired policy.

    In the request body, include the following fields:

    <Expandable title="body attributes" defaultOpen="true">
      <ParamField path="name" type="string">
        Name to assign to the rule.
      </ParamField>

      <ParamField path="method" type="'personal_sign' | 'eth_signTypedData_v4' | 'eth_signTransaction' | 'eth_sendTransaction' | 'signTransaction' | 'signAndSendTransaction' | '*'">
        RPC method to apply the `conditions` to. Must correspond to the `chain_type` of the parent policy.
      </ParamField>

      <ParamField path="conditions" type="Condition[]">
        A set of boolean conditions that define the action the rule allows or denies.
      </ParamField>

      <ParamField path="action" type="'ALLOW' | 'DENY'">
        Whether the rule should allow or deny a wallet request if it satisfies all of the rule's
        `conditions`.
      </ParamField>
    </Expandable>

    **Body**

    Here is an example of a request body:

    ```bash  theme={"system"}
    $ curl --request PATCH https://api.privy.io/v1/policies/fmfdj6yqly31huorjqzq38zc/rules/allow-list-usdt-18381838 \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H "privy-authorization-signature: <authorization-signature-for-request>" \
    -H 'Content-Type: application/json' \
    -d '{
          "name": "Allowlist USDT",
          "method": "eth_sendTransaction",
          "conditions": [
              {
                  "field_source": "ethereum_transaction",
                  "field": "to",
                  "operator": "eq",
                  "value": "0xdAC17F958D2ee523a2206206994597C13D831ec7"
              }
          ],
          "action": "ALLOW"
    }'
    ```

    **Response**

    If the rule is added successfully, the response will include the full rule object, like below:

    ```json  theme={"system"}
    {
      "name": "Allowlist USDT",
      "method": "eth_sendTransaction",
      "conditions": [
        {
          "field_source": "ethereum_transaction",
          "field": "to",
          "operator": "eq",
          "value": "0xdAC17F958D2ee523a2206206994597C13D831ec7"
        }
      ],
      "action": "ALLOW",
      "id": "allow-list-usdt-18381838"
    }
    ```
  </Tab>
</Tabs>

### Delete a rule from a policy

<Tabs>
  <Tab title="NodeJS">
    Use the **`PrivyClient`**'s **`deleteRule`** method in the `policies()` interface to delete a rule from a policy.

    ```tsx  theme={"system"}
    const rule = await client.policies().deleteRule('insert-rule-id', {
      policy_id: 'insert-policy-id'
    });
    ```
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    Use the **`PrivyClient`**'s **`deleteRuleFromPolicy`** method to delete a rule from a policy.

    ```ts  theme={"system"}
    import {PrivyClient} from '@privy-io/server-auth';

    const client = new PrivyClient('insert-app-id', 'insert-app-secret');

    const rule = await client.walletApi.deleteRuleFromPolicy({
      policyId: 'fmfdj6yqly31huorjqzq38zc',
      ruleId: 'allow-list-usdt-18381838'
    });
    ```
  </Tab>

  <Tab title="Rust">
    Use the **`PrivyClient`**'s **`delete_rule`** method in the `policies()` interface to delete a rule from a policy.

    ```rust  theme={"system"}
    use privy_rs::PrivyClient;

    let client = PrivyClient::new(app_id, app_secret)?;

    let request = DeletePolicyRuleBody {
        policy_id: "insert-policy-id".to_string(),
    };

    let response = client
        .policies()
        .delete_rule("insert-rule-id", request, &authorization_context)
        .await?;

    println!("Rule deleted successfully");
    ```

    ### Parameters and Returns

    See the Rust SDK documentation for detailed parameter and return types, including embedded examples:

    * [PoliciesClient::delete\_rule](https://docs.rs/privy-rs/latest/privy_rs/subclients/struct.PoliciesClient.html#method.delete_rule)

    For REST API details, see the [API reference](/api-reference/policies/rules/delete).
  </Tab>

  <Tab title="REST API">
    To delete a rule from a policy, make a `DELETE` request to:

    ```sh  theme={"system"}
    https://api.privy.io/v1/policies/<policy_id>/rules/<rule_id>
    ```

    Replacing `<policy_id>` with the ID of your desired policy and `<rule_id>` with the ID of the rule you want to delete.

    **Response**

    If the rule is deleted successfully, the response will be

    ```sh  theme={"system"}
    {success: true}
    ```
  </Tab>
</Tabs>

## Update a whole policy

<Tabs>
  <Tab title="NodeJS">
    Use the **`PrivyClient`**'s **`update`** method from the `policies()` interface to update an existing policy.

    ```tsx  theme={"system"}
    const policy = await client.policies().update('fmfdj6yqly31huorjqzq38zc', {
      name: 'Transactions must be <= 5ETH',
      rules: [
        {
          name: 'Transactions must be <= 5ETH',
          method: 'eth_sendTransaction',
          action: 'ALLOW',
          conditions: [
            {
              field_source: 'ethereum_transaction',
              field: 'value',
              operator: 'lte',
              value: '0x2386F26FC10000'
            }
          ]
        }
      ]
    });
    ```
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    Use the **`PrivyClient`**'s **`updatePolicy`** method to update an existing policy.

    ```tsx  theme={"system"}
    const policy = await client.walletApi.updatePolicy({
      id: 'fmfdj6yqly31huorjqzq38zc',
      name: 'Transactions must be <= 5ETH',
      rules: [
        {
          name: 'Transactions must be <= 5ETH',
          method: 'eth_sendTransaction',
          action: 'ALLOW',
          conditions: [
            {
              fieldSource: 'ethereum_transaction',
              field: 'value',
              operator: 'lte',
              value: '0x2386F26FC10000'
            }
          ]
        }
      ]
    });
    ```
  </Tab>

  <Tab title="Java">
    You can update a policy using the Java SDK by using the `policies().update()` method.

    <Tip>
      If the policy has an owner, the owner's signature is required to modify the policy. Use an
      [authorization context](/controls/authorization-keys/using-owners/sign/signing-on-the-server) to
      pass into the `update()` method and sign the request.
    </Tip>

    ```java  theme={"system"}
    try {
        PolicyRule valueUnder5Eth = PolicyRule.builder()
            .name("Transactions must be <= 5ETH")
            .method(PolicyRuleMethod.ETH_SEND_TRANSACTION)
            .action(Action.ALLOW)
            .conditions(List.of(
                EthereumTransactionCondition.builder()
                    .fieldSource(EthereumTransactionConditionFieldSource.ETHEREUM_TRANSACTION)
                    .field(EthereumTransactionConditionField.VALUE)
                    .operator(ConditionOperator.LTE)
                    .value(ConditionValue.of("0x2386F26FC10000"))
                    .build()
            ))
            .build();

        PolicyUpdateRequestBody updateRequest = PolicyUpdateRequestBody.builder()
          .name("Transactions must be <= 5ETH")
          .rules(List.of(valueUnder5Eth))
          .build();

        // Example: If wallet's owner is an authorization private key
        AuthorizationContext authorizationContext = AuthorizationContext.builder()
            .addAuthorizationPrivateKey("authorization-key")
            .build();

        PolicyUpdateResponse response = privyClient
            .policies()
            .update(
                "fmfdj6yqly31huorjqzq38zc",
                updateRequest,
                authorizationContext
            );

        if (response.policy().isPresent()) {
          Policy policy = response.policy().get();
          String policyId = policy.id();
        }
    } catch (APIException e) {
        String errorBody = e.bodyAsString();
        System.err.println(errorBody);
    } catch (Exception e) {
        System.err.println(e.getMessage());
    }
    ```

    ### Parameters

    When updating a policy, you may specify the following values on the `PolicyUpdateRequestBody` builder:

    <ParamField path="name" type="String">
      Name to assign to policy.
    </ParamField>

    <ParamField path="chainType" type="PolicyChainType">
      Chain type for wallets that the policy will be applied to.
    </ParamField>

    <ParamField path="rules" type="List<PolicyRule>">
      A list of `Rule` objects describing what rules to apply to each RPC method (e.g.
      `'eth_sendTransaction'`) that the wallet can take. [Learn more about
      `Rules`](/controls/policies/overview#rules).
    </ParamField>

    <ParamField path="owner" type="OwnerInput">
      The owner of the policy.
    </ParamField>

    <ParamField path="ownerId" type="String">
      The key quorum ID of the owner of the policy.
    </ParamField>

    ### Returns

    The `PolicyUpdateResponse` object contains an optional `policy()` field that contains the updated
    policy if the policy was updated successfully.

    <ResponseField name="policy()" type="Optional<Policy>">
      The updated policy.

      <Expandable title="Policy">
        <ResponseField name="version" type="Version">
          Version of the policy.
        </ResponseField>

        <ResponseField name="name" type="String">
          Name of the policy.
        </ResponseField>

        <ResponseField name="chainType" type="PolicyChainType">
          Chain type of the wallets that the policy will be applied to.
        </ResponseField>

        <ResponseField name="id" type="String">
          Unique ID of the policy.
        </ResponseField>

        <ResponseField name="ownerId" type="String">
          The key quorum ID of the owner of the policy.
        </ResponseField>

        <ResponseField name="createdAt" type="Double">
          The Unix time of when the policy was created.
        </ResponseField>

        <ResponseField name="rules" type="List<PolicyRule>">
          A list of `Rule` objects describing what rules to apply to each RPC method (e.g.
          `'eth_sendTransaction'`) that the wallet can take. [Learn more about
          `Rules`](/controls/policies/overview#rules).
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="Rust">
    Use the **`PrivyClient`**'s **`update`** method from the `policies()` interface to update an existing policy.

    ```rust  theme={"system"}
    use privy_rs::{PrivyClient, generated::types::*};

    let client = PrivyClient::new(app_id, app_secret)?;

    let value_condition = PolicyRuleCondition {
        field_source: "ethereum_transaction".to_string(),
        field: "value".to_string(),
        operator: "lte".to_string(),
        value: serde_json::Value::String("0x2386F26FC10000".to_string()),
    };

    let value_rule = PolicyRule {
        name: "Transactions must be <= 5ETH".to_string(),
        method: "eth_sendTransaction".to_string(),
        action: PolicyRuleAction::Allow,
        conditions: vec![value_condition],
    };

    let request = UpdatePolicyBody {
        name: Some("Transactions must be <= 5ETH".to_string()),
        rules: Some(vec![value_rule]),
        owner_id: None,
        owner: None,
    };

    let policy = client
        .policies()
        .update("fmfdj6yqly31huorjqzq38zc", request, &authorization_context)
        .await?;

    println!("Updated policy: {}", policy.name);
    ```

    ### Parameters and Returns

    See the Rust SDK documentation for detailed parameter and return types, including embedded examples:

    * [PoliciesClient::update](https://docs.rs/privy-rs/latest/privy_rs/subclients/struct.PoliciesClient.html#method.update)

    For REST API details, see the [API reference](/api-reference/policies/update).
  </Tab>

  <Tab title="REST API">
    To update an existing policy, make a `PATCH` request to:

    ```sh  theme={"system"}
    https://api.privy.io/v1/policies/<policy_id>
    ```

    Replacing `<policy_id>` with the ID of your desired policy.

    <Tip>
      In the request headers, make sure to include Privy's [required authentication
      headers](/basics/rest-api/setup#authentication) and [headers that may be required for your app's
      wallet API setup](/basics/rest-api/quickstart#2-sign-a-message).
    </Tip>

    ## **Body**

    In the request body, include the following fields:

    <ParamField path="name" type="string">
      (Optional) New name to assign to policy.
    </ParamField>

    <ParamField path="rules" type="Rule">
      (Optional) New list of `Rule` objects describing what rules to apply to each RPC method (e.g.
      `'eth_sendTransaction'`) that the wallet can take. [Learn more about
      `Rules`](/controls/policies/overview#rules).
    </ParamField>

    <ParamField type="{public_key: string} | null" path="owner">
      The P-256 public key of the owner of the policy. If you provide this, do not specify an owner\_id
      as it will be generated automatically.

      View [this guide](/controls/authorization-keys/owners/overview) to learn more about owners.
    </ParamField>

    <ParamField type="string | null" path="owner_id">
      The key quorum ID of the owner of the policy. If you provide this, do not specify an owner.

      View [this guide](/controls/authorization-keys/owners/overview) to learn more about owners.
    </ParamField>

    Any fields not included in the `PATCH` request body will remain unchanged from the original policy.

    ## **Response**

    If the policy is updated successfully, the response will include the full updated policy object.

    <ResponseField name="id" type="string">
      Unique ID for the policy.
    </ResponseField>

    <ResponseField name="version" type="'1.0'">
      Version of the policy. Currently, 1.0 is the only version.
    </ResponseField>

    <ResponseField name="name" type="string">
      Updated name of the policy.
    </ResponseField>

    <ResponseField name="chain_type" type="'ethereum'">
      Chain type for wallets that the policy will be applied to.
    </ResponseField>

    <ResponseField name="rules" type="Rule">
      Updated list of `Rule` objects describing what rules to apply to each RPC method (e.g.
      `'eth_sendTransaction'`) that the wallet can take. [Learn more about
      `Rules`](/controls/policies/overview#rules).
    </ResponseField>

    <ResponseField type="string | null" name="owner_id">
      The key quorum ID of the owner of the policy, whose signature is required to modify the policy.
    </ResponseField>

    ## Example

    As an example, a sample request to update the `rules` of a policy with ID `fmfdj6yqly31huorjqzq38zc` might look like the following:

    ```bash  theme={"system"}
    $ curl --request PATCH https://api.privy.io/v1/policies/fmfdj6yqly31huorjqzq38zc \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H "privy-authorization-signature: <authorization-signature-for-request>" \
    -H 'Content-Type: application/json' \
    -d '{
        "rules": [{
          "name": "Allowlist USDT",
          "method": "eth_sendTransaction",
          "conditions": [
              {
                  "field_source": "ethereum_transaction",
                  "field": "to",
                  "operator": "eq",
                  "value": "0xdAC17F958D2ee523a2206206994597C13D831ec7"
              }
          ],
          "action": "ALLOW"
        }]
    }'
    ```

    A successful response will look like the following:

    ```json  theme={"system"}
    {
      "id": "fmfdj6yqly31huorjqzq38zc",
      "name": "Allowlist certain smart contracts",
      "version": "1.0",
      "chain_type": "ethereum",
      "rules": [
        {
          "name": "Allowlist USDT",
          "method": "eth_sendTransaction",
          "conditions": [
            {
              "field_source": "ethereum_transaction",
              "field": "to",
              "operator": "eq",
              "value": "0xdAC17F958D2ee523a2206206994597C13D831ec7"
            }
          ],
          "action": "ALLOW",
          "id": "allow-list-usdt-18381838"
        }
      ],
      "owner_id": "fmfdj6yqly31huorjqzq38zc"
    }
    ```
  </Tab>
</Tabs>


# Integrate Aave with Privy
Source: https://docs.privy.io/recipes/aave-guide



Create a seamless DeFi lending experience with Privy's embedded wallets and Aave protocol. This guide shows you how to build an app where users can supply tokens directly to Aave, deploy yield-bearing vaults, and manage deposits—all without external wallets or complex onboarding.

## Resources

<CardGroup cols={2}>
  <Card title="Aave Docs" icon="arrow-up-right-from-square" href="https://docs.aave.com/" arrow>
    Official documentation for Aave protocol and smart contracts.
  </Card>

  <Card title="Privy Wallets" icon="wallet" href="/wallets/overview" arrow>
    Privy Wallets are a powerful tool for helping users interact with DeFi.
  </Card>
</CardGroup>

***

## Integrate with Aave protocol

There are two ways to integrate Aave into your application:

* **Supply directly to Aave**: Directly supply tokens into Aave's liquidity pools to earn interest. Your tokens become available for borrowers and you earn yield from interest payments.
* **Create a managed Aave vault**: Create ERC-4626 compliant vaults that hold aTokens (Aave's interest-bearing tokens). Vaults allow applications to manage supplied tokens on behalf of users and earn a percentage of the yield generated.

For this walkthrough, we'll demonstrate using **Base Sepolia** and the **WETH lending pool**. The same patterns work across all Aave-supported networks and assets—explore the complete list of available pools and addresses in the [BGD Labs Address Book](https://github.com/bgd-labs/aave-address-book).

### Install and configure the Aave SDK

<Tabs>
  <Tab title="React">
    ### Installation

    ```bash  theme={"system"}
    npm install @aave/react@latest @privy-io/react-auth@latest
    ```

    ### Setup

    Below is a minimal setup for Privy provider with Aave provider setup. To customize your Privy provider, follow the instructions in the [Privy Quickstart](/basics/get-started/dashboard/create-new-app) to get your app set up with Privy.

    ```tsx  theme={"system"}
    // App.tsx
    import {PrivyProvider} from '@privy-io/react-auth';
    import {AaveProvider, AaveClient} from '@aave/react';

    const client = AaveClient.create();

    export function App() {
      return (
        <PrivyProvider appId="your-privy-app-id">
          <AaveProvider client={client}>{/* Your application components */}</AaveProvider>
        </PrivyProvider>
      );
    }
    ```

    ### Supply directly to Aave protocol

    This approach lets users deposit tokens directly into Aave's lending pools to earn interest. When you supply tokens, they become available for other users to borrow, and you earn yield from the borrowing fees. This is the simplest way to start earning on idle assets.

    <Steps>
      <Step title="1. Execute the supply transaction">
        The Aave SDK returns transaction objects that you execute with Privy's `sendTransaction`:

        ```tsx  theme={"system"}
        import {useSupply, bigDecimal} from '@aave/react';
        import {useSendTransaction, useWallets} from '@privy-io/react-auth';

        const {wallets} = useWallets();
        const {sendTransaction} = useSendTransaction();
        const [supply] = useSupply();

        const supplyToken = async () => {
          const result = await supply({
            market: '0x8bAB6d1b75f19e9eD9fCe8b9BD338844fF79aE27',
            amount: {native: bigDecimal(0.1)}, // Supply 0.1 ETH
            sender: wallets[0].address,
            chainId: 84532
          });

          if (result.isErr()) {
            throw new Error(`Supply failed: ${result.error}`);
          }

          const plan = result.value;

          // Handle approval if required
          if (plan.__typename === 'ApprovalRequired') {
            await sendTransaction(
              {
                to: plan.approval.to,
                value: BigInt(plan.approval.value),
                data: plan.approval.data,
                chainId: plan.approval.chainId
              },
              {address: wallets[0].address}
            );

            // Execute supply transaction
            return await sendTransaction(
              {
                to: plan.originalTransaction.to,
                value: BigInt(plan.originalTransaction.value),
                data: plan.originalTransaction.data,
                chainId: plan.originalTransaction.chainId
              },
              {address: wallets[0].address}
            );
          }

          // Direct supply transaction
          if (plan.__typename === 'TransactionRequest') {
            return await sendTransaction(
              {
                to: plan.to,
                value: BigInt(plan.value),
                data: plan.data,
                chainId: plan.chainId
              },
              {address: wallets[0].address}
            );
          }

          throw new Error(`Unhandled plan type: ${plan.__typename}`);
        };
        ```
      </Step>
    </Steps>

    ***

    ### Create a managed Aave vault

    Aave Vaults are ERC-4626 compliant yield-bearing vaults that allow users to supply and withdraw ERC-20 tokens supported by Aave V3. Vaults enable applications to manage supplied tokens on behalf of users and earn a percentage of revenue.

    <Steps>
      <Step title="1. Get reserve information for vault deployment">
        ```tsx  theme={"system"}
        import {useAaveReserve, useVaultDeploy, bigDecimal} from '@aave/react';
        import {useSendTransaction, useWallets} from '@privy-io/react-auth';

        const {wallets} = useWallets();
        const {sendTransaction} = useSendTransaction();
        const [deployVault] = useVaultDeploy();

        // Get reserve data for WETH on Base Sepolia (needed for vault deployment)
        const {data: reserve} = useAaveReserve({
          market: '0x8bAB6d1b75f19e9eD9fCe8b9BD338844fF79aE27', // Base Sepolia Pool
          underlyingToken: '0x4200000000000000000000000000000000000006', // WETH
          chainId: 84532,
          suspense: true
        });
        ```
      </Step>

      <Step title="2. Deploy a new vault">
        ```tsx  theme={"system"}
        const deploy = async () => {
          const result = await deployVault({
            market: reserve.market.address,
            chainId: 84532,
            underlyingToken: reserve.underlyingToken.address,
            deployer: wallets[0].address,
            initialFee: bigDecimal(3), // 3% performance fee
            shareName: 'Aave WETH Vault Shares',
            shareSymbol: 'avWETH',
            initialLockDeposit: bigDecimal(1) // 1 WETH initial deposit
          });

          if (result.isErr()) {
            throw new Error(`Deployment failed: ${result.error}`);
          }

          const plan = result.value;

          // Handle approval if required
          if (plan.__typename === 'ApprovalRequired') {
            await sendTransaction(
              {
                to: plan.approval.to,
                value: BigInt(plan.approval.value),
                data: plan.approval.data,
                chainId: plan.approval.chainId
              },
              {address: wallets[0].address}
            );

            return await sendTransaction(
              {
                to: plan.originalTransaction.to,
                value: BigInt(plan.originalTransaction.value),
                data: plan.originalTransaction.data,
                chainId: plan.originalTransaction.chainId
              },
              {address: wallets[0].address}
            );
          }

          if (plan.__typename === 'TransactionRequest') {
            return await sendTransaction(
              {
                to: plan.to,
                value: BigInt(plan.value),
                data: plan.data,
                chainId: plan.chainId
              },
              {address: wallets[0].address}
            );
          }

          throw new Error(`Unhandled plan type: ${plan.__typename}`);
        };
        ```
      </Step>

      <Step title="3. Deposit into a vault">
        ```tsx  theme={"system"}
        import {useVault, useVaultDeposit} from '@aave/react';

        const {data: vault} = useVault({
          by: {address: '0x36b22e03bc9f8d08109ca4bb36241e3bfb7077fa'}, // vault address to deposit tokens
          chainId: 84532
        });

        const [deposit] = useVaultDeposit();

        const depositTokens = async () => {
          const result = await deposit({
            chainId: vault.chainId,
            vault: vault.address,
            amount: {
              currency: vault.usedReserve.underlyingToken.address,
              value: bigDecimal(100) // 100 tokens
            },
            depositor: wallets[0].address
          });

          if (result.isErr()) {
            throw new Error(`Deposit failed: ${result.error}`);
          }

          const plan = result.value;

          // Handle approval if required
          if (plan.__typename === 'ApprovalRequired') {
            await sendTransaction(
              {
                to: plan.approval.to,
                value: BigInt(plan.approval.value),
                data: plan.approval.data,
                chainId: plan.approval.chainId
              },
              {address: wallets[0].address}
            );

            return await sendTransaction(
              {
                to: plan.originalTransaction.to,
                value: BigInt(plan.originalTransaction.value),
                data: plan.originalTransaction.data,
                chainId: plan.originalTransaction.chainId
              },
              {address: wallets[0].address}
            );
          }

          if (plan.__typename === 'TransactionRequest') {
            return await sendTransaction(
              {
                to: plan.to,
                value: BigInt(plan.value),
                data: plan.data,
                chainId: plan.chainId
              },
              {address: wallets[0].address}
            );
          }

          throw new Error(`Unhandled plan type: ${plan.__typename}`);
        };
        ```
      </Step>
    </Steps>
  </Tab>

  <Tab title="NodeJS">
    ### Installation

    ```bash  theme={"system"}
    npm install @aave/client@latest @privy-io/server-auth@latest
    ```

    ### Setup

    ```tsx  theme={"system"}
    import {PrivyClient} from '@privy-io/server-auth';
    import {AaveClient} from '@aave/client';

    // Initialize Privy SDK client
    const privyClient = new PrivyClient('insert-your-app-id', 'insert-your-app-secret');

    // Get Privy wallet details
    const walletId = 'privy-wallet-id';
    const walletAddress = 'privy-wallet-address';

    // Initialize Aave SDK client
    const aaveClient = AaveClient.create();
    ```

    <Info>
      If you haven't created a wallet yet, you can create one by following the [Node.js
      Quickstart](/basics/nodeJS-server-auth/quickstart#1-creating-a-wallet).
    </Info>

    ### Supply directly to Aave protocol

    This approach lets users deposit tokens directly into Aave’s lending pools to earn interest. When you supply tokens, they become available for other users to borrow, and you earn yield from the borrowing fees. This is the simplest way to start earning on idle assets.

    <Steps>
      <Step title="1. Execute the supply transaction">
        We use Aave Client Actions to generate the payload for our transaction and use the `sendWith` method from the Aave SDK, which handles sending the transaction. It also automatically sends a token approval transaction if needed to complete the supply transaction.

        ```tsx  theme={"system"}
        import {supply} from '@aave/client/actions';
        import {sendWith} from '@aave/client/privy';
        import {bigDecimal} from '@aave/client';

        const supplyToken = async () => {
          const result = await supply(aaveClient, {
            market: '0x8bAB6d1b75f19e9eD9fCe8b9BD338844fF79aE27',
            amount: {
              erc20: {
                currency: '0x4200000000000000000000000000000000000006', // WETH
                value: bigDecimal(1) // 1 WETH
              }
            },
            sender: walletAddress,
            chainId: 84532
          }).andThen(sendWith(privyClient, walletId));

          if (result.isOk()) {
            console.log('Transaction sent with hash:', result.value);
            return result.value;
          } else {
            throw new Error(`Supply failed: ${result.error}`);
          }
        };
        ```
      </Step>
    </Steps>

    ### Create a managed Aave vault

    Aave Vaults are ERC-4626 compliant yield-bearing vaults that allow users to supply and withdraw ERC-20 tokens supported by Aave V3. Vaults enable applications to manage supplied tokens on behalf of users and earn a percentage of revenue.

    <Steps>
      <Step title="1. Get reserve information for vault deployment">
        ```tsx  theme={"system"}
        import {reserve} from '@aave/client/actions';

        // Get reserve details (needed for vault deployment)
        const reserveDetails = await reserve(aaveClient, {
          market: '0x8bAB6d1b75f19e9eD9fCe8b9BD338844fF79aE27', // Base Sepolia Pool
          underlyingToken: '0x4200000000000000000000000000000000000006', // WETH
          chainId: 84532
        });
        ```
      </Step>

      <Step title="2. Deploy a new vault">
        ```tsx  theme={"system"}
        import {vaultDeploy} from '@aave/client/actions';
        import {sendWith} from '@aave/client/privy';

        const deploy = async () => {
          const result = await vaultDeploy(aaveClient, {
            market: reserveDetails?.value?.market.address,
            chainId: reserveDetails?.value?.market.chain.chainId,
            underlyingToken: reserveDetails?.value?.underlyingToken.address,
            deployer: walletAddress,
            // owner: "0x1234...", // Optional: set a different owner
            initialFee: bigDecimal(3), // 3% performance fee
            shareName: 'Aave WETH Vault Shares',
            shareSymbol: 'avWETH',
            initialLockDeposit: bigDecimal(1) // 1 WETH initial deposit
          }).andThen(sendWith(privyClient, walletId));

          if (result.isOk()) {
            console.log('Transaction sent with hash:', result.value);
            return result.value;
          } else {
            throw new Error(`Deployment failed: ${result.error}`);
          }
        };
        ```
      </Step>

      <Step title="3. Deposit into a vault">
        ```tsx  theme={"system"}
        import {vaultDeposit, vault} from '@aave/client/actions';
        import {sendWith} from '@aave/client/privy';

        const depositTokens = async () => {
          const vaultDetails = await vault(aaveClient, {
            by: {address: vaultAddress},
            chainId: 84532,
            user: walletAddress
          });

          const result = await vaultDeposit(aaveClient, {
            chainId: vaultDetails?.value?.chainId,
            vault: vaultDetails?.value?.address,
            amount: {
              currency: vaultDetails?.value?.usedReserve.underlyingToken.address,
              value: bigDecimal(100) // 100 tokens (USDC, WETH)
            },
            depositor: walletAddress
          }).andThen(sendWith(privyClient, walletId));

          if (result.isOk()) {
            console.log('Transaction sent with hash:', result.value);
            return result.value;
          } else {
            throw new Error(`Deposit failed: ${result.error}`);
          }
        };
        ```
      </Step>
    </Steps>
  </Tab>
</Tabs>

## Key integration tips

1. **In NodeJS**: the `sendWith` method from the Aave SDK is feature-rich and streamlines complex transaction flows. It automatically handles token approvals when required and then sends the main Aave transaction, making the overall process more seamless.

2. **Handle transaction plans**: The Aave SDK returns various plan types (actions) like `TransactionRequest` and `ApprovalRequired` which can be used to handle different transaction scenarios accordingly. This allows for flexible handling of different approval and execution patterns.

3. **Add error handling**: Production applications should wrap all async functions in try/catch blocks to handle common blockchain errors like user rejection, insufficient funds, network issues, and contract failures. Consider implementing user-friendly error messages and retry mechanisms for failed transactions.

***

## Conclusion

With Privy and the Aave, building powerful DeFi lending experiences becomes seamless and secure. Users can interact with Aave protocol seamlessly through embedded wallets without needing external wallet management.


# Storing smart account addresses
Source: https://docs.privy.io/recipes/account-abstraction/address



<Tip>
  Privy now allows you to natively use smart wallet for a better developer experience. Check out the
  docs [here](/wallets/using-wallets/evm-smart-wallets/overview).
</Tip>

Once you've used Privy's embedded wallet as a **signer** to create smart accounts, you can also store the user's smart account address on their user object.

At a high-level, this is accomplished by requesting a Sign-In With Ethereum (SIWE) signature from the user's smart account, and passing the resulting signature to Privy to verify that the smart account is associated with the authenticated user.

Read below to learn more!

<Tip>
  Storing a user's smart account address on the user object makes the address available in their [
  <b>`user` state in your client</b>](/user-management/users/the-user-object) and the user object
  you might [<b>query from your server</b>](/user-management/users/managing-users/querying-users).
  This enables you to easily associate smart account addresses with users.
</Tip>

## 1. Generate a SIWE message for the smart account

To start, import the `useLinkWithSiwe` hook from `@privy-io/react-auth`. This hook allows you to generate a SIWE message for an arbitrary wallet and pass the resulting signature for verification.

```tsx  theme={"system"}
import {useLinkWithSiwe} from '@privy-io/react-auth';
```

Then, call the `generateSiweMessage` method returned by the hook to generate a SIWE message for the smart account to sign. As parameters to this method, pass an object with the following fields:

| Parameter | Type     | Description                                                                                                                                                                                                                                      |
| --------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `address` | `string` | Required. The user's smart account address. Must be properly checksummed per [EIP-55](https://eips.ethereum.org/EIPS/eip-55).                                                                                                                    |
| `chainId` | `number` | Required. The chain ID of the smart account. Must be a [CAIP-2 formatted](https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-2.md) chain ID that correspond to a valid network where signatures from the smart account can be verified. |

<Info>
  Make sure the `chainId` you pass to `generateSiweMessage` and `linkWithSiwe` is{' '}
  <a href="https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-2.md">CAIP-2 formatted</a>.
</Info>

As an example, you might generate a SIWE message for the smart account like so:

```tsx  theme={"system"}
const {generateSiweMessage} = useLinkWithSiwe();
const message = await generateSiweMessage({
  address: 'insert-smart-account-address',
  chainId: 'eip155:8453' // Replace with a CAIP-2 chain ID where signatures from the smart account can be verified
});
```

## 2. Request a `personal_sign` signature from the smart account

Next, with the `message` you generated in step (1), request a EIP191 `personal_sign` signature from the smart account.

The interface for requesting this signature may depend on which smart account provider ([ZeroDev](/recipes/account-abstraction/custom-implementation), [Pimlico](/recipes/account-abstraction/custom-implementation), [Safe](/recipes/account-abstraction/custom-implementation), [Biconomy](/recipes/account-abstraction/custom-implementation), [Alchemy](/recipes/account-abstraction/custom-implementation) your app uses; see the corresponding guides to understand the best way to request a signature from the wallet.

```tsx  theme={"system"}
// In this example, the `kernelClient` corresponds to a ZeroDev smart account. The interface for requesting
// may depend on your chosen smart account provider, so be sure to swap out this implementation for the
// correct one for your setup.
const signature = await kernelClient.signMessage({
  // This `message` is what you generated in step (1)
  message: message
});
```

## 3. Pass the signature to Privy

Lastly, pass the `signature` from the smart account to Privy using the `linkWithSiwe` method returned by the `useLinkWithSiwe` hook. As parameters to this method, include an object with the following fields:

| Parameter          | Type     | Description                                                                                                                                                                                       |
| ------------------ | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `message`          | `string` | Required. The SIWE message you generated with `generateSiweMessage`.                                                                                                                              |
| `chainId`          | `number` | Required. The [CAIP-2](https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-2.md) chain ID you passed to `generateSiweMessage`.                                                            |
| `signature`        | `string` | Required. The signature produced by the smart account.                                                                                                                                            |
| `walletClientType` | `string` | Recommended. A signature indicating the wallet client you'd like to associate with the smart account. We recommend using `'privy_smart_account'`.                                                 |
| `connectorType`    | `string` | Recommended. A signature indicating the connector type you'd like to associate with the smart account. We recommend using the snake\_cased name of your smart account provider, e.g. `'zerodev'`. |

As an example, you can pass the smart account's signature to Privy for verification like so:

```tsx  theme={"system"}
const {linkWithSiwe} = useLinkWithSiwe();

await linkWithSiwe({
  // The SIWE message generated from `generateSiweMessage`
  message: message,
  // The same `chainId` you passed to `generateSiweMessage`
  chainId: 'eip155:8453',
  // The signature from the smart account
  signature: signature,
  // You can replace this with whatever wallet client you'd like to associate with the smart account
  walletClientType: 'privy_smart_account',
  // You can replace this with whatever connector type you'd like to associate with the smart account
  connectorType: 'zerodev'
});
```

## 4. Get the smart account address

Once you've successfully linked the smart account to the user, you can easily get their smart account address from their Privy `user` object. Simply inspect the `linkedAccounts` array for the entry with:

* `type: 'wallet'`
* `walletClientType: 'privy_smart_account'`, or any other custom `walletClientType` you chose

As an example, you can get the smart account address like so!

```tsx  theme={"system"}
const {user} = usePrivy();
const address = user.linkedAccounts.find(
  (account): account is WalletWithMetadata =>
    account.type === 'wallet' && account.walletClientType === 'privy_smart_account'
);
```

**That's it!** You can also find the user's smart account when [querying Privy's API from your server](/user-management/users/managing-users/querying-users), and applying the same logic to parsing the `linked_accounts` array.


# Custom account abstraction implementation
Source: https://docs.privy.io/recipes/account-abstraction/custom-implementation



<Tip>
  Privy now allows you to natively use smart wallet for a better developer experience. Check out the
  docs [here](/wallets/using-wallets/evm-smart-wallets/overview).
</Tip>

<Tabs>
  <Tab title="ZeroDev">
    ## Account abstraction with ZeroDev

    [ZeroDev](https://zerodev.app/) is a toolkit for creating [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337)-compatible smart wallets for your users, using the user's EOA as the smart wallet's signer. This allows you to easily add [Account Abstraction](https://ethereum.org/en/roadmap/account-abstraction/) features into your app.

    **You can easily integrate ZeroDev alongside Privy to create smart wallets from your user's embedded or external wallets, allowing you to enhance your app with gas sponsorship, batched transactions, and more!**

    Read below to learn how to configure your app to create smart wallets for *all* your users!

    <details>
      <summary><b>What is an EOA?</b></summary>

      An [**EOA, or externally-owned account**](https://ethereum.org/en/developers/docs/accounts/), is any Ethereum account that is controlled by a private key. Privy's embedded wallets and most external wallets (MetaMask, Coinbase Wallet, Rainbow Wallet, etc.) are EOAs.

      EOAs differ from **contract accounts**, which are instead controlled by smart contract code and do not have their own private key. ZeroDev's smart wallet is a contract account. Contract accounts have [enhanced capabilities, such as gas sponsorship and batched transactions](https://ethereum.org/en/roadmap/account-abstraction/).

      Since they do not have their own private key, contract accounts cannot *directly* produce signatures and initiate transaction flows. Instead, each contract account is generally "managed" by an EOA, which authorizes actions taken by the contract account via a signature; this EOA is called a **signer**.

      In this integration, the user's EOA (from Privy) serves as the signer for their smart wallet (from ZeroDev). The smart wallet (ZeroDev) holds all assets and submits all transactions to the network, but the signer (Privy) is responsible for producing signatures and "kicking off" transaction flows.
    </details>

    <details>
      <summary><b>How much does deploying a smart wallet for a user cost?</b></summary>

      The transaction to deploy a ZeroDev smart wallet requires approximately 258522 in gas. At time of writing, this corresponds to:

      * 0.0168 ETH (28 USD) on **Ethereum Mainnet**
      * 0.04 POL (0.024 USD) on **Polygon**
      * 0.00005 ETH (0.08 USD) on **Arbitrum**

      The exact deployment cost you see will vary depending on the current gas price.

      **Importantly, ZeroDev deploys smart wallets lazily, ensuring that you do not pay deployment costs for functionally unused wallets.**

      When you first initialize a ZeroDev smart wallet for a user, ZeroDev does not yet deploy the wallet, but instead *predicts* the smart wallet's address (via the [`CREATE2`](https://docs.openzeppelin.com/cli/2.8/deploying-with-create2) opcode). This allows you to associate a smart wallet with your user, without any upfront deployment costs.

      ZeroDev only *deploys* the smart wallet to the predicted address when the user sends their first transaction with the smart wallet. This ensures that you only ever pay deployment costs for wallets that are actually used to transact on-chain.
    </details>

    ### 1. Install the required dependencies from Privy and ZeroDev

    In your app's repository, install the required dependencies from Privy and ZeroDev, as well as the [`permissionless`](https://www.npmjs.com/package/permissionless), and [`viem`](https://www.npmjs.com/package/viem) libraries:

    ```sh  theme={"system"}
    npm i @privy-io/react-auth @zerodev/sdk @zerodev/ecdsa-validator permissionless viem
    ```

    ### 2. Sign up for a ZeroDev account and get your project ID

    Visit the [**ZeroDev dashboard**](https://dashboard.zerodev.app/) and sign up for a new account if you do not have one already. Set up a new project for your required chain(s) and retrieve your ZeroDev **project ID**, as well as your **paymaster and bundler URLs** for the project.

    Within this Dashboard, you can also configure [settings for gas sponsorship and other ZeroDev features](https://docs.zerodev.app/sdk/getting-started/tutorial)!

    ### 2. Configure your app's Privy settings

    First, follow the instructions in the [**Privy Quickstart**](/basics/react/quickstart) to get your app set up with a basic Privy integration.

    Next, set **Add confirmation modals** to "off" in your app's \[**Embedded wallets**] {/* TODO: add link */} page in the Privy [**dashboard**](https://dashboard.privy.io). This will configure Privy to *not* show its default UIs when your user must sign messages or send transactions. Instead, we recommend you use your own custom UIs for showing users the [user operations](https://www.alchemy.com/overviews/user-operations)s they sign.

    Lastly, update the **`config.embeddedWallets.createOnLogin`** property of your **`PrivyProvider`** to `'users-without-wallets'`.This will configure Privy to create an embedded wallet for users logging in via a web2 method (email, phone, socials), ensuring that *all* of your users have a wallet that can be used as an EOA.

    Your **`PrivyProvider`** should then look like:

    ```tsx  theme={"system"}
    <PrivyProvider
        appId='insert-your-privy-app-id'
        config={{
            embeddedWallets: {
                createOnLogin: 'users-without-wallets',
            }
            ...insertTheRestOfYourPrivyProviderConfig
        }}
    >
        {/* Your app's components */}
    </PrivyProvider>
    ```

    ### 3. Create a smart account for your user

    You'll now create a smart account for your user, using the Privy embedded wallet (an EOA) as the signer.

    To do so, when the user logs in, first find the user's embedded wallet from Privy's **`useWallets`** hook, and get its [EIP1193 provider](/wallets/using-wallets/ethereum/web3-integrations). You can find embedded wallet by finding the only entry in the **`useWallets`** array with a **`walletClientType`** of `'privy'`.

    ```tsx  theme={"system"}
    import {useWallets} from '@privy-io/react-auth';
    import {sepolia} from 'viem/chains'; // Replace this with the chain used by your application
    import {createWalletClient, custom} from 'viem';
    ...
    // Find the embedded wallet and get its EIP1193 provider
    const {wallets} = useWallets();
    const embeddedWallet = wallets.find((wallet) => (wallet.walletClientType === 'privy'));
    const provider = await embeddedWallet.getEthereumProvider();
    ```

    Next, pass the returned EIP1193 `provider` to the [`toSimpleSmartAccount`](https://docs.pimlico.io/references/permissionless/reference/accounts/toSimpleSmartAccount#tosimplesmartaccount) method from `permissionless` to create a SmartAccount. This signer corresponds to the user's embedded wallet and authorizes actions for the user's smart account.

    ```ts {skip-check} theme={"system"}
    import {createSmartAccountClient} from 'permissionless';
    import {toSimpleSmartAccount} from 'permissionless/accounts';
    import {createPublicClient, http, zeroAddress} from 'viem';
    import {sepolia} from 'viem/chains';
    import {createPimlicoClient} from 'permissionless/clients/pimlico';
    import {entryPoint07Address} from 'viem/account-abstraction';

    const publicClient = createPublicClient({
      chain: sepolia, // or whatever chain you are using
      transport: http()
    });

    const pimlicoUrl = `https://api.pimlico.io/v2/sepolia/rpc?apikey=<PIMLICO_API_KEY>`;
    const pimlicoClient = createPimlicoClient({
      transport: http(pimlicoUrl),
      entryPoint: {
        address: entryPoint07Address,
        version: '0.7'
      }
    });

    // Use the EIP1193 `provider` from Privy to create a `SmartAccount`
    const kernelSmartAccount = await toKernelSmartAccount({
      owners: [provider],
      client: publicClient,
      entryPoint: {
        address: entryPoint07Address,
        version: '0.7'
      }
    });
    ```

    Finally, using the `SmartAccount` from above, initialize a smart account client for the user like so:

    ```tsx  theme={"system"}
    import {sepolia} from 'viem/chains'; // Replace this with the chain used by your application
    import {createPublicClient, http} from 'viem';
    import {ENTRYPOINT_ADDRESS_V07} from 'permissionless';
    import {createZeroDevPaymasterClient, createKernelAccount, createKernelAccountClient} from "@zerodev/sdk";
    import {signerToEcdsaValidator} from "@zerodev/ecdsa-validator";

    ...

    // Initialize a viem public client on your app's desired network
    const publicClient = createPublicClient({
      transport: http(sepolia.rpcUrls.default.http[0]),
    })

    // Create a ZeroDev ECDSA validator from the `smartAccountSigner` from above and your `publicClient`
    const ecdsaValidator = await signerToEcdsaValidator(publicClient, {
      signer: kernelSmartAccount,
      entryPoint: ENTRYPOINT_ADDRESS_V07,
    })

    // Create a Kernel account from the ECDSA validator
    const account = await createKernelAccount(publicClient, {
      plugins: {
        sudo: ecdsaValidator,
      },
      entryPoint: ENTRYPOINT_ADDRESS_V07,
    });

    // Create a Kernel account client to send user operations from the smart account
    const kernelClient = createKernelAccountClient({
      account,
      chain: sepolia,
      entryPoint: ENTRYPOINT_ADDRESS_V07,
      bundlerTransport: http('insert-your-bundler-RPC-from-the-dashboard'),
      middleware: {
        sponsorUserOperation: async ({ userOperation }) => {
          const zerodevPaymaster = createZeroDevPaymasterClient({
            chain: sepolia,
            entryPoint: ENTRYPOINT_ADDRESS_V07,
            transport: http('insert-your-paymaster-RPC-to-the-dashboard'),
          })
          return zerodevPaymaster.sponsorUserOperation({
            userOperation,
            entryPoint: ENTRYPOINT_ADDRESS_V07,
          })
        }
      }
    })
    ```

    The `kernelClient` is a drop-in replacement for a `viem` [Wallet Client](https://viem.sh/docs/clients/wallet.html), and requests to the smart account can be made using [`viem`'s API](https://docs.zerodev.app/sdk/core-api/send-transactions).

    <Tip>
      You can also store the user's smart account address on Privy's user object. See [this
      guide](./address.md) for more.
    </Tip>

    <details>
      <summary><b>Want to see this code end-to-end?</b></summary>
      You can find the code snippets above pasted in an end-to-end example below.

      ```tsx  theme={"system"}
      /**
       * This example assumes your app is wrapped with the `PrivyProvider` and
       * is configured to create embedded wallets for users upon login. Aside from
       * the imports, all of the code in this snippet must be used within a React component
       * or context.
       */
      import {createSmartAccountClient} from 'permissionless';
      import {toSimpleSmartAccount} from 'permissionless/accounts';
      import {createPublicClient, http, zeroAddress} from 'viem';
      import {sepolia} from 'viem/chains';
      import {createPimlicoClient} from 'permissionless/clients/pimlico';
      import {entryPoint07Address} from 'viem/account-abstraction';
      import {useWallets} from '@privy-io/react-auth';
      import {
        createZeroDevPaymasterClient,
        createKernelAccount,
        createKernelAccountClient
      } from '@zerodev/sdk';
      import {signerToEcdsaValidator} from '@zerodev/ecdsa-validator';

      const {wallets} = useWallets();
      const embeddedWallet = wallets.find((wallet) => wallet.walletClientType === 'privy');
      const provider = await embeddedWallet.getEthereumProvider();

      // Initialize a viem public client on your app's desired network
      const publicClient = createPublicClient({
        chain: sepolia, // or whatever chain you are using
        transport: http()
      });

      const pimlicoUrl = `https://api.pimlico.io/v2/sepolia/rpc?apikey=<PIMLICO_API_KEY>`;
      const pimlicoClient = createPimlicoClient({
        transport: http(pimlicoUrl),
        entryPoint: {
          address: entryPoint07Address,
          version: '0.7'
        }
      });

      // Use the EIP1193 `provider` from Privy to create a `SmartAccount`
      const kernelSmartAccount = await toKernelSmartAccount({
        owners: [provider],
        client: publicClient,
        entryPoint: {
          address: entryPoint07Address,
          version: '0.7'
        }
      });

      // Create a ZeroDev ECDSA validator from the `smartAccountSigner` from above and your `publicClient`
      const ecdsaValidator = await signerToEcdsaValidator(publicClient, {
        signer: smartAccountSigner,
        entryPoint: entryPoint07Address
      });

      // Create a Kernel account from the ECDSA validator
      const account = await createKernelAccount(publicClient, {
        plugins: {
          sudo: ecdsaValidator
        },
        entryPoint: entryPoint07Address
      });

      // Create a Kernel client to send user operations from the smart account
      const kernelClient = createKernelAccountClient({
        account,
        chain: sepolia,
        entryPoint: entryPoint07Address,
        bundlerTransport: http('insert-your-bundler-RPC-from-the-dashboard'),
        middleware: {
          // See https://docs.zerodev.app/sdk/core-api/sponsor-gas
          sponsorUserOperation: async ({userOperation}) => {
            const zerodevPaymaster = createZeroDevPaymasterClient({
              chain: sepolia,
              entryPoint: entryPoint07Address,
              transport: http('insert-your-paymaster-RPC-from-the-dashboard')
            });
            return zerodevPaymaster.sponsorUserOperation({
              userOperation,
              entryPoint: entryPoint07Address
            });
          }
        }
      });
      ```

      Note: if your app uses React, we suggest that you store the user's `kernelClient` in a [React context](https://react.dev/learn/passing-data-deeply-with-context) that wraps your application. This allows you to easily access the smart account from your app's pages and components.
    </details>

    ### 4. Send user operations (transactions) from the smart account

    Now that your users have Kernel (ZeroDev) smart accounts, they can now send [**UserOperations**](https://eips.ethereum.org/EIPS/eip-4337) from their smart account. This is the AA analog to sending a transaction.

    **To send a user operation from a user's smart account, use the Kernel client's [`sendTransaction`](https://docs.zerodev.app/sdk/core-api/send-transactions#sending-transactions-1) method.**

    ```tsx  theme={"system"}
    const txHash = await kernelClient.sendTransaction({
      to: 'TO_ADDRESS',
      value: VALUE, // default to 0
      data: '0xDATA' // default to 0x
    });
    ```

    This is a drop-in replacement for viem's [`sendTransaction`](https://viem.sh/docs/actions/wallet/sendTransaction.html) method, and will automatically apply any smart account configurations (e.g. gas sponsorship) you configure in the `middleware` before sending the transaction.

    **That's it! You've configured your app to create smart wallets for all of your users, and can seamlessly add in AA features like gas sponsorship, batched transactions, and more.** 🎉
  </Tab>

  <Tab title="Safe">
    ## Account Abstraction with Safe

    [Safe Smart Accounts](https://safe.global/) is a product by [Safe](https://safe.global/wallet) for creating [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337)-compatible smart accounts for your users, using the user's EOA as the smart account's signer. The product builds off of the smart contract infrastructure powering the widely-used [Safe wallet](https://safe.global/wallet) and allows you to easily add [Account Abstraction](https://ethereum.org/en/roadmap/account-abstraction/) and other Safe features into your app.

    <details>
      <summary><b>What is an EOA?</b></summary>

      An [**EOA, or externally-owned account**](https://ethereum.org/en/developers/docs/accounts/), is any Ethereum account that is controlled by a private key. Privy's embedded wallets and most external wallets (MetaMask, Coinbase Wallet, Rainbow Wallet, etc.) are EOAs.

      EOAs differ from **contract accounts**, which are instead controlled by smart contract code and do not have their own private key. Safe's smart wallet is a contract account. Contract accounts have [enhanced capabilities, such as gas sponsorship and batched transactions](https://ethereum.org/en/roadmap/account-abstraction/).

      Since they do not have their own private key, contract accounts cannot *directly* produce signatures and initiate transaction flows. Instead, each contract account is generally "managed" by an EOA, which authorizes actions taken by the contract account via a signature; this EOA is called a **signer**.

      In this integration, the user's EOA (from Privy) serves as the signer for their smart wallet (from Safe). The smart wallet (Safe) holds all assets and submits all transactions to the network, but the signer (Privy) is responsible for producing signatures and "kicking off" transaction flows.
    </details>

    **To create Safe smart accounts for your users, simply follow our Pimlico integration guide.** Safe does not operate its own paymaster and bundler infrastructure, and developers generally compose the Safe smart account with paymasters or bundlers from Pimlico.

    **When integrating Safe alongside Pimlico, the only change from the default Pimlico setup is to replace the [`toSimpleSmartAccount`](https://docs.pimlico.io/references/permissionless/reference/accounts/toSimpleSmartAccount#usage) method with [`toSafeSmartAccount`](https://docs.pimlico.io/references/permissionless/reference/accounts/toSafeSmartAccount#usage).** This modifies the setup to deploy a Safe smart account for the user instead of a simple smart account.

    For example, when initializing the smart account from a `viem` wallet client for the user's Privy embedded wallet, you should update your code as follows:

    ```tsx  theme={"system"}
    import {createSmartAccountClient} from 'permissionless';
    import {toSimpleSmartAccount} from 'permissionless/accounts'; // [!code --]
    import {toSafeSmartAccount} from 'permissionless/accounts'; // [!code ++]

    import {createPimlicoClient} from 'permissionless/clients/pimlico';
    import {createPublicClient, http} from 'viem';
    import {entryPoint07Address} from 'viem/account-abstraction';

    // Create a viem public client for RPC calls
    const publicClient = createPublicClient({
      chain: sepolia, // Replace this with the chain of your app
      transport: http()
    });

    // Initialize the smart account for the user
    const simpleSmartAccount = await toSimpleSmartAccount({
      // [!code --]
      client: publicClient, // [!code --]
      owner: privyClient.account, // [!code --]
      factoryAddress: '0x9406Cc6185a346906296840746125a0E44976454' // [!code --]
    }); // [!code --]
    const safeSmartAccount = await toSafeSmartAccount({
      // [!code ++]
      owners: [privyClient.account], // [!code ++]
      safeVersion: '1.4.1', // [!code ++]
      entryPoint: {
        // [!code ++]
        address: ENTRYPOINT_ADDRESS_V07, // [!code ++]
        version: '0.7' // [!code ++]
      } // [!code ++]
    }); // [!code ++]

    // Create the Paymaster for gas sponsorship using the API key from your Pimlico dashboard
    const pimlicoPaymaster = createPimlicoClient({
      transport: http('https://api.pimlico.io/v2/sepolia/rpc?apikey=YOUR_PIMLICO_API_KEY')
    });

    // Create the SmartAccountClient for requesting signatures and transactions (RPCs)
    const smartAccountClient = createSmartAccountClient({
      account: simpleSmartAccount, // [!code --]
      account: safeSmartAccount, // [!code ++]
      chain: sepolia, // Replace this with the chain for your app
      bundlerTransport: http('https://api.pimlico.io/v1/sepolia/rpc?apikey=YOUR_PIMLICO_API_KEY'),
      paymaster: pimlicoPaymaster // If your app uses a paymaster for gas sponsorship
    });
    ```

    <Tip>
      You can also store the user's smart account address on Privy's user object. See [this guide](/recipes/account-abstraction/address) for more.
    </Tip>
  </Tab>

  <Tab title="Pimlico">
    ## Account Abstraction with permissionless.js and Pimlico

    [**`permissionless.js`**](https://www.npmjs.com/package/permissionless) is a modular and extensible TypeScript library originally created by [**Pimlico**](https://pimlico.io) for deploying and managing ERC-4337 smart accounts. You can use this library for all major smart account implementations, including [Safe](https://docs.pimlico.io/guides/how-to/accounts/use-safe-account), [Kernel](https://docs.pimlico.io/references/permissionless/how-to/accounts/use-kernel-account), [Biconomy](https://docs.pimlico.io/guides/how-to/accounts/use-nexus-account), [SimpleAccount](https://docs.pimlico.io/guides/how-to/accounts/use-simple-account), and more.

    **You can easily integrate [`permissionless.js`](https://www.npmjs.com/package/permissionless) alongside Privy to create smart wallets from your user's embedded or external wallets, allowing you to enhance your app with gas sponsorship, batched transactions, and more.**

    Just follow the steps below!

    <Tip>
      Want to see an end-to-end integration of Privy with `permissionless.js`? Check out [**our example
      app**](https://github.com/privy-io/examples/tree/main/examples/privy-next-permissionless)!
    </Tip>

    <details>
      <summary><b>What is an EOA?</b></summary>

      An [**EOA, or externally-owned account**](https://ethereum.org/en/developers/docs/accounts/), is any Ethereum account that is controlled by a private key. Privy's embedded wallets and most external wallets (MetaMask, Coinbase Wallet, Rainbow Wallet, etc.) are EOAs.

      EOAs differ from **contract accounts**, which are instead controlled by smart contract code and do not have their own private key. Smart wallets are contract accounts. Contract accounts have [enhanced capabilities, such as gas sponsorship and batched transactions](https://ethereum.org/en/roadmap/account-abstraction/).

      Since they do not have their own private key, contract accounts cannot *directly* produce signatures and initiate transaction flows. Instead, each contract account is generally "managed" by an EOA, which authorizes actions taken by the contract account via a signature; this EOA is called a **signer**.

      In this integration, the user's EOA (from Privy) serves as the signer for their smart wallet (from permissionless). The smart wallet holds all assets and submits all transactions to the network, but the signer (Privy) is responsible for producing signatures and "kicking off" transaction flows.
    </details>

    ### 1. Install Privy and `permissionless.js`

    In your project, install the necessary dependencies from Privy, Pimlico, and [`viem`](https://viem.sh/):

    ```bash  theme={"system"}
    npm i @privy-io/react-auth permissionless viem
    ```

    ### 2. Sign up for a Pimlico account and create an API key.

    To send transactions from smart accounts, you will need access to a [**bundler**](https://www.alchemy.com/overviews/what-is-a-bundler). We also recommend using [**paymaster**](https://www.alchemy.com/overviews/what-is-a-paymaster) to sponsor your user's transactions.

    To get a **bundler** and **paymaster** for your application, [**sign up for a Pimlico account**](https://dashboard.pimlico.io/) and copy down your API key for the rest of this guide!

    ### 3. Configure your app's `PrivyProvider`

    First, follow the instructions in the [**Privy Quickstart**](/basics/react/quickstart) to get your app set up with Privy.

    Next, set **Add confirmation modals** to "off" in your app's **Embedded wallets** page in the Privy [**dashboard**](https://dashboard.privy.io). This will configure Privy to *not* show its default UIs when your user must sign messages or send transactions. Instead, we recommend you use your own custom UIs for showing users the [`UserOperation`](https://www.alchemy.com/overviews/user-operations)s they sign.

    Then, update the **`config.embeddedWallets.createOnLogin`** property of your **`PrivyProvider`** to `'users-without-wallets'`.This will configure Privy to create an embedded wallet for users logging in via a web2 method (email, phone, socials), ensuring that *all* of your users have a wallet that can be used as an EOA.

    Your **`PrivyProvider`** should then look like:

    ```tsx  theme={"system"}
    <PrivyProvider
        appId='insert-your-privy-app-id'
        config={{
            /* Replace this with your desired login methods */
            loginMethods: ['email', 'wallet'],
            /* Replace this with your desired appearance configuration */
            appearance: {
                theme: 'light',
                accentColor: '#676FFF',
                logo: 'your-logo-url'
            }
            embeddedWallets: {
                createOnLogin: 'users-without-wallets',
                showWalletUIs: false
            }
        }}
    >
        {/* Your app's components */}
    </PrivyProvider>
    ```

    ### 4. Create a smart account for your user

    You'll now create a smart account for your user, using the Privy embedded wallet (an EOA) as the signer.

    To do so, when the user logs in, **find the user's embedded wallet from Privy's `useWallets` hook, and create a viem [`WalletClient`](https://viem.sh/docs/clients/wallet.html) for it**. You can find embedded wallet by finding the only entry in the **`useWallets`** array with a **`walletClientType`** of `'privy'`.

    ```tsx  theme={"system"}
    import {useWallets} from '@privy-io/react-auth';
    import {sepolia} from 'viem/chains'; // Replace this with the chain used by your application
    import {createWalletClient, custom} from 'viem';

    ...

    // Find the embedded wallet and get its EIP1193 provider
    const {wallets} = useWallets();
    const embeddedWallet = wallets.find((wallet) => (wallet.walletClientType === 'privy'));
    const eip1193provider = await embeddedWallet.getEthereumProvider();

    // Create a viem WalletClient from the embedded wallet's EIP1193 provider
    // This will be used as the signer for the user's smart account
    const privyClient = createWalletClient({
      account: embeddedWallet.address,
      chain: sepolia, // Replace this with the chain used by your application
      transport: custom(eip1193provider)
    });
    ```

    Next, using the **`privyClient`** from above, create a **`SmartAccountClient`** which represents the user's smart account. In creating the smart account, you can also specify which smart account implementation you'd like to use. Possible options include: [Safe](https://docs.pimlico.io/guides/how-to/accounts/use-safe-account), [Kernel](https://docs.pimlico.io/guides/how-to/accounts/use-kernel-account), [Biconomy](https://www.biconomy.io/), and [SimpleAccount](https://docs.pimlico.io/guides/how-to/accounts/use-simple-account) (the original smart account implementation).

    If your app also uses a **paymaster** to sponsor gas on behalf of users, you can also specify which paymaster to use by calling the **`createPimlicoClient`** method from `permissionless` with the RPC URL in your Pimlico Dashboard.

    ```ts {skip-check} theme={"system"}
    import {createSmartAccountClient} from 'permissionless';
    import {toSimpleSmartAccount} from 'permissionless/accounts';
    import {createPimlicoClient} from 'permissionless/clients/pimlico';
    import {createPublicClient, http} from 'viem';
    import {sepolia} from 'viem/chains';
    import {entryPoint07Address} from 'viem/account-abstraction';
    import {useWallets} from '@privy-io/react-auth';

    const {wallets} = useWallets();
    const embeddedWallet = wallets.find((wallet) => wallet.walletClientType === 'privy');
    const provider = await embeddedWallet.getEthereumProvider();

    // Create a viem public client for RPC calls
    const publicClient = createPublicClient({
      chain: sepolia, // Replace this with the chain of your app
      transport: http()
    });

    // Initialize the smart account for the user
    const simpleSmartAccount = await toSimpleSmartAccount({
      client: publicClient,
      owner: {request: provider.request},
      entryPoint: {
        address: entryPoint07Address,
        version: '0.7'
      }
    });

    // Create the Paymaster for gas sponsorship using the API key from your Pimlico dashboard
    const pimlicoPaymaster = createPimlicoClient({
      transport: http('https://api.pimlico.io/v2/sepolia/rpc?apikey=YOUR_PIMLICO_API_KEY')
    });

    // Create the SmartAccountClient for requesting signatures and transactions (RPCs)
    const smartAccountClient = createSmartAccountClient({
      account: simpleSmartAccount,
      chain: sepolia, // Replace this with the chain for your app
      bundlerTransport: http('https://api.pimlico.io/v1/sepolia/rpc?apikey=YOUR_PIMLICO_API_KEY'),
      paymaster: pimlicoPaymaster // If your app uses a paymaster for gas sponsorship
    });
    ```

    When using the snippets above, make sure replace `YOUR_PIMLICO_API_KEY` with your Pimlico API key that you created in step 2!

    <Tip>
      You can also store the user's smart account address on Privy's user object. See [this
      guide](./address.md) for more.
    </Tip>

    <details>
      <summary><b>Want to see this code end-to-end?</b></summary>
      You can find the code snippets above pasted in an end-to-end example below.

      ```tsx  theme={"system"}
      /**
       * This example assumes your app is wrapped with the `PrivyProvider` and
       * is configured to create embedded wallets for users upon login. Aside from
       * the imports, all of the code in this snippet must be used within a React component
       * or context.
       */
      import {useWallets} from '@privy-io/react-auth';
      import {sepolia} from 'viem/chains'; // Replace this with the chain used by your application
      import {createWalletClient, createPublicClient, custom, http} from 'viem';
      import {entryPoint07Address} from 'viem/account-abstraction';
      import {createSmartAccountClient, walletClientToCustomSigner} from "permissionless";
      import {createPimlicoClient} from "permissionless/clients/pimlico";
      import {toSimpleSmartAccount} from "permissionless/accounts";

      ...

      // Find the embedded wallet and get its EIP1193 provider
      const {wallets} = useWallets();
      const embeddedWallet = wallets.find((wallet) => (wallet.walletClientType === 'privy'));
      const eip1193provider = await embeddedWallet.getEthereumProvider();

      // Create a viem WalletClient from the embedded wallet's EIP1193 provider
      const privyClient = createWalletClient({
        account: embeddedWallet.address,
        chain: sepolia, // Replace this with the chain used by your application
        transport: custom(eip1193provider)
      });

      // Create a viem public client for RPC calls
      const publicClient = createPublicClient({
        chain: sepolia, // Replace this with the chain of your app
        transport: http()
      })

      // Initialize the smart account for the user using the embedded wallet as the signer
      const customSigner = walletClientToCustomSigner(privyClient);
      const simpleSmartAccount = await toSimpleSmartAccount({
        client: publicClient,
        owner: eip1193provider,
        entryPoint: {
          address: entryPoint07Address,
          version: "0.7"
        },
      })

      // Create the Paymaster for gas sponsorship using the API key from your Pimlico dashboard
      const pimlicoPaymaster = createPimlicoClient({
        transport: http(
          "https://api.pimlico.io/v2/sepolia/rpc?apikey=YOUR_PIMLICO_API_KEY",
        ),
      })

      // Create the SmartAccountClient for requesting signatures and transactions
      const smartAccountClient = createSmartAccountClient({
          account: simpleSmartAccount,
          chain: sepolia, // Replace this with the chain for your app
          transport: http("https://api.pimlico.io/v1/sepolia/rpc?apikey=YOUR_PIMLICO_API_KEY"),
          paymaster: pimlicoPaymaster // If your app uses a paymaster for gas sponsorship
      })
      ```

      Note: if your app uses React, we suggest that you store the user's `SmartAccountClient` in a [React context](https://react.dev/learn/passing-data-deeply-with-context) that wraps your application. This allows you to easily access the smart account from your app's pages and components.
    </details>

    ### 5. Send transactions from the smart account

    You can now send transactions using the **`sendTransaction`** method on the [**`SmartAccountClient`**](https://docs.pimlico.io/references/permissionless/reference/clients/smartAccountClient) object, like so:

    ```ts {skip-check} theme={"system"}
    const txHash = await smartAccountClient.sendTransaction({
      account: smartAccountClient.account,
      to: 'zero-address',
      data: '0x',
      value: BigInt(0)
    });
    ```

    You can also request signatures, typed data signatures, and more from the smart account! The [**`SmartAccountClient`**](https://docs.pimlico.io/references/permissionless/reference/clients/smartAccountClient) functions as a drop-in replacement for [`viem`'s wallet client](https://viem.sh/docs/clients/wallet#wallet-client) - you can use the same interfaces with the [**`SmartAccountClient`**](https://docs.pimlico.io/references/permissionless/reference/clients/smartAccountClient) object!

    **That's it! Once you've created smart accounts for your users, you can easily add AA features into your application like gas sponsorship, batched transactions, and more.** 🎉 To learn more about what you can do with smart accounts, check out the [**`permissionless.js` guide**](https://docs.pimlico.io/guides/how-to/signers/privy).
  </Tab>

  <Tab title="Biconomy">
    ## Account abstraction with Biconomy

    <Info>
      Biconomy has an updated guide for using the new [Biconomy
      Nexus](https://www.biconomy.io/post/nexus-modular-smart-account) smart accounts. Please refer to
      the [Biconomy guide](https://docs.biconomy.io/tutorials/signers/privy) for the most up-to-date
      information.
    </Info>

    [Biconomy](https://www.biconomy.io/) is a toolkit for creating [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337)-compatible smart accounts for your users, using the user's EOA as the smart account's signer. This allows you to easily add [Account Abstraction](https://ethereum.org/en/roadmap/account-abstraction/) features into your app.

    **You can easily integrate Biconomy alongside Privy to create smart wallets from your user's embedded or external wallets, allowing you to enhance your app with [gas sponsorship](https://docs.biconomy.io/dashboard/paymaster) and more!**

    Read below to learn how to configure your app to create smart wallets for *all* your users!

    <Tip>
      Want to see an end-to-end integration of Privy with Biconomy? Check out **an example
      [app](https://aaprivy.vercel.app/) and [repo](https://github.com/bcnmy/biconomy_privy_example)**!
    </Tip>

    <details>
      <summary><b>What is an EOA?</b></summary>

      An [**EOA, or externally-owned account**](https://ethereum.org/en/developers/docs/accounts/), is any Ethereum account that is controlled by a private key. Privy's embedded wallets and most external wallets (MetaMask, Coinbase Wallet, Rainbow Wallet, etc.) are EOAs.

      EOAs differ from **contract accounts**, which are instead controlled by smart contract code and do not have their own private key. Biconomy's smart wallet is a contract account. Contract accounts have [enhanced capabilities, such as gas sponsorship and batched transactions](https://ethereum.org/en/roadmap/account-abstraction/).

      Since they do not have their own private key, contract accounts cannot *directly* produce signatures and initiate transaction flows. Instead, each contract account is generally "managed" by an EOA, which authorizes actions taken by the contract account via a signature; this EOA is called a **signer**.

      In this integration, the user's EOA (from Privy) serves as the signer for their smart wallet (from Biconomy). The smart wallet (Biconomy) holds all assets and submits all transactions to the network, but the signer (Privy) is responsible for producing signatures and "kicking off" transaction flows.
    </details>

    ### 1. Install Privy and Biconomy

    In your app's repository, install the [**`@privy-io/react-auth`**](https://www.npmjs.com/package/@privy-io/react-auth) SDK from Privy and the [**`@biconomy/account`**](https://docs.biconomy.io/Account/integration#installation) SDK from Biconomy:

    ```sh  theme={"system"}
    npm i @privy-io/react-auth @biconomy/account
    ```

    ### 2. Configure your app's `PrivyProvider`

    First, follow the instructions in the [**Privy Quickstart**](/basics/react/quickstart) to get your app set up with Privy.

    Next, set **Add confirmation modals** to "off" in your app's **Embedded wallets** page in the Privy [**dashboard**](https://dashboard.privy.io). This will configure Privy to *not* show its default UIs when your user must sign messages or send transactions. Instead, we recommend you use your own custom UIs for showing users the [`UserOperation`](https://www.alchemy.com/overviews/user-operations)s they sign.

    Then, update the **`config.embeddedWallets.createOnLogin`** property of your **`PrivyProvider`** to `'users-without-wallets'`.This will configure Privy to create an embedded wallet for users logging in via a web2 method (email, phone, socials), ensuring that *all* of your users have a wallet that can be used as an EOA.

    Your **`PrivyProvider`** should then look like:

    ```tsx  theme={"system"}
    <PrivyProvider
        appId='insert-your-privy-app-id'
        config={{
            embeddedWallets: {
                createOnLogin: 'users-without-wallets',
            }
            ...insertTheRestOfYourPrivyProviderConfig
        }}
    >
        {/* Your app's components */}
    </PrivyProvider>
    ```

    ### 3. Configure your Biconomy bundler and paymaster

    Go to the [**Biconomy Dashboard**](https://dashboard.biconomy.io/) and configure a **Paymaster** and a **Bundler** for your app. Make sure these correspond to the desired network for your user's smart accounts.

    <figure style="width: 100%; display: flex; flex-direction: column; align-items: center;">
      <img src="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/biconomy-paymaster.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=ebaf688fd3e3abafbabfe704b4aaf395" style="width: 80%;" alt="Pregenerate user wallets" data-og-width="3824" width="3824" data-og-height="1920" height="1920" data-path="images/biconomy-paymaster.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/biconomy-paymaster.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=90427164fac4c460e0265bebaca4ead5 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/biconomy-paymaster.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=bfc392d6e28a685a6139ce6e837e680f 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/biconomy-paymaster.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=eb023e2326eb9c9b7a9d24a78d181ce6 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/biconomy-paymaster.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=c4d4d634b9096f91c3e1fd12f0a4b66d 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/biconomy-paymaster.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=ea98698da960fd215492e8001eeb8054 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/biconomy-paymaster.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=3cced7762e0436dddfb0c3f006f616e1 2500w" />

      <figcaption>Configuring your Biconomy Paymaster</figcaption>
    </figure>

    Once you've configured a **Paymaster**, you can also deposit funds into your app's gas tank and configure specific policies for [**gas sponsorship**](https://docs.biconomy.io/dashboard/paymaster).

    Save the bundler URL and paymaster API key for your project, as you will need those values later.

    ### 4. Initialize your users' smart accounts

    When users log into your app, Privy provisions each user an embedded wallet, which is an EOA. In order to leverage the features of Biconomy's account abstraction, each user also needs a Biconomy smart account. **You can provision Biconomy smart accounts for each user by assigning their embedded wallet as a signer for their smart account**.

    To start, after a user logs in, **find the user's embedded wallet from Privy's `useWallets` hook, and switch its network to your app's target network**. You can find embedded wallet by finding the only entry in the **`useWallets`** array with a **`walletClientType`** of `'privy'`.

    ```tsx  theme={"system"}
    import {useWallets} from '@privy-io/react-auth';
    ...
    // Find the embedded wallet
    const {wallets} = useWallets();
    const embeddedWallet = wallets.find((wallet) => (wallet.walletClientType === 'privy'));
    // Switch the embedded wallet to your target network
    // Replace '80001' with your desired chain ID.
    await embeddedWallet.switchChain(80001);
    ```

    Next, using your paymaster API key and bundler URL from the Biconomy Dashboard, **initialize the user's smart account using Biconomy's [`createSmartAccountClient`](https://docs.biconomy.io/Account/methods#createsmartaccountclient) method**:

    ```tsx  theme={"system"}
    import { createSmartAccountClient } from "@biconomy/account";
    ...
    // Get an ethers provider and signer for the user's embedded wallet
    const provider = await embeddedWallet.getEthereumProvider();
    const ethersProvider = new ethers.providers.Web3Provider(provider);
    const ethersSigner = ethersProvider.getSigner()

    const smartAccount = await createSmartAccountClient({
        signer: ethersSigner,
        bundlerUrl: 'your-bundler-url-from-the-biconomy-dashboard',
        biconomyPaymasterApiKey: 'your-paymaster-api-key-from-the-biconomy-dashboard'
    });
    ```

    <Tip>
      You can also store the user's smart account address on Privy's user object. See [this
      guide](./address.md) for more.
    </Tip>

    <details>
      <summary><b>Want to see this code end-to-end?</b></summary>
      You can find the code snippets above pasted in an end-to-end example below.

      ```tsx  theme={"system"}
      import {createSmartAccountClient} from '@biconomy/account';

      import {useWallets} from '@privy-io/react-auth';

      // Find the embedded wallet and switch it to your target network
      const {wallets} = useWallets();
      const embeddedWallet = wallets.find((wallet) => wallet.walletClientType === 'privy');
      await embeddedWallet.switchChain(80001);

      const provider = await embeddedWallet.getEthereumProvider();
      const ethersProvider = new ethers.providers.Web3Provider(provider);
      const ethersSigner = ethersProvider.getSigner();

      // Initialize your smart account
      const smartAccount = await createSmartAccountClient({
        signer: ethersSigner,
        bundlerUrl: 'your-bundler-url-from-the-biconomy-dashboard',
        biconomyPaymasterApiKey: 'your-paymaster-api-key-from-the-biconomy-dashboard'
      });
      ```

      Note: if your app uses React, we suggest that you store the user's Biconomy `smartAccount` in a React context that wraps your application. This allows you to easily access the smart account from your app's pages and components.
    </details>

    ## 5. Send transactions from the smart account

    Now that your users have Biconomy smart accounts, they can now send transaction from their smart account.

    To send a transaction from a user's smart account, use Biconomy's [**`sendTransaction`**](https://docs.biconomy.io/Account/methods#sendtransaction-) method. An example of sending a transaction to mint an NFT gaslessly is below:

    ```tsx  theme={"system"}
    // Initialize an ethers JsonRpcProvider for your network
    const provider = new ethers.providers.JsonRpcProvider(`insert-rpc-url-for-your-network`);
    // Initialize an ethers contract instance for your NFT
    const nft = new ethers.Contract('insert-your-NFT-address', insertYourNftAbi, provider);

    // Construct a Transaction for the minting transaction
    const mintTransaction = await nft.populateTransaction.mint!('insert-the-smart-account-address');
    // `smartAccount` is the Biconomy smart account we initialized above
    const mintTx = {
      to: 'insert-your-NFT-address',
      data: mintTransaction.data
    };

    // Send transaction to mempool, to mint NFT gaslessly
    const userOpResponse = await smartAccount.sendTransaction(mintTx, {
      paymasterServiceData: {mode: PaymasterMode.SPONSORED}
    });

    const {transactionHash} = await userOpResponse.waitForTxHash();
    console.log('Transaction Hash', transactionHash);

    const userOpReceipt = await userOpResponse.wait();
    if (userOpReceipt.success == 'true') {
      console.log('UserOp receipt', userOpReceipt);
      console.log('Transaction receipt', userOpReceipt.receipt);
    }
    ```

    **That's it! You've configured your app to create smart wallets for all of your users, and can seamlessly add in AA features like [gas sponsorship](https://docs.biconomy.io/dashboard/paymaster) and more.** 🎉
  </Tab>

  <Tab title="AccountKit">
    ## Account Abstraction with AccountKit

    [AccountKit](https://accountkit.alchemy.com/) is a toolkit by [Alchemy](https://www.alchemy.com/) for creating [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337)-compatible smart accounts for your users, using the user's EOA as the smart account's signer. This allows you to easily add [Account Abstraction](https://ethereum.org/en/roadmap/account-abstraction/) features into your app.

    **You can easily integrate AccountKit alongside Privy to create smart wallets from your user's embedded or external wallets, allowing you to enhance your app with gas sponsorship, batched transactions, and more!**

    Read below to learn how to configure your app to create smart wallets for *all* your users!

    <details>
      <summary><b>What is an EOA?</b></summary>

      An [**EOA, or externally-owned account**](https://ethereum.org/en/developers/docs/accounts/), is any Ethereum account that is controlled by a private key. Privy's embedded wallets and most external wallets (MetaMask, Coinbase Wallet, Rainbow Wallet, etc.) are EOAs.

      EOAs differ from **contract accounts**, which are instead controlled by smart contract code and do not have their own private key. AccountKit's smart wallet is a contract account. Contract accounts have [enhanced capabilities, such as gas sponsorship and batched transactions](https://ethereum.org/en/roadmap/account-abstraction/).

      Since they do not have their own private key, contract accounts cannot *directly* produce signatures and initiate transaction flows. Instead, each contract account is generally "managed" by an EOA, which authorizes actions taken by the contract account via a signature; this EOA is called a **signer**.

      In this integration, the user's EOA (from Privy) serves as the signer for their smart wallet (from AccountKit). The smart wallet (AccountKit) holds all assets and submits all transactions to the network, but the signer (Privy) is responsible for producing signatures and "kicking off" transaction flows.
    </details>

    ### 1. Install Privy and AccountKit

    Install the [**`@privy-io/react-auth`**](https://www.npmjs.com/package/@privy-io/react-auth) SDK from Privy, the [**`@account-kit/privy-integration`**](https://www.alchemy.com/docs/wallets/third-party/signers/privy) SDKs from Alchemy, and [**`viem`**](https://viem.sh/):

    ```sh  theme={"system"}
    npm i @privy-io/react-auth @account-kit/privy-integration viem
    ```

    ### 2. Configure your app's `PrivyProvider`

    First, follow the instructions in the [**Privy Quickstart**](/basics/react/quickstart) to get your app set up with Privy.

    Next, set **Add confirmation modals** to "off" in your app's **Embedded wallets** page in the Privy [**dashboard**](https://dashboard.privy.io). This will configure Privy to *not* show its default UIs when your user must sign messages or send transactions. Instead, we recommend you use your own custom UIs for showing users the [`UserOperation`](https://www.alchemy.com/overviews/user-operations)s they sign.

    Then, update the **`config.embeddedWallets.createOnLogin`** property of your **`PrivyProvider`** to `'users-without-wallets'`.This will configure Privy to create an embedded wallet for users logging in via a web2 method (email, phone, socials), ensuring that *all* of your users have a wallet that can be used as an EOA.

    Lastly, add the `AlchemyProvider` as a child of your `PrivyProvider`, passing in your Alchemy API key and gas policy ID.

    Your **`PrivyProvider`** should then look like:

    ```tsx  theme={"system"}
    <PrivyProvider
        appId='insert-your-privy-app-id'
        config={{
            /* Replace this with your desired login methods */
            loginMethods: ['email', 'wallet'],
            /* Replace this with your desired appearance configuration */
            appearance: {
                theme: 'light',
                accentColor: '#676FFF',
                logo: 'your-logo-url'
            }
            embeddedWallets: {
                createOnLogin: 'users-without-wallets',
                showWalletUIs: false
            },
            // Import your desired chain from `viem/chains` and pass it to `defaultChain`
            defaultChain: sepolia,
        }}
    >
      <AlchemyProvider apiKey="your-alchemy-api-key" policyId="your-gas-policy-id">
        {/* Your app's components */}
      </AlchemyProvider>
    </PrivyProvider>
    ```

    Just like that, your app is now configured to create smart accounts for all of your users automatically upon login!

    ### 3. Send gasless transactions with Alchemy's AccountKit SDK

    Now that your users have smart accounts created for them automatically, you can use Alchemy's AccountKit SDK to send gasless transactions from their smart accounts.

    ```tsx  theme={"system"}
    import {useAlchemySendTransaction} from '@account-kit/privy-integration';

    function SendButtons() {
      const {sendTransaction, isLoading} = useAlchemySendTransaction();

      const single = async () => await sendTransaction({to: '0x...', data: '0x...', value: '0x0'});

      const batch = async () =>
        await sendTransaction([
          {to: '0x...', data: '0x...'},
          {to: '0x...', data: '0x...'}
        ]);

      return (
        <>
          <button onClick={single} disabled={isLoading}>
            Send
          </button>
          <button onClick={batch} disabled={isLoading}>
            Send Batch
          </button>
        </>
      );
    }
    ```

    **That's it! You've configured your app to create smart wallets for all of your users, and can seamlessly add in AA features like gas sponsorship, batched transactions, and more.** 🎉 To learn more about using Alchemy's AccountKits with Privy, check out the [full guide from Alchemy](https://www.alchemy.com/docs/wallets/third-party/signers/privy).
  </Tab>
</Tabs>


# Integrating smart accounts with wagmi
Source: https://docs.privy.io/recipes/account-abstraction/wagmi



If your app uses wagmi and one of Privy's account abstraction integrations to set up smart accounts for the embedded wallet, you can configure wagmi to reflect the smart account for the embedded wallet instead of the externally-owned account (e.g. signer) by following the instructions below.

## Resources

<CardGroup cols={1}>
  <Card title="Wagmi starter template" icon="github" href="https://github.com/privy-io/examples/tree/main/examples/privy-next-wagmi" arrow>
    Complete starter repository showcasing Privy's wagmi integration with smart accounts and
    embedded wallets.
  </Card>
</CardGroup>

## 0. Setup

This guide assumes that you have already integrated both Privy and wagmi into your app, and are now looking to set up wagmi with smart accounts.

If you have not yet set up the basic integration, please first follow the [Privy quickstart](/basics/react/quickstart) and our [wagmi integration guide](/wallets/connectors/ethereum/integrations/wagmi).

## 1. Initialize an EIP1193 provider for the smart account

Once you've set up your app with wagmi, implement a function that initializes the smart account of your choice (Kernel, SimpleAccount, Biconomy, etc.) from the Privy embedded wallet.

As a parameter, the function should accept an object with a `signer` field that contains a viem [`EIP1193Provider`](https://github.com/wevm/viem/blob/74dbb2e7276af349bc03988eca5ec99b83292e61/src/types/eip1193.ts#L26) for the Privy embedded wallet. It should then initialize a smart account, using the embedded wallet as a signer, and should return a Promise for a viem [`EIP1193Provider`](https://github.com/wevm/viem/blob/74dbb2e7276af349bc03988eca5ec99b83292e61/src/types/eip1193.ts#L26) for the smart account.The function should have the following type:

```tsx  theme={"system"}
async ({signer}: {signer: EIP1193Provider}) => Promise<EIP1193Provider>;
```

As an example, if you are using Privy alongside ZeroDev for smart account support, you can define this function like so:

```tsx  theme={"system"}
import {signerToEcdsaValidator} from '@zerodev/ecdsa-validator';
import {
  createKernelAccount,
  createZeroDevPaymasterClient,
  createKernelAccountClient,
  KernelEIP1193Provider,
  KernelAccountClient
} from '@zerodev/sdk';
import {getEntryPoint, KERNEL_V3_1} from '@zerodev/sdk/constants';
import {http, createPublicClient, EIP1193Provider} from 'viem';
import {baseSepolia} from 'viem/chains';

// Create a public client
const publicClient = createPublicClient({
  transport: http(process.env.BUNDLER_RPC)
});

const entryPoint = getEntryPoint('0.7');
const kernelVersion = KERNEL_V3_1;

export const signerToZeroDevSmartAccount = async ({
  signer
}: {
  signer: EIP1193Provider;
}): Promise<EIP1193Provider> => {
  // Create an ECDSA validator using the EIP1193Provider directly
  const ecdsaValidator = await signerToEcdsaValidator(publicClient, {
    signer: signer,
    entryPoint,
    kernelVersion
  });

  // Create a Kernel account
  const kernelAccount = await createKernelAccount(publicClient, {
    plugins: {
      sudo: ecdsaValidator
    },
    entryPoint,
    kernelVersion
  });

  // Initialize a Kernel (smart account) client from the signer
  const kernelClient = createKernelAccountClient({
    account: kernelAccount,
    chain: baseSepolia,
    bundlerTransport: http(process.env.BUNDLER_RPC),
    client: publicClient,
    paymaster: {
      getPaymasterData: async ({userOperation}) => {
        const paymasterClient = createZeroDevPaymasterClient({
          chain: baseSepolia,
          transport: http(process.env.PAYMASTER_RPC),
          entryPoint
        });
        return paymasterClient.sponsorUserOperation({
          userOperation,
          entryPoint
        });
      }
    }
  }) as KernelAccountClient;

  // Get an EIP1193Provider for the Kernel smart account and return it
  const kernelProvider = new KernelEIP1193Provider(kernelClient);
  return kernelProvider as EIP1193Provider;
};
```

## 2. Use the smart account's EIP1193Provider to register a wagmi connector

Next, import the `useEmbeddedSmartAccountConnector` hook from `@privy-io/wagmi`. This hook allows you to register a smart account connector for wagmi that replaces the regular embedded wallet connector.

```tsx  theme={"system"}
import {useEmbeddedSmartAccountConnector} from '@privy-io/wagmi';
```

Now, call the `useEmbeddedSmartAccountConnector` hook to register a smart account connector with wagmi. As a parameter to the hook, pass an object with the following fields:

| Field                       | Type                                                                      | Description                                                                                                                                                                                   |
| --------------------------- | ------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `getSmartAccountFromSigner` | `async ({signer}: {signer: EIP1193Provider}) => Promise<EIP1193Provider>` | A function that takes an `EIP1193Provider` for the user's embedded wallet and converts it to an `EIP1193Provider` for the smart account. This is the same function you implemented in step 1. |

<Info>
  **The `useEmbeddedSmartAccountConnector` hook must be mounted at all times when using wagmi with
  the smart account.** We recommend calling the hook in a component close to the root of your
  application.
</Info>

As an example, if you are using Privy alongside ZeroDev for smart account support, you might call the hook like so:

```tsx  theme={"system"}
// This hook must be mounted whenever using wagmi with the smart account
// See step 1 for the implementation of `signerToZeroDevSmartAccount`
useEmbeddedSmartAccountConnector({
  getSmartAccountFromSigner: signerToZeroDevSmartAccount
});
```

**That's it! You've now registered a smart account connector for the embedded wallet with Privy's wagmi integration, and can use wagmi hooks to interface with the smart account 🎉.**

<Info>
  Currently, Privy's wagmi integration only supports using a smart account with **embedded wallets**, not external wallets (e.g. MetaMask). With the setup above, if a user has an embedded wallet, the smart account connector will be the *only* wallet connected to wagmi.

  If a user does not have an embedded wallet and is using an external wallet, wagmi will interface with the external wallets as usual.
</Info>


# Using Supabase as an authentication provider
Source: https://docs.privy.io/recipes/authentication/using-supabase-for-custom-auth



This guide demonstrates how to integrate Supabase's authentication system with Privy to create a custom authentication flow. This setup allows you to leverage Supabase's powerful authentication and backend features, including Row Level Security (RLS) for data access control, while managing user wallets in Privy.

## Configure your Supabase project

Before integrating with Privy, you need to configure your Supabase project to use JWT tokens for authentication. Follow the [Supabase JWT signing keys documentation](https://supabase.com/docs/guides/auth/signing-keys) to:

1. Migrate your Supabase project to use the new JWT signing keys.
2. Get the JWKS endpoint URL, which will look like `https://[PROJECT_ID].supabase.co/auth/v1/.well-known/jwks.json`.
3. Ensure your Supabase project is using an asymmetric signing algorithm.

<Info>
  Make sure to complete the JWT signing key migration in Supabase before proceeding with the Privy
  integration. This ensures your tokens will be properly validated.
</Info>

## Configure your Privy project

Navigate to your Privy dashboard and configure JWT-based authentication following the [custom authentication guide](/authentication/user-authentication/jwt-based-auth/setup).

## Configure your Next.js project

### 1. Create Supabase clients

Create separate Supabase clients for server-side and client-side operations.

<Tabs>
  <Tab title="Server">
    ```typescript lib/supabase/server.ts theme={"system"}
    import { createServerClient } from '@supabase/ssr'
    import { cookies } from 'next/headers'

    export async function createSupabaseServer(token?: string) {
      const cookieStore = cookies()

      return createServerClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY!,
        {
          cookies: {
            get(name: string) {
              return cookieStore.get(name)?.value
            },
            set(name: string, value: string, options: any) {
              cookieStore.set({ name, value, ...options })
            },
            remove(name: string, options: any) {
              cookieStore.set({ name, value: '', ...options })
            },
          },
          global: {
            headers: token ? { Authorization: `Bearer ${token}` } : {},
          },
        }
      )
    }
    ```
  </Tab>

  <Tab title="Client">
    ```typescript lib/supabase/client.ts theme={"system"}
    import { createBrowserClient } from '@supabase/ssr'

    export function createSupabaseClient(token?: string) {
      return createBrowserClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY!,
      )
    }
    ```
  </Tab>
</Tabs>

### 2. Create a Supabase provider and hook

Create a provider that integrates Privy authentication with Supabase:

```tsx components/SupabaseProvider.tsx theme={"system"}
'use client';

import {createContext, useContext, useEffect, useMemo, useState} from 'react';
import {SupabaseClient, Session, User} from '@supabase/supabase-js';
import {usePathname, useRouter} from 'next/navigation';
import {createClient} from '@/lib/supabase/client';

interface SupabaseContextType {
  supabase: SupabaseClient;
  session: Session | null;
  user: User | null;
  loading: boolean;
}

const SupabaseContext = createContext<SupabaseContextType | undefined>(undefined);

export const SupabaseProvider = ({children}: {children: React.ReactNode}) => {
  const [session, setSession] = useState<Session | null>(null);
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const router = useRouter();
  const pathname = usePathname();

  const supabase = useMemo(() => createClient(), []);

  useEffect(() => {
    supabase.auth
      .getSession()
      .then(({data: {session}}) => {
        setSession(session);
        setUser(session?.user || null);
        setLoading(false);
      })
      .catch(() => {
        setLoading(false);
      });

    const {data: authListener} = supabase.auth.onAuthStateChange(async (event, currentSession) => {
      setSession(currentSession);
      setUser(currentSession?.user || null);
      setLoading(false);

      // Optional: Redirect based on auth state
      if (event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED') {
        // console.log("User signed in or token refreshed");
        // router.push("/dashboard"); // Example redirect
      } else if (event === 'SIGNED_OUT') {
        // console.log("User signed out");
        router.push('/'); // Example redirect
      }
    });

    return () => {
      authListener.subscription.unsubscribe();
    };
  }, [pathname]);

  return (
    <SupabaseContext.Provider value={{supabase, session, user, loading}}>
      {children}
    </SupabaseContext.Provider>
  );
};

export const useSupabase = () => {
  const context = useContext(SupabaseContext);
  if (context === undefined) {
    throw new Error('useSupabase must be used within a SupabaseProvider');
  }
  return context;
};
```

### 3. Create a Providers component and add to root layout

Create a combined providers component and wrap your application with it in the root layout:

```tsx components/Providers.tsx theme={"system"}
'use client';

import {PrivyProvider} from '@privy-io/react-auth';
import {SupabaseProvider, useSupabase} from './SupabaseProvider';

export default function Providers({children}: {children: React.ReactNode}) {
  return (
    <SupabaseProvider>
      <InnerPrivyProvider>{children}</InnerPrivyProvider>
    </SupabaseProvider>
  );
}

function InnerPrivyProvider({children}: {children: React.ReactNode}) {
  const {loading, supabase, session} = useSupabase();

  async function getCustomAuthToken() {
    if (!session) return undefined;

    const {data, error} = await supabase.auth.getSession();
    if (error) {
      console.error('Error getting session:', error);
      return undefined;
    }

    return data.session?.access_token || undefined;
  }

  return (
    <PrivyProvider
      appId={process.env.NEXT_PUBLIC_PRIVY_APP_ID || ''}
      config={{
        customAuth: {
          isLoading: loading,
          getCustomAccessToken: getCustomAuthToken
        },
        embeddedWallets: {
          createOnLogin: 'all-users'
        }
      }}
    >
      {children}
    </PrivyProvider>
  );
}
```

The `getCustomAuthToken` function retrieves the current session's access token from Supabase and passes it to Privy's `getCustomAccessToken` configuration. Privy uses this token to validate the user's authentication state through the JWKS endpoint configured in your Privy dashboard.

### 4. Just use Privy!

You can now access the Privy user object, create wallets and sign messages!

## Conclusion

With this setup complete, you now have a fully integrated Privy and Supabase authentication system. You can:

* Use Supabase for user management, database operations, and real-time features.
* Leverage Privy's wallet management capabilities.
* Customize your authentication flow to match your brand and UI while taking advantage of Supabase RLS!


# Bankr Twitter bot guide
Source: https://docs.privy.io/recipes/bankr-bot-guide



This guide will walk through building a Twitter bot on top of the Clanker protocol similar to **[Bankr](https://bankr.bot/)**, **[Dealr](https://dealr.fun/)**, **[Beamr](https://beamr.xyz/)**, and others. This bot will use an LLM to interpret user requests, Privy wallets to manage EVM accounts, and the Clanker protocol to deploy tokens on Base.

### Resources

<CardGroup cols={3}>
  <Card title="Clanker API docs" icon="arrow-up-right-from-square" href="https://clanker.gitbook.io/clanker-documentation/developers/api" arrow>
    Learn how to deploy tokens on Base using the Clanker API.
  </Card>

  <Card title="Privy Wallets" icon="wallet" href="/wallets/overview" arrow>
    Privy wallets for secure EVM wallet management.
  </Card>

  <Card title="Twitter API" icon="twitter" href="https://developer.twitter.com/en/docs/twitter-api" arrow>
    Reference for building bots on Twitter.
  </Card>
</CardGroup>

## Set up your Twitter bot

To interact with users, you'll need a Twitter developer account and a bot. Learn more [here](https://developer.twitter.com/en/docs/twitter-api/getting-started/getting-access-to-the-twitter-api).

<Expandable title="Set up Twitter bot (pseudocode)">
  <Steps>
    <Step title="Register your Twitter app">
      1. Go to the [Twitter Developer Portal](https://developer.twitter.com/en/portal/dashboard).
      2. Create a new project and app.
      3. Generate API keys and access tokens.
      4. Safely store your credentials.
    </Step>

    <Step title="Set up Node.js Twitter bot server">
      1. Use a library like `twitter-api-v2` to interact with Twitter.
      2. Install the library:

      <CodeGroup>
        ```bash npm theme={"system"}
        npm install twitter-api-v2
        ```

        ```bash pnpm theme={"system"}
        pnpm install twitter-api-v2
        ```

        ```bash yarn theme={"system"}
        yarn add twitter-api-v2
        ```
      </CodeGroup>

      3. Create a basic Twitter client setup:

      ```typescript  theme={"system"}
      import { TwitterApi } from 'twitter-api-v2';

      // Initialize the Twitter client with your credentials
      const client = new TwitterApi({
        appKey: process.env.TWITTER_API_KEY!,
        appSecret: process.env.TWITTER_API_SECRET!,
        accessToken: process.env.TWITTER_ACCESS_TOKEN!,
        accessSecret: process.env.TWITTER_ACCESS_SECRET!,
      });

      // Get the read/write client
      const rwClient = client.readWrite;
      ```

      4. Example Node.js code to poll for mentions and robustly parse commands:

      <Expandable title="Example Twitter API mention payload">
        ```json  theme={"system"}
        {
          "data": {
            "id": "1234567890123456789",
            "text": "@bankr_bot send @elonmusk 1 eth from my wallet",
            "author_id": "09876543210987654321",
            "entities": {
              "mentions": [
                { "start": 0, "end": 10, "username": "bankr_bot" },
                { "start": 16, "end": 25, "username": "elonmusk" }
              ]
            }
          },
          "includes": {
            "users": [
              { "id": "09876543210987654321", "username": "sender_username", "name": "Sender Name" },
              { "id": "12345678909876543210", "username": "bankr_bot", "name": "Bankr Bot" },
              { "id": "11223344556677889900", "username": "elonmusk", "name": "Elon Musk" }
            ]
          }
        }
        ```
      </Expandable>

      ```typescript  theme={"system"}
      async function pollMentions() {
        let sinceId: string | undefined = undefined;
        while (true) {
          const mentions = await rwClient.v2.userMentionTimeline('YOUR_BOT_USER_ID', {
            since_id: sinceId,
            expansions: ['author_id', 'entities.mentions.username'],
            'user.fields': ['username', 'name'],
            max_results: 5,
          });
          for (const tweet of mentions.data?.data || []) {
            const parsed = processTweet(tweet, mentions);
            if (parsed) {
              // Call your LLM or transaction logic here
              // e.g. handleCommand(parsed)
            }
            sinceId = tweet.id;
          }
          await new Promise(res => setTimeout(res, 10000)); // poll every 10s
        }
      }

      function processTweet(tweet, mentionsResponse) {
        // Extract basic tweet information
        const text = tweet.text;
        const authorId = tweet.author_id;
        const tweetId = tweet.id;
        const mentions = tweet.entities?.mentions || [];

        // Extract all mentioned users
        const mentionedUsers = mentions.map(mention => {
          const username = mention.username;
          const user = mentionsResponse.includes?.users.find(u => u.username === username);
          return {
            username,
            userId: user?.id,
            isBot: username === 'bankr_bot' // Identify if this is our bot
          };
        });

        // Pass the structured data to the LLM for intent detection
        return {
          text,
          authorId,
          tweetId,
          mentions: mentionedUsers,
          // Additional context can be added here
        };
      }
      ```

      * This code polls for new mentions, parses the tweet for sender, recipient, amount, and currency, and passes the result to your LLM or transaction logic.
      * For production, consider using the [filtered stream](https://github.com/PLhery/node-twitter-api-v2/blob/master/doc/streaming.md) for real-time events.
    </Step>
  </Steps>
</Expandable>

## Set up Privy wallets

Privy wallets let you create and control EVM wallets programmatically. Learn more about [getting started with wallets](/basics/nodeJS/installation).

## Using wallets

In our example application, we will build two basic interactions with Privy wallets:

* **Create a wallet**
* **Get a user's wallet**

Using these core building blocks, we can allow our bot to seamlessly and securely create and manage wallets for users.

<Steps>
  <Step title="Create a wallet for a user">
    This function creates a new wallet for a user and saves the wallet ID to the database.

    <CodeGroup>
      ```ts @privy-io/node {skip-check} theme={"system"}
      /**
       * Creates a new wallet for a user
       * @param userId - The Twitter user ID
       * @returns The wallet object with id, address, and other properties
       */
      async function createUserWallet(userId) {
        // Create a new wallet for the user
        const wallet = await privy.wallets().create({chain_type: 'ethereum'});

        // EXAMPLE: Save the wallet ID to the database to save the mapping between the user and their wallet
        await db.wallets.set(userId, wallet.id);

        return wallet;
      }
      ```

      ```ts @privy-io/server-auth {skip-check} theme={"system"}
      /**
       * Creates a new wallet for a user
       * @param userId - The Twitter user ID
       * @returns The wallet object with id, address, and other properties
       */
      async function createUserWallet(userId) {
        // Create a new wallet for the user
        const wallet = await privy.walletApi.createWallet({chainType: 'ethereum'});

        // EXAMPLE: Save the wallet ID to the database to save the mapping between the user and their wallet
        await db.wallets.set(userId, wallet.id);

        return wallet;
      }
      ```
    </CodeGroup>
  </Step>

  <Step title="Get a user wallet">
    This function checks if a user has a wallet and returns it if it exists.

    <CodeGroup>
      ```ts @privy-io/node {skip-check} theme={"system"}
      /**
       * Gets a user's wallet if it exists
       * @param userId - The Twitter user ID
       * @returns The wallet object or null if no wallet exists
       */
      async function getUserWallet(userId) {
        // EXAMPLE: Check if user already has a wallet
        const walletId = await db.wallets.get(userId);

        // If wallet exists, retrieve and return the wallet
        if (walletId) {
          const wallet = await privy.wallets().get(walletId);
          return wallet;
        }

        return null;
      }
      ```

      ```ts @privy-io/server-auth {skip-check} theme={"system"}
      /**
       * Gets a user's wallet if it exists
       * @param userId - The Twitter user ID
       * @returns The wallet object or null if no wallet exists
       */
      async function getUserWallet(userId) {
        // EXAMPLE: Check if user already has a wallet
        const walletId = await db.wallets.get(userId);

        // If wallet exists, retrieve and return the wallet
        if (walletId) {
          const wallet = await privy.walletApi.getWallet(walletId);
          return wallet;
        }

        return null;
      }
      ```
    </CodeGroup>
  </Step>

  <Step title="Get or create a wallet">
    A higher level function that uses the `getUserWallet` and `createUserWallet` functions to get or create a wallet for a user.

    ```typescript {skip-check} theme={"system"}
    /**
     * Gets a user's wallet or creates one if they don't have one
     * @param userId - The Twitter user ID
     * @returns The wallet object with id, address, and other properties
     */
    async function getOrCreateUserWallet(userId) {
      // Try to get existing wallet
      const existingWallet = await getUserWallet(userId);

      // Return existing wallet if found
      if (existingWallet) {
        return existingWallet;
      }

      // Create a new wallet if none exists
      return createUserWallet(userId);
    }

    // Example usage:
    const wallet = await getOrCreateUserWallet(parsed.authorId);
    ```
  </Step>
</Steps>

## Integrate LLM for intent detection

Use an LLM to interpret user messages and decide what action to take. Treat the LLM as a black box that receives a prompt and returns a structured intent.

<Expandable title="Pseudocode for LLM integration">
  <Steps>
    <Step title="Sample LLM prompt and response">
      **Prompt:**

      ```text  theme={"system"}
      User: Launch a token called $CAT with 1B supply
      System: Extract the intent and parameters for a token launch on Base.
      Output format: { action: string, params: object }
      ```

      **LLM Response:**

      ```json  theme={"system"}
      {
        "action": "launch_token",
        "params": {
          "name": "CAT",
          "symbol": "$CAT",
          "supply": "1000000000"
        }
      }
      ```
    </Step>

    <Step title="Pseudocode for LLM integration">
      ```typescript  theme={"system"}
      // Pseudocode: send user message to LLM and parse response
      const llmResponse = await llm.query({ prompt: userMessage });
      if (llmResponse.action === 'launch_token') {
        // Proceed to Clanker integration
      }
      ```
    </Step>
  </Steps>
</Expandable>

***

## Getting set up with Clanker API

To deploy tokens via the Clanker API, you first need to obtain an API key.

<Steps>
  <Step title="Request API access">
    1. Visit the [Clanker API
       documentation](https://clanker.gitbook.io/clanker-documentation/developers/api/deploy-a-token).
    2. Follow the instructions or contact the Clanker team via their documentation or [contact
       page](https://clanker.gitbook.io/clanker-documentation/references/contact) to request API
       access.
    3. Once approved, you'll receive an `x-api-key` to use in your API requests.
  </Step>

  <Step title="Next: Deploy a token">
    Once you have your API key, you can use it to deploy tokens via the Clanker API. See the next
    section for a full deployment code example.
  </Step>
</Steps>

***

## Example Interactions

### Deploy a token

Let users deploy tokens on Base by simply messaging the bot. The LLM interprets the intent, and the bot handles wallet lookup/creation and token deployment.

<Expandable title="Pseudocode for deploying a token">
  <Steps>
    <Step title="Sample LLM prompt and response">
      **Prompt:**

      ```text  theme={"system"}
      User: create a new $Example token
      System: Extract the intent and parameters for a token launch on Base.
      Output format: { action: string, params: object }
      ```

      **LLM Response:**

      ```json  theme={"system"}
      {
        "action": "launch_token",
        "params": {
          "name": "Example",
          "symbol": "$Example"
        }
      }
      ```
    </Step>

    <Step title="Parse Twitter message for command">
      ```typescript  theme={"system"}
      // Example incoming tweet
      const tweet = {
        text: "@YOUR_BOT_HANDLE create a new $Example token",
        author_id: "1234567890",
        id: "9876543210",
        // ...other fields
      };
      // Remove bot mention to get user command
      const userMessage = tweet.text.replace(/@YOUR_BOT_HANDLE\s*/i, "").trim();
      ```
    </Step>

    <Step title="Use LLM to extract intent and parameters">
      ```typescript  theme={"system"}
      // Send the user message to your LLM
      const llmResponse = await llm.query({ prompt: userMessage });
      // Example LLM response:
      // {
      //   action: "launch_token",
      //   params: { name: "Example", symbol: "$Example" }
      // }
      if (llmResponse.action !== 'launch_token') {
        throw new Error('Not a token launch command');
      }
      const { name, symbol } = llmResponse.params;
      ```
    </Step>

    <Step title="Look up or create user's wallet">
      ```typescript  theme={"system"}
      // Get or create a wallet for the user
      const wallet = await getOrCreateUserWallet(tweet.author_id);
      // wallet.address will be used as the requestorAddress
      ```
    </Step>

    <Step title="Deploy token using Clanker API">
      ```typescript  theme={"system"}
      import axios from 'axios';
      import crypto from 'crypto';

      const apiKey = process.env.CLANKER_API_KEY;
      const requestKey = crypto.randomBytes(16).toString('hex');
      const payload = {
        name,
        symbol,
        image: 'https://example.com/token.png', // Optional: add your image
        requestorAddress: wallet.address,
        requestKey,
        // ...other optional params
      };
      const response = await axios.post('https://www.clanker.world/api/tokens/deploy', payload, {
        headers: {
          'x-api-key': apiKey,
          'Content-Type': 'application/json'
        }
      });
      const tokenInfo = response.data;
      ```
    </Step>

    <Step title="Notify user of deployment">
      ```typescript  theme={"system"}
      // Send a DM or reply to the user with the token address
      await twitterClient.sendDM({
        userId: tweet.author_id,
        text: `Token deployed! Address: ${tokenInfo.address}`
      });
      ```
    </Step>
  </Steps>
</Expandable>

### Send tokens to another Twitter user with LLM

Let users send tokens (e.g., ETH on Base) to other Twitter users by simply messaging the bot. The LLM interprets the intent, and the bot handles wallet lookup/creation and transaction sending.

<Expandable title="Pseudocode for sending tokens">
  <Steps>
    <Step title="Sample LLM prompt and response">
      **Prompt:**

      ```text  theme={"system"}
      User: Hey bot, send 0.01 ETH from my wallet to @privy_io on twitter
      System: Extract the intent and parameters for a token transfer on Base.
      Output format: { action: string, params: object }
      ```

      **LLM Response:**

      ```json  theme={"system"}
      {
        "action": "send_token",
        "params": {
          "amount": "0.01",
          "token": "ETH",
          "recipient": "@privy_io"
        }
      }
      ```
    </Step>

    <Step title="Look up sender and recipient wallets">
      ```typescript  theme={"system"}
      // 1. Get sender's Twitter ID from the parsed tweet
      const senderTwitterId = parsed.authorId;

      // 2. Get recipient's Twitter handle from LLM response (e.g., '@privy_io')
      const recipientHandle = llmResponse.params.recipient.replace('@', '');

      // 3. Look up recipient's Twitter ID from parsed mentions
      const recipientMention = parsed.mentions.find(m => m.username === recipientHandle);
      if (!recipientMention || !recipientMention.userId) {
        throw new Error('Recipient not found in tweet mentions');
      }
      const recipientTwitterId = recipientMention.userId;

      // 4. Get or create recipient's wallet
      const recipientWallet = await getOrCreateUserWallet(recipientTwitterId);

      // 5. Get or create sender's wallet
      const senderWallet = await getOrCreateUserWallet(senderTwitterId);
      ```
    </Step>

    <Step title="Send transaction using Privy wallet (NodeJS)">
      <CodeGroup>
        ```ts @privy-io/node theme={"system"}
        import { parseEther } from 'viem';

        // 1. Parse the amount to wei (ETH uses 18 decimals)
        const amountEth = llmResponse.params.amount; // e.g., '1'
        const amountWei = parseEther(amountEth); // '1000000000000000000'

        // 2. Prepare transaction details
        const transaction = {
          to: recipientWallet.address,      // Recipient's EVM address
          value: amountWei,                // Amount in wei
          chainId: 8453,                   // Base chain ID
          // (Optional: add gas, data, etc.)
        };

        // 3. Send the transaction using Privy wallet
        const sendResult = await privy.wallets().ethereum().sendTransaction(senderWallet.id, {
          caip2: 'eip155:8453', // CAIP2 for Base
          params: {
            transaction,
          }
        });
        ```

        ```ts @privy-io/server-auth theme={"system"}
        import { parseEther } from 'viem';

        // 1. Parse the amount to wei (ETH uses 18 decimals)
        const amountEth = llmResponse.params.amount; // e.g., '1'
        const amountWei = parseEther(amountEth); // '1000000000000000000'

        // 2. Prepare transaction details
        const transaction = {
          to: recipientWallet.address,      // Recipient's EVM address
          value: amountWei,                // Amount in wei
          chainId: 8453,                   // Base chain ID
          // (Optional: add gas, data, etc.)
        };

        // 3. Send the transaction using Privy wallet
        const sendResult = await privy.walletApi.ethereum.sendTransaction({
          walletId: senderWallet.id,        // Sender's Privy wallet ID
          caip2: 'eip155:8453',           // CAIP2 for Base
          transaction,
        });
        ```
      </CodeGroup>
    </Step>
  </Steps>
</Expandable>


# OAuth with Capacitor
Source: https://docs.privy.io/recipes/capacitor-oauth



**[Capacitor](https://capacitorjs.com/) is a cross-platform native runtime that makes it easy to build modern web apps that run natively on iOS, Android, and the web.** Capacitor apps can leverage native device capabilities while maintaining a single codebase.

**Privy enables your Capacitor apps to easily integrate OAuth authentication with native mobile OAuth flows.** This provides a seamless authentication experience that feels native to each platform while maintaining the flexibility of web-based development.

**Important**: OAuth for Capacitor requires Universal App Links (HTTPS URLs) and does not work with custom URL schemes like `com.capacitor-example.app`. You'll need to set up deep links using HTTPS domains.

Here's how to set up OAuth authentication in your Capacitor app!

<Tip>
  Capacitor OAuth integration provides native authentication flows on mobile devices while falling
  back to web-based OAuth on other platforms.
</Tip>

<details>
  <summary><b>How does Capacitor OAuth work?</b></summary>

  Capacitor OAuth leverages the native OAuth capabilities of each platform:

  * **iOS**: Uses `ASWebAuthenticationSession` for secure in-app browser authentication
  * **Android**: Uses Chrome Custom Tabs for secure authentication flows
  * **Web**: Falls back to standard web OAuth flows

  This approach provides the best user experience on each platform while maintaining code consistency across your app.

  ***
</details>

### 1. Install Capacitor OAuth dependencies

First, install the necessary Capacitor plugins for OAuth authentication:

```bash  theme={"system"}
npm install @capacitor/browser
npm install @capacitor/app
```

Then sync your Capacitor project:

```bash  theme={"system"}
npx cap sync
```

### 2. Configure OAuth providers in your dashboard

Go to your app in your [developer dashboard](https://dashboard.privy.io) and navigate to **User management > Authentication > Socials**. Enable the OAuth providers you want to support (Google, Apple, etc.).

Configure your OAuth redirect URIs and allowed origins for your Capacitor app.

#### Configure allowed origins

Navigate to **App Settings > Domains** and add platform-specific origins for your Capacitor app:

<img src="https://mintcdn.com/privy-c2af3412/iLCCWBdcq9hjhX4f/images/allowed-origins-for-capacitor.png?fit=max&auto=format&n=iLCCWBdcq9hjhX4f&q=85&s=12d6a02c3cdf291466c1c779d2d709fd" alt="Dashboard settings showing allowed origins for Capacitor" data-og-width="1186" width="1186" data-og-height="512" height="512" data-path="images/allowed-origins-for-capacitor.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/iLCCWBdcq9hjhX4f/images/allowed-origins-for-capacitor.png?w=280&fit=max&auto=format&n=iLCCWBdcq9hjhX4f&q=85&s=224a2b6daf68dceb33ab70cec5f571f9 280w, https://mintcdn.com/privy-c2af3412/iLCCWBdcq9hjhX4f/images/allowed-origins-for-capacitor.png?w=560&fit=max&auto=format&n=iLCCWBdcq9hjhX4f&q=85&s=ed383fcc555bebbb3fcbc6fbca717fc6 560w, https://mintcdn.com/privy-c2af3412/iLCCWBdcq9hjhX4f/images/allowed-origins-for-capacitor.png?w=840&fit=max&auto=format&n=iLCCWBdcq9hjhX4f&q=85&s=c2cf44c67423550cb12095c8f0fd64ec 840w, https://mintcdn.com/privy-c2af3412/iLCCWBdcq9hjhX4f/images/allowed-origins-for-capacitor.png?w=1100&fit=max&auto=format&n=iLCCWBdcq9hjhX4f&q=85&s=4348399222f347dc5b5fd660e46db3c1 1100w, https://mintcdn.com/privy-c2af3412/iLCCWBdcq9hjhX4f/images/allowed-origins-for-capacitor.png?w=1650&fit=max&auto=format&n=iLCCWBdcq9hjhX4f&q=85&s=c16d304d396f494e4d8672c53928826a 1650w, https://mintcdn.com/privy-c2af3412/iLCCWBdcq9hjhX4f/images/allowed-origins-for-capacitor.png?w=2500&fit=max&auto=format&n=iLCCWBdcq9hjhX4f&q=85&s=93de78a3c8c7c87d8c9d08981af5fa11 2500w" />

* **Android**: `https://localhost` (origin for Capacitor Android apps)
* **iOS**: `capacitor://localhost` (origin for Capacitor iOS apps)
* **Development**: `https://your-ngrok-url.ngrok.io` (must match your redirect URL domain)

#### Configure allowed redirect URLs

Navigate to **App Settings > Advanced** and add your ngrok URL to the allowed redirect URLs:

<img src="https://mintcdn.com/privy-c2af3412/iLCCWBdcq9hjhX4f/images/allowed-redirect-urls.png?fit=max&auto=format&n=iLCCWBdcq9hjhX4f&q=85&s=fbfcfc1bf244f15f5be0789cfdaf1f43" alt="Dashboard settings showing allowed redirect URLs configuration" data-og-width="1234" width="1234" data-og-height="512" height="512" data-path="images/allowed-redirect-urls.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/iLCCWBdcq9hjhX4f/images/allowed-redirect-urls.png?w=280&fit=max&auto=format&n=iLCCWBdcq9hjhX4f&q=85&s=a3f10d53a5b8920130f56b9024a9a77b 280w, https://mintcdn.com/privy-c2af3412/iLCCWBdcq9hjhX4f/images/allowed-redirect-urls.png?w=560&fit=max&auto=format&n=iLCCWBdcq9hjhX4f&q=85&s=6902ea46211be532ed59300da483d4ee 560w, https://mintcdn.com/privy-c2af3412/iLCCWBdcq9hjhX4f/images/allowed-redirect-urls.png?w=840&fit=max&auto=format&n=iLCCWBdcq9hjhX4f&q=85&s=1b4b17bc4ad05e760c193d30f52890c3 840w, https://mintcdn.com/privy-c2af3412/iLCCWBdcq9hjhX4f/images/allowed-redirect-urls.png?w=1100&fit=max&auto=format&n=iLCCWBdcq9hjhX4f&q=85&s=5702a51bf4f548886b65d66889ae7bfc 1100w, https://mintcdn.com/privy-c2af3412/iLCCWBdcq9hjhX4f/images/allowed-redirect-urls.png?w=1650&fit=max&auto=format&n=iLCCWBdcq9hjhX4f&q=85&s=16321159623d18d33211b10c871fff60 1650w, https://mintcdn.com/privy-c2af3412/iLCCWBdcq9hjhX4f/images/allowed-redirect-urls.png?w=2500&fit=max&auto=format&n=iLCCWBdcq9hjhX4f&q=85&s=87d7c70311c88593b4972fc482d167d1 2500w" />

* Redirect URI: `https://your-ngrok-url.ngrok.io/redirect`

For more information on configuring OAuth redirect URLs, see our [allowed OAuth redirects guide](/recipes/react/allowed-oauth-redirects).

<Warning>
  The allowed OAuth redirect URL domain must match your allowed origins. Both should use the same
  ngrok domain during development.
</Warning>

#### Production deployment considerations

When deploying to production, you'll need to update these settings:

* Replace your ngrok URL with your production domain
* Update both the allowed redirect URLs and allowed origins to use your production domain
* The platform-specific origins (`https://localhost` for Android and `capacitor://localhost` for iOS) remain the same

### 3. Set up Capacitor configuration

Configure your `capacitor.config.ts` file to handle OAuth redirects:

```typescript  theme={"system"}
import type {CapacitorConfig} from '@capacitor/cli';

const config: CapacitorConfig = {
  appId: 'com.yourcompany.yourapp',
  appName: 'your-app-name',
  webDir: 'dist',
  plugins: {
    App: {
      urlScheme: 'com.yourcompany.yourapp'
    }
  }
};

export default config;
```

### 4. Set up deep links with ngrok

For OAuth to work properly in your Capacitor app, you need to set up deep links. During development, you can use ngrok to create a public URL that redirects to your local app.

Follow the [Capacitor Deep Links guide](https://capacitorjs.com/docs/guides/deep-links) to set up deep linking in your app.

Once you have ngrok running, note your ngrok URL (e.g., `https://abc123.ngrok.io`) as you'll need it for the Privy configuration.

<Warning>
  Remember to update your ngrok domain in both your Privy provider configuration and dashboard
  settings when the ngrok URL changes.
</Warning>

### 5. Add the AppUrlListener component

Create an `AppUrlListener` component to handle deep link redirects for OAuth flows. Add this component before your `PrivyProvider`:

<Info>
  This component is specifically for handling social login OAuth redirects. Other Privy
  authentication methods (email, SMS, etc.) don't require this setup.
</Info>

```tsx  theme={"system"}
import {useEffect} from 'react';
import {App} from '@capacitor/app';

export const AppUrlListener = () => {
  useEffect(() => {
    App.addListener('appUrlOpen', (event) => {
      try {
        const deepLinkUrl = new URL(event.url);

        // Extract search params from deep link
        if (
          deepLinkUrl.search &&
          deepLinkUrl.searchParams.has('privy_oauth_code') &&
          deepLinkUrl.searchParams.has('privy_oauth_state') &&
          deepLinkUrl.searchParams.has('privy_oauth_provider')
        ) {
          const currentUrl = new URL(window.location.href);
          currentUrl.search = deepLinkUrl.search;
          window.location.assign(currentUrl.toString());
        }
      } catch (error) {
        console.error('Failed to parse deep link URL:', error);
      }
    });
  }, []);

  return null;
};
```

### 6. Configure your Privy provider

Set up your Privy provider with deep link support for Capacitor:

```tsx  theme={"system"}
import {PrivyProvider} from '@privy-io/react-auth';
import {Capacitor} from '@capacitor/core';
import {AppUrlListener} from './AppUrlListener';

function App() {
  return (
    <>
      <AppUrlListener />
      <PrivyProvider
        appId={process.env.REACT_APP_PRIVY_APP_ID}
        config={{
          appearance: {
            loginMethods: ['google', 'apple', 'email']
          },
          // Replace with your actual ngrok URL
          customOAuthRedirectUrl: 'https://your-ngrok-url.ngrok.io/redirect'
        }}
      >
        {/* Your app content */}
      </PrivyProvider>
    </>
  );
}
```

### 7. Platform-specific setup

<Tabs>
  <Tab title="iOS">
    Configure your iOS app to handle OAuth redirects by adding URL schemes to your `Info.plist`:

    ```xml  theme={"system"}
    <!-- Add this to ios/App/App/Info.plist -->
    <key>CFBundleURLTypes</key>
    <array>
      <dict>
        <key>CFBundleURLName</key>
        <string>com.yourcompany.yourapp</string>
        <key>CFBundleURLSchemes</key>
        <array>
          <string>com.yourcompany.yourapp</string>
        </array>
      </dict>
    </array>
    ```
  </Tab>

  <Tab title="Android">
    Configure your Android app to handle OAuth redirects by adding intent filters to your `AndroidManifest.xml`:

    ```xml  theme={"system"}
    <!-- Add this to android/app/src/main/AndroidManifest.xml -->
    <activity
        android:name=".MainActivity"
        android:exported="true"
        android:launchMode="singleTask">

        <intent-filter android:autoVerify="true">
            <action android:name="android.intent.action.VIEW" />
            <category android:name="android.intent.category.DEFAULT" />
            <category android:name="android.intent.category.BROWSABLE" />
            <data
                android:scheme="https"
                android:host="your-ngrok-url.ngrok.io"
                android:pathPrefix="/"
            />
        </intent-filter>

    </activity>
    ```

    <Warning>
      Your development server must be running and configured to serve the `assetlinks.json` file for
      Android and `apple-app-site-association` file for iOS. See the [Capacitor Deep Links
      guide](https://capacitorjs.com/docs/guides/deep-links) for more details on configuring these
      files.
    </Warning>
  </Tab>
</Tabs>

### 8. Test your implementation

Test your OAuth implementation across different platforms:

1. **Web**: Test in your browser during development
2. **iOS Simulator**: Test the native iOS OAuth flow
3. **Android Emulator**: Test the native Android OAuth flow
4. **Physical devices**: Test on real devices for the full experience

That's it! Your Capacitor app now supports native OAuth authentication across all platforms while maintaining a single codebase.

<Tip>
  Remember to test your OAuth flows on actual devices, as the authentication experience can differ
  between simulators and real devices.
</Tip>


# Funding wallets with Apple Pay and Google Pay
Source: https://docs.privy.io/recipes/card-based-funding



export const CardOnrampMainnetOnly = () => <Warning>
    Card and fiat on-ramp purchases are supported on mainnets only. On testnets (e.g. Polygon Amoy,
    Sepolia), on-ramps cannot purchase testnet tokens, so this flow will not be shown or will fail.
  </Warning>;

Privy makes it easy to allow your users to fund their embedded wallets with convenient payment methods like Apple Pay and Google Pay via `@privy-io/expo` and on the web through `@privy-io/react-auth`.

This guide will walk you through setting up Privy's funding flows, allowing your users to fund their wallets quickly and easily in under two minutes.

<img src="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/card-based-funding.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=8618b999fb1d2f574e78d2710c196ffd" alt="card-based-funding" data-og-width="1843" width="1843" data-og-height="1317" height="1317" data-path="images/card-based-funding.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/card-based-funding.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=42ed6f4ea44caa3ee9bfa2c74a9aaf7a 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/card-based-funding.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=36fd0fb3832e66ce9691b4340a62b4fc 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/card-based-funding.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=25b7d28cb776c85fceb703b3afc8a0e1 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/card-based-funding.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=98b27a3b139fc6810454bdd5f90ff940 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/card-based-funding.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=e3770184c30dc57b847612231045f3b3 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/card-based-funding.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=e597b1c7834bb0338a0c15d28442756c 2500w" />

<CardOnrampMainnetOnly />

## 1. Enable debit card funding in the Dashboard

In the [Privy
Dashboard](https://dashboard.privy.io/apps?page=funding), enable **Pay with card** on the **User management > Account funding** page.

With this option enabled, if Apple Pay or Google Pay is available on your user's device, Privy will provide users the option to purchase with those methods.

Choose your desired network across EVM and Solana and set a recommended amount for users to fund. Users can update the amount manually if they choose.

## 2. Prompt the user to fund

### `@privy-io/react-auth`

Prompt the user to fund by calling `fundWallet`

<Tabs>
  <Tab title="Fund with EVM">
    | Parameter | Type                                                | Description                                                                                                                                                                                                                                                                               |
    | --------- | --------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | `chain`   | [`Chain`](https://viem.sh/docs/chains/introduction) | Optional. A [`viem/chains`](https://viem.sh/docs/chains/introduction) object for the network on which users should fund their accounts. Defaults to the network you configured in the Privy Dashboard.                                                                                    |
    | `asset`   | `'native-currency' \| 'USDC' \| {erc20: string}`    | Optional. The asset you'd like the user to fund their accounts with. Set `'native-currency'` to fund with the `chain`'s native currency (e.g. ETH), `'USDC'` to fund with USDC, or a token address in the `erc20` field to fund with an arbitrary ERC20. Defaults to `'native-currency'`. |
    | `amount`  | `string`                                            | Required if `asset` is set, optional otherwise. The amount of the asset to fund as a decimal string. Defaults to the amount you configured in the Privy Dashboard.                                                                                                                        |

    ```tsx  theme={"system"}
    import {useFundWallet} from '@privy-io/react-auth';
    // Replace this with your desired network
    import {base} from 'viem/chains'
    ...
    // `fundWallet` from the useFundWallet() hook
    fundWallet('your-wallet-address-here', {
      chain: base,
      amount: '0.01' // Since no `asset` is set, defaults to 'native-currency' (ETH)
    })
    ```
  </Tab>

  <Tab title="Fund with SOL">
    | Parameter | Type            | Description                                                                                                                                                        |
    | --------- | --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
    | `cluster` | `SolanaCluster` | Optional. An object for the cluster on which users should fund their accounts. Defaults to `mainnet-beta`.                                                         |
    | `amount`  | `string`        | Required if `asset` is set, optional otherwise. The amount of the asset to fund as a decimal string. Defaults to the amount you configured in the Privy Dashboard. |

    As an example, you can configure the cluster and amount to fund like so:

    ```tsx  theme={"system"}
    import {useFundWallet} from '@privy-io/react-auth/solana';
    ...
    // `fundWallet` from the useFundWallet() hook
    const {fundWallet} = useFundWallet();
    fundWallet('your-wallet-address-here', {
      cluster: {name: 'devnet'},
      amount: '0.01', // SOL
    });
    ```
  </Tab>
</Tabs>

### `@privy-io/expo`

<Tabs>
  <Tab title="Fund with EVM">
    | Parameter | Type                                                | Description                                                                                                                                                                                                                                                                               |
    | --------- | --------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | `address` | `string`                                            | The destination address to fund.                                                                                                                                                                                                                                                          |
    | `chain`   | [`Chain`](https://viem.sh/docs/chains/introduction) | Optional. A [`viem/chains`](https://viem.sh/docs/chains/introduction) object for the network on which users should fund their accounts. Defaults to the network you configured in the Privy Dashboard.                                                                                    |
    | `asset`   | `'native-currency' \| 'USDC' \| {erc20: string}`    | Optional. The asset you'd like the user to fund their accounts with. Set `'native-currency'` to fund with the `chain`'s native currency (e.g. ETH), `'USDC'` to fund with USDC, or a token address in the `erc20` field to fund with an arbitrary ERC20. Defaults to `'native-currency'`. |
    | `amount`  | `string`                                            | Required if `asset` is set, optional otherwise. The amount of the asset to fund as a decimal string. Defaults to the amount you configured in the Privy Dashboard.                                                                                                                        |

    ```tsx  theme={"system"}
    import {useFundWallet} from '@privy-io/expo/ui';
    // Replace this with your desired network
    import {base} from 'viem/chains'
    ...
    // `fundWallet` from the useFundWallet() hook
    fundWallet({
      address: '0x2F3eb40872143b77D54a6f6e7Cc120464C764c09',
      asset: "USDC",
      chain: base,
      amount: '1'
    })
    ```
  </Tab>

  <Tab title="Fund with SOL">
    | Parameter | Type            | Description                                                                                                                                                        |
    | --------- | --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
    | `cluster` | `SolanaCluster` | Optional. An object for the cluster on which users should fund their accounts. Defaults to `mainnet-beta`.                                                         |
    | `amount`  | `string`        | Required if `asset` is set, optional otherwise. The amount of the asset to fund as a decimal string. Defaults to the amount you configured in the Privy Dashboard. |

    As an example, you can configure the cluster and amount to fund like so:

    ```tsx  theme={"system"}
    import {useFundSolanaWallet} from '@privy-io/expo/ui';
    ...
    // `fundWallet` from the useFundSolanaWallet() hook
    const {fundWallet} = useFundSolanaWallet();
    fundWallet({
      address: 'address'
      amount: '0.01', // SOL
    });
    ```
  </Tab>
</Tabs>

## Resources

<CardGroup cols={1}>
  <Card title="Funding starter template" icon="github" href="https://github.com/privy-io/examples/tree/main/examples/privy-next-funding" arrow>
    Complete starter repository showcasing Privy's funding hooks and wallet funding flows.
  </Card>
</CardGroup>

## All set!

Users can now fund their wallets with Apple Pay and Google Pay natively within the application.


# Using the vanilla JavaScript SDK
Source: https://docs.privy.io/recipes/core-js



The `@privy-io/js-sdk-core` library is a vanilla JavaScript library, intended for use in a browser-like environment, it allows you to add secure authentication, non-custodial embedded wallets, and powerful user management into your application.

<Note>
  `@privy-io/js-sdk-core` library is a low-level JavaScript library. Please do not attempt to use
  this library without first reaching out to the Privy team to discuss your project and which Privy
  SDK options may be better suited to it.
</Note>

## Prerequisites

Before you begin, make sure you have [set up your Privy app and obtained your app ID](/basics/get-started/dashboard/create-new-app) from the Privy Dashboard.

## Installation

<CodeGroup>
  ```bash npm theme={"system"}
  npm install @privy-io/js-sdk-core@latest
  ```

  ```bash pnpm theme={"system"}
  pnpm install @privy-io/js-sdk-core@latest
  ```

  ```bash yarn theme={"system"}
  yarn add @privy-io/js-sdk-core@latest
  ```
</CodeGroup>

## Getting a `Privy` instance

Import the **`Privy`** class and create an instance of it, passing the Privy **app ID** and **app client ID** and storage adapter. You may also configure any EVM chains you would like to support.

```tsx  theme={"system"}
import Privy, {LocalStorage} from '@privy-io/js-sdk-core';

new Privy({
  appId,
  clientId,
  supportedChains,
  storage: new LocalStorage()
});
```

<Note>
  You should ensure that there is only ever one instance of the Privy client instantiated for your
  app.
</Note>

## Connecting to the secure context

Configure the Privy SDK with the Privy iframe to be able to provision non-custodial embedded wallets for your users.

First, create and mount an iframe in your app, use the Privy client to get the src URL.

```tsx  theme={"system"}
const iframeUrl = privy.embeddedWallet.getURL();
const iframe = document.createElement('iframe');
iframe.src = iframeUrl;
document.body.appendChild(iframe);
```

Then, pass through a reference to the iframe to the Privy client and attach listeners for message events.

```tsx  theme={"system"}
privy.setMessagePoster(iframe.contentWindow);
const listener = (e) => privy.embeddedWallet.onMessage(e.data);
window.addEventListener('message', listener);
```

If you are using a UI rendering library or framework we recommend rendering the iframe and registering listener using that library instead of using the DOM directly.

## Authentication

The Privy core SDK supports a variety of authentication options including email, SMS, OAuth and JWT-based auth.

<CodeGroup>
  ```tsx Email theme={"system"}
  const emailAddress = 'insert-user-email-address';
  await privy.auth.email.sendCode(emailAddress);
  const emailOTP = 'insert-otp-collected-from-user';
  const session = await privy.auth.email.loginWithCode(emailAddress, emailOTP);
  ```

  ```tsx SMS theme={"system"}
  // Example phone number formatting: '+1 555-555-5555'.
  const phoneNumber = 'insert-user-phone-number';
  await privy.auth.phone.sendCode(phoneNumber);
  const phoneOTP = 'insert-otp-collected-from-user';
  const session = await privy.auth.phone.loginWithCode(phoneAddress, phoneOTP);
  ```

  ```tsx OAuth theme={"system"}
  // Replace this with your desired OAuth provider
  const provider = 'google';
  // Replace this with the URI you'd like to redirect users to after login
  const redirectURI = `${window.location.origin}/login-callback`;
  const oauthURL = await privy.auth.oauth.generateURL(provider, redirectURI);
  // Redirect the user to the OAuth site
  window.location.assign(oauthURL);

  // When the user returns to your app from the OAUth site
  const queryParams = new URLSearchParams(window.location.search);
  const oauthCode = queryParams.get('privy_oauth_code');
  const oauthState = queryParams.get('privy_oauth_state');
  const session = await privy.auth.oauth.loginWithCode(oauthCode, oauthState);
  ```

  ```tsx JWT based auth theme={"system"}
  const authToken = 'insert-access-or-identity-token-for-user';
  const session = await privy.auth.customProvider.syncWithToken(authToken);
  ```
</CodeGroup>

## Creating a an embedded wallet

Your app can [**manually** create wallets](/wallets/wallets/create/create-a-wallet) for users when desired.

<Info>Privy can provision wallets for your users on both **Ethereum** and **Solana**.</Info>

<CodeGroup>
  ```tsx Ethereum theme={"system"}
  import {getUserEmbeddedEthereumWallet, getEntropyDetailsFromUser} from '@privy-io/js-sdk-core';

  const {user} = await privy.embeddedWallet.create({});
  const wallet = getUserEmbeddedEthereumWallet(user);
  const {entropyId, entropyIdVerifier} = getEntropyDetailsFromUser(user);
  const provider = await privy.embeddedWallet.getEthereumProvider({
    wallet,
    entropyId,
    entropyIdVerifier
  });
  ```

  ```tsx Solana theme={"system"}
  import {getUserEmbeddedSolanaWallet, getEntropyDetailsFromUser} from '@privy-io/js-sdk-core';

  const {user} = await privy.embeddedWallet.createSolana();
  const account = getUserEmbeddedSolanaWallet(user);
  const {entropyId, entropyIdVerifier} = getEntropyDetailsFromUser(user);
  const provider = await privy.embeddedWallet.getSolanaProvider(
    account,
    entropyId,
    entropyIdVerifier
  );
  ```
</CodeGroup>

## Using the embedded wallet

<Info>
  In order to send a transaction, your wallet must have some funds to pay for gas. You can use a
  testnet [faucet](https://console.optimism.io/faucet) to test transacting on a testnet (e.g. Base
  Sepolia) or send funds to the wallet on the network of your choice.
</Info>

With the users' embedded wallet, your application can now prompt the user to sign and send transactions.

<CodeGroup>
  ```tsx Ethereum theme={"system"}
  const provider = await privy.embeddedWallet.getEthereumProvider({...args});
  await provider.request({
    method: 'personal_sign',
    params: ['hello', signingAddress]
  });
  ```

  ```tsx Solana theme={"system"}
  const provider = await privy.embeddedWallet.getSolanaProvider(...args);
  await provider.request({
    method: 'signMessage',
    params: {message: 'hello'}
  });
  ```
</CodeGroup>

<Tip>
  [Learn more](/wallets/using-wallets/ethereum/send-a-transaction) about sending transactions with
  the embedded wallet. Privy enables you to take many actions on the embedded wallet, including
  [sign a message](/wallets/using-wallets/ethereum/sign-a-message), [sign typed
  data](/wallets/using-wallets/ethereum/sign-typed-data), and [sign a
  transaction](/wallets/using-wallets/ethereum/sign-a-transaction).
</Tip>


# Configure account transfer
Source: https://docs.privy.io/recipes/dashboard/account-transfer



### Login method transfer

If **User management > Authentication > Login method transfer** is enabled, if a user attempts to link a login method that is already linked to another account they own, they can choose to transfer the login method to their currently logged-in account.

<img src="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/account-transfer.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=615ecae9c06c7cd9017fd71cc705c1be" alt="Sample account transfer flow" data-og-width="560" width="560" data-og-height="600" height="600" data-path="images/account-transfer.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/account-transfer.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=fc51fe7e70635d6319d42c9a52bc3276 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/account-transfer.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=269a992d71fa083ba37ac31ec495eaf6 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/account-transfer.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=622bf3470cab0291d22c77865c1a35d3 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/account-transfer.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=ce7b128840138df98e7ddefd3d09103c 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/account-transfer.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=fc2892ad370a4c336674f18cc5f2547c 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/account-transfer.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=586b70366aefcd3a752a47ea8926c72a 2500w" />

**Once the login method is transferred to the current user, the previous account will then be deleted.** Please ensure that the embedded wallet associated with the previous account has either been exported or that its assets have been transferred out prior to the account deletion.

<Info>
  Currently, login method transfer is only supported when the orphan account is associated with a
  single login method (the account to transfer). We are working to allow for transfers of login
  methods without full deletion of the orphan account to allow for login method transfer when
  multiple login methods are linked to the orphan account.
</Info>


# Managing your allowlist with Airtable
Source: https://docs.privy.io/recipes/dashboard/airtable



**If you use [Airtable](https://airtable.com/) or a similar tool to manage a waitlist of wallet addresses for your app, you can easily set up a [Privy allowlist](/user-management/users/managing-users/allowlist) and manage it from the same interface.** Just follow the steps outlined below.

## 0. Prerequisites

This guide assumes:

* You have an allowlist enabled for your Privy app. If you would like to enable an allowlist for your app, please [reach out](https://privy.io/slack)!
* You are managing a waitlist of users with Airtable, and that the base at minimum includes the user's wallet address and a boolean/checkbox column for whether the user should be invited off the waitlist or not.

## 1. Create an automation

In your Airtable with your waitlist, create a custom automation by clicking on "Automations" in the top right corner of your screen, and then clicking "Create a custom automation" from the dropdown. You can find Airtable's complete instructions around automations [here](https://support.airtable.com/docs/creating-an-airtable-automation#setup).

## 2. Configure a trigger for your automation

Once you start creating your custom automation, click "Add a trigger", and select the "When a record is updated" option.

Then, in the right sidebar that appears, under "Table", select the name of your Airtable base with your waitlist. Under "Fields", select the column from your base that indicates whether or not a user should be invited off your waitlist.

This configures your automation to run whenever you update this column (whether the user is allowed or not) for any record.

## 3. Set up your script

After you've configured your trigger, click "Add action" in the same automation. This will set up an action that runs whenever your automation is triggered.

First, you need to configure the inputs for your action. In the right sidebar, under "Input Variables", create the following two variables:

* the user's wallet address. Set the `Name` as 'address' and `Value` as the column in your table with the user's wallet address.
* whether or not the user should be invited off the waitlist. Set the `Name` as 'isAllowed' and `Value` as the corresponding column in your table.

Next, after you've configured your input variables, copy the following script into your code box and replace the variables at the top with your corresponding values. The script essentially parses the input variables you just configured, and makes a request to Privy's API to [add the corresponding user to your app's allowlist](/user-management/users/managing-users/allowlist).

```tsx  theme={"system"}
// These are variables to set up our script
const appId = /* paste your Privy App ID here */;
const appSecret = /* Paste your Privy App Secret */;
const base64 = /* Paste a base-64 encoding of appId + ":" + appSecret */
const url = `https://auth.privy.io/api/v1/apps/${appId}/allowlist`;

// This parses the input variables we configured earlier
const inputConfig = input.config();
const isAllowed = inputConfig.isAllowed;
const address = inputConfig.address;

async function addToAllowlist() {
    const data = {'type': 'wallet', 'value': address};

    try {
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Basic ${base64}`,
                'privy-app-id': appId
            },
            body: JSON.stringify(data)
        })
        console.log(response);
    } catch (error) {
        console.log(error.data);
    }
}

if (isAllowed) {
    addToAllowlist();
}
```

## 4. Enable your script!

**That's it! You can now manage your app's allowlist directly from Airtable.** Just go ahead and enable the automation.

If you’d like to test this automation before enabling it, in the right sidebar, you can scroll down and select a test record to use to make sure things work smoothly.


# Configure allowed URLs
Source: https://docs.privy.io/recipes/dashboard/allowed-domains



## Allowed domains

Use the **Configuration > App settings** page > **Domains** tab of the Privy Dashboard to manage **allowed origins** for web and native mobile apps and to manage **HttpOnly cookies** in web apps.

<Info>You should only use this setting when using Privy in a production website.</Info>

#### Browser (web & mobile web)

In a browser environment (web & mobile web), allowed origins restrict which **domains** are allowed to use your Privy app ID.

In the **Allowed origins** section of this page, select the **Web & mobile web** option. In the input field, list any domains that will use your Privy app ID, separated by commas, spaces, or breaks.

Please note the following requirements:

* The protocol (`https`) is required.
* Trailing paths (`/path`) are not supported.
* Wildcards (`*`) are only supported as a subdomain (`*.domain.com`), but not as a domain alone (`*.com`).
* Partial wildcards of the form `*-sometext.domain.com` are not supported.
* Localhost (`http://localhost:port`) *is* supported but you *must* specify the `port` number. Though supported, we do **not** recommend listing `localhost` as an allowed domain for production apps. If you need to temporarily list `localhost` as an allowed domain for your production app ID, please take care to remove it when not developing.

<Tip>
  Many hosting providers and their corresponding DNS configurations treat `https://www.example.com`
  and `https://example.com` interchangeably. If these URLs are equivalent for your app setup, we
  recommend adding **both** (with and without the `www` subdomain) domains as allowed origins to the
  dashboard.
</Tip>

<Info>
  Setting allowed domains restricts **client-side access** to your Privy app ID only. Privy's REST
  API endpoints that you would query from your backend are gated by your app secret, which should
  **never** be exposed on a user's client.
</Info>

#### Supporting preview URLs

Many hosting providers (e.g. Vercel) support preview deployment URLs to make it easy to test changes, like:

```
// Matches the pattern *.netlify.app, which anyone with a free Netlify account can deploy to
deploy-preview-id--yoursitename.netlify.app
```

For security reasons, **we do not allow whitelisting domains with a *generic* pattern** that are commonly used for these preview deployments, such as:

* `https://*.netlify.app` / `https://*.vercel.app`
* `https://*-projectname.netlify.app` / `https://*-projectname.vercel.app`

Any project can deploy to a domain that matches `https://*.netlify.app`, `https://*.vercel.app`, or similar. If you were to whitelist this domain for your production App ID, any actor could set up any arbitrary deployment with your hosting provider and can use your production App ID within their site.

**If you'd like to secure your Privy App ID on preview deployment URLs, please check if your hosting provider allows you to map preview deployments to a stable subdomain that only *you control***, like:

```
// Matches the pattern *.yoursitename.netlify.app, which only members of your Netlify account
// (or hosting provider) can deploy to
deploy-preview-42<b>.yoursitename.netlify.app</b>
```

This allows you to list `https://*.yoursitename.netlify.app` under allowed domains, which arbitrary actors cannot deploy to. See instructions to set this up with [Vercel](https://vercel.com/docs/deployments/generated-urls#preview-deployment-suffix) or [Netlify](https://docs.netlify.com/domains-https/custom-domains/automatic-deploy-subdomains/).

### Native mobile

<Info>
  You should only use this setting if you use Privy in a native mobile app (e.g. via the [Expo
  SDK](/basics/react-native/quickstart).
</Info>

In a native mobile environment (e.g. iOS and Android apps), allowed origins request which **application identifiers** are allowed to use your Privy app ID.

In the **Allowed origins** section of this page, select the **Native** option. In the input field, list any domains that will use your Privy app ID, separated by commas, spaces, or breaks.

### HttpOnly Cookies

Set secure cookies that restrict access to client-side scripts, protecting sensitive data from XSS attacks. Once toggled on, you’ll be prompted to add an app domain which Privy to store user access tokens as a first-party cookie. This improves your app security and enhances your app with features like server-side rendering (SSR).

Please see our [cookies guide](/recipes/react/cookies) for instructions on how to set an app domain in this field.


# Customize your application
Source: https://docs.privy.io/recipes/dashboard/customization



Use the **Configuration > UI components** page of the dashboard to configure your app's brand settings, including name, logo, accent color, and legal policies.

## Name

Use the **Name** input to set a name for your product as you'd like to present it to users. Privy will use this value to reference your product in OTP messages sent to users for login and various UIs throughout your app.

## Logo

Use the **Logo** input to set a logo for your product. Provide the URL to a hosted image. We recommend a 2:1 aspect ratio with a size of 180px by 90px for best results. Please note that SVGs are not allowed, as they are incompatible with many major email clients.

Privy will use this logo in two places:

* in OTP emails sent to your users for passwordless email login
* in the Privy modal shown to users when they login to your app

If you'd like to remove the logo from the Privy modal or set a different logo instead, you can customize the logo via the SDK directly. You should still set a logo in the dashboard for use in OTP emails.

## Brand color

Use the **Brand color** input to set an accent color for your application. Provide the color as a hexadecimal string. This will apply to links and buttons within Privy's UIs in your app.

## Legal

### Terms & conditions

Use the **Terms & conditions** input to set the terms & conditions for your app. Please provide a hosted URL to a publicly viewable site.

If set, users will be shown your terms & conditions as part of their login flow.

### Privacy policy

Use the **Privacy policy** input to set the privacy policy for your app. Please provide a hosted URL to a publicly viewable site.

If set, users will be shown your privacy policy as part of their login flow.

### Affirmative consent

If your app requires affirmative consent for your users for your terms & conditions and privacy policy, enable the **Require affirmative consent** option.

If enabled, users will be prompted for affirmative consent on your legal policies as part of their first login to your app. If disabled, users will be shown your legal policies without an explicit prompt.


# Enable SMS and WhatsApp login
Source: https://docs.privy.io/recipes/dashboard/login-methods/sms-whatsapp



Privy enables your users to log in to their account via SMS or WhatsApp.

<Note>
  You can enable **either** SMS or WhatsApp, not both. Also, once your account is enabled for SMS,
  it **cannot** be switched to WhatsApp, and vice versa.
</Note>

<Info>
  For most apps, we recommend either including alternative login options alongside SMS or enabling
  [Multi-Factor Authentication](/authentication/user-authentication/mfa). This ensures broad
  accessibility in regions without SMS coverage and that users can continue accessing their accounts
  in the event that they lose SMS access.
</Info>

## US and Canada SMS support

US and Canada SMS support is included at no additional cost on the Core, Scale, and Enterprise plans. You can enable SMS login and linking via the **Authentication** page of the dashboard.

## International SMS support

International SMS support is available on the Enterprise plan. Please reach out to [support@privy.io](mailto:support@privy.io) to request access. Once approved, international SMS will automatically be enabled for all apps on your account.

<Warning>
  If you enable international SMS support, you will be responsible for additional charges per SMS
  sent. Underlying Twilio network costs will be passed through directly. See Twilio's pricing page
  [here](https://assets.cdn.prod.twilio.com/pricing-csv/SMSPricing.csv).
</Warning>

Privy supports these default international regions:

<Expandable title="list of default international region support for SMS">
  | Region         | Region Code |
  | -------------- | ----------- |
  | Argentina      | +54         |
  | Australia      | +61         |
  | Canada         | +1          |
  | Chile          | +56         |
  | Czech Republic | +420        |
  | Germany        | +49         |
  | Hong Kong      | +852        |
  | Hungary        | +36         |
  | Japan          | +81         |
  | New Zealand    | +64         |
  | Portugal       | +351        |
  | Saudi Arabia   | +966        |
  | Singapore      | +65         |
  | South Korea    | +82         |
  | Sweden         | +46         |
  | Taiwan         | +886        |
  | Thailand       | +66         |
  | Turkey         | +90         |
  | United Kingdom | +44         |
  | United States  | +1          |
</Expandable>

If you would like to enable additional international SMS regions for your account beyond the default international regions, you can set-up your own instance of Twilio, and we can connect your Twilio account with your Privy account. To connect your own Twilio set-up, please reach out to us at [support@privy.io](mailto:support@privy.io) and provide the following:

* Twilio Account SID
* Twilio Auth token or API key SID/secret
* Twilio Verify service SID
* Twilio Messaging service SID
* Twilio Template SID

<Info>
  Supported regions may differ for your app if you enabled international SMS prior to August 26,\
  2024\.
</Info>

## WhatsApp support

WhatsApp support is included at no additional cost on the Core, Scale, and Enterprise plans. Please reach out to [support@privy.io](mailto:support@privy.io) to request access. Once approved, WhatsApp will automatically be enabled for all apps on your account.


# Using Privy and Due for on/off ramping
Source: https://docs.privy.io/recipes/due-on-off-ramp



Due is an API platform for moving money between crypto and fiat. It lets you send, receive, and convert funds using stablecoins and bank accounts. You use Due to automate on/off ramping and track transfers programmatically. If you want to bridge crypto and traditional finance, Due makes it simple.

## Table of Contents

* Prerequisites
* Initial setup (required for all transfers)
* Off ramping crypto to fiat
  * Option A: Signature-based transfer (via transfer intent)
  * Option B: Direct transfer (via funding address)
* On ramping fiat to crypto
* Virtual accounts (fiat on-ramp) Dedicated banking details for automatic fiat-to-crypto conversion.
* Tracking transfer status

## Prerequisites

You will need an **[API key](https://www.opendue.com/api)** for the Due Network APIs.

## Initial setup (required for all transfers)

Before executing any transfers, you must create and link accounts for your user.

### 1. Create a customer account in Due

Create an account for your user in Due. Save the returned `id` as `ACCOUNT_ID`.

```bash  theme={"system"}
curl --request POST \
  --url https://api.due.network/v1/accounts \
  --header 'Authorization: Bearer <YOUR_API_KEY>' \
  --header 'Content-Type: application/json' \
  --data '{
    "type": "individual",
    "email": "user@example.com",
    "details": {
      "firstName": "John",
      "lastName": "Doe"
    }
  }'
```

### 2. Create or get a Privy wallet

Create an embedded wallet for the user via the [Privy API](/api-reference/wallets/create). Save the `id` as `wallet_id` and the wallet's `address`.

```bash  theme={"system"}
curl --request POST \
  --url https://api.privy.io/v1/wallets \
  -u "<your-privy-app-id>:<your-privy-app-secret>" \
  --header 'privy-app-id: <your-privy-app-id>' \
  --header 'Content-Type: application/json' \
  --data '{
    "owner": {
      "user_id": "did:privy:clxduz8al00kql00fva24ggty"
    },
    "chain_type": "ethereum"
  }'
```

### 3. Link Privy wallet to Due account

Link the Privy wallet address to the user's Due account.

```bash  theme={"system"}
curl --request POST \
  --url https://api.due.network/v1/wallets \
  --header 'Authorization: Bearer <YOUR_API_KEY>' \
  --header 'Content-Type: application/json' \
  --header 'Due-Account-Id: <ACCOUNT_ID>' \
  --data '{
    "address": "0xcF5AaaBe14Ba42d9D765C8f2b9099c3b69a25321"
  }'
```

***

## Off ramping crypto to fiat

This flow moves cryptocurrency from a user's Privy wallet to an external bank account. You can choose between two methods:

* Signature based transfer: via Transfer Intent, more secure, requires signatures.
* Direct transfer via funding address: simpler, no signatures needed.

### Option A: Signature-based transfer (via transfer intent)

This method involves the user signing transaction data with their Privy wallet.

#### Step 1: Create a recipient

Define the destination bank account.

```bash  theme={"system"}
curl --request POST \
  --url https://api.due.network/v1/recipients \
  --header 'Authorization: Bearer <YOUR_API_KEY>' \
  --header 'Due-Account-Id: <ACCOUNT_ID>' \
  --data '{
    "name": "Marie Dubois",
    "details": {
      "schema": "bank_sepa",
      "accountType": "individual",
      "firstName": "Marie",
      "lastName": "Dubois",
      "IBAN": "FR1420041010050500013M02606"
    }
  }'
```

#### Step 2: Get a quote

Get a quote for the transfer.

**Note:** Quotes are short-lived (2 mins), so get it right before creating the transfer.

```bash  theme={"system"}
curl --request POST \
  --url https://api.due.network/v1/transfers/quote \
  --header 'Authorization: Bearer <YOUR_API_KEY>' \
  --header 'Due-Account-Id: <ACCOUNT_ID>' \
  --data '{
    "source": {"rail": "base", "currency": "USDC"},
    "destination": {"rail": "sepa", "currency": "EUR", "amount": "1000"}
  }'
```

<Accordion title="Example quote">
  ```json  theme={"system"}
  {
      "token": "eyJhbGciOiJFZERTQSIsInR5cCI6IkpXVCJ9...",
      "source": {
          "rail": "base",
          "currency": "USDC",
          "amount": "1177.171875",
          "fee": "5.296875"
      },
      "destination": {
          "rail": "sepa",
          "currency": "EUR",
          "amount": "1000",
          "fee": "4.52"
      },
      "fxRate": 1.1718750000000002,
      "fxMarkup": 5,
      "expiresAt": "2025-10-02T16:40:31.951762984Z"
  }
  ```
</Accordion>

<Note>
  Be sure to take note of the `token` field in the response, as you'll need it to create the
  transfer.
</Note>

#### Step 3: Create a transfer

Use the token returned by the quote to create the transfer.

```bash  theme={"system"}
curl --request POST \
  --url https://api.due.network/v1/transfers \
  --header 'Authorization: Bearer <YOUR_API_KEY>' \
  --header 'Due-Account-Id: <ACCOUNT_ID>' \
  --data '{
    "quote": "eyJhbGciOiJFZERTQSIsInR5cCI6IkpXVCJ9...",
    "sender": "wlt_e3lLDBYiPMHxCv1Q",
    "recipient": "rcp_fRlKXtbmyzvRwmY9",
    "memo": "Invoice#1"
  }'
```

#### Step 4: Create & sign the transfer intent

1. **Create the Intent:** Request a transfer intent from Due for the transfer ID (`tf_...`) created above.

   ```bash  theme={"system"}
   curl --request POST \
     --url https://api.due.network/v1/transfers/<TRANSFER_ID>/transfer_intent \
     --header 'Authorization: Bearer <YOUR_API_KEY>' \
     --header 'Due-Account-Id: <ACCOUNT_ID>'
   ```

   The response contains a `signables` array, typically with two objects to sign (`Permit` and `PayoutIntent`).

2. **Sign with Privy:** For *each object* in the `signables` array, call the [Privy API](/api-reference/wallets/ethereum/eth-signtypeddata-v4) to get a signature or send the signables to the client side for [signing](/wallets/using-wallets/ethereum/sign-typed-data#sign-typed-data). Use the `eth_signTypedData_v4` method with the `value` object from each signable.

<CodeGroup>
  ```bash REST API theme={"system"}
  curl --request POST \
    --url https://api.privy.io/v1/wallets/<wallet_id>/rpc \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    --data '{
      "method": "eth_signTypedData_v4",
      "params": {
        "typed_data": {
          // ... Paste the `value` object from a signable here ...
        }
      }
    }'
  ```

  ```tsx React theme={"system"}
  import {useSignTypedData} from '@privy-io/react-auth';

  const signables = [/* ... signables array from Due ... */];
  const {signTypedData} = useSignTypedData();

  const signatures = await Promise.all(
  signables.map(async (signable) => {
  const signature = await signTypedData({
  typedData: signable.value,
  });
  return {
  id: signable.id,
  signature,
  };
  })
  );

  ```
</CodeGroup>

#### Step 5: Submit the signed intent

Submit the original transfer intent object back to Due, now including the `signature` for each object in the `signables` array.

```bash  theme={"system"}
curl --request POST \
--url https://api.due.network/v1/transfer_intents/submit \
--header 'Authorization: Bearer <YOUR_API_KEY>' \
--header 'Due-Account-Id: <ACCOUNT_ID>' \
--data '{
  "id": "ti_24QbulYAT9nfjU",
  // ... entire transfer intent object from the previous step ...
  "signables": [
    {
      // ... first signable object ...
      "signature": "0xd99802ab7a14b535ad0bf9c69a7cfd86..."
    },
    {
      // ... second signable object ...
      "signature": "0xa1b2c3d4e5f678901234567890abcdef..."
    }
  ]
  // ... rest of transfer intent object ...
}'
```

### Option B: Direct transfer (via funding address)

This simpler method provides a temporary address to send funds to, avoiding the signature flow.

1. **Create Funding Address:** After creating a transfer (Steps 1-3 above), request a funding address for it.

   ```bash  theme={"system"}
   curl --request POST \
     --url https://api.due.network/v1/transfers/<TRANSFER_ID>/funding_address \
     --header 'Authorization: Bearer <YOUR_API_KEY>' \
     --header 'Due-Account-Id: <ACCOUNT_ID>'
   ```

2. **Send Funds via Privy:** Use the Privy API to send the *exact* transfer amount to the funding `address` received. The transfer will process automatically once funds are received.

***

## On ramping fiat to crypto

This flow enables users to convert fiat currency from their bank account into cryptocurrency, which is deposited directly into their Privy wallet. It involves obtaining a transfer quote, creating the transfer, and providing the user with banking details to complete the transaction. Due handles the fiat-to-crypto conversion seamlessly, requiring no additional signatures or manual intervention.

1. **Get a quote:**

   ```bash  theme={"system"}
   curl --request POST \
     --url https://api.due.network/v1/transfers/quote \
     --header 'Authorization: Bearer <YOUR_API_KEY>' \
     --header 'Due-Account-Id: <ACCOUNT_ID>' \
     --data '{
       "source": {"rail": "ach", "currency": "USD", "amount": "100"},
       "destination": {"rail": "base", "currency": "USDC"}
     }'
   ```

2. **Create a transfer:** Use the quote token and specify your linked Due wallet ID as the `recipient`.

   ```bash  theme={"system"}
   curl --request POST \
     --url https://api.due.network/v1/transfers \
     --header 'Authorization: Bearer <YOUR_API_KEY>' \
     --header 'Due-Account-Id: <ACCOUNT_ID>' \
     --data '{
       "quote": "eyJhbGciOiJFZERTQSIsInR5cCI6IkpXVCJ9...",
       "recipient": "wlt_e3lLDBYiPMHxCv1Q"
     }'
   ```

3. **Provide banking details to your user:** The API response will include `bankingDetails` (account number, routing number, etc.). Share these details with the user so they can initiate the fiat transfer from their bank account. Due will handle the conversion and deposit the cryptocurrency into the recipient Privy wallet automatically. No additional signatures are required.

***

## Virtual accounts (fiat on-ramp)

Virtual accounts provide dedicated banking details (e.g., an IBAN) that automatically convert incoming fiat deposits to a specified stablecoin and send them to your wallet.

### Example: Create a EUR → EURC virtual account

```bash  theme={"system"}
curl --request POST \
  --url https://api.due.network/v1/virtual_accounts \
  --header 'Authorization: Bearer <YOUR_API_KEY>' \
  --header 'Due-Account-Id: <ACCOUNT_ID>' \
  --data '{
    "destination": "wlt_e3lLDBYiPMHxCv1Q",
    "schemaIn": "bank_sepa",
    "currencyIn": "EUR",
    "railOut": "base",
    "currencyOut": "EURC",
    "reference": "customer_x_eur_onramp"
  }'
```

The response provides an IBAN. Any EUR sent to this IBAN will be automatically converted to EURC and deposited into the destination wallet.

***

## Tracking transfer status

Check the status of any transfer using its ID.

```bash  theme={"system"}
curl --request GET \
  --url https://api.due.network/v1/transfers/<TRANSFER_ID> \
  --header 'Authorization: Bearer <YOUR_API_KEY>' \
  --header 'Due-Account-Id: <ACCOUNT_ID>'
```

**That's it! You can now move value between fiat bank accounts and stablecoins using Privy embedded wallets and the Due Network API.**

Here are some additional resources to help expand your integration:

* [Privy API references](/api-reference/introduction)
* [Due Network API documentation](https://due.readme.io/docs/privy-due#using-privy-x-due-to-move-between-fiat-and-stablecoins)


# null
Source: https://docs.privy.io/recipes/ecosystem/abstract-global-wallet



This recipe assumes you have already [created an app](https://docs.privy.io/basics/get-started/dashboard/create-new-app) on the Privy Dashboard and configured your Privy Provider. Refer to our [React SDK Setup](/basics/react/setup) or [React Native SDK Setup](/basics/react-native/setup) documentation to get started.

<Steps>
  <Step title="Enable Abstract integration">
    From the Privy dashboard, navigate to [**Global Wallet > Integrations**](https://dashboard.privy.io/apps?page=ecosystem\&tab=integrations).

    Scroll down to find Abstract and toggle the switch to enable the integration.

    Note the provider app id, you will need it in the next step.
  </Step>

  <Step title="Login users with their Abstract Global Wallet">
    <Tabs>
      <Tab title="React">
        To prompt users to log into your app with their Abstract Global Wallet, use the `loginWithCrossAppAccount` method from the `useCrossAppAccounts` hook:

        ```tsx  theme={"system"}
        import {usePrivy, useCrossAppAccounts} from '@privy-io/react-auth';

        function LoginButton() {
          const {ready, authenticated} = usePrivy();
          const {loginWithCrossAppAccount} = useCrossAppAccounts();

          return (
            <button
              onClick={() => loginWithCrossAppAccount({appId: 'insert-abstract-provider-app-id'})}
              disabled={!ready || !authenticated}
            >
              Log in with Abstract Global Wallet
            </button>
          );
        }
        ```
      </Tab>

      <Tab title="React Native">
        To prompt users to log into your app with an account from a provider app, use the `loginWithCrossApp` method from the `useLoginWithCrossApp` hook:

        ```tsx  theme={"system"}
        import {usePrivy, useLoginWithCrossApp} from '@privy-io/expo';

        function LoginButton() {
          const {ready, user} = usePrivy();
          const {loginWithCrossApp} = useLoginWithCrossApp();

          return (
            <Button
              onPress={() => loginWithCrossApp({appId: 'insert-provider-app-id'})}
              disabled={!ready || !!user}
            >
              Log in with Abstract Global Wallet
            </Button>
          );
        }
        ```
      </Tab>
    </Tabs>
  </Step>

  <Step title="Sign a message with the user's Abstract Global Wallet">
    <Tabs>
      <Tab title="React">
        To prompt users to sign a message with their Abstract Global Wallet, use the `signMessage` method from the `useCrossAppAccounts` hook:

        ```tsx  theme={"system"}
        import {usePrivy, useCrossAppAccounts} from '@privy-io/react-auth';

        function SignMessageButton() {
          const {user} = usePrivy();
          const {signMessage} = useCrossAppAccounts();
          const crossAppAccount = user.linkedAccounts.find((account) => account.type === 'cross_app');
          const address = crossAppAccount.embeddedWallets[0].address;

          return (
            <button onClick={() => signMessage('Hello world', {address: address})} disabled={!address}>
              Sign a message with your Abstract Global Wallet
            </button>
          );
        }
        ```

        Refer to [Using Global Wallets](/wallets/global-wallets/integrate-a-global-wallet/using-global-wallets) for more details.
      </Tab>

      <Tab title="React Native">
        To prompt users to sign a message with their Abstract Global Wallet, use the `signMessage` method from the `useSignMessageWithCrossApp` hook:

        ```tsx  theme={"system"}
        import {usePrivy, useSignMessageWithCrossApp} from '@privy-io/expo';

        function SignMessageButton() {
          const {user} = usePrivy();
          const {signMessage} = useSignMessageWithCrossApp();
          const crossAppAccount = user.linked_accounts.find((account) => account.type === 'cross_app');
          const address = crossAppAccount.embedded_wallets[0].address;

          return (
            <button onClick={() => signMessage({address, message: 'Hello world'})} disabled={!address}>
              Sign a message with your cross-app wallet
            </button>
          );
        }
        ```

        Refer to [Using Global Wallets](/wallets/global-wallets/integrate-a-global-wallet/using-global-wallets) for more details.
      </Tab>
    </Tabs>
  </Step>
</Steps>


# Swapping crypto using Privy and Bebop
Source: https://docs.privy.io/recipes/evm/bebop-swap-guide

Learn how to integrate Bebop's swap functionality with Privy embedded wallets

Bebop enables applications to execute gasless or self-executed token swaps using a request-for-quote (RFQ) model that eliminates slippage. This guide demonstrates how to integrate Bebop's swap functionality with Privy embedded wallets.

## Prerequisites

Before implementing swaps, contact Bebop to receive the following credentials:

* **Auth Key** – Enables authenticated API calls with improved rate limits and pricing
* **Source ID** – Identifies the application as an integration partner for revenue tracking

## Setup token approvals

Bebop requires token approvals before executing swaps. Applications can use either standard ERC20 approvals or Permit2.

### Standard ERC20 approvals

To use standard ERC20 approvals, specify `approval_type=Standard` when requesting a quote from Bebop's API.

Before executing a swap, the application must grant the Bebop settlement contract (`0xbbbbbBB520d69a9775E85b458C58c648259FAD5F`) an allowance to spend the user's tokens.

<Tabs>
  <Tab title="React">
    ```tsx  theme={"system"}
    import {maxUint256, erc20Abi, encodeFunctionData} from 'viem';
    import {useWallets} from '@privy-io/react-auth';

    const BEBOP_SETTLEMENT_ADDRESS = '0xbbbbbBB520d69a9775E85b458C58c648259FAD5F';
    const WETH_ADDRESS = '0x4200000000000000000000000000000000000006'; // WETH on Base

    async function approveToken() {
      const {wallets} = useWallets();
      const embeddedWallet = wallets.find((wallet) => wallet.walletClientType === 'privy');

      // Get EIP-1193 provider from Privy embedded wallet
      const provider = await embeddedWallet.getEthereumProvider();

      // Encode approval transaction data
      const data = encodeFunctionData({
        abi: erc20Abi,
        functionName: 'approve',
        args: [BEBOP_SETTLEMENT_ADDRESS, maxUint256]
      });

      // Submit approval transaction
      const txHash = await provider.request({
        method: 'eth_sendTransaction',
        params: [
          {
            from: embeddedWallet.address,
            to: WETH_ADDRESS,
            data,
            value: '0x0'
          }
        ]
      });

      return txHash;
    }
    ```
  </Tab>

  <Tab title="React Native">
    ```tsx  theme={"system"}
    import {maxUint256, erc20Abi, encodeFunctionData} from 'viem';
    import {useEmbeddedEthereumWallet} from '@privy-io/expo';

    const BEBOP_SETTLEMENT_ADDRESS = '0xbbbbbBB520d69a9775E85b458C58c648259FAD5F';
    const WETH_ADDRESS = '0x4200000000000000000000000000000000000006'; // WETH on Base

    async function approveToken() {
      const wallet = useEmbeddedEthereumWallet();

      // Get EIP-1193 provider from Privy embedded wallet
      const provider = await wallet.getEthereumProvider();

      // Encode approval transaction data
      const data = encodeFunctionData({
        abi: erc20Abi,
        functionName: 'approve',
        args: [BEBOP_SETTLEMENT_ADDRESS, maxUint256]
      });

      // Submit approval transaction
      const txHash = await provider.request({
        method: 'eth_sendTransaction',
        params: [
          {
            from: wallet.address,
            to: WETH_ADDRESS,
            data,
            value: '0x0'
          }
        ]
      });

      return txHash;
    }
    ```
  </Tab>

  <Tab title="Node.js">
    ```typescript  theme={"system"}
    import {maxUint256, erc20Abi, encodeFunctionData} from 'viem';
    import {PrivyClient} from '@privy-io/node';

    const BEBOP_SETTLEMENT_ADDRESS = '0xbbbbbBB520d69a9775E85b458C58c648259FAD5F';
    const WETH_ADDRESS = '0x4200000000000000000000000000000000000006'; // WETH on Base

    const privy = new PrivyClient({
      appId: process.env.PRIVY_APP_ID,
      appSecret: process.env.PRIVY_APP_SECRET
    });

    async function approveToken(walletId: string) {
      // Encode approval transaction data
      const data = encodeFunctionData({
        abi: erc20Abi,
        functionName: 'approve',
        args: [BEBOP_SETTLEMENT_ADDRESS, maxUint256]
      });

      // Submit approval transaction
      const response = await privy
        .wallets()
        .ethereum()
        .sendTransaction(walletId, {
          caip2: 'eip155:8453', // Base
          params: {
            transaction: {
              to: WETH_ADDRESS,
              data,
              chain_id: 8453
            }
          }
        });

      return response.hash;
    }
    ```
  </Tab>

  <Tab title="Python">
    ```python  theme={"system"}
    from privy import PrivyClient
    from viem import encode_function_data
    from viem.constants import MAX_UINT256

    BEBOP_SETTLEMENT_ADDRESS = "0xbbbbbBB520d69a9775E85b458C58c648259FAD5F"
    WETH_ADDRESS = "0x4200000000000000000000000000000000000006"  # WETH on Base

    client = PrivyClient(
        app_id=os.environ["PRIVY_APP_ID"],
        app_secret=os.environ["PRIVY_APP_SECRET"],
    )

    def approve_token(wallet_id: str) -> str:
        # Encode approval transaction data
        erc20_abi = [
            {
                "inputs": [
                    {"name": "spender", "type": "address"},
                    {"name": "amount", "type": "uint256"}
                ],
                "name": "approve",
                "outputs": [{"name": "", "type": "bool"}],
                "stateMutability": "nonpayable",
                "type": "function"
            }
        ]

        data = encode_function_data(
            abi=erc20_abi,
            function_name="approve",
            args=[BEBOP_SETTLEMENT_ADDRESS, MAX_UINT256]
        )

        # Submit approval transaction
        tx = client.wallets.rpc(
            wallet_id=wallet_id,
            method="eth_sendTransaction",
            caip2="eip155:8453",  # Base
            params={
                "transaction": {
                    "to": WETH_ADDRESS,
                    "data": data,
                },
            },
        )

        return tx["hash"]
    ```
  </Tab>
</Tabs>

<Info>
  Applications can also use Permit2 for approvals. Consult Bebop's documentation for implementation
  details.
</Info>

## Request a quote

After configuring approvals, request a quote from Bebop's API. The RFQ model guarantees the quoted price with zero slippage.

The following example requests a quote to swap 1 WETH for USDC on Base:

<Tabs>
  <Tab title="TypeScript">
    ```typescript  theme={"system"}
    import axios from 'axios';
    import {parseEther} from 'viem';

    const BEBOP_SOURCE_ID = process.env.BEBOP_SOURCE_ID || ''; // Source ID issued by Bebop
    const BEBOP_AUTH_KEY = process.env.BEBOP_AUTH_KEY || ''; // Auth key issued by Bebop

    const tokensToSell = ['0x4200000000000000000000000000000000000006']; // WETH on Base
    const sellAmounts = [parseEther('1')]; // 1 WETH
    const tokensToBuy = ['0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913']; // USDC on Base

    interface Chain {
      chainId: number;
      name: string;
    }

    const chain: Chain = {
      chainId: 8453,
      name: 'base'
    };

    async function getSwapQuote(walletAddress: string): Promise<any> {
      const {data: quote} = await axios.get(`https://api.bebop.xyz/pmm/${chain.name}/v3/quote`, {
        params: {
          buy_tokens: tokensToBuy.toString(),
          sell_tokens: tokensToSell.toString(),
          sell_amounts: sellAmounts.toString(),
          taker_address: walletAddress,
          gasless: false,
          approval_type: 'Standard',
          source: BEBOP_SOURCE_ID
        },
        headers: {
          'source-auth': BEBOP_AUTH_KEY
        }
      });

      if (quote.error) {
        throw new Error(`Quote error: ${quote.error}`);
      }

      return quote.tx;
    }
    ```
  </Tab>

  <Tab title="Python">
    ```python  theme={"system"}
    import requests
    import os

    BEBOP_SOURCE_ID = os.environ.get("BEBOP_SOURCE_ID", "")  # Source ID issued by Bebop
    BEBOP_AUTH_KEY = os.environ.get("BEBOP_AUTH_KEY", "")  # Auth key issued by Bebop

    TOKENS_TO_SELL = ["0x4200000000000000000000000000000000000006"]  # WETH on Base
    SELL_AMOUNTS = ["1000000000000000000"]  # 1 WETH in wei
    TOKENS_TO_BUY = ["0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"]  # USDC on Base

    chain = {
        "chain_id": 8453,
        "name": "base"
    }

    def get_swap_quote(wallet_address: str) -> dict:
        """Request a swap quote from Bebop API"""
        url = f"https://api.bebop.xyz/pmm/{chain['name']}/v3/quote"

        params = {
            "buy_tokens": ",".join(TOKENS_TO_BUY),
            "sell_tokens": ",".join(TOKENS_TO_SELL),
            "sell_amounts": ",".join(SELL_AMOUNTS),
            "taker_address": wallet_address,
            "gasless": False,
            "approval_type": "Standard",
            "source": BEBOP_SOURCE_ID
        }

        headers = {
            "source-auth": BEBOP_AUTH_KEY
        }

        response = requests.get(url, params=params, headers=headers)
        quote = response.json()

        if "error" in quote:
            raise Exception(f"Quote error: {quote['error']}")

        return quote["tx"]
    ```
  </Tab>
</Tabs>

## Execute the swap

Once Bebop returns a quote, the application can execute the swap by broadcasting the transaction using Privy's embedded wallet provider.

<Tabs>
  <Tab title="React">
    ```tsx  theme={"system"}
    import {useWallets} from '@privy-io/react-auth';

    async function executeSwap(rawTransaction) {
      const {wallets} = useWallets();
      const embeddedWallet = wallets.find((wallet) => wallet.walletClientType === 'privy');
      const provider = await embeddedWallet.getEthereumProvider();

      const txHash = await provider.request({
        method: 'eth_sendTransaction',
        params: [rawTransaction]
      });

      return txHash;
    }

    // Complete swap flow
    async function performSwap() {
      try {
        const {wallets} = useWallets();
        const embeddedWallet = wallets.find((wallet) => wallet.walletClientType === 'privy');

        // Request quote from Bebop
        const transaction = await getSwapQuote(embeddedWallet.address);

        // Execute transaction onchain
        const txHash = await executeSwap(transaction);

        return txHash;
      } catch (error) {
        console.error('Swap failed:', error);
        throw error;
      }
    }
    ```
  </Tab>

  <Tab title="React Native">
    ```tsx  theme={"system"}
    import {useEmbeddedEthereumWallet} from '@privy-io/expo';

    async function executeSwap(rawTransaction, wallet) {
      const provider = await wallet.getEthereumProvider();

      const txHash = await provider.request({
        method: 'eth_sendTransaction',
        params: [rawTransaction]
      });

      return txHash;
    }

    // Complete swap flow
    async function performSwap() {
      try {
        const wallet = useEmbeddedEthereumWallet();

        // Request quote from Bebop
        const transaction = await getSwapQuote(wallet.address);

        // Execute transaction onchain
        const txHash = await executeSwap(transaction, wallet);

        return txHash;
      } catch (error) {
        console.error('Swap failed:', error);
        throw error;
      }
    }
    ```
  </Tab>

  <Tab title="Node.js">
    ```typescript {skip-check} theme={"system"}
    import {PrivyClient} from '@privy-io/node';

    const privy = new PrivyClient({
      appId: process.env.PRIVY_APP_ID,
      appSecret: process.env.PRIVY_APP_SECRET
    });

    async function executeSwap(walletId: string, rawTransaction: any) {
      const response = await privy
        .wallets()
        .ethereum()
        .sendTransaction(walletId, {
          caip2: rawTransaction.caip2 || 'eip155:8453', // Base
          params: {
            transaction: {
              to: rawTransaction.to,
              data: rawTransaction.data,
              value: rawTransaction.value,
              chain_id: 8453
            }
          }
        });

      return response.hash;
    }

    // Complete swap flow
    async function performSwap(walletId: string) {
      try {
        // Get wallet address
        const wallet = await privy.wallets().get(walletId);

        // Request quote from Bebop
        const transaction = await getSwapQuote(wallet.address);

        // Execute transaction onchain
        const txHash = await executeSwap(walletId, transaction);

        return txHash;
      } catch (error) {
        console.error('Swap failed:', error);
        throw error;
      }
    }
    ```
  </Tab>

  <Tab title="Python">
    ```python  theme={"system"}
    from privy import PrivyClient
    import os

    client = PrivyClient(
        app_id=os.environ["PRIVY_APP_ID"],
        app_secret=os.environ["PRIVY_APP_SECRET"],
    )

    def execute_swap(wallet_id: str, raw_transaction: dict) -> str:
        tx = client.wallets.rpc(
            wallet_id=wallet_id,
            method="eth_sendTransaction",
            caip2=raw_transaction.get("caip2", "eip155:8453"),  # Base
            params={
                "transaction": {
                    "to": raw_transaction["to"],
                    "data": raw_transaction["data"],
                    "value": raw_transaction.get("value", "0x0"),
                },
            },
        )

        return tx["hash"]

    # Complete swap flow
    def perform_swap(wallet_id: str) -> str:
        try:
            # Get wallet address
            wallet = client.wallets.get(wallet_id)

            # Request quote from Bebop
            transaction = get_swap_quote(wallet.address)

            # Execute transaction onchain
            tx_hash = execute_swap(wallet_id, transaction)

            return tx_hash
        except Exception as error:
            print(f"Swap failed: {error}")
            raise
    ```
  </Tab>
</Tabs>

## Fee monetization

Bebop embeds fees directly in quotes, which are collected by market makers and distributed to integration partners monthly. The source ID must be included in all requests to ensure proper revenue tracking.

Bebop can optionally hedge collected fees to stablecoins (such as ETH to USDC) to prevent applications from accumulating unwanted token inventory.

<Tip>Contact Bebop to configure fee hedging preferences and review revenue distribution terms.</Tip>


# Using Flashblocks with Privy
Source: https://docs.privy.io/recipes/evm/flashblocks



[Flashblocks](https://docs.base.org/base-chain/flashblocks/apps) are a new development on the Base L2 that allow for faster transaction confirmation times, with most pre-confirmations happening close to 200ms.

**Privy offers Flashblocks support on Base and Base Sepolia by default.** There is nothing you need to do to enable Flashblocks support – your application automatically leverages Flashblocks pre-confirmations for faster transaction experiences.

If you'd like to integrate your **own** Flashblocks provider instead of using Privy's default offering, you can do so following the guide below.

### 0. Set up Privy in your app

To start, if you haven't yet set up Privy, get your application on service [set up with Privy's basic functionality](/basics/get-started/platforms). Follow the linked quickstarts depending on your

If using Privy's React or Expo SDKs, install the `@privy-io/chains` package as well:

### 1. Get your Flashblocks RPC URL

Next, get your custom Flashblocks RPC URL from your own RPC provider. Most RPC providers like Quicknode, Alchemy, and Infura offer Flashblocks RPCs for Base.

### 2. Use your custom RPC URL for Base and/or Base Sepolia

Next, configure Privy with your custom Flashblocks RPC URL.

<Tabs>
  <Tab title="React, Expo">
    In addition to Privy's React or Expo SDKs, install the `@privy-io/chains` and `viem` packages:

    ```sh  theme={"system"}
    npm i @privy-io/chains viem
    ```

    Next, use the `addRpcUrlOverride` method from `@privy-io/chains` to set your RPC URL in a `viem/chains` object:

    ```tsx  theme={"system"}
    import {base, baseSepolia} from 'viem/chains';
    import {addRpcUrlOverride} from '@privy-io/chains';

    const baseWithFlashblocks = addRpcUrlOverride(base, 'insert-flashblocks-rpc-url-for-base');
    const baseSepoliaWithFlashblocks = addRpcUrlOverride(
        baseSepolia,
        'insert-flashblocks-rpc-url-for-base-sepolia'
    );
    ```

    Then, pass the chain representations with your custom Flashblocks RPC URLs to the `PrivyProvider`'s `defaultChain` and `supportedChains` property:

    ```tsx  theme={"system"}
    <PrivyProvider
        appId='your-privy-app-id'
        config={{
            ...theRestOfYourConfig,
            // Replace this with your desired default chain
            defaultChain: baseWithFlashblocks
            supportedChains: [baseWithFlashblocks, baseSepoliaWithFlashblocks, ...otherChains]
        }}
    >
        {/* your app's content */}
    </PrivyProvider>
    ```
  </Tab>

  <Tab title="NodeJS">
    Use the NodeJS SDK's [`signTransaction`](/wallets/using-wallets/ethereum/sign-a-transaction) method to request a signature over your desired transaction on Base or Base Sepolia:

    <CodeGroup>
      ```ts @privy-io/node theme={"system"}
      const {signedTransaction} = await privy.wallets().ethereum().signTransaction('insert-wallet-id', {
          params: {
              // Replace with your desired transaction
              transaction: {
                  to: '0xE3070d3e4309afA3bC9a6b057685743CF42da77C',
                  value: '0x2386F26FC10000',
                  chainId: 8453,
              }
          }
      });
      ```

      ```ts @privy-io/server-auth theme={"system"}
      const {signedTransaction} = await privy.walletApi.ethereum.signTransaction({
          walletId: 'insert-wallet-id',
          // Replace with your desired transaction
          transaction: {
                  to: '0xE3070d3e4309afA3bC9a6b057685743CF42da77C',
                  value: '0x2386F26FC10000',
                  chainId: 8453,
              }
          }
      });
      ```
    </CodeGroup>

    Next, create a viem public client, setting the `transport` to an HTTP transport with your custom Flashblocks URL:

    ```ts  theme={"system"}
    import {createPublicClient, http} from 'viem';
    import {base} from 'viem/chains';

    const publicClient = createPublicClient({
        chain: base,
        transport: http('insert-custom-flashblocks-RPC-URL')
    });
    ```

    Lastly, broadcast the `signedTransaction` using the public client's [`sendRawTransaction`](https://viem.sh/docs/actions/wallet/sendRawTransaction#sendrawtransaction) method. You can then wait for the transaction to be confirmed using the client's `waitForTransactionReceipt` method:

    ```ts  theme={"system"}
    const hash = await publicClient.sendRawTransaction({serializedTransaction: signedTransaction});
    const receipt = await publicClient.waitForTransactionReceipt({hash});
    ```
  </Tab>

  <Tab title="REST API">
    Use the REST API's [`POST /v1/wallets/[wallet_id]/rpc`](/wallets/using-wallets/ethereum/sign-a-transaction) method with the `eth_signTransaction` RPC to request a signature over your desired transaction:

    ```sh  theme={"system"}
    $ curl --request POST https://api.privy.io/v1/wallets/<wallet_id>/rpc \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H "privy-authorization-signature: <authorization-signature-for-request>" \
    -H 'Content-Type: application/json' \
    -d '{
        "method": "eth_signTransaction",
        "params": {
            # Replace with your desired transaction
            "transaction": {
                "to": "0xE3070d3e4309afA3bC9a6b057685743CF42da77C",
                "value": "0x2386F26FC10000",
                "chain_id": 8453,
                "type": 2,
                "gas_limit": "0x5208",
                "nonce": 1,
                "max_fee_per_gas": "0x14bf7dadac",
                "max_priority_fee_per_gas": "0xf4240"
            }
        }
    }'
    ```

    Next, using the `signed_transaction` from the response, broadcast the `signed_transaction` to your custom Flashblocks RPC URL using the `eth_sendRawTransaction` RPC method, like so:

    <Info>
      Make sure to update the cURL below with any authentication or headers required by your RPC provider.
    </Info>

    ```sh  theme={"system"}
    curl -X POST <insert-custom-flashblocks-RPC-url> \
    -H "Content-Type: application/json" \
    -d '{
        "jsonrpc": "2.0",
        "method": "eth_sendRawTransaction",
        "params": ["insert-signed-transaction"],
        "id": 1
    }'
    ```
  </Tab>
</Tabs>

### 3. Send transactions

**That's it!** Privy will now route transactions on Base and/or Base Sepolia through the Flashblocks RPC URL you configured. Transactions should execute with near-200ms pre-confirmation times.


# Login with Farcaster
Source: https://docs.privy.io/recipes/farcaster/login



[**Farcaster**](https://www.farcaster.xyz/) is a sufficiently decentralized social network whose core social graph is stored on-chain. Users can choose how content they create is stored and it enables unique, composable experiences by enabling users to link their accounts with a wallet of their choosing.

**Privy enables your users to easily log in to your app using their Farcaster account.** This means you can easily integrate Privy with Farcaster to compose experiences with a user's existing social graph or network.

Here's how!

<Tip>
  Log in with Farcaster enables log in and read access to a user's Farcaster account but does not
  provide write access to the account today.
</Tip>

<details>
  <summary><b>How does Farcaster login work?</b></summary>

  Farcaster identifies users via a **signer**: this is an EdDSA keypair that is used by the client application to sign content like posts ("casts"), follows, etc on behalf of users.

  These Farcaster signers are managed through various clients such as [Farcaster](https://farcaster.xyz/), [Supercast](https://www.supercast.xyz/) and others.

  Privy uses a standard called **Sign in with Farcaster** ([FIP-11](https://github.com/farcasterxyz/protocol/discussions/110)) to issue a signature request to a user's Farcaster account via the client a user has.

  ***
</details>

### 1. Enable Farcaster login in your dashboard

Go to your app in your [developer dashboard](https://dashboard.privy.io) and navigate to **User management > Authentication > Socials**. From here, enable **Farcaster** as a social option.

This will enable you to configure Farcaster as a login and account linking option in your app.

### 2. Configure your app's Farcaster integration

The following assumes you have set up Privy with your app. If you haven't, start by following the instructions in the [**Privy Quickstart**](/basics/get-started/dashboard/create-new-app) to get your app set up with Privy.

From there, if you'd like users to be able to [**`login`**](/authentication/user-authentication/login-methods/farcaster) to your app with their Farcaster account, you can configure `'farcaster'` as an upfront login method in your **`PrivyProvider`**, like so:

```tsx  theme={"system"}
<PrivyProvider
  appId={process.env.NEXT_PUBLIC_PRIVY_APP_ID}
  config={{
    // This configures email, farcaster and wallet login for your app.
    appearance: {
        loginMethods: ['farcaster', ...insertTheRestOfYourLoginMethods]
    },
    ...insertTheRestOfYourPrivyProviderConfig
  }}
>
```

You can also prompt existing users to link their Farcaster account to their existing account.

```tsx  theme={"system"}
import {usePrivy} from '@privy-io/react-auth';

function Page() {
  const {linkFarcaster} = usePrivy();
  // You may replace this hook with any of the other `link-` hooks to
  // link a different account type.
  return <button onClick={linkFarcaster}>Link your Farcaster</button>;
}
```

### 3. Use your Farcaster link to power custom logic

Once a user has logged in with or linked their Farcaster account, you can find their **`Farcaster`** object, including their `fid`, `username`, `pfp` and more, in the [**`user`**](/user-management/users/the-user-object) object returned by the `usePrivy` hook.

**That's it! Once you've linked a Farcaster account to a user object, you can use this to power composable experiences in your app.** You should also consider using toolkits like [Farcaster's APIs](https://docs.farcaster.xyz/) or [Neynar](https://neynar.com/) to query and interact with protocol data.

### 4. (Optional) Refresh Farcaster info

Sometimes, a user may update their Farcaster profile information (`username`, `pfp`) - while this is publicly available using a public hub endpoint, Privy caches a version whenever the user logs in for convenience. To refresh the Privy cache, you can use our [REST API](/basics/rest-api/setup) (`server-auth` coming soon) and hitting the `/api/v1/users/farcaster/refresh` endpoint.

```tsx  theme={"system"}
const response = await fetch('https://auth.privy.io/api/v1/users/farcaster/refresh', {
  method: 'POST',
  body: JSON.stringify({
    fid: 1
  }),
  headers: {
    Authorization: `Basic ${btoa(`${'your-privy-app-id'}:${'your-privy-app-secret'}`)}`,
    'privy-app-id': 'your-privy-app-id',
    'content-type': 'application/json'
  }
});
```

If you're simply looking for the current Privy user object, we recommend using [`getUserByFarcasterId`](/user-management/users/managing-users/querying-users#by-farcaster-fid).

To be considerate of public hubs, we only allow refreshing of user data once every 24 hours. If you need more frequent than daily freshness, we recommend that you query public hub data using the user's `fid`.


# Building a Farcaster Mini App
Source: https://docs.privy.io/recipes/farcaster/mini-apps



[**Farcaster**](https://www.farcaster.xyz/) is a sufficiently decentralized social network whose core social graph is stored on-chain. Users can choose how content they create is stored and it enables unique, composable experiences by enabling users to link their accounts with a wallet of their choosing.

**Privy enables seamless login with your user's Farcaster account within a Mini App.** This means you can easily integrate Privy with Farcaster Mini Apps to compose experiences with a user's existing social graph or network.

Here's how!

<Tip>
  Privy supports [Farcaster auth
  addresses](https://github.com/farcasterxyz/protocol/discussions/225), including authentication
  from The Base App. To authenticate a user, pass a Sign-In With Farcaster (SIWF) message signed by
  an auth address to `loginToMiniApp`.
</Tip>

<CardGroup cols={3}>
  <Card title="Mini Apps starter" icon="github" href="https://github.com/privy-io/examples/tree/main/examples/privy-next-farcaster-mini-app" arrow>
    A starter repository for building a Farcaster Mini App with Privy and the Mini Apps SDK.
  </Card>
</CardGroup>

<Expandable title="How does seamless Farcaster login work in a Mini App?">
  Privy uses a standard called **Sign in with Farcaster** ([FIP-11](https://github.com/farcasterxyz/protocol/discussions/110)) to issue a signature request to a user's Farcaster account via the client the user has.

  The [Mini Apps spec](https://miniapps.farcaster.xyz/docs/specification) introduces a new `sdk.actions.signIn` action. This will produce the same [FIP-11](https://github.com/farcasterxyz/protocol/discussions/110) conformant signature automatically on the Farcaster mobile app.

  The `sdk.actions.signIn` action, in combination with the Privy `useLoginToMiniApp` hook, provides a seamless login experience that automatically and securely authenticates a user on Farcaster.
</Expandable>

### 1. Enable Farcaster login in your dashboard

Go to your app in your [developer dashboard](https://dashboard.privy.io/apps?page=login-methods) and navigate to **User management > Authentication > Socials**. From here, enable **Farcaster** as a social option.

This will enable you to configure Farcaster as a login and account linking option in your app.

### 2. Configure your allowed domains and cookies

<Info>
  When building a Farcaster Mini App, you must include `https://farcaster.xyz` as an allowed domain. Allowed domains is **required** for iframe-in-iframe which Farcaster uses, even for staging environments.
</Info>

Go to the `Domains` tab of your `Configuration > App settings` page in the developer dashboard and [configure allowed domains](/recipes/react/allowed-domains) for your app. This is the URL that your app is deployed to.

To use the embedded wallet, your application must also include `https://farcaster.xyz` as an allowed domain. Including Farcaster as an allowed domain allows the Privy iframe, where the embedded wallet is hosted, to load in the Farcaster browser app.

<Tip>
  Use an [appClient](/basics/get-started/dashboard/app-clients) to override the default cookie
  settings.
</Tip>

Currently Mini Apps do not support httpOnly cookies. If you have httpOnly cookies enabled for your app, it is recommended to set up an appClient to override the default cookie settings. Learn more about appClients [here](/basics/get-started/dashboard/app-clients#cookies).

### 3. Configure your app's Farcaster integration

The following assumes you have set up Privy with your app. If you haven't, start by following the instructions in the [**Privy Quickstart**](/basics/react/quickstart) to get your app set up with Privy.

Be sure to configure `'farcaster'` as an upfront login method in your **`PrivyProvider`**, like so:

```tsx  theme={"system"}
<PrivyProvider
  appId={process.env.NEXT_PUBLIC_PRIVY_APP_ID}
  config={{
    loginMethods: ['farcaster', ...insertTheRestOfYourLoginMethods]
    ...insertTheRestOfYourPrivyProviderConfig
  }}
>
```

### 4. Setup seamless Farcaster login with the Mini Apps SDK

<Info>
  Use `loginToMiniApp` from `useLoginToMiniApp` for proper Farcaster Mini App authentication (not
  Farcaster's quick auth).
</Info>

In your app, install the
[@farcaster/miniapp-sdk](https://www.npmjs.com/package/@farcaster/miniapp-sdk):

```bash  theme={"system"}
npm install @farcaster/miniapp-sdk
```

<Tip>
  Privy now supports authentication with Farcaster auth addresses, including from the new Base app!
</Tip>

To authenticate with an auth address, pass a SIWF message signed by an auth address to `loginToMiniApp` from `useLoginToMiniApp`. This can be done by fetching a signature from an external wallet, the Farcaster Wallet, or in an app with mini app support (such as the Base app) by calling `miniappSdk.actions.signIn`.

<Warning>
  Automatic embedded wallet creation is currently not supported for Farcaster Mini Apps. You have
  two options: use the wallet that clients like the Farcaster app and The Base App automatically
  inject (recommended), or [manually create embedded
  wallets](/wallets/wallets/create/create-a-wallet) at your chosen onboarding point.
</Warning>

```tsx  theme={"system"}
import miniappSdk from '@farcaster/miniapp-sdk';
import {usePrivy} from '@privy-io/react-auth';
import {useLoginToMiniApp} from '@privy-io/react-auth/farcaster';
...

const {ready, authenticated} = usePrivy();
const {initLoginToMiniApp, loginToMiniApp} = useLoginToMiniApp();

// Login to Mini App with Privy automatically
useEffect(() => {
  if (ready && !authenticated) {
    const login = async () => {
      // Initialize a new login attempt to get a nonce for the Farcaster wallet to sign
      const { nonce } = await initLoginToMiniApp();
      // Request a signature from Farcaster
      const result = await miniappSdk.actions.signIn({nonce});
      // Send the received signature from Farcaster to Privy for authentication
      // or pass a SIWF message signed by an auth address
      await loginToMiniApp({
        message: result.message,
        signature: result.signature,
      });
    };
    login();
  }
}, [ready, authenticated]);
```

<Warning>
  **The Base App (TBA) Special Requirement:** If your users are accessing your Mini App through The
  Base App, they must add their The Base App Wallet address as an auth address to their Farcaster
  account for authentication to work properly.
</Warning>

<Tip>
  Always check that `ready` and `authenticated` from the `usePrivy` hook are `true` before taking
  actions!
</Tip>

Once a user has logged in with or linked their Farcaster account, you can find their **`Farcaster`** object, including their `fid`, `username`, `pfp` and more, in the [**`user`**](/user-management/users/the-user-object) object returned by the `usePrivy` hook.

**That's it! You can now use this to power composable experiences in your new Mini App.** When building out your Mini App, be sure to visit [Farcaster's resources page](https://docs.farcaster.xyz/developers/frames/v2/resources) for help with testing and common issues!


# Writing to Farcaster
Source: https://docs.privy.io/recipes/farcaster/writes



[**Farcaster**](https://www.farcaster.xyz/) is a sufficiently decentralized social network whose core social graph is stored on-chain. Users can choose how content they create is stored and it enables unique, composable experiences by enabling users to link their accounts with a wallet of their choosing.

## Getting started

**Privy enables your users to easily log in to and write with their Farcaster account.** This means you can easily integrate Privy with Farcaster to compose experiences with a user's existing social graph or network. Generating a signer to power this is sponsored by the Privy team and is free to you and your users.

You can see a demo here: [https://farcaster-demo.vercel.app](https://farcaster-demo.vercel.app).
The example repo is at [https://github.com/privy-io/examples/tree/main/examples/privy-next-farcaster](https://github.com/privy-io/examples/tree/main/examples/privy-next-farcaster).

Here's how to get started!

### 0. Install the latest version of @privy-io/react-auth

In order to use embedded signers, we recommend you install the latest version of our SDK, as the interfaces have changed.

### 1. Login with Farcaster

The following assumes you have set up Privy with your app. If you haven't, start by following the instructions in the [**Privy Quickstart**](/basics/react/quickstart) to get your app set up with Privy.

You must also enable Farcaster as a sign-in method for your app from the dashboard. Please see the [**Farcaster Integration**](/authentication/user-authentication/login-methods/farcaster) recipe to get set up.

### 2. Create an embedded Farcaster signer

<Warning>
  This guide requires your Privy app to be configured with **on-device wallet mode**. Embedded
  Farcaster signers are not compatible with TEE mode.
</Warning>

The first step to write to Farcaster is to create an embedded signer.

<details>
  <summary><b>What is an embedded Farcaster signer?</b></summary>

  Farcaster data is shared across a network of servers called "hubs". Hubs are responsible for verifying and sharing messages on the protocol. In order to submit messages, you need to create a Farcaster signer.

  This is an Ed25519 key-pair that is authorized to sign messages on your user's behalf. Privy generates a new non-custodial signer for your user.

  A user can authorize their embedded Farcaster signer to post on their behalf via Farcaster's signer connect flow. This allows your app to post messages with your user's Farcaster account!

  ***
</details>

In order to do so, a user must go through an authorization flow, which grants their new Farcaster signer permission to submit casts on their behalf. Use the `useFarcasterSigner()` hook to request a new signer from a user's existing Farcaster account.

```tsx  theme={"system"}
import { useFarcasterSigner, usePrivy } from @privy-io/react-auth;

const { user } = usePrivy();
const { requestFarcasterSignerFromWarpcast } = useFarcasterSigner();

const farcasterAccount = user.linkedAccounts.find((account) => account.type === 'farcaster');

<button
  onClick={() => requestFarcasterSignerFromWarpcast()}
  // Prevent requesting a Farcaster signer if a user has not already linked a Farcaster account
  // or if they have already requested a signer
  disabled={!farcasterAccount || farcasterAccount.signerPublicKey}
>
  Authorize my Farcaster signer from Farcaster
</button>
```

<Tip>
  You can see if your user already has an embedded Farcaster signer authorized by checking if
  `user.linkedAccounts.find((account) => account.type === 'farcaster').signerPublicKey` is defined!
</Tip>

### 3. Create an external signer

In order to interface with Farcaster libraries, we need to build a simple signer object. This can easily be constructed using the Privy Farcaster signer interfaces.

This step requires that you install [@standard-crypto/farcaster-js](https://www.npmjs.com/package/@standard-crypto/farcaster-js).

```
npm install @farcaster/frame-sdk
```

First, define an ExternalEd25519Signer:

```tsx  theme={"system"}
import {ExternalEd25519Signer} from '@standard-crypto/farcaster-js';

const {getFarcasterSignerPublicKey, signFarcasterMessage} = useFarcasterSigner();

const privySigner = new ExternalEd25519Signer(signFarcasterMessage, getFarcasterSignerPublicKey);
```

### 4. Build the hub client

Now that we have a signer object built, we can build our [@standard-crypto/farcaster-js](https://www.npmjs.com/package/@standard-crypto/farcaster-js) client for interacting with Farcaster!

```tsx  theme={"system"}
import {HubRestAPIClient} from '@standard-crypto/farcaster-js';

const client = new HubRestAPIClient({
  hubUrl: 'https://hub.farcaster.standardcrypto.vc:2281'
});
```

### 5. Submit a cast

Now that you have a client initialized, you can now begin submitting messages to the protocol!

Luckily, farcaster-js makes submitting a cast as easy as:

```tsx  theme={"system"}
const submitCastResponse = await client.submitCast(
  {text: 'Hello world!'},
  user.farcaster.fid,
  privySigner
);
```

### 6. Interact with other Farcasters!

Alright, your user has created a new cast, but how do they interact with other people?

First off, we need our user to follow people to display casts on their feed! Let's go ahead and follow Vitalik.

```tsx  theme={"system"}
// Vitalik's Farcaster ID (FID) is 5650
const followUserResponse = await client.followUser(5650, user.farcaster.fid, privySigner);
```

Next, let's like and recast some of his casts.

```tsx  theme={"system"}
// Liking one of Vitalik's recent casts
// https://farcaster.xyz/vitalik.eth/0x3e9b3734
const submitLikeResponse = await client.submitReaction(
  {
    type: 'like',
    target: {
      fid: 5650,
      hash: '0x3e9b3734a29ad341f1c73912c42343a21d5df75a'
    }
  },
  user.farcaster.fid,
  privySigner
);

// Recasting another one of Vitalik's recent casts
// https://farcaster.xyz/vitalik.eth/0x6be44f32
const submitRecastResponse = await client.submitReaction(
  {
    type: 'recast',
    target: {
      fid: 5650,
      hash: '0x6be44f32011a59e239d5a00bb6302c3105ad3214'
    }
  },
  user.farcaster.fid,
  privySigner
);
```

Awesome! We've already submitted, liked, and recasted a cast + followed a user.

Now, your user wants to shake up their feed, so they are going to unfollow Vitalik.

```tsx  theme={"system"}
const unfollowUserResponse = await client.unfollowUser(5650, user.farcaster.fid, privySigner);
```

That's it!

Your user has now logged in with Farcaster, authorized a new non-custodial signer, and started writing to the protocol. Wowow!

## Caveats

Some Privy features cannot be used alongside Farcaster embedded signers.

1. A user must always have an embedded wallet to use Farcaster embedded signers. Before calling `requestFarcasterSignerFromWarpcast` be sure to either [manually or automatically](/wallets/wallets/create/create-a-wallet) create an embedded wallet.
2. **MFA** cannot be enabled when using Farcaster embedded signers.
3. **Passwords** on embedded wallets cannot be added when using Farcaster embedded signers.

## Resources

If you're new to Farcaster, here are some great places to get started:

* [https://docs.farcaster.xyz/](https://docs.farcaster.xyz/)
* [https://www.thehubble.xyz/](https://www.thehubble.xyz/)

Interacting with the Farcaster protocol requires reading existing data. The Farcaster team has a set of open source libraries for reading from hubs directly: [https://github.com/farcasterxyz](https://github.com/farcasterxyz).

Alternatively, you can use data APIs built for Farcaster developers that drastically improve developer and user UX using [Neynar](https://neynar.com/).

## FAQ

<br />

**Q**: *Will my users have to pay Warps?*

**A**: We are sponsoring all signers created so that your users will not have to spend any Warps!

**Q**: *How do I revoke my embedded Farcaster signer?*

**A**: If your account was created on Farcaster, you can go to Settings -> Advanced -> Manage connected apps. Then, delete the key you wish to revoke. Note that this will **delete all messages** posted by that signer. Revoking a signer without Farcaster is a somewhat involved process. Using your custody address (wallet from Farcaster), you can call `remove(mySignerPublicKey)` on the [Farcaster Key Registry](https://optimistic.etherscan.io/address/0x00000000fc1237824fb747abde0ff18990e59b7e) contract to permanently deauthorize an embedded Farcaster signer. [Here is an example](https://optimistic.etherscan.io/tx/0x49f4de7596eced1ac34abd2e78329ba8ff02569156cf4f5919250cca0144e783).

<br />

**Q**: *I really like/dislike 'X'. How do I tell someone?*

**A**: We would love ANY feedback on your experience so far! Please reach out to us on [Farcaster](https://farcaster.xyz/privy) or [Slack](https://privy.io/slack).


# Integrating Flashbots Protect
Source: https://docs.privy.io/recipes/flashbots-protect



[Flashbots Protect](https://docs.flashbots.net/flashbots-protect/overview) is an RPC service that helps protect your users' Ethereum transactions from dangerous frontrunning attacks by submitting transactions to a private mempool that remains hidden from bots. You can also use the service to earn MEV refunds on any MEV realized through backrunning.

To integrate Flashbots Protect with Privy, first configure the [Flashbots RPC URL](https://docs.flashbots.net/flashbots-protect/quick-start) for the chain your app needs:

<Tabs>
  <Tab title="Mainnet">
    ```tsx  theme={"system"}
    import {mainnet} from 'viem/chains';

    import {addRpcUrlOverrideToChain} from '@privy-io/react-auth';

    // Configure the Flashbots RPC URL for mainnet
    const mainnetWithFlashbotsProtect = addRpcUrlOverrideToChain(
      mainnet,
      'https://rpc.flashbots.net/fast'
    );
    ```
  </Tab>

  <Tab title="Sepolia">
    ```tsx  theme={"system"}
    import {sepolia} from 'viem/chains';

    import {addRpcUrlOverrideToChain} from '@privy-io/react-auth';

    // Configure the Flashbots RPC URL for sepolia
    const sepoliaWithFlashbotsProtect = addRpcUrlOverrideToChain(
      sepolia,
      'https://rpc-sepolia.flashbots.net/'
    );
    ```
  </Tab>

  <Tab title="Holesky">
    ```tsx  theme={"system"}
    import {holesky} from 'viem/chains';

    import {addRpcUrlOverrideToChain} from '@privy-io/react-auth';

    // Configure the Flashbots RPC URL for holesky
    const holeskyWithFlashbotsProtect = addRpcUrlOverrideToChain(
      holesky,
      'https://rpc-holesky.flashbots.net/'
    );
    ```
  </Tab>
</Tabs>

Next, pass the chain configured with the Flashbots RPC URL to the `config.supportedChains` property of the `PrivyProvider`:

<Tabs>
  <Tab title="Mainnet">
    ```tsx  theme={"system"}
    <PrivyProvider
      appId="your-privy-app-id"
      config={{
        ...theRestOfYourConfig,
        supportedChains: [mainnetWithFlashbotsProtect, ...otherChains]
      }}
    >
      {/* your app's content */}
    </PrivyProvider>
    ```
  </Tab>

  <Tab title="Sepolia">
    ```tsx  theme={"system"}
    <PrivyProvider
      appId="your-privy-app-id"
      config={{
        ...theRestOfYourConfig,
        supportedChains: [sepoliaWithFlashbotsProtect, ...otherChains]
      }}
    >
      {/* your app's content */}
    </PrivyProvider>
    ```
  </Tab>

  <Tab title="Holesky">
    ```tsx  theme={"system"}
    <PrivyProvider
      appId="your-privy-app-id"
      config={{
        ...theRestOfYourConfig,
        supportedChains: [holeskyWithFlashbotsProtect, ...otherChains]
      }}
    >
      {/* your app's content */}
    </PrivyProvider>
    ```
  </Tab>
</Tabs>

**That's it!** Once you've configured Flashbots Protect as the RPC URL for your desired chain, Privy will route your users' transactions through the private Flashbots mempool.

<Info>
  Flashbots Protect currently only supports Ethereum mainnet, the Ethereum Sepolia testnet, and the
  Ethereum Holesky testnet. The team is actively building support for other networks, including L2s,
  as well.
</Info>


# Custom gas sponsorship rate limits
Source: https://docs.privy.io/recipes/gas-sponsorship-rate-limits

Implement spending controls for gas-sponsored transactions

Gas sponsorship allows your app to pay for transaction fees on behalf of users. Privy natively offers controls to limit total spend and allows for per-transaction control on whether to sponsor gas, but your app may implement finer controls on spend across wallets, users, or apps.

This guide walks through an implementation of wallet-level, user-level, and app-level spending limits for Privy gas-sponsored transactions across a given timeframe.

## Prerequisites

* A Privy app with [gas sponsorship enabled](/wallets/gas-and-asset-management/gas/setup)
* Basic familiarity with [sending transactions](/wallets/using-wallets/ethereum/send-a-transaction)

## Overview

The recipe implements a three-tier spending control system:

* **Wallet-level**: Limit spending per individual wallet
* **User-level**: Limit spending per user across all their wallets
* **App-level**: Limit total spending across all users

Privy exposes a `sponsor` parameter in a transaction request to conditionally enable gas sponsorship, which your app can integrate with. Based on whether a given meter is exceeded, the app
can conditionally choose to send a gas sponsored transaction or fallback to a non-sponsored submission. This allows the app to create a stopgap in spend based on custom metering.

## Step 1: Configure custom spending limits

To start, set up a simple policy configuration based on a daily spending limit. This strategy defines daily spending limits for each tier, resetting these limits every day, e.g. at midnight UTC.

```tsx  theme={"system"}
const LIMITS = {
  perWalletDailyCents: 200, // $2 per wallet per day
  perUserDailyCents: 500, // $5 per user per day
  perAppDailyCents: 10000 // $100 per app per day
};
```

## Step 2: Set up spend tracking

To actually know how much gas your app has consumed, set up a storage system to track spending.

```tsx  theme={"system"}
interface SpendTracker {
  date: string; // YYYY-MM-DD
  spentCents: number;
}

const walletSpend = new Map<string, SpendTracker>();
const userSpend = new Map<string, SpendTracker>();
let appSpend: SpendTracker = {date: '', spentCents: 0};
```

## Step 3: Estimate transaction costs

Define cost estimates per chain. For production use, implement dynamic cost estimation based on current gas prices.

In practice, your app could also adjust the cost multipliers dynamically based on the type of transaction and a given chain. For example, recording a higher multiple of gas spend for a transaction on Solana that is also an SPL token transfer.

```tsx  theme={"system"}
const CHAIN_COSTS: Record<string, number> = {
  'eip155:1': 100, // Ethereum: ~$1
  'eip155:8453': 5, // Base: ~$0.05
  'solana:mainnet': 1 // Solana: ~$0.01
};

function estimateCostCents(chainId: string): number {
  return CHAIN_COSTS[chainId] || 100; // Default $1
}
```

## Step 4: Implement rate limit checks

Check spending against all tiers based on current date before allowing sponsorship.

```tsx  theme={"system"}
function getToday(): string {
  return new Date().toISOString().split('T')[0];
}

function canSponsor(
  walletAddress: string,
  userId: string,
  costCents: number
): {allowed: boolean; reason?: string} {
  const today = getToday();

  // Level 1: Check wallet limit
  let walletTracker = walletSpend.get(walletAddress);
  if (!walletTracker || walletTracker.date !== today) {
    walletTracker = {date: today, spentCents: 0};
  }

  if (walletTracker.spentCents + costCents > LIMITS.perWalletDailyCents) {
    return {
      allowed: false,
      reason: `Wallet daily limit of $${LIMITS.perWalletDailyCents / 100} reached`
    };
  }

  // Level 2: Check user limit
  let userTracker = userSpend.get(userId);
  if (!userTracker || userTracker.date !== today) {
    userTracker = {date: today, spentCents: 0};
  }

  if (userTracker.spentCents + costCents > LIMITS.perUserDailyCents) {
    return {
      allowed: false,
      reason: `User daily limit of $${LIMITS.perUserDailyCents / 100} reached`
    };
  }

  // Level 3: Check app limit
  if (appSpend.date !== today) {
    appSpend = {date: today, spentCents: 0};
  }

  if (appSpend.spentCents + costCents > LIMITS.perAppDailyCents) {
    return {
      allowed: false,
      reason: `App daily limit of $${LIMITS.perAppDailyCents / 100} reached`
    };
  }

  return {allowed: true};
}
```

## Step 5: Record spending after transactions

Update all spending trackers when a sponsored transaction is allowed and is successfully submitted.

```tsx  theme={"system"}
function recordSpend(walletAddress: string, userId: string, costCents: number): void {
  const today = getToday();

  // Update wallet tracker
  let walletTracker = walletSpend.get(walletAddress);
  if (!walletTracker || walletTracker.date !== today) {
    walletTracker = {date: today, spentCents: 0};
  }
  walletTracker.spentCents += costCents;
  walletSpend.set(walletAddress, walletTracker);

  // Update user tracker
  let userTracker = userSpend.get(userId);
  if (!userTracker || userTracker.date !== today) {
    userTracker = {date: today, spentCents: 0};
  }
  userTracker.spentCents += costCents;
  userSpend.set(userId, userTracker);

  // Update app tracker
  if (appSpend.date !== today) {
    appSpend = {date: today, spentCents: 0};
  }
  appSpend.spentCents += costCents;
}
```

## Step 6: Send transactions with conditional sponsorship

Integrate the rate limiting logic with Privy's transaction API.

```tsx  theme={"system"}
async function sendTransaction({userId, walletAddress, chainId, transaction}) {
  const estimatedCostCents = estimateCostCents(chainId);
  const {allowed, reason} = canSponsor(walletAddress, userId, estimatedCostCents);

  const response = await fetch(`https://api.privy.io/v1/wallets/${walletAddress}/rpc`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'privy-app-id': process.env.PRIVY_APP_ID!,
      Authorization: `Bearer ${process.env.PRIVY_APP_SECRET}`
    },
    body: JSON.stringify({
      method: 'eth_sendTransaction',
      params: {
        transaction: {transaction}
      },
      caip2: chainId,
      sponsor: allowed // Conditionally sponsor based on limits
    })
  });

  if (response.ok) {
    const result = await response.json();

    // Record spend if sponsored
    if (allowed) {
      recordSpend(walletAddress, userId, estimatedCostCents);
    } else {
      console.log(reason);
    }
  }
}
```

## Advanced considerations

Some additional directions to explore for more advanced custom rate limiting:

* Replace in-memory rate limit storage with persistent storage, e.g. Redis
* For smoother limits, consider implementing sliding window rate limiting
* Implement rate limit counters for number of total transactions sent in addition to transaction dollar volume. For example, a rate limit to allow at most 100 transactions per day
* Implement per-transaction limits. For example, reject a transaction if its gas cost estimate prior to submission is over \$1

## Related resources

<CardGroup cols={2}>
  <Card title="Gas sponsorship overview" icon="gas-pump" href="/wallets/gas-and-asset-management/gas/overview">
    Learn about Privy's gas sponsorship engine
  </Card>

  <Card title="Send a transaction" icon="paper-plane" href="/wallets/using-wallets/ethereum/send-a-transaction">
    Guide to sending transactions with Privy
  </Card>
</CardGroup>


# Hierarchical deterministic (HD) wallets
Source: https://docs.privy.io/recipes/hd-wallets



Privy embedded wallets are **hierarchical deterministic (HD)** wallets. An HD wallet allows you to generate multiple addresses and private keys from a shared source of entropy: the wallet seed (or equivalently, a [BIP-39 mnemonic](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) encoding the seed, known as a seed *phrase*).

In kind, **Privy can be used to provision multiple embedded wallets for a single user.** Read more below to learn how!

<details>
  <summary>Read more about how HD wallets work.</summary>

  HD wallets use a shared source of entropy to derive the wallet seed; this entropy is protected by the Privy cryptosystem.

  Each wallet is generated from the seed and a unique path parameter, which has the format:

  ```
  m / purpose' / coin_type' / account' / change / address_index
  ```

  For Privy's embedded wallets, the path used for the `i`-th wallet is:

  ```
  m/44'/60'/0'/0/i for Ethereum
  m/44'/501'/i/0'  for Solana
  ```

  where `i` is 0-indexed. An HD wallet is said to have an index of `i` if it is derived from the `i`-th path above. You can read more about these derivation paths [here](https://help.myetherwallet.com/en/articles/5867305-hd-wallets-and-derivation-paths).
</details>

<Tabs>
  <Tab title="React">
    ## Creating multiple HD wallets

    To create multiple HD wallets for a user, use the `createWallet` method:

    <Tabs>
      <Tab title="Ethereum">
        ```tsx  theme={"system"}
        import {useCreateWallet} from '@privy-io/react-auth';

        const {createWallet} = useCreateWallet();
        ```
      </Tab>

      <Tab title="Solana">
        ```tsx  theme={"system"}
        import {useCreateWallet} from '@privy-io/react-auth/solana';

        const {createWallet} = useCreateWallet();
        ```
      </Tab>
    </Tabs>

    ### Creating the user's first wallet

    If this is the first wallet you are creating for the user (e.g. the 0th index), you may call **`createWallet`** with no parameters:

    ```tsx  theme={"system"}
    // Creating the first wallet for a user
    await createWallet();
    ```

    ### Creating additional wallets

    There are two approaches to creating additional wallets.

    #### 1. Create an additional wallet with the next available index

    If the user already has an embedded wallet, and you are creating an additional embedded wallet, call `createWallet` with `createAdditional` set to `true`:

    <ParamField path="createAdditional" type="boolean">
      If `true`, will allow the user to create a wallet regardless if it is their first wallet or an
      additional wallet. If `false`, createWallet will succeed *only if the use is creating their first
      wallet.* Defaults to `false`.
    </ParamField>

    Once invoked, **`createWallet`** will return a Promise that resolves to the **`Wallet`** created for the user at the specified index, if it was successful. This method will reject with an error if:

    * the user is not `authenticated`
    * the user already has an embedded wallet and `createAdditional` was not set to `true`
    * if there is another error during wallet creation, such as the user exiting prematurely

    ```tsx  theme={"system"}
    // Creating additional embedded wallets for the user
    // You can also create the first wallet for the user using this syntax
    await createWallet({createAdditional: true});
    ```

    #### 2. Create an additional wallet with a specified HD wallet index

    To create a wallet at a specified HD wallet index, call `createWallet` with the preferred `walletIndex`.
    This method will either create a new wallet, or return the existing one if one already exists at the specified index.

    <ParamField path="walletIndex" type="number">
      The specified HD wallet index. Must be a positive number, and must be `0` for the user's first
      wallet.
    </ParamField>

    <Info>
      A wallet with HD index 0 must be created before creating a wallet at greater HD indices.
    </Info>

    ```tsx  theme={"system"}
    // Create an additional embedded wallet at index 5
    await createWallet({walletIndex: 5});
    ```

    An error can be thrown if:

    * the user is not `authenticated`
    * wallet creation fails or the wallet cannot be added to the user's account.
    * an invalid HD wallet index is supplied, i.e. `walletIndex` is less than 0, or if `walletIndex` is greater than 0 while user has no wallet with HD index 0.

    ## Using multiple HD wallets

    ### Getting a specific embedded wallet

    Once a user has one or more embedded wallets, the wallets are added to both [`linkedAccounts`](/user-management/users/the-user-object) array of the **`user`** object and the array of connected wallets returned by [`useWallets`](/wallets/wallets/get-a-wallet/get-connected-wallet).

    To find a specific embedded wallet for the user, search the `useWallets` array for a wallet with `walletClientType: 'privy'` and an `address` that matches your desired address:

    <Tabs>
      <Tab title="Ethereum">
        ```tsx  theme={"system"}
        import {useWallets} from '@privy-io/react-auth';

        // Ensure the wallet address is checksummed per EIP55
        const desiredAddress = 'insert-your-desired-address-in-EIP55-format';
        const {wallets} = useWallets();
        const desiredWallet = wallets.find(
          (wallet) => wallet.walletClientType === 'privy' && wallet.address === desiredAddress
        );
        ```
      </Tab>

      <Tab title="Solana">
        ```tsx  theme={"system"}
        import {useWallets} from '@privy-io/react-auth/solana';

        const desiredAddress = 'insert-your-desired-address';
        const {wallets} = useWallets();
        const desiredWallet = wallets.find(
          (wallet) => wallet.walletClientType === 'privy' && wallet.address === desiredAddress
        );
        ```
      </Tab>
    </Tabs>

    You can also get a list of all of the user's embedded wallets by filtering the `useWallets` array for entries with `walletClientType: 'privy'`:

    ```tsx  theme={"system"}
    const embeddedWallets = wallets.filter((wallet) => wallet.walletClientType === 'privy');
    ```

    ### Requesting signatures and transactions

    Your app can then use Privy's native signature and transaction methods, the wallet's EIP1193 provider, or a third-party library like `viem` or `ethers`, per the instructions below.

    #### Using Privy's native signature and transaction methods

    To use Privy's native `signMessage`, `signTypedData`, and `sendTransaction` methods with a specific embedded wallet, simply pass the address for your desired wallet as the final optional parameter to these methods:

    <Tabs>
      <Tab title="Ethereum">
        #### `signMessage`

        ```tsx  theme={"system"}
        const {signMessage} = usePrivy();
        const signature = await signMessage(
          {message: 'insert-message-to-sign'},
          {
            uiOptions: insertOptionalUIConfigOrUndefined,
            address: desiredWallet.address // Replace with the address of the desired embedded wallet
          }
        );
        ```

        #### `signTypedData`

        ```tsx  theme={"system"}
        const {signTypedData} = usePrivy();
        const signature = await signTypedData(insertTypedDataObject, {
          uiOptions: insertOptionalUIConfigOrUndefined,
          address: desiredWallet.address // Replace with the address of the desired embedded wallet
        });
        ```

        #### `sendTransaction`

        ```tsx  theme={"system"}
        const {sendTransaction} = usePrivy();
        const signature = await sendTransaction(insertTransactionRequest, {
          uiOptions: insertOptionalUIConfigOrUndefined,
          fundingConfig: insertOptionalUIConfigOrUndefined,
          address: desiredWallet.address // Replace with the address of the desired embedded wallet
        });
        ```
      </Tab>

      <Tab title="Solana">
        #### `signMessage`

        ```tsx  theme={"system"}
        import {useSignMessage} from '@privy-io/react-auth/solana';

        const {signMessage} = useSignMessage();
        const signature = await signMessage(
          {message: new TextEncoder().encode('insert-message-to-sign')},
          {
            uiOptions: insertOptionalUIConfigOrUndefined,
            address: desiredWallet.address // Replace with the address of the desired embedded wallet
          }
        );
        ```

        #### `sendTransaction`

        ```tsx  theme={"system"}
        import {useSendTransaction} from '@privy-io/react-auth/solana';

        const {sendTransaction} = useSendTransaction();
        const signature = await sendTransaction({
          transaction,
          uiOptions: insertOptionalUIConfigOrUndefined,
          fundWalletConfig: insertOptionalUIConfigOrUndefined,
          address: desiredWallet.address // Replace with the address of the desired embedded wallet
        });
        ```
      </Tab>
    </Tabs>

    #### Using the EIP1193 provider, viem, and ethers (EVM only)

    You can also request signatures and transactions from a specific embedded wallet using the wallet's [EIP1193 provider](/wallets/using-wallets/ethereum/web3-integrations) or a library like `viem` or `ethers`.

    To get the EIP1193 provider for a specific embedded wallet, first find the corresponding `ConnectedWallet` object from the `useWallets` array:

    ```tsx  theme={"system"}
    // Ensure the wallet address is checksummed per EIP55
    const address = 'insert-your-desired-address-in-EIP55-format';
    const {wallets} = useWallets();
    const wallet = wallets.find(
      (wallet) => wallet.walletClientType === 'privy' && wallet.address === address
    );
    ```

    Then, call the object's `getEthereumProvider` method to get an EIP1193 provider for that wallet:

    ```tsx  theme={"system"}
    const provider = await wallet.getEthereumProvider();
    ```

    You can then easily pass that EIP1193 provider to a library like [`viem`](/wallets/using-wallets/ethereum/web3-integrations#viem) or [`ethers`](/wallets/using-wallets/ethereum/web3-integrations#ethers) to use those libraries' interfaces to send requests to the wallet.

    ## Exporting HD wallets

    To export the private key for a specific HD wallet, simply pass the address of the wallet you'd like to export as an `address` parameter to the `exportWallet` method:

    <Tabs>
      <Tab title="Ethereum">
        ```tsx  theme={"system"}
        const {exportWallet} = usePrivy();
        await exportWallet({address: 'insert-your-desired-address'});
        ```
      </Tab>

      <Tab title="Solana">
        ```tsx  theme={"system"}
        import {useExportWallet} from '@privy-io/react-auth/solana';

        const {exportWallet} = useExportWallet();
        await exportWallet({address: 'insert-your-desired-address'});
        ```
      </Tab>
    </Tabs>

    If no `address` is passed to `exportWallet`, Privy will default to exporting the non-imported wallet at `walletIndex: 0`.

    ## Pregenerating multiple HD wallets (EVM only)

    Privy supports pregenerating multiple HD wallets in Ethereum when creating new users. With our user import endpoint, you can create a user with up to 10 pregenerated HD wallets. Simply call the import endpoint with `create_n_ethereum_wallets` set to the number of embedded wallets you want to generate for your user.

    <Info>
      Pregeneration endpoints have heavier rate limit of 240 users per minute. If you are being rate
      limited, responses will have status code 429. We suggest you setup exponential back-offs starting
      at 1 second to seamlessly recover.
    </Info>

    Below is a sample cURL command for pregenerating two new wallets for a user with Privy:

    ```bash  theme={"system"}
    $ curl --request POST https://auth.privy.io/api/v1/users \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H 'Content-Type: application/json' \
    -d '{
      "create_n_ethereum_wallets": 2,
      "linked_accounts": [
        {
          "address": "batman@privy.io",
          "type": "email"
        }
      ]
    }'
    ```

    A successful response will include the new user object along with their Privy user ID and embedded wallet addresses, like below. The generated wallets will be available to the user upon sign in.

    Below is a sample successful response for generating two new wallets for a user with Privy:

    ```json  theme={"system"}
    {
      "id": "did:privy:clddy332f002tyqpq3b3lv327",
      "created_at": 1674788927,
      "linked_accounts": [
        {
          "address": "batman@privy.io",
          "type": "email"
        },
        {
          "address": "0x3DAF84b3f09A0E2092302F7560888dBc0952b7B7",
          "type": "wallet",
          "wallet_index": 0,
          "walletClient": "privy",
          "chain_type": "ethereum"
        },
        {
          "address": "0x1a235d54C58d0B5E339c784Fd98d4D71125fEb1c",
          "type": "wallet",
          "wallet_index": 1,
          "walletClient": "privy",
          "chain_type": "ethereum"
        }
      ]
    }
    ```
  </Tab>

  <Tab title="React Native">
    <Tabs>
      <Tab title="Ethereum">
        ## Creating multiple HD wallets

        To create multiple Ethereum wallets for a user, use the `create` method from the `useEmbeddedEthereumWallet` hook:

        ```tsx  theme={"system"}
        import {useEmbeddedEthereumWallet} from '@privy-io/expo';

        const {create} = useEmbeddedEthereumWallet();
        ```

        As a parameter to `create`, pass an object containing a `createAdditional` boolean specifying if you would like to create an additional wallet, even if the user has an existing one.

        <ParamField path="createAdditional" type="boolean">
          If `true`, will allow the user to create a Ethereum wallet regardless if it is their first wallet
          or an additional wallet. If `false`, createWallet will succeed *only if the use is creating their
          first wallet.* Defaults to `false`.
        </ParamField>

        Once invoked, **`create`** will return a Promise that resolves to the newly created [wallet](/wallets/wallets/get-a-wallet/get-connected-wallet), if it was successful. This method will reject with an error if:

        * the user is not `authenticated`.
        * the user already has an embedded Ethereum wallet and `createAdditional` was not set to `true`.
        * if there is another error during wallet creation, such as the user exiting prematurely.

        ```tsx  theme={"system"}
        // Creating additional embedded wallets for the user
        // You can also create the first wallet for the user using this syntax
        await create({createAdditional: true});
        ```

        ## Using multiple HD wallets

        Once a user has one or more embedded wallets, the wallets are added to the `wallets` array returned by `useEmbeddedEthereumWallet`:

        ```tsx  theme={"system"}
        import {useEmbeddedEthereumWallet} from '@privy-io/expo';
        ...
        const {wallets} = useEmbeddedEthereumWallet();
        ```

        Refer to the [requests section](/wallets/wallets/get-a-wallet/get-connected-wallet) to learn how to interact with the wallets you create.

        ### Getting a specific embedded wallet

        To find a specific embedded wallet for the user, search the `wallets` array for a wallet with the `address` that matches your desired address:

        ```tsx  theme={"system"}
        const desiredAddress = 'insert-your-desired-wallet-address';
        const {wallets} = useEmbeddedEthereumWallet();
        const desiredWallet = wallets.find((wallet) => wallet.address === desiredAddress);
        ```

        You can alternatively search the wallets array by your desired HD index:

        ```tsx  theme={"system"}
        // Replace this with your desired HD index
        const desiredHdIndex = 0;
        const {wallets} = useEmbeddedEthereumWallet();
        const desiredWallet = wallets.find((wallet) => wallet.walletIndex === desiredHdIndex);
        ```
      </Tab>

      <Tab title="Solana">
        ## Creating multiple HD wallets

        To create multiple Solana wallets for a user, use the `create` method from the `useEmbeddedSolanaWallet` hook:

        ```tsx  theme={"system"}
        import {useEmbeddedSolanaWallet} from '@privy-io/expo';
        ...
        const {create} = useEmbeddedSolanaWallet();
        ```

        As an optional parameter to `create`, you may pass an object containing the following fields:

        <ParamField path="createAdditional" type="boolean">
          If `true`, will allow the user to create a Solana wallet regardless if it is their first wallet or
          an additional wallet. If `false`, createWallet will succeed *only if the use is creating their
          first wallet.* Defaults to `false`.
        </ParamField>

        Once invoked, **`create`** will return a Promise that resolves to the [provider](/wallets/wallets/get-a-wallet/get-connected-wallet) for the wallet created for the user, if it was successful. This method will reject with an error if:

        * the user is not `authenticated`
        * the user already has an embedded Solana wallet and `createAdditional` was not set to `true`
        * if there is another error during wallet creation, such as the user exiting prematurely

        ### Creating the user's first wallet

        If this is the first wallet you are creating for the user (e.g. the 0th index), you may call **`create`** with no parameters:

        ```tsx  theme={"system"}
        // Creating the first wallet for a user
        const provider = await create();
        ```

        ### Creating additional wallets

        If the user already has an embedded wallet, and you are creating an additional embedded wallet, **you must call `create` with `createAdditional` set to `true`**:

        ```tsx  theme={"system"}
        // Creating additional embedded wallets for the user
        // You can also create the first wallet for the user using this syntax
        const provider = await create({createAdditional: true});
        ```

        ## Using multiple HD wallets

        Once a user has one or more embedded wallets, the wallets are added to the `wallets` array returned by `useEmbeddedSolanaWallet`:

        ```tsx  theme={"system"}
        import {useEmbeddedSolanaWallet} from '@privy-io/expo';
        ...
        const {wallets} = useEmbeddedSolanaWallet();
        ```

        Each entry in the `wallets` array is an object with the following fields:

        <ParamField path="address" type="string">
          The address (base58-encoded public key) for the wallet.
        </ParamField>

        <ParamField path="publicKey" type="string">
          The address (base58-encoded public key) for the wallet.
        </ParamField>

        <ParamField path="walletIndex" type="number">
          The HD index for the wallet.
        </ParamField>

        <ParamField path="getProvider" type="() => Promise<PrivyEmbeddedSolanaWalletProvider>">
          Method to get a [provider](/wallets/wallets/get-a-wallet/get-connected-wallet) for the wallet for
          requesting signatures and transactions.
        </ParamField>

        ### Getting a specific embedded wallet

        To find a specific embedded wallet for the user, search the `wallets` array for a wallet with the `address` that matches your desired address:

        ```tsx  theme={"system"}
        const desiredAddress = 'insert-your-desired-wallet-address';
        const {wallets} = useEmbeddedSolanaWallet();
        const desiredWallet = wallets.find((wallet) => wallet.address === desiredAddress);
        ```

        You can alternatively search the wallets array by your desired HD index:

        ```tsx  theme={"system"}
        // Replace this with your desired HD index
        const desiredHdIndex = 0;
        const {wallets} = useEmbeddedSolanaWallet();
        const desiredWallet = wallets.find((wallet) => wallet.walletIndex === desiredHdIndex);
        ```

        ### Requesting signatures and transactions

        To request a signature or transaction from a specific embedded wallet, first find the corresponding wallet object from the `wallets` array:

        ```tsx  theme={"system"}
        const desiredAddress = 'insert-your-desired-wallet-address';
        const {wallets} = useEmbeddedSolanaWallet();
        const wallet = wallets.find((wallet) => wallet.address === desiredAddress);
        ```

        Then, call the object's `getProvider` method to get a [provider](/wallets/wallets/get-a-wallet/get-connected-wallet) for the wallet:

        ```tsx  theme={"system"}
        const provider = await wallet.getProvider();
        ```

        You can then easily request signatures from the [`provider`](/wallets/wallets/get-a-wallet/get-connected-wallet) using its [`request`](/wallets/using-wallets/solana/sign-a-message) method, like so:

        ```tsx  theme={"system"}
        const message = 'Hello world';
        const {signature} = await provider.request({
          method: 'signMessage',
          params: {
            message: message
          }
        });
        ```
      </Tab>
    </Tabs>
  </Tab>
</Tabs>


# Quickstart
Source: https://docs.privy.io/recipes/hyperliquid-guide



[Hyperliquid](https://hyperliquid.xyz/) is a high-performance blockchain designed specifically for decentralized derivatives trading. It offers incredibly fast transaction processing, low fees, and a fully onchain open financial system.

This guide demonstrates how to programmatically access Hyperliquid through Privy's SDKs, covering essential operations including agent wallet creation, trade execution, subaccount management, and builder code integration for revenue sharing

## Prerequisites

Before you begin, make sure you have:

* A [Privy account](https://dashboard.privy.io) with an app created
* Node.js 16+ installed
* Basic familiarity with TypeScript/JavaScript

## Installation

Install the required dependencies:

```bash  theme={"system"}
npm install @nktkas/hyperliquid @privy-io/node viem
```

## Quickstart

Here's a minimal example to get you started:

```javascript  theme={"system"}
import { PrivyClient } from '@privy-io/node';
import { createViemAccount } from '@privy-io/node/viem';
import * as hl from '@nktkas/hyperliquid';

// Initialize Privy client
const privy = new PrivyClient({
  appId: 'insert-your-app-id',
  appSecret: 'insert-your-app-secret',
});

// Create a wallet
const wallet = await privy.wallets().createWallet({
  chain_type: 'ethereum',
});

// Create a viem account
const account = createViemAccount(privy, {
  walletId: wallet.id,
  address: wallet.address as `0x${string}`,
});

// Initialize Hyperliquid client
const transport = new hl.HttpTransport({
  isTestnet: true,
});

const client = new hl.ExchangeClient({
  transport,
  wallet: account,
});
```

## Placing Your First Order

Once you have your client set up, you can place a limit order:

```javascript  theme={"system"}
// Place a limit buy order for BTC
const order = await client.order({
  orders: [
    {
      a: 0, // Asset index (0 = BTC)
      b: true, // Buy side (true = buy, false = sell)
      p: '95000', // Limit price in USD
      s: '0.001', // Size (0.001 BTC)
      r: false, // Reduce-only (false = can open new position)
      t: {limit: {tif: 'Gtc'}} // Time in force: Good-til-canceled
    }
  ],
  grouping: 'na' // Order grouping (usually "na")
});

console.log('Order placed:', order);
```

<Note>
  This example places a buy order for 0.001 BTC at \$95,000. The order will remain active until it's
  filled or you cancel it. Learn more about different order types and trading patterns in the
  [Trading Patterns guide](/recipes/hyperliquid/trading-patterns).
</Note>

## Funding

### Deposit to HyperCore

To start trading on Hyperliquid, you need to deposit funds to HyperCore. A minimum of **\$5 USDC on Arbitrum** is required to deposit. Funds will be credited to the address that makes the deposit.

```javascript  theme={"system"}
import {encodeFunctionData, parseUnits, erc20Abi} from 'viem';

const HYPERLIQUID_BRIDGE_ADDRESS = '0x2Df1c51E09aECF9cacB7bc98cB1742757f163dF7';
const ARBITRUM_USDC_ADDRESS = '0xaf88d065e77c8cC2239327C5EDb3A432268e5831';

// Deposit USDC from Arbitrum to HyperCore
const transaction = await privy
  .wallets()
  .ethereum()
  .sendTransaction(wallet.id, {
    sponsor: true,
    caip2: 'eip155:42161',
    params: {
      transaction: {
        to: ARBITRUM_USDC_ADDRESS,
        data: encodeFunctionData({
          abi: erc20Abi,
          functionName: 'transfer',
          args: [HYPERLIQUID_BRIDGE_ADDRESS, parseUnits('5', 6)]
        })
      }
    }
  });

console.log(transaction);
```

<Note>
  Learn more about the Hyperliquid bridge in the [official
  documentation](https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/bridge2).
</Note>

### Withdraw from HyperCore

To withdraw funds from Hyperliquid back to your wallet, use the `withdraw3` method. Funds will be credited to the `destination` address on Arbitrum as USDC.

```javascript  theme={"system"}
// Withdraw USDC from HyperCore to your wallet
const withdraw = await client.withdraw3({
  destination: wallet.address,
  amount: '5'
});

console.log(withdraw);
```

<Warning>
  Withdrawals are **User Signed Actions** and must be signed by the master wallet. Agent wallets
  cannot initiate withdrawals directly.
</Warning>

### Faucet (Testnet Only)

To use the testnet faucet, your master account must first be activated on mainnet. Send at least **\$5 USDC on Arbitrum** to the bridge address from the master account to activate it.

Once activated, you can claim testnet funds by making an API request:

<CodeGroup>
  ```javascript Fetch theme={"system"}
  const response = await fetch('https://api.hyperliquid-testnet.xyz/info', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      type: 'claimDrip',
      user: wallet.address
    })
  });

  const result = await response.json();
  console.log(result);
  ```

  ```bash Curl theme={"system"}
  curl 'https://api.hyperliquid-testnet.xyz/info' \
    -H 'Content-Type: application/json' \
    --data-raw '{"type":"claimDrip","user":"YOUR_WALLET_ADDRESS"}'
  ```
</CodeGroup>

<Note>
  The faucet provides **\$1000 USDC** for testnet trading. You can only claim from the faucet **once
  per address**.
</Note>

### View Wallet Activity

You can track all deposits, withdrawals, and trading activity by viewing your wallet on the [Hyperliquid explorer](https://app.hyperliquid.xyz/explorer):

<Tip>
  The explorer shows real-time transaction history, trading positions, and account balances for any
  Hyperliquid address.
</Tip>

## Next Steps

Explore these guides to learn more about building with Hyperliquid and Privy:

<CardGroup cols={2}>
  <Card title="Agent wallets" icon="key" href="/recipes/hyperliquid/agents-and-subaccounts">
    Learn how to set up API wallets for secure, programmatic trading operations.
  </Card>

  <Card title="Executing trades" icon="chart-line" href="/recipes/hyperliquid/trading-patterns">
    Discover common trading patterns and best practices for placing orders, managing positions, and
    more.
  </Card>

  <Card title="Client-side SDKs" icon="browser" href="/recipes/hyperliquid/client-side-usage">
    Build React apps with external wallets like MetaMask and agent wallets.
  </Card>

  <Card title="Policies" icon="shield-check" href="/recipes/hyperliquid/policies-and-offline-actions">
    Implement secure trading policies and execute offline actions for advanced risk management.
  </Card>

  <Card title="HyperEVM" icon="code" href="/recipes/hyperliquid/hyperevm">
    Develop smart contracts on Hyperliquid's EVM-compatible blockchain.
  </Card>
</CardGroup>

## Resources

<CardGroup cols={3}>
  <Card title="Hyperliquid Docs" icon="arrow-up-right-from-square" href="https://hyperliquid.gitbook.io/hyperliquid-docs/" arrow>
    Official documentation explaining Hyperliquid's architecture, trading features, and API
    endpoints.
  </Card>

  <Card title="HyperEVM Docs" icon="arrow-up-right-from-square" href="https://hyperliquid.gitbook.io/hyperliquid-docs/hyperevm" arrow>
    Overview of Hyperliquid's EVM chain, including architecture and features.
  </Card>

  <Card title="EVM Transactions with Privy" icon="arrow-up-right-from-square" href="/wallets/using-wallets/ethereum/send-a-transaction" arrow>
    Learn how to send EVM transactions using Privy wallets.
  </Card>
</CardGroup>

## Why Use Privy with Hyperliquid?

* **Security**: Private keys never leave Privy's secure infrastructure
* **Simplicity**: No need to manage key storage or rotation
* **Compatibility**: Full compatibility with Hyperliquid's SDK and API
* **Flexibility**: Easily create and manage multiple wallets for different strategies

<Check>You're ready to start building secure trading applications on Hyperliquid!</Check>


# Agent wallets
Source: https://docs.privy.io/recipes/hyperliquid/agents-and-subaccounts



Learn how to use agent wallets (API wallets) to build secure, scalable trading systems on Hyperliquid with Privy.

<Note>
  Before continuing with this guide, make sure you have initialized your Hyperliquid client as shown
  in the [Getting Started guide](/recipes/hyperliquid-guide). This guide assumes you have `client`
  and other basic setup completed.
</Note>

## Overview

[Agent wallets](https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/nonces-and-api-wallets#api-wallets) (also known as **API wallets**) are permissioned signers that do not hold funds but can execute Hyperliquid actions for a master account and its subaccounts. This lets you:

* Keep user keys isolated while trading programmatically
* Give each bot or trading strategy its own nonce space
* Simplify concurrent trading operations
* Easily rotate keys without affecting trading
* Preserve consolidated fee tiers and account-level PnL {/* spellchecker:disable-line */}

## Creating an Agent Wallet

```javascript  theme={"system"}
import { PrivyClient } from '@privy-io/node';
import { createViemAccount } from '@privy-io/node/viem';
import * as hl from '@nktkas/hyperliquid';

// Initialize Privy client
const privy = new PrivyClient({
  appId: 'insert-your-app-id',
  appSecret: 'insert-your-app-secret',
});

// Create your master trading wallet
const masterWallet = await privy.wallets().createWallet({
  chain_type: 'ethereum',
});

const masterAccount = createViemAccount(privy, {
  walletId: masterWallet.id,
  address: masterWallet.address as `0x${string}`,
});

// Initialize Hyperliquid client with master account
const transport = new hl.HttpTransport({
  isTestnet: true,
});

const masterClient = new hl.ExchangeClient({
  transport,
  wallet: masterAccount,
});

// Create a new agent wallet
const agentWallet = await privy.wallets().createWallet({
  chain_type: 'ethereum',
});

// Register the agent wallet with the master account
await masterClient.registerAgent({
  agentAddress: agentWallet.address as `0x${string}`,
  agentName: "Trading Bot 1",
});
```

## Using an Agent Wallet

Once registered, the agent wallet can execute trades on behalf of the master account:

```javascript  theme={"system"}
// Create a viem account for the agent
const agentAccount = createViemAccount(privy, {
  walletId: agentWallet.id,
  address: agentWallet.address as `0x${string}`,
});

// Create an exchange client using the agent wallet
const agentClient = new hl.ExchangeClient({
  transport,
  wallet: agentAccount,
});

// The agent can now trade on behalf of the master account
const orderResponse = await agentClient.order({
  orders: [
    {
      a: 0, // BTC
      b: true, // Buy
      s: "0.01", // Size
      r: false, // Not reduce-only
      p: "50000", // Price
      t: { limit: { tif: "Gtc" } },
    },
  ],
  grouping: "na",
});
```

## Setting Agent Expiration

You can set an expiration timestamp for agent wallets using the agent name:

```javascript  theme={"system"}
// Create an agent that expires in 24 hours
const expirationTimestamp = Date.now() + 24 * 60 * 60 * 1000;

await masterClient.registerAgent({
  agentName: `Trading Bot valid_until ${expirationTimestamp}`,
  agentAddress: agentWallet.address as `0x${string}`,
});
```

## Listing Agent Wallets

Retrieve all registered agents for a master account:

```javascript  theme={"system"}
const infoClient = new hl.InfoClient({ transport });

const agents = await infoClient.extraAgents({
  user: masterWallet.address as `0x${string}`,
});

console.log("Registered agents:", agents);
```

## Best Practices

<AccordionGroup>
  <Accordion title="Organize by strategy">
    Create separate agent wallets for each trading strategy or bot. This isolates nonce management
    and makes it easier to track which system placed which orders.
  </Accordion>

  <Accordion title="Set appropriate expirations">
    For automated trading systems, set reasonable expiration times on agent wallets to limit
    exposure if a key is compromised.
  </Accordion>

  <Accordion title="Monitor agent permissions">
    Regularly audit which agent wallets are registered and revoke access for agents that are no
    longer needed.
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="Subaccounts" icon="folder-tree" href="/recipes/hyperliquid/subaccounts">
    Learn how to use subaccounts for risk isolation
  </Card>

  <Card title="Executing trades" icon="chart-line" href="/recipes/hyperliquid/trading-patterns">
    Learn common trading patterns and order types
  </Card>
</CardGroup>


# Builder Codes
Source: https://docs.privy.io/recipes/hyperliquid/builder-codes



Learn how to earn fees with builder codes using Privy's wallet infrastructure.

<Note>
  Before continuing with this guide, make sure you have initialized your Hyperliquid client as shown
  in the [Getting Started guide](/recipes/hyperliquid-guide). This guide assumes you have `client`
  and other basic setup completed.
</Note>

## Overview

[Builder codes](https://hyperliquid.gitbook.io/hyperliquid-docs/trading/builder-codes) are an on-chain, per-order attribution mechanism that lets apps and interfaces earn fees on orders they route for users.

Builder codes enable **order-level revenue sharing** - completely independent of which market the order is on:

* Apps earn a small fee on every order fill they route through their interface
* Works on **all markets** across Hyperliquid
* Users must approve a max builder fee for each builder they want to use
* Builder codes can override referral codes on specific orders

## How Builder Codes Work

1. **User Approval**: User approves your builder code and sets a max builder fee they're willing to pay
2. **Order Attribution**: When placing orders through your app, include your builder code in the order
3. **Fee Collection**: You earn a small fee on each filled order
4. **On-Chain Tracking**: Revenue is tracked on-chain and paid out automatically

## Obtaining a Builder Code

To get started with builder codes, you'll need to register as a builder with Hyperliquid. Contact the Hyperliquid team or refer to the [builder codes documentation](https://hyperliquid.gitbook.io/hyperliquid-docs/trading/builder-codes) for registration details.

## Approving Builder Fees

Before users can use your builder code, they must approve your builder address and set a max fee rate (one-time per user per builder):

```javascript  theme={"system"}
import * as hl from '@nktkas/hyperliquid';
import {createViemAccount} from '@privy-io/node/viem';

// Create exchange client with user's wallet
const client = new hl.ExchangeClient({
  transport,
  wallet: userAccount // User's viem account from Privy
});

// User approves your builder and sets max fee
await client.approveBuilderFee({
  builder: '0xBuilderAddress', // Your builder address
  maxFeeRate: '0.05%' // Max fee rate user approves
  // Perps: max 0.10% (10 bps)
  // Spot: max 1.00% (100 bps)
});
```

<Note>
  The `maxFeeRate` is the maximum fee the user is willing to pay. Actual fees charged can be lower,
  but never higher than this approved rate.
</Note>

## Applying Builder Codes to Orders

Once approved, include your builder code when placing orders to earn fees:

```javascript  theme={"system"}
// Place an order with builder code attribution
await client.order({
  orders: [
    {
      a: 0, // BTC index
      b: true, // Buy
      s: '0.001', // Size
      p: '100000', // Price
      r: false, // Not reduce-only
      t: {limit: {tif: 'Gtc'}}
    }
  ],
  builder: {
    b: '0xBuilderAddress', // Your builder address
    f: 50 // Fee in tenths of a bp (50 = 5 bps = 0.05%)
  }
});
```

**Builder fee format:**

* `f` is specified in **tenths of a basis point**
* Example: `f: 50` means 50 tenths of a bp = 5 bps = 0.05%
* Must be ≤ the user's approved `maxFeeRate`

## Checking Builder Fee Approval

Verify a user's builder fee approval before placing orders:

```javascript  theme={"system"}
const infoClient = new hl.InfoClient({transport});

// Check if user has approved your builder
const approval = await infoClient.maxBuilderFee({
  user: userWallet.address as `0x${string}`,
  builder: '0xBuilderAddress'
});

console.log('Max approved fee:', approval.maxBuilderFee);

// If maxBuilderFee is "0" or undefined, user hasn't approved yet
if (!approval.maxBuilderFee || approval.maxBuilderFee === '0') {
  console.log('User needs to approve builder fee first');
}
```

## Best Practices

<AccordionGroup>
  <Accordion title="Monitor builder code performance">
    Track the fee revenue from your builder code to understand user engagement and optimize your
    application.
  </Accordion>

  <Accordion title="Set competitive builder fees">
    Balance between earning revenue and providing value to users. Lower fees may attract more users.
  </Accordion>

  <Accordion title="Test on testnet first">
    Always test your builder code integration on testnet before going live.
  </Accordion>
</AccordionGroup>

## Resources

<Card title="Builder Codes Documentation" icon="arrow-up-right-from-square" href="https://hyperliquid.gitbook.io/hyperliquid-docs/trading/builder-codes" arrow>
  Official guide to order-level revenue sharing
</Card>

## Next Steps

<Card title="Executing trades" icon="chart-line" href="/recipes/hyperliquid/trading-patterns">
  Learn common trading patterns
</Card>


# Client-side SDKs
Source: https://docs.privy.io/recipes/hyperliquid/client-side-usage



Learn how to integrate Hyperliquid with client-side applications using React and external wallets like MetaMask.

## Overview

When building client-side applications with Hyperliquid, you'll typically want to:

1. Allow users to connect with external wallets (MetaMask, Coinbase Wallet, etc.)
2. Create an embedded agent wallet for programmatic trading
3. Execute L1 actions (trading) through the agent wallet
4. Execute User Signed Actions (withdrawals, approvals) through the user's external wallet

This pattern provides the best user experience - users maintain control through their external wallet while trading operations happen seamlessly through the agent wallet.

## Using External Wallets with Agent Wallets

If you want to execute L1 actions (like placing orders, canceling orders, etc.) with external wallets like MetaMask, create an [Agent Wallet](/recipes/hyperliquid/agents-and-subaccounts) and execute all L1 actions through it.

Agent wallets are designed specifically for programmatic trading and provide a better user experience - users won't see confusing chain switching prompts, and it creates a cleaner separation between user wallets and trading operations.

```javascript  theme={"system"}
import { usePrivy, useWallets, toViemAccount } from "@privy-io/react-auth";
import { useCallback } from "react";
import * as hl from "@nktkas/hyperliquid";

export function useInitializeAgent() {
  const { user, ready } = usePrivy();
  const { wallets, ready: walletsReady } = useWallets();

  const initializeAgent = useCallback(async () => {
    if (!ready || !walletsReady) {
      return null;
    }

    const externalWallet = wallets.find(
      (w) => (
        w.walletClientType != "privy"
        && w.address === user?.wallet?.address
      )
    );

    if (!externalWallet) {
      throw new Error("External wallet not found");
    }

    const embeddedWallet = wallets.find(
      (w) => w.walletClientType == "privy"
    );

    if (!embeddedWallet) {
      throw new Error("Embedded wallet not found");
    }

    const externalViemAccount = await toViemAccount({ wallet: externalWallet });
    const embeddedViemAccount = await toViemAccount({ wallet: embeddedWallet });

    const transport = new hl.HttpTransport();
    const client = new hl.ExchangeClient({
      wallet: externalViemAccount,
      transport,
    });

    await client.approveAgent({
      agentAddress: embeddedWallet.address as `0x${string}`,
      agentName: "Privy Agent",
    });

    const agentClient = new hl.ExchangeClient({
      wallet: embeddedViemAccount,
      transport,
    });

    return agentClient;
  }, [user, wallets, ready, walletsReady]);

  return { initializeAgent };
}
```

<Note>
  **User Signed Actions** (like withdrawals and agent approvals) use the standard Ethereum mainnet
  (chain 1) and work normally with external wallets.
</Note>

## Understanding Action Types

### L1 Actions (Trading Operations)

These actions can be executed by agent wallets without requiring the master wallet's signature:

* Placing orders
* Canceling orders
* Modifying leverage
* Setting position sizes

**Best Practice**: Execute these through an agent wallet for a seamless user experience.

### User Signed Actions

These sensitive operations require the master wallet's signature:

* Withdrawing funds
* Approving agents
* Account transfers
* Approving builder fees

**Best Practice**: Execute these through the user's connected external wallet.

## Best Practices

<AccordionGroup>
  <Accordion title="Initialize agent on first use">
    Create and approve the agent wallet the first time a user wants to trade. Store the agent wallet
    reference for future sessions.
  </Accordion>

  <Accordion title="Handle wallet disconnections">
    Implement proper error handling for when users disconnect their external wallet. The agent
    wallet can continue operating, but User Signed Actions will fail.
  </Accordion>

  <Accordion title="Clear user feedback">
    Communicate to users which wallet is being used for each action. For example, "Placing order
    with trading wallet" vs "Approve with MetaMask".
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="Agent wallets" icon="key" href="/recipes/hyperliquid/agents-and-subaccounts">
    Learn more about agent wallets
  </Card>

  <Card title="Executing trades" icon="chart-line" href="/recipes/hyperliquid/trading-patterns">
    Explore trading patterns and order types
  </Card>
</CardGroup>


# HyperEVM
Source: https://docs.privy.io/recipes/hyperliquid/hyperevm



Learn how to build on HyperEVM using Privy's wallet infrastructure.

<Note>
  Before continuing with this guide, make sure you have set up your Privy client as shown in the
  [Getting Started guide](/recipes/hyperliquid-guide).
</Note>

## Overview

[HyperEVM](https://hyperliquid.gitbook.io/hyperliquid-docs/hyperevm) is Hyperliquid's EVM-compatible blockchain that enables:

* Deploying smart contracts with Solidity
* Building DeFi applications
* Creating custom trading logic
* Integrating with existing EVM tooling

## Setting Up HyperEVM

Configure your application to work with HyperEVM:

<CodeGroup>
  ```javascript NodeJS theme={"system"}
  import {PrivyClient} from '@privy-io/node';
  import {hyperevmTestnet} from 'viem/chains';

  const privy = new PrivyClient({
    appId: 'insert-your-app-id',
    appSecret: 'insert-your-app-secret'
  });

  // Send a transaction on HyperEVM testnet
  const {hash, caip2} = await privy
    .wallets()
    .ethereum()
    .sendTransaction('insert-wallet-id', {
      caip2: `eip155:${hyperevmTestnet.id}`,
      params: {
        transaction: {
          to: '0xE3070d3e4309afA3bC9a6b057685743CF42da77C',
          value: '0x2386F26FC10000',
          chain_id: hyperevmTestnet.id
        }
      }
    });
  ```

  ```javascript React theme={"system"}
  import {PrivyProvider} from '@privy-io/react-auth';
  import {hyperliquidEvmTestnet} from 'viem/chains';

  function App() {
    return (
      <PrivyProvider
        appId={'YOUR_PRIVY_APP_ID'}
        config={{
          defaultChain: hyperliquidEvmTestnet,
          supportedChains: [hyperliquidEvmTestnet]
        }}
      >
        {/* Your app components */}
      </PrivyProvider>
    );
  }
  ```
</CodeGroup>

## Gas Sponsorship

### Smart Wallets on HyperEVM

HyperEVM supports [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337) Smart Wallet accounts, allowing you to pay for your users' transaction fees using gas sponsorship.

<Note>
  HyperEVM is compatible with popular smart wallet providers including Alchemy, ZeroDev, and
  Biconomy. You can use Privy's smart wallet infrastructure with any of these providers.
</Note>

### Setting Up a Paymaster and Bundler

Follow these steps to configure gas sponsorship for HyperEVM:

#### 1. Navigate to Smart Wallets Settings

In your [Privy Dashboard](https://dashboard.privy.io), go to **Wallet Infrastructure** → **Smart Wallets**.

#### 2. Choose a Smart Wallet Provider

Select one of the supported providers:

* **ZeroDev**
* **Alchemy**
* **Biconomy**

#### 3. Add HyperEVM as a Custom Chain

Click **Add a new Chain** → **Custom Chain** and configure HyperEVM:

<img src="https://mintcdn.com/privy-c2af3412/p9eun2yyY6PeENXT/images/hyperevm-custom-chain.png?fit=max&auto=format&n=p9eun2yyY6PeENXT&q=85&s=2fcb2aa00949781113aed4418e06f90b" alt="Configure HyperEVM custom chain" data-og-width="512" width="512" data-og-height="787" height="787" data-path="images/hyperevm-custom-chain.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/p9eun2yyY6PeENXT/images/hyperevm-custom-chain.png?w=280&fit=max&auto=format&n=p9eun2yyY6PeENXT&q=85&s=bf93d236072fe7a6832ff8df91f1b62e 280w, https://mintcdn.com/privy-c2af3412/p9eun2yyY6PeENXT/images/hyperevm-custom-chain.png?w=560&fit=max&auto=format&n=p9eun2yyY6PeENXT&q=85&s=53292388b71f2e6cc7cc7603e428dd54 560w, https://mintcdn.com/privy-c2af3412/p9eun2yyY6PeENXT/images/hyperevm-custom-chain.png?w=840&fit=max&auto=format&n=p9eun2yyY6PeENXT&q=85&s=ba310ad06ada8f85cf2479a1ad226778 840w, https://mintcdn.com/privy-c2af3412/p9eun2yyY6PeENXT/images/hyperevm-custom-chain.png?w=1100&fit=max&auto=format&n=p9eun2yyY6PeENXT&q=85&s=3ff27a8aeecb4cd219ef613a1adb926e 1100w, https://mintcdn.com/privy-c2af3412/p9eun2yyY6PeENXT/images/hyperevm-custom-chain.png?w=1650&fit=max&auto=format&n=p9eun2yyY6PeENXT&q=85&s=a2245b68a1a7aeaf12c23661ea0b2c7d 1650w, https://mintcdn.com/privy-c2af3412/p9eun2yyY6PeENXT/images/hyperevm-custom-chain.png?w=2500&fit=max&auto=format&n=p9eun2yyY6PeENXT&q=85&s=2abdc9250d64559aad88de8459b9b5db 2500w" />

* **Name**: HyperEVM Testnet
* **ID number**: 998
* **RPC URL**: Your HyperEVM RPC endpoint
* **Bundler URL**: Your provider's bundler URL (e.g., `https://rpc.zerodev.app/api/v3/ZERO_DEV_API_KEY/chain/998`)
* **Paymaster URL**: Your provider's paymaster URL (e.g., `https://rpc.zerodev.app/api/v3/ZERO_DEV_API_KEY/chain/998`)

<Warning>
  Make sure the smart wallet contract is deployed on HyperEVM for it to save and function correctly.
</Warning>

#### 4. Save and Test

After configuring the chain, click **Save and close**. Your app can now sponsor gas fees for users on HyperEVM using smart wallets.

## Resources

<CardGroup cols={2}>
  <Card title="HyperEVM Documentation" icon="arrow-up-right-from-square" href="https://hyperliquid.gitbook.io/hyperliquid-docs/hyperevm" arrow>
    Official HyperEVM smart contract documentation
  </Card>

  <Card title="Smart Wallets Documentation" icon="wallet" href="https://docs.privy.io/wallets/using-wallets/evm-smart-wallets/overview" arrow>
    Learn more about using smart wallets, including how to send transactions, batch operations, and
    configure advanced features.
  </Card>
</CardGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="Building on Hyperliquid with Privy" icon="rocket" href="/recipes/hyperliquid-guide">
    Return to the getting started guide
  </Card>

  <Card title="Executing trades" icon="chart-line" href="/recipes/hyperliquid/trading-patterns">
    Learn common trading patterns
  </Card>
</CardGroup>


# Policies
Source: https://docs.privy.io/recipes/hyperliquid/policies-and-offline-actions



Learn how to implement secure trading policies using Privy's signers and policies to control Hyperliquid operations with multi-signature authorization.

## Overview

Privy's [signers](/wallets/using-wallets/session-signers/overview) enable you to add additional signers to wallets, allowing you to. Combined with [policies](/controls/policies/overview), you can define granular controls over which Hyperliquid actions are allowed or denied.

## High-Level Steps

1. **Create policies** - Define which Hyperliquid actions are allowed or denied for your authorization keys
2. **Create authorization keys** - Generate signers that will be used to sign transactions on behalf of wallets
3. **Update wallet** - Attach the authorization key as a signer with your policies applied

Once configured, your authorization keys can execute Hyperliquid operations within the boundaries defined by your policies.

## How It Works

Policies enforce security controls on wallet operations by evaluating each transaction against a set of conditions. When a transaction is attempted with an authorization key:

1. The transaction is analyzed against all policies attached to that signer
2. If any DENY policy matches, the transaction is rejected
3. If an ALLOW policy matches and no DENY policies match, the transaction proceeds
4. Operations that don't match any policies follow the default behavior

## User Signed Actions vs L1 Actions

Hyperliquid operations are divided into two categories:

### User Signed Actions

These are sensitive operations that require the master account's signature. Policies can be applied to control any User Signed Action, including:

* **Withdrawals** - Transferring funds out of Hyperliquid to external addresses
* **Approving Agents** - Registering or managing agent wallets
* **Account Transfers** - Moving funds between master account and subaccounts using `sendAsset`
* **Approving Builder Fees** - Authorizing builder code fee arrangements

These actions require explicit authorization and are ideal candidates for policy controls to protect user funds and account security.

### L1 Actions

Other operations are L1 Actions that can be performed by any registered agent wallet without requiring master account approval. These include:

* Placing orders
* Canceling orders
* Modifying orders
* Setting leverage
* Other trading operations

This separation allows you to enable automated trading through agent wallets while maintaining strict control over sensitive account operations.

## Prerequisites

Before implementing policies for Hyperliquid operations, you'll need to set up signers and create policies:

<CardGroup cols={2}>
  <Card title="Signers" icon="key" href="/wallets/using-wallets/session-signers/overview">
    Learn how to create additional signers for your wallets
  </Card>

  <Card title="Policies" icon="shield-check" href="/controls/policies/overview">
    Learn how to define and create policies for wallet operations
  </Card>
</CardGroup>

## Creating Policies

Policies determine which Hyperliquid operations are allowed or denied. Here are common policy examples for controlling User Signed Actions:

### DENY Withdrawal Attempts

Only the master account for a Hyperliquid account can initiate withdrawal attempts. You can setup policies to DENY the additional signer on the master account from being able to withdraw funds without user consent.

This is critical for protecting user funds - even if an authorization key is compromised, withdrawals cannot be executed without explicit user approval.

```json  theme={"system"}
{
  "name": "DENY Withdrawal from account",
  "method": "eth_signTypedData_v4",
  "action": "DENY",
  "conditions": [
    {
      "field_source": "ethereum_typed_data_message",
      "field": "hyperliquidChain",
      "typed_data": {
        "types": {
          "EIP712Domain": [
            {
              "name": "name",
              "type": "string"
            },
            {
              "name": "version",
              "type": "string"
            },
            {
              "name": "chainId",
              "type": "uint256"
            },
            {
              "name": "verifyingContract",
              "type": "address"
            }
          ],
          "HyperliquidTransaction:Withdraw": [
            {
              "name": "hyperliquidChain",
              "type": "string"
            },
            {
              "name": "destination",
              "type": "string"
            },
            {
              "name": "amount",
              "type": "string"
            },
            {
              "name": "time",
              "type": "uint64"
            }
          ]
        },
        "primary_type": "HyperliquidTransaction:Withdraw"
      },
      "operator": "in",
      "value": ["Testnet", "Mainnet"]
    }
  ]
}
```

### DENY Account Transfers

The master account can transfer funds between subaccounts using the `sendAsset` action. You can setup policies to DENY the additional signer on the master account from transferring funds between subaccounts without user authorization.

This ensures that subaccount balances remain isolated and protected - an important security measure when managing multiple trading strategies or client accounts.

```json  theme={"system"}
{
  "name": "DENY Account Transfers",
  "method": "eth_signTypedData_v4",
  "action": "DENY",
  "conditions": [
    {
      "field_source": "ethereum_typed_data_message",
      "field": "hyperliquidChain",
      "typed_data": {
        "types": {
          "EIP712Domain": [
            {
              "name": "name",
              "type": "string"
            },
            {
              "name": "version",
              "type": "string"
            },
            {
              "name": "chainId",
              "type": "uint256"
            },
            {
              "name": "verifyingContract",
              "type": "address"
            }
          ],
          "HyperliquidTransaction:SendAsset": [
            {
              "name": "hyperliquidChain",
              "type": "string"
            },
            {
              "name": "destination",
              "type": "string"
            },
            {
              "name": "sourceDex",
              "type": "string"
            },
            {
              "name": "destinationDex",
              "type": "string"
            },
            {
              "name": "token",
              "type": "string"
            },
            {
              "name": "amount",
              "type": "string"
            },
            {
              "name": "fromSubAccount",
              "type": "string"
            },
            {
              "name": "nonce",
              "type": "uint64"
            }
          ]
        },
        "primary_type": "HyperliquidTransaction:SendAsset"
      },
      "operator": "in",
      "value": ["Testnet", "Mainnet"]
    }
  ]
}
```

### ALLOW Approve Agent

Permit the master account to register new agent wallets. This allows the additional signer to approve agent registrations on behalf of the user.

By explicitly allowing agent approval, you can enable operational flexibility while still denying other sensitive operations like withdrawals and account transfers.

```json  theme={"system"}
{
  "name": "ALLOW Approve Agent",
  "method": "eth_signTypedData_v4",
  "action": "ALLOW",
  "conditions": [
    {
      "field_source": "ethereum_typed_data_message",
      "field": "hyperliquidChain",
      "typed_data": {
        "types": {
          "EIP712Domain": [
            {
              "name": "name",
              "type": "string"
            },
            {
              "name": "version",
              "type": "string"
            },
            {
              "name": "chainId",
              "type": "uint256"
            },
            {
              "name": "verifyingContract",
              "type": "address"
            }
          ],
          "HyperliquidTransaction:ApproveAgent": [
            {
              "name": "hyperliquidChain",
              "type": "string"
            },
            {
              "name": "agentAddress",
              "type": "string"
            },
            {
              "name": "agentName",
              "type": "string"
            },
            {
              "name": "nonce",
              "type": "uint64"
            }
          ]
        },
        "primary_type": "HyperliquidTransaction:ApproveAgent"
      },
      "operator": "in",
      "value": ["Testnet", "Mainnet"]
    }
  ]
}
```

## Creating Authorization Keys

Authorization keys are signers that allow you to execute actions on wallets within the constraints defined by your policies. These keys can be controlled by your server, stored securely, and used to sign transactions on behalf of wallets.

To create an authorization key, you can use either the Privy Dashboard or the REST API. The process generates a keypair where:

* The **private key** is generated on your device and only known to you (Privy never sees it)
* The **public key** is registered with Privy's secure enclave to verify signatures

<Note>
  Save your authorization private key securely - Privy does not store it and cannot help you recover
  it later. You'll need this key to sign transactions with your policies applied.
</Note>

For detailed instructions on creating authorization keys, see the [Authorization Keys documentation](https://docs.privy.io/controls/authorization-keys/keys/create/key).

## Applying Policies to Wallets

Once you've created policies, you can apply them to wallets by adding additional signers with policy overrides:

```javascript  theme={"system"}
// Update a wallet to add additional signers with specific policies
const wallet = await privy.wallets().update('WALLET_ID', {
  policy_ids: [], // Global policies (empty in this case)
  additional_signers: [
    {
      signer_id: 'SIGNER_ID', // Authorization key ID
      override_policy_ids: ['POLICY_ID'] // Policies for this signer
    }
  ]
});
```

Once you've applied policies to a wallet, you can use the authorization private key to sign transactions on behalf of the wallet:

```javascript  theme={"system"}
import { createViemAccount } from '@privy-io/node/viem';

// Create a viem account with authorization context
const account = createViemAccount(privy, {
  walletId: wallet.id,
  address: wallet.address as `0x${string}`,
  authorizationContext: {
    authorization_private_keys: [
      "AUTHORIZATION_PRIVATE_KEY"
    ]
  }
});

// Use the account with Hyperliquid
const client = new hl.ExchangeClient({
  transport,
  wallet: account,
});
```

<Note>
  The authorization private key (`wallet-auth:...`) allows the additional signer to sign
  transactions. Any operations attempted will be evaluated against the policies you've defined. If a
  policy denies an action (like withdrawal), the transaction will fail before execution.
</Note>

## Best Practices

<AccordionGroup>
  <Accordion title="Use separate keys for different functions">
    Create dedicated authorization keys for trading operations vs. administrative functions.
  </Accordion>

  <Accordion title="Start with restrictive policies">
    Begin with strict policies and gradually relax them as needed, rather than starting permissive.
  </Accordion>

  <Accordion title="Test policies in testnet">
    Always validate your policy configuration on Hyperliquid testnet before deploying to production.
  </Accordion>

  <Accordion title="Regular policy reviews">
    Periodically review and update policies to match current risk management needs.
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={3}>
  <Card title="Agent wallets" icon="users" href="/recipes/hyperliquid/agents-and-subaccounts">
    Learn about managing multiple accounts
  </Card>

  <Card title="Builder Codes" icon="dollar-sign" href="/recipes/hyperliquid/builder-codes">
    Earn fees with builder codes on Hyperliquid orders
  </Card>

  <Card title="HyperEVM" icon="code" href="/recipes/hyperliquid/hyperevm">
    Develop smart contracts on HyperEVM
  </Card>
</CardGroup>


# Subaccounts
Source: https://docs.privy.io/recipes/hyperliquid/subaccounts



Learn how to use Hyperliquid subaccounts to isolate balances, positions, and PnL per strategy or user while maintaining consolidated fee tiers. {/* spellchecker:disable-line */}

<Note>
  Before continuing with this guide, make sure you have initialized your Hyperliquid client as shown
  in the [Getting Started guide](/recipes/hyperliquid-guide). This guide assumes you have `client`
  and other basic setup completed.
</Note>

## Overview

[Subaccounts](https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#subaccounts-and-vaults) let you isolate balances, positions, and PnL per strategy or user while still rolling up trading volume to the master account for fee tier benefits. You can create up to 10 subaccounts per master account. {/* spellchecker:disable-line */}

**Key Benefits:**

* **Risk Isolation**: Separate balances and positions for different strategies
* **Consolidated Fees**: All trading volume rolls up to the master account
* **Organization**: Manage multiple strategies or users under one master account
* **Flexibility**: Each subaccount can have its own risk parameters

<Warning>
  Subaccounts are only available for master accounts with at least **\$100,000** in total trading
  volume.
</Warning>

## Creating a Subaccount

```javascript  theme={"system"}
// Create a new subaccount
await masterClient.createSubAccount({
  name: "Strategy Alpha",
});

// List all subaccounts
const subAccounts = await infoClient.subAccounts({
  user: masterWallet.address as `0x${string}`,
});

console.log("Subaccounts:", subAccounts);
```

## Trading with a Subaccount

To execute trades for a specific subaccount, create a client with the `defaultVaultAddress` parameter:

```javascript  theme={"system"}
// Get the first subaccount
const subAccount = subAccounts[0];

// Create a client for the subaccount
const subAccountClient = new hl.ExchangeClient({
  transport,
  wallet: masterAccount, // Use the master account signer
  defaultVaultAddress: subAccount.subAccountUser
});

// Place an order using the subaccount
const subAccountOrder = await subAccountClient.order({
  orders: [
    {
      a: 0, // BTC
      b: true, // Buy
      s: '0.01', // Size
      r: false,
      p: '50000',
      t: {limit: {tif: 'Gtc'}}
    }
  ],
  grouping: 'na'
});
```

## Transferring Funds Between Accounts

Transfer funds between the master account and subaccounts using the `sendAsset` method:

```javascript  theme={"system"}
// Transfer from master to subaccount
await masterClient.sendAsset({
  destination: subAccount.subAccountUser,
  sourceDex: "",
  token: "USDC",
  amount: "1000",
  fromSubAccount: "",        // Empty string = from master account
  destinationDex: ""
});

// Transfer from subaccount back to master
await masterClient.sendAsset({
  destination: masterWallet.address as `0x${string}`,
  sourceDex: "",
  token: "USDC",
  amount: "500",
  fromSubAccount: subAccount.subAccountUser,  // Specify source subaccount
  destinationDex: ""
});
```

<Note>
  The `fromSubAccount` parameter determines the source: an empty string `""` transfers from the
  master account, while specifying a subaccount address transfers from that subaccount.
</Note>

## Combining Agents and Subaccounts

You can use agent wallets to trade on behalf of subaccounts, creating a flexible multi-account trading architecture:

```javascript  theme={"system"}
// Agent wallet can trade for any subaccount of the master
const agentForSubAccountClient = new hl.ExchangeClient({
  transport,
  wallet: agentAccount, // Agent wallet
  defaultVaultAddress: subAccount.subAccountUser // Subaccount
});

// Place order using agent for the subaccount
await agentForSubAccountClient.order({
  orders: [
    {
      a: 0,
      b: true,
      s: '0.01',
      r: false,
      p: '50000',
      t: {limit: {tif: 'Gtc'}}
    }
  ],
  grouping: 'na'
});
```

<Tip>
  This pattern is ideal for managing multiple strategies or user accounts - each subaccount gets
  isolated risk, while a single agent wallet can manage trading operations across all of them.
</Tip>

## Best Practices

<AccordionGroup>
  <Accordion title="Use subaccounts for risk isolation">
    Create separate subaccounts for different risk profiles. For example, maintain one subaccount
    for conservative strategies with tight stop losses, and another for high-risk, high-reward
    strategies.
  </Accordion>

  <Accordion title="Monitor subaccount balances">
    Regularly check subaccount balances and positions to ensure proper risk allocation across your
    strategies.
  </Accordion>

  <Accordion title="Consolidate for fee benefits">
    Remember that all subaccount trading volume rolls up to the master account, so you maintain your
    fee tier benefits across all strategies.
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="Agent wallets" icon="key" href="/recipes/hyperliquid/agents-and-subaccounts">
    Learn about agent wallets for programmatic trading
  </Card>

  <Card title="Executing trades" icon="chart-line" href="/recipes/hyperliquid/trading-patterns">
    Explore common trading patterns and order types
  </Card>
</CardGroup>


# Executing trades
Source: https://docs.privy.io/recipes/hyperliquid/trading-patterns



Learn common trading patterns and best practices for placing orders, managing positions, and executing strategies on Hyperliquid with Privy.

<Note>
  Before continuing with this guide, make sure you have initialized your Hyperliquid client as shown
  in the [Getting Started guide](/recipes/hyperliquid-guide). This guide assumes you have `client`
  and other basic setup completed.
</Note>

## Overview

This guide covers essential trading patterns and techniques for building robust trading applications on Hyperliquid using Privy's secure wallet infrastructure.

## Getting Market Data

Before placing trades, you'll need to fetch asset metadata and current market conditions:

```javascript  theme={"system"}
import * as hl from '@nktkas/hyperliquid';

const transport = new hl.HttpTransport({
  isTestnet: true
});

const infoClient = new hl.InfoClient({transport});

// Get all available assets and their current context
const [meta, contexts] = await infoClient.metaAndAssetCtxs();

// Find a specific asset (e.g., BTC)
const btcIndex = meta.universe.findIndex((asset) => asset.name === 'BTC');
const btcMeta = meta.universe[btcIndex];
const btcContext = contexts[btcIndex];

console.log('BTC Mark Price:', btcContext.markPx);
console.log('BTC Funding Rate:', btcContext.funding);
```

## Understanding Tick Size and Lot Size

Before placing orders, it's critical to understand how Hyperliquid formats prices and sizes. Using incorrect precision will cause your orders to be rejected.

**Price Precision (Tick Size):**

Prices can have up to **5 significant figures**, but no more than `MAX_DECIMALS - szDecimals` decimal places:

* **Perpetuals**: `MAX_DECIMALS = 6`
* **Spot**: `MAX_DECIMALS = 8`

Integer prices are always allowed, regardless of significant figures.

**Examples for Perps:**

* ✅ `1234.5` is valid
* ❌ `1234.56` is not valid (too many significant figures)
* ✅ `0.001234` is valid
* ❌ `0.0012345` is not valid (more than 6 decimal places)

**If `szDecimals = 1`:**

* ✅ `0.01234` is valid
* ❌ `0.012345` is not valid (more than `6 - 1 = 5` decimal places)

**Size Precision (Lot Size):**

Sizes are rounded to the `szDecimals` of that asset. For example:

* If `szDecimals = 3`, then `1.001` is valid but `1.0001` is not
* If `szDecimals = 2`, then `10.25` is valid but `10.251` is not

You can find `szDecimals` for each asset in the meta response:

```javascript  theme={"system"}
const [meta, contexts] = await infoClient.metaAndAssetCtxs();
const btcMeta = meta.universe[0]; // Assuming BTC is first

console.log('BTC szDecimals:', btcMeta.szDecimals);
```

<Note>
  **Important**: When implementing signing, trailing zeroes should be removed from prices and sizes.
  See the [Hyperliquid tick and lot size
  documentation](https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/tick-and-lot-size)
  for more details.
</Note>

## Order Types

### Market Orders

Hyperliquid doesn't have traditional market orders, but you can achieve market-like execution by placing a limit order with `tif: "Ioc"` (Immediate-Or-Cancel) and a price that guarantees immediate execution:

* **For buys**: Set limit price ≥ current best ask
* **For sells**: Set limit price ≤ current best bid

```javascript  theme={"system"}
// Get current market price
const [meta, contexts] = await infoClient.metaAndAssetCtxs();
const btcContext = contexts[0]; // BTC
const currentPrice = parseFloat(btcContext.markPx);

// Market buy: use a price above current market to ensure execution
await client.order({
  orders: [
    {
      a: 0, // BTC
      b: true, // Buy
      p: String(currentPrice * 1.01), // 1% above mark price
      s: '0.01', // Size
      r: false,
      t: {limit: {tif: 'Ioc'}} // Immediate-or-cancel
    }
  ],
  grouping: 'na'
});

// Market sell: use a price below current market to ensure execution
await client.order({
  orders: [
    {
      a: 0, // BTC
      b: false, // Sell
      p: String(currentPrice * 0.99), // 1% below mark price
      s: '0.01',
      r: false,
      t: {limit: {tif: 'Ioc'}}
    }
  ],
  grouping: 'na'
});
```

<Warning>
  Market orders execute at the best available price, which may differ significantly from the mark
  price in volatile or illiquid markets. Always validate that the execution price is acceptable
  before placing large orders.
</Warning>

### Limit Orders

Place an order at a specific price. Limit orders let you control the exact price at which you're willing to buy or sell.

```javascript  theme={"system"}
// Place a limit buy order for BTC at $95,000
await client.order({
  orders: [
    {
      a: 0, // Asset index (0 = BTC from meta.universe)
      b: true, // Buy side (true = buy, false = sell)
      p: '95000', // Limit price in USD
      s: '0.01', // Size (0.01 BTC)
      r: false, // Reduce-only (false = can open new position)
      t: {limit: {tif: 'Gtc'}} // Time in force
    }
  ],
  grouping: 'na'
});
```

**Order Parameters:**

* **`a` (asset)**: The asset index from `meta.universe`. For example, `0` is typically BTC.
* **`b` (buy/sell)**: `true` for buy orders, `false` for sell orders.
* **`p` (price)**: Limit price as a string. Must follow tick size rules (see above).
* **`s` (size)**: Order size as a string. Must follow lot size rules based on `szDecimals`.
* **`r` (reduce-only)**: If `true`, order can only reduce existing position, not open new positions.
* **`t` (order type)**: Object specifying order type and parameters.
* **`grouping`**: Order grouping strategy, typically `"na"` for standard orders.

**Time In Force (TIF) Options:**

The `tif` parameter in limit orders controls how long the order remains active:

<AccordionGroup>
  <Accordion title="Gtc (Good-'Til-Canceled)" icon="infinity">
    Fills what it can immediately; any remainder stays on the order book until filled or manually canceled. This is the most common option for limit orders.

    ```javascript  theme={"system"}
    t: { limit: { tif: "Gtc" } }
    ```
  </Accordion>

  <Accordion title="Ioc (Immediate-Or-Cancel)" icon="clock">
    Fills immediately up to your limit price; any unfilled remainder is automatically canceled. The order never rests on the book. Useful for ensuring immediate execution without leaving open orders.

    ```javascript  theme={"system"}
    t: { limit: { tif: "Ioc" } }
    ```
  </Accordion>

  <Accordion title="Alo (Add-Liquidity-Only / Post-Only)" icon="layer-plus">
    Must add liquidity to the order book. If the order would cross the spread and immediately match (take liquidity), it's rejected/canceled instead. This guarantees you receive maker fees rather than paying taker fees.

    ```javascript  theme={"system"}
    t: { limit: { tif: "Alo" } }
    ```
  </Accordion>
</AccordionGroup>

### Stop Loss and Take Profit Orders

You can create linked TP/SL (Take Profit/Stop Loss) orders that trigger when price reaches specific levels. Use `grouping: "normalTpsl"` to link the entry order with its stop-loss and take-profit exit orders.

```javascript  theme={"system"}
// Create an entry order with linked TP/SL
const tpsl = await client.order({
  grouping: 'normalTpsl', // Links the three orders as a TP/SL set
  orders: [
    // (A) Entry order - limit GTC at $100,000
    {
      a: 0, // Asset index (BTC)
      b: true, // Buy
      s: '0.0036', // Size (respect szDecimals for BTC)
      p: '100000', // Limit price
      r: false, // Not reduce-only
      t: {limit: {tif: 'Gtc'}}
    },
    // (B) Stop-loss - triggers at $95,000, executes as limit at $94,000
    {
      a: 0,
      b: false, // Sell to close
      s: '0.0036', // Must match entry size
      p: '94000', // Limit price once triggered (allows slippage)
      r: true, // Reduce-only
      t: {
        trigger: {
          isMarket: true,
          tpsl: 'sl', // Stop-loss type
          triggerPx: '95000' // Trigger price (when order activates)
        }
      }
    },
    // (C) Take-profit - triggers at $105,000, executes as limit at $101,200
    {
      a: 0,
      b: false, // Sell to close
      s: '0.0036', // Must match entry size
      p: '101200', // Limit price once triggered
      r: true, // Reduce-only
      t: {
        trigger: {
          isMarket: true,
          tpsl: 'tp', // Take-profit type
          triggerPx: '105000' // Trigger price (when order activates)
        }
      }
    }
  ]
});
```

**Understanding Trigger vs Limit Prices:**

The `triggerPx` and `p` (limit price) serve different purposes in TP/SL orders:

* **`triggerPx`**: The price level that activates the order
* **`p` (limit price)**: The worst price you're willing to accept once triggered

For stop-loss orders, set the limit price (`p`) **below** the trigger to allow for slippage during fast price movements. In the example above, the stop-loss triggers at \$95,000 but will execute at \$94,000 or better.

For take-profit orders, you can set a more conservative limit price to ensure execution. The take-profit triggers at \$105,000 but will accept \$101,200 or better.

This approach ensures your orders execute even in volatile conditions while still providing some price protection.

<Note>
  When one of the TP/SL orders executes (either stop-loss or take-profit), the other is
  automatically canceled. The `r: true` (reduce-only) flag ensures these orders can only close
  positions, not open new ones.
</Note>

### TWAP Orders

TWAP (Time-Weighted Average Price) orders split large orders into smaller chunks executed over time to minimize market impact and reduce slippage.

```javascript  theme={"system"}
// Execute a TWAP buy order over 30 minutes
const twap = await client.twapOrder({
  twap: {
    a: 3, // Asset index
    b: true, // Buy side (true = buy, false = sell)
    s: '0.01252', // Total size to execute (respects szDecimals)
    r: false, // Reduce-only
    m: 30, // Duration in minutes
    t: false // Randomize timing between chunks (false = evenly spaced)
  }
});
```

**TWAP Parameters:**

* **`a` (asset)**: The asset index from `meta.universe`
* **`b` (buy/sell)**: `true` for buy orders, `false` for sell orders
* **`s` (size)**: Total size to execute across all chunks
* **`r` (reduce-only)**: If `true`, order can only reduce existing positions
* **`m` (minutes)**: Duration over which to execute the order (e.g., 30 = 30 minutes)
* **`t` (randomize)**: If `true`, randomizes timing between chunks to make execution less predictable; if `false`, chunks are evenly spaced

<Note>
  TWAP orders are ideal for executing large orders without significantly moving the market. The
  order is automatically split into smaller chunks and executed at regular (or randomized) intervals
  over the specified duration.
</Note>

## Risk Management

Hyperliquid supports two margin modes: **cross margin** and **isolated margin**.

* **Cross Margin**: Uses your total perps balance as collateral across all positions. If one position loses money, other positions can help cover the loss.
* **Isolated Margin**: Margin is isolated to each individual position. If a position is liquidated, it won't affect your other positions.

```javascript  theme={"system"}
// Update leverage for an asset
const updateLeverage = await client.updateLeverage({
  asset: 0,           // Asset index (BTC)
  isCross: true,      // true = cross margin, false = isolated margin
  leverage: 12        // Leverage multiplier (e.g., 12x)
});

console.log("Leverage updated:", updateLeverage);

// Check active asset data to verify leverage settings
const assetData = await infoClient.activeAssetData({
  user: wallet.address as `0x${string}`,
  coin: "BTC",      // Asset name (e.g., "BTC", "ETH", "SOL")
});

console.log("Current leverage:", assetData.leverage);
console.log("Margin mode:", assetData.marginMode);
```

<Warning>
  Higher leverage amplifies both gains and losses. Always understand your liquidation price before
  increasing leverage. Cross margin provides more flexibility but risks your entire account balance.
</Warning>

## Monitoring and Analytics

Get comprehensive information about your account balance, open positions, and risk metrics:

```javascript  theme={"system"}
const transport = new hl.HttpTransport();
const infoClient = new hl.InfoClient({ transport });

// Get user clearinghouse state (positions, balance, margin)
const clearinghouseState = await infoClient.clearinghouseState({
  user: wallet.address as `0x${string}`,
});

console.log("Account balance:", clearinghouseState.marginSummary.accountValue);
console.log("Total position value:", clearinghouseState.marginSummary.totalNtlPos);
console.log("Unrealized PnL:", clearinghouseState.marginSummary.totalRawUsd);
console.log("Open positions:", clearinghouseState.assetPositions);
```

**Checking Open Orders:**

View all your active orders across all assets:

```javascript  theme={"system"}
// Get all open orders for the user
const openOrders = await infoClient.openOrders({
  user: wallet.address as `0x${string}`,
});

console.log("Open orders:", openOrders);
```

## Best Practices

<AccordionGroup>
  <Accordion title="Always validate prices">
    Before placing orders, verify that prices are within expected ranges to avoid fat-finger errors.
  </Accordion>

  <Accordion title="Use reduce-only orders for exits">
    When closing positions, use reduce-only orders to prevent accidentally opening new positions.
  </Accordion>

  <Accordion title="Monitor funding rates">
    Keep track of funding rates, especially for large positions, as they can significantly impact
    profitability.
  </Accordion>

  <Accordion title="Implement circuit breakers">
    Add safeguards to stop trading if certain thresholds are hit (e.g., max daily loss, max position
    size).
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="Agent wallets" icon="key" href="/recipes/hyperliquid/agents-and-subaccounts">
    Learn about agent wallets for programmatic trading
  </Card>

  <Card title="Policies" icon="shield-check" href="/recipes/hyperliquid/policies-and-offline-actions">
    Implement advanced security policies
  </Card>
</CardGroup>


# Login with Lens
Source: https://docs.privy.io/recipes/lens



[Lens Protocol](https://www.lens.xyz/) is an open social network that allows users to own their content and connections. Developers can build on the network, leveraging its audience and infrastructure. Users can seamlessly switch between social apps without losing their profiles, content, or connections.

Allowing users to log into Lens with Privy is fully supported and simple to integrate.

In this recipe, you'll integrate Privy + wagmi with the Lens React SDK, then let users log in with their Lens account using an embedded or external wallet.

## Resources

<CardGroup cols={2}>
  <Card title="Lens Docs" icon="arrow-up-right-from-square" href="https://lens.xyz/docs/protocol/getting-started/react" arrow>
    Official documentation for Lens protocol and SDK.
  </Card>

  <Card title="Privy Wagmi integration" icon="wallet" href="/wallets/connectors/ethereum/integrations/wagmi" arrow>
    Configure Privy with wagmi for EVM integrations.
  </Card>
</CardGroup>

***

## Integrate Lens login

<Steps>
  <Step title="1. Install dependencies">
    ```bash  theme={"system"}
    pnpm add @privy-io/react-auth @lens-protocol/react@canary @privy-io/wagmi @tanstack/react-query wagmi viem
    ```

    <Tip>We use <code>@lens-protocol/react\@canary</code> to access the latest Lens features.</Tip>
  </Step>

  <Step title="2. Set up providers">
    This step assumes you have set up your project with Privy and integrated with wagmi. If not, follow the [Privy wagmi guide](https://docs.privy.io/wallets/connectors/ethereum/integrations/wagmi#complete-example).
    Once your Privy setup is complete, initialize the Lens provider and client.

    Lens Protocol runs on the Lens chain (mainnet and testnet). Ensure your wagmi and Privy configs include the Lens chains.

    Wrap your app with <code>LensProvider</code> to use the Lens SDK across your app.

    <Tabs>
      <Tab title="providers.tsx">
        ```tsx {skip-check} theme={"system"}
        import {QueryClient, QueryClientProvider} from '@tanstack/react-query';
        import {LensProvider, PublicClient, mainnet} from '@lens-protocol/react'; // [!code ++]

        const queryClient = new QueryClient();

        // [!code ++:4]
        const lensClient = PublicClient.create({
          environment: mainnet,
          storage: window.localStorage
        });

        return (
          <PrivyProvider appId="your-privy-app-id" config={privyConfig}>
            <QueryClientProvider client={queryClient}>
              <WagmiProvider config={wagmiConfig}>
                <LensProvider client={lensClient}>{children}</LensProvider> {/* [!code ++] */}
              </WagmiProvider>
            </QueryClientProvider>
          </PrivyProvider>
        );
        ```
      </Tab>

      <Tab title="privy-config.ts">
        ```ts {skip-check} theme={"system"}
        import {lens, lensTestnet} from 'viem/chains';

        export const privyConfig = {
          supportedChains: [lens, lensTestnet]
        };
        ```
      </Tab>

      <Tab title="wagmi-config.ts">
        ```ts {skip-check} theme={"system"}
        import {createConfig} from '@privy-io/wagmi';
        import {http} from 'wagmi';
        import {lens, lensTestnet} from 'viem/chains';

        export const wagmiConfig = createConfig({
          chains: [lens, lensTestnet],
          transports: {
            [lens.id]: http(),
            [lensTestnet.id]: http()
          }
        });
        ```
      </Tab>
    </Tabs>

    You’ve successfully set up the Lens SDK. Your app is now ready to use features like logging in with Lens and posting directly on Lens.
  </Step>

  <Step title="3. Connect a wallet with Privy">
    Use `login` to prompt the user to connect a wallet. With Privy, you can automatically create wallets for users who don’t have one (for example, when signing in with Google or another social method). With this new wallet, you can onboard the user to your Lens‑powered app and keep the onboarding experience seamless.

    <Tip>
      You can customize whether to automatically create an embedded wallet for the user. See the
      <a href="/basics/react/advanced/automatic-wallet-creation">automatic wallet creation guide</a>.
    </Tip>

    ```tsx  theme={"system"}
    import {usePrivy} from '@privy-io/react-auth';

    const {login} = usePrivy();

    <button onClick={login}>Login</button>;
    ```
  </Step>

  <Step title="4. Fetch accounts for the connected wallet">
    First, fetch all the Lens accounts associated with the connected user wallet.

    ```ts {skip-check} theme={"system"}
    import {useAccountsAvailable} from '@lens-protocol/react';
    import {useAccount} from 'wagmi';

    const {address} = useAccount();
    const {data: lensAccounts} = useAccountsAvailable({
      managedBy: address
    });
    ```

    <Accordion title="Switching wallets (if the user has more than one wallet)">
      If a user has multiple wallets connected, set the active wallet to ensure you log in with the
      correct Lens account.

      ```ts  theme={"system"}
      import {useWallets} from '@privy-io/react-auth';
      import {useSetActiveWallet} from '@privy-io/wagmi';

      const {wallets} = useWallets();
      const {setActiveWallet} = useSetActiveWallet();
      await setActiveWallet(wallets[0]);
      ```
    </Accordion>
  </Step>

  <Step title="5. Implement login with Lens">
    Create a hook that handles the Lens login process for the selected account.

    ```ts {skip-check} theme={"system"}
    import {AccountAvailable, EvmAddress, useLogin} from '@lens-protocol/react';
    import {signMessageWith} from '@lens-protocol/react/viem';
    import {useAccount, useWalletClient} from 'wagmi';

    export function useLensLogin() {
      const {address} = useAccount();
      const {data: signer} = useWalletClient();
      const {execute: login} = useLogin();

      return (item: AccountAvailable) => {
        if (!signer) return;
        const ownerOrManager = signer.account?.address ?? (address as EvmAddress | undefined);
        if (!ownerOrManager) return;

        const payload =
          item.__typename === 'AccountManaged'
            ? {
                accountManager: {
                  account: item.account.address as EvmAddress,
                  manager: ownerOrManager as EvmAddress
                }
              }
            : {
                accountOwner: {
                  account: item.account.address as EvmAddress,
                  owner: ownerOrManager as EvmAddress
                }
              };

        return login({
          ...payload,
          signMessage: signMessageWith(signer)
        });
      };
    }
    ```
  </Step>

  <Step title="6. Render accounts and trigger login">
    Show the fetched accounts and let users pick one to log in.

    ```tsx {skip-check} theme={"system"}
    import {useAccountsAvailable} from '@lens-protocol/react';
    import {useAccount} from 'wagmi';
    import {useLensLogin} from './use-lens-login';

    export function LensAccountsList() {
      const {address} = useAccount();
      const {data: lensAccounts} = useAccountsAvailable({managedBy: address});
      const loginWithLensAccount = useLensLogin();

      if (!lensAccounts || lensAccounts.items.length === 0) {
        return <p>No Lens accounts found for {address}.</p>;
      }

      return (
        <div>
          {lensAccounts.items.map((item) => (
            <div key={item.account.address}>
              <button onClick={() => loginWithLensAccount(item)}>
                Login with {item.account.username?.value ?? item.account.address}
              </button>
            </div>
          ))}
        </div>
      );
    }
    ```
  </Step>

  <Step title="7. Check authentication status">
    Use `useAuthenticatedUser` to check whether the user is authenticated with a Lens account.

    ```ts {skip-check} theme={"system"}
    import {useAuthenticatedUser} from '@lens-protocol/react';

    const {data: isAuthenticated} = useAuthenticatedUser();
    ```
  </Step>
</Steps>

***

## Next steps

Explore the full [Lens SDK documentation](https://lens.xyz/docs/protocol/getting-started/react).

* Create posts and publications
* React to publications
* Manage profiles and metadata

For wagmi setup with Privy, see [Integrating with wagmi](https://docs.privy.io/wallets/connectors/ethereum/integrations/wagmi).


# Mocking tokens for testing
Source: https://docs.privy.io/recipes/mock-jwt



If your project uses automated testing (e.g. with [Jest](https://jestjs.io/docs/configuration)), your test setup may need access to a Privy token in order to mock out an authenticated session, authorized API calls, and more.

To obtain a Privy token for tests, we **do not recommend** using an actual auth token issued by Privy's production service. Rather, you should construct a test JWT in the [Privy format](/authentication/user-authentication/access-tokens) and then sign it with a key that you control.

### Overview

At a high-level, the instructions for creating and signing a JWT in the Privy format are:

1. **Generate your signing & verification keys for tests.** Privy uses an asymmetric [ECDSA P256](https://csrc.nist.gov/csrc/media/events/workshop-on-elliptic-curve-cryptography-standards/documents/papers/session6-adalier-mehmet.pdf) keypair, but you can choose any key setup you like.
2. **Construct a JWT with the Privy claims.** For tests, you can use any arbitrary Privy DID for the `sub` claim and any arbitrary session ID for the `sid` claim.
3. **Sign your JWT with your signing key.** Privy uses the [ES256 algorithm](https://ldapwiki.com/wiki/ES256) to sign & verify JWTs for your app, but you can choose any signing algorithm you like, as long as it is compatible with your key setup from Step 1.

Below is a reference implementation in JavaScript for generating keys, signing JWTs in the Privy format, and verifying those JWTs using the library [`jose`](https://www.npmjs.com/package/jose).

### Generating signing & verification keys for tests

Generate a keypair using `jose`'s [`generateKeyPair`](https://github.com/panva/jose/blob/HEAD/docs/functions/key_generate_key_pair.generateKeyPair.md#readme) method, specifying the 'ES256' algorithm as a parameter.

```typescript  theme={"system"}
import * as jose from 'jose';

const {publicKey, privateKey} = await jose.generateKeyPair('ES256');
```

You can now use the `privateKey` to sign JWTs and the `publicKey` to verify JWTs in your tests.

### Creating and signing test JWTs

First, define the values you will use to populate your test JWT's claims.

```typescript  theme={"system"}
const session = 'an arbitrary session ID';
const subject = 'an arbitrary Privy DID';
const issuer = 'privy.io';
const audience = 'your Privy app ID';
const expiration = '1h';
```

Next, create and sign your test JWT with your test [`privateKey`](/recipes/mock-jwt.md#generating-signing--verification-keys-for-tests) using `jose`'s [`SignJWT`](https://github.com/panva/jose/blob/9a918a88c5fded3b17bcf356dd58fafefb34a4d0/docs/classes/jwt_sign.SignJWT.md) class.

```typescript  theme={"system"}
import * as jose from 'jose';

const authToken = await new jose.SignJWT({sid: '$SESSION'})
  .setProtectedHeader({alg: 'ES256', typ: 'JWT'})
  .setIssuer('$ISSUER')
  .setIssuedAt()
  .setAudience('$AUDIENCE')
  .setSubject('$SUBJECT')
  .setExpirationTime('$EXPIRATION')
  .sign(new TextEncoder().encode('$PRIVATE_KEY')); // Replace with your CryptoKey
```

### Verifying test JWTs

Use `jose`'s [`jwtVerify`](https://github.com/panva/jose/blob/9a918a88c5fded3b17bcf356dd58fafefb34a4d0/docs/functions/jwt_verify.jwtVerify.md) method to verify your test JWT against your test [`publicKey`](/recipes/mock-jwt.mdx#generating-signing--verification-keys-for-tests)

```typescript  theme={"system"}
import * as jose from 'jose';

try {
  const payload = await jose.jwtVerify(
    '$AUTH_TOKEN',
    (await jose.generateKeyPair('ES256')).privateKey, // Replace with your CryptoKey
    {
      issuer: 'privy.io',
      audience: 'your Privy App ID'
    }
  );
  console.log(payload);
} catch (error) {
  console.log(`JWT failed to verify with error ${error}.`);
}
```


# Building on Morpho with Privy
Source: https://docs.privy.io/recipes/morpho-guide



Create a seamless yield-earning experience with Privy's embedded wallets and Morpho's vaults. This guide shows you how to build a Next.js app where users can approve, deposit, check balances, and withdraw USDC with yield—all without external wallets or complex onboarding.

## Resources

<CardGroup cols={3}>
  <Card title="Morpho Docs" icon="arrow-up-right-from-square" href="https://docs.morpho.org/" arrow>
    Official documentation for Morpho protocol and smart contracts.
  </Card>

  <Card title="Privy Wallets" icon="wallet" href="/wallets/overview" arrow>
    Privy Wallets are a powerful tool for helping users interact with DeFi.
  </Card>
</CardGroup>

***

## Getting started with Privy

If you have not set up Privy yet, start by following the Privy React [quickstart guide](/basics/react/quickstart) to integrate Privy's authentication and wallet functionality.

Optionally, after completing the React quickstart, integrate viem by following the [viem integration guide](/wallets/connectors/ethereum/integrations/viem).

***

## Using Morpho Vaults with Privy

Morpho vaults are smart contracts that let users earn yield by depositing assets into automated, yield-optimizing pools. Now we'll integrate Morpho vaults into the app.

### Configure and deposit into a Morpho vault

Morpho offers multiple vaults, each with different strategies and underlying assets. You can discover vaults on the [Morpho App](https://app.morpho.org/base/earn) or via the [Morpho API](https://api.morpho.org/graphql). For this example, we'll use the Steakhouse USDC Vault on Base:

<Steps>
  <Step title="1. Configure the vault">
    ```tsx  theme={"system"}
    const MORPHO_VAULT_ADDRESS = '0xbeeF010f9cb27031ad51e3333f9aF9C6B1228183';
    const USDC_ADDRESS = '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913';
    const BASE_CHAIN_ID = 8453;
    ```
  </Step>

  <Step title="2. Approve the vault to spend USDC">
    Use viem's `encodeFunctionData` to encode the approval, and Privy's `useSendTransaction` to send it:

    ```tsx  theme={"system"}
    import {encodeFunctionData, maxUint256, erc20Abi} from 'viem';
    import {useSendTransaction} from '@privy-io/react-auth';

    const {sendTransaction} = useSendTransaction();

    const data = encodeFunctionData({
      abi: erc20Abi,
      functionName: 'approve',
      args: [MORPHO_VAULT_ADDRESS as `0x${string}`, maxUint256]
    });

    const tx = await sendTransaction({
      to: USDC_ADDRESS as `0x${string}`,
      data,
      chainId: BASE_CHAIN_ID
    });
    ```
  </Step>

  <Step title="3. Deposit USDC into the Vault">
    Use viem to encode the deposit and Privy's `useSendTransaction` to fund the vault:

    ```tsx  theme={"system"}
    import {encodeFunctionData, parseUnits, parseAbi} from 'viem';
    import {useSendTransaction} from '@privy-io/react-auth';

    const {sendTransaction} = useSendTransaction();

    const vaultAbi = parseAbi([
      'function deposit(uint256 assets, address receiver) external returns (uint256 shares)'
    ]);
    const depositAmount = parseUnits('100', 6); // 100 USDC
    const data = encodeFunctionData({
      abi: vaultAbi,
      functionName: 'deposit',
      args: [depositAmount, address]
    });

    const tx = await sendTransaction({
      to: MORPHO_VAULT_ADDRESS as `0x${string}`,
      data,
      chainId: BASE_CHAIN_ID
    });
    ```
  </Step>
</Steps>

***

### Read the vault share balance

Query the vault's `balanceOf` function to determine how much the user can withdraw.

```tsx  theme={"system"}
import {publicClient} from './viem';
import {parseAbi} from 'viem';

const balanceAbi = parseAbi([
  'function balanceOf(address account) external view returns (uint256)'
]);

const userShares = await publicClient.readContract({
  address: MORPHO_VAULT_ADDRESS as `0x${string}`,
  abi: balanceAbi,
  functionName: 'balanceOf',
  args: [address]
});
```

***

### Withdraw from the Vault

Users have options to withdraw a specific amount of USDC or redeem all shares (full exit).

<Tabs>
  <Tab title="Withdraw a specific USDC amount">
    ```tsx  theme={"system"}
    import {encodeFunctionData, parseUnits, parseAbi} from 'viem';
    import {useSendTransaction} from '@privy-io/react-auth';

    const {sendTransaction} = useSendTransaction();

    const withdrawAbi = parseAbi([
      'function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares)'
    ]);
    const withdrawAmount = parseUnits('50', 6); // 50 USDC
    const data = encodeFunctionData({
      abi: withdrawAbi,
      functionName: 'withdraw',
      args: [withdrawAmount, address, address]
    });
    const tx = await sendTransaction({
      to: MORPHO_VAULT_ADDRESS as `0x${string}`,
      data,
      chainId: BASE_CHAIN_ID
    });
    ```
  </Tab>

  <Tab title="Redeem all shares (full exit)">
    ```tsx  theme={"system"}
    import {encodeFunctionData, parseAbi} from 'viem';
    import {useSendTransaction} from '@privy-io/react-auth';

    const {sendTransaction} = useSendTransaction();

    const redeemAbi = parseAbi([
      'function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets)'
    ]);
    const data = encodeFunctionData({
      abi: redeemAbi,
      functionName: 'redeem',
      args: [userShares, address, address]
    });
    const tx = await sendTransaction({
      to: MORPHO_VAULT_ADDRESS as `0x${string}`,
      data,
      chainId: BASE_CHAIN_ID
    });
    ```
  </Tab>
</Tabs>

***

### Get real-time vault data

You can fetch live vault information using Morpho's GraphQL API:

```tsx  theme={"system"}
const fetchVaultData = async () => {
  const query = `
    query {
      vaultByAddress(
        address: "${MORPHO_VAULT_ADDRESS}"
        chainId: ${BASE_CHAIN_ID}
      ) {
        state {
          sharePriceUsd
          apy
        }
        asset {
          priceUsd
        }
      }
    }
  `;
  const response = await fetch('https://api.morpho.org/graphql', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({query})
  });
  return response.json();
};
```

***

## Key integration tips

1. **Always approve first**: Users need ERC-20 approval before any deposit.
2. **Use `deposit()` and `redeem()`**: These cover most use cases effectively.
3. **Handle decimals correctly**: USDC uses 6 decimals, vault shares use 18.
4. **Check liquidity**: During high utilization, withdrawals may be limited.
5. **Monitor gas**: Complex vaults may require more gas for transactions.

***

## Conclusion

With Privy, setting up secure, user-friendly access to Morpho contracts is fast and easy. For advanced use cases, refer to the [Morpho Docs](https://docs.morpho.org/), or reach out to us in [Slack](https://privy.io/slack)

<Check>Your app is now ready to interact with Morpho using Privy embedded wallets!</Check>


# Off-ramping with Privy
Source: https://docs.privy.io/recipes/off-ramp-guide



Privy makes it easy to let your users off-ramp crypto assets to fiat by integrating with third-party providers. Whether you want to offer a seamless widget experience or implement a pure API solution, Privy's flexible integration options ensure your users can convert their crypto to cash with minimal friction.

These integrations create a seamless user experience, allowing your users to cash out their crypto assets without leaving your application ecosystem.

## Off-ramping with Privy

<Steps>
  <Step title="User has assets in their wallet">
    Assets are stored in the user's Privy wallet and can be off-ramped
  </Step>

  <Step title="Integration and setup">
    Add your chosen off-ramp provider's SDK to your application, configure it with your API keys,
    and allow users to trigger withdrawals via the provider's interface
  </Step>

  <Step title="User verification">
    User completes the provider's KYC process (only required once) and connects their bank account
    through the provider's secure interface
  </Step>

  <Step title="Transaction and payout">
    Privy handles signing and sending the transaction to the provider's address, then the provider
    processes the transaction and transfers funds to user's bank account
  </Step>
</Steps>

Privy makes it easy to off ramp assets with a number of third party providers. Select which provider you'd like to use and follow the instructions to integrate.

| Provider     | Off-Ramp Documentation                                                                               |
| ------------ | ---------------------------------------------------------------------------------------------------- |
| Coinflow     | [Coinflow off-ramp docs](https://docs.coinflow.cash/docs/how-withdraws-work)                         |
| MoonPay      | [MoonPay off-ramp docs](https://dev.moonpay.com/v1.0/docs/off-ramp-overview)                         |
| Ramp Network | [Ramp Network off-ramp docs](https://docs.ramp.network/off-ramp)                                     |
| Coinbase     | [Coinbase off-ramp docs](https://docs.cdp.coinbase.com/onramp/docs/api-offramp-overview)             |
| Hifi         | [Hifi off-ramp docs](https://docs.hifibridge.com/docs/api-offramp)                                   |
| Bridge       | [Bridge off-ramp docs](https://apidocs.bridge.xyz/get-started/guides/move-money/offramp_liquidation) |

## Sending assets from a Privy wallet

To send assets to an off ramp provider, you can use any of Privy's SDKS to send a Transaction either on Ethereum or Solana. Learn more about sending transactions with Privy below:

* [Ethereum](https://docs.privy.io/wallets/using-wallets/ethereum/send-a-transaction)
* [Solana](https://docs.privy.io/wallets/using-wallets/solana/send-a-transaction)


# Integrating OneBalance
Source: https://docs.privy.io/recipes/one-balance



[OneBalance](https://docs.onebalance.io/) is a framework for setting up [Credible Accounts](https://docs.onebalance.io/technical-details/onebalance-accounts) for users, that allow them to use their balance on any EVM chain for transactions on any other EVM chain. This allows your app to abstract away the concept of "chains" for end users, and makes it significantly simpler to use balances across multiple EVM chains without the UX friction of explicitly bridging between them.

You can easily [integrate OneBalance with Privy](https://docs.onebalance.io/chain-abstraction-suite/getting-started-guide-for-privy-less-than-greater-than-onebalance) to abstract users' embedded wallet balances across the various chains that your app might support.

Get started with the steps below, or check out [the sample app](https://github.com/OneBalance-io/integration-examples/blob/main/privy/src/features/quote/sign-quote.ts) for a full walkthrough!

## 1. Set up OneBalance accounts for users

To start, create OneBalance accounts for your users and deposit any user assets to the account to set it up for executing transactions.

Follow the guide [here](https://docs.onebalance.io/chain-abstraction-suite/getting-started-guide-for-privy-less-than-greater-than-onebalance/step-2-setting-configurations) to create your OneBalance API key and instantiate your users' accounts and deposit their assets to it.

You can also use your OneBalance API key to fetch an aggregated balance across all the chains your app supports.

## 2. Fetch a quote for a transaction

When executing a transaction, first fetch a quote from the OneBalance API for the transaction per this [guide](https://docs.onebalance.io/chain-abstraction-suite/getting-started-guide-for-privy-less-than-greater-than-onebalance/step-5-fetch-a-quote-for-transaction-execution).

OneBalance supports swaps, transfers, and arbitrary calldata execution, supporting any transaction use case that your app might have.

## 3. Sign the transaction with the embedded wallet

Lastly, after fetching a quote for the transaction, sign the transaction using the user's embedded wallet by requesting an [EIP-712](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md) typed data signature, like so:

```tsx  theme={"system"}
// below interface corresponds to ChainOperationSwaggerDto on OneBalance Swagger documentation
import {ChainOperation} from '<your path to OneBalance interfaces>';
// below interface corresponds to QuoteSwaggerDto on OneBalance Swagger documentation
import {Quote} from '<your path to OneBalance interfaces>';
import {Address, createWalletClient, custom, Hash} from 'viem';

import {ConnectedWallet} from '@privy-io/react-auth';

const signTypedDataWithPrivy =
  (embeddedWallet: ConnectedWallet) =>
  async (typedData: any): Promise<Hash> => {
    const provider = await embeddedWallet.getEthereumProvider();
    const walletClient = createWalletClient({
      transport: custom(provider),
      account: embeddedWallet.address as Address
    });

    return walletClient.signTypedData(typedData);
  };

const signOperation =
  (embeddedWallet: ConnectedWallet) =>
  async (operation: ChainOperation): Promise<ChainOperation> => {
    const signature = await signTypedDataWithPrivy(embeddedWallet)(operation.typedDataToSign);

    return {
      ...operation,
      userOp: {...operation.userOp, signature}
    };
  };

export const signQuote = async (quote: Quote, embeddedWallet: ConnectedWallet) => {
  const signWithEmbeddedWallet = signOperation(embeddedWallet);

  const signedQuote = {
    ...quote
  };

  signedQuote.originChainsOperations = await Promise.all(
    quote.originChainsOperations.map(signWithEmbeddedWallet)
  );
  if (quote.destinationChainOperation) {
    signedQuote.destinationChainOperation = await signWithEmbeddedWallet(
      quote.destinationChainOperation
    );
  }
  return signedQuote;
};
```

Once you have successfully signed the transaction, you can [execute the transaction with the OneBalance API](https://docs.onebalance.io/chain-abstraction-suite/getting-started-guide-for-privy-less-than-greater-than-onebalance/step-7-executing-transactions) and track its execution status.

**That's it! Your users can now transact on any chain with a unified balance!**


# null
Source: https://docs.privy.io/recipes/overview



export const LinkCard = ({title, links, search = ''}) => {
  const filteredLinks = links.filter(link => link.text.toLowerCase().includes(search.toLowerCase()));
  if (filteredLinks.length === 0) return null;
  return <div className="link-card">
      <h2 className="link-card-title">{title}</h2>
      <div className="link-card-links">
        {filteredLinks.map((link, i) => <a key={i} href={link.href} className="link-card-link">
            {link.text}
          </a>)}
      </div>
    </div>;
};


export default function RecipesOverview() {
  const [search, setSearch] = useState('');
  const popularCards = [{
    title: "Send USDC",
    icon: "money-bill",
    href: "/recipes/send-usdc",
    description: "Format your transaction payload to send tokens."
  }, {
    title: "Send USDC on Solana",
    icon: "money-bill",
    href: "/recipes/solana/send-spl-tokens",
    description: "Format your transaction payload to send SPL tokens."
  }, {
    title: "Bridge Onramp",
    icon: <svg xmlns="http://www.w3.org/2000/svg" width={32} height={32} viewBox="0 0 400 400">

<path fill="#010101" d="M224.203 51.625 227 54c.84.701 1.68 1.403 2.547 2.125C252.756 76.063 266.935 105.775 270 136c.22 3.682.399 7.326 0 11-2.155 2.155-7.071 1.26-10.066 1.316l-2.754.063c-2.914.066-5.828.125-8.743.184l-5.912.13c-4.841.108-9.683.209-14.525.307l.06-2.794c.267-21.661-8.112-41.257-22.892-57.124-16.496-15.842-37.567-22.753-60.063-22.557-8.462.269-16.1 1.786-24.105 4.475l-3.191 1.063C99.657 78.877 84.939 92.95 76 110c-5.696 12.603-7.437 23.931-9 38H27c-4.536-22.682 7.016-49.244 19-68 4.668-6.989 9.864-13.267 16-19l2.438-2.5c43.143-42.09 113.078-44.794 159.765-6.875Z" />
<path fill="#020202" d="M69 162c1.462 2.924 1.81 5.999 2.402 9.2.708 3.317 1.655 6.542 2.598 9.8-4.284 1.964-8.57 3.92-12.86 5.872-1.457.663-2.912 1.329-4.367 1.996-2.1.963-4.204 1.919-6.308 2.874l-1.945.897C44.396 194.502 40.36 195.855 36 197c-.989-2.83-1.966-5.664-2.938-8.5l-.841-2.398-.81-2.383-.747-2.158C29.77 178.11 29.442 174.536 29 171l40-9Z" />
<path fill="#040404" d="M158 227c.434 4.231.86 8.463 1.282 12.695.143 1.436.289 2.87.436 4.306.822 8.02 1.472 15.924 1.282 23.999-8.569 1.624-17.423 1.596-26 0-.197-7.88.567-15.548 1.438-23.375l.408-3.848c1.021-9.38 1.021-9.38 2.154-12.777l8.938-.5 2.576-.145 2.45-.136 2.27-.127A53.3 53.3 0 0 1 158 227Z" />
<path fill="#050505" d="m226 162 41 9c-1.125 8.997-1.125 8.997-2.156 11.922l-.66 1.918-.684 1.91c-1.301 3.725-2.581 7.41-3.5 11.25a1761.89 1761.89 0 0 1-15.326-6.561 712.075 712.075 0 0 0-5.218-2.226 690.433 690.433 0 0 1-7.483-3.225l-2.37-.982c-5.354-2.377-5.354-2.377-6.636-5.615.036-2.616.499-4.406 1.47-6.828C226.05 168.52 226 166.792 226 162Z" />
<path fill="#030303" d="m190 217 1.421 2.491a39418.626 39418.626 0 0 0 7.517 13.169c1.089 1.91 2.179 3.818 3.269 5.727l1.014 1.777c1.46 2.555 2.934 5.08 4.516 7.562C209 250 209 250 209 253a1117.97 1117.97 0 0 1-8.063 3.938l-2.279 1.13c-4.625 2.223-8.536 3.504-13.658 3.932-3.152-7.527-5.78-15.163-8.25-22.938l-1.102-3.4-1.039-3.252-.938-2.933C173 227 173 227 173 224l2.773-1.277 3.602-1.66 3.586-1.653C188.155 217 188.155 217 190 217Z" />
<path fill="#040404" d="M106 217c5.92 1.76 11.416 4.397 17 7-.592 5.031-1.684 9.653-3.285 14.465l-.668 2.055c-.698 2.14-1.404 4.28-2.11 6.417l-1.431 4.385c-1.163 3.562-2.332 7.12-3.506 10.678-6.464-.463-11.236-2.17-17-5.063l-2.348-1.142A699.406 699.406 0 0 1 87 253c.694-3.8 2.395-6.768 4.273-10.121l.984-1.763c1.035-1.854 2.076-3.704 3.118-5.554l2.078-3.72c2.788-4.985 5.585-9.957 8.547-14.842Z" />
<path fill="#050505" d="M81.957 195.04c2.935 1.38 4.636 3.366 6.793 5.773l2.422 2.644C93 206 93 206 93 210c-1.723 2.078-1.723 2.078-4.063 4.25a147.895 147.895 0 0 0-10.097 10.621C75.294 228.974 71.636 232.977 68 237c-5.426-2.313-9.007-6.795-13-11l-1.73-1.785c-1.395-1.528-1.395-1.528-3.27-4.215.191-2.705.734-3.745 2.699-5.628l2.203-1.579 2.436-1.77 2.6-1.835 2.62-1.882c1.71-1.224 3.422-2.445 5.137-3.66a250.807 250.807 0 0 0 5.649-4.154l2.594-1.93 2.152-1.62C80 195 80 195 81.957 195.038ZM214 194c9.26 5.5 17.678 11.964 26.16 18.577A432.068 432.068 0 0 0 246 217c-.559 3.975-2.5 5.985-5.188 8.875l-2.445 2.64A320.507 320.507 0 0 1 230 237c-4.256-1.605-6.86-4.821-9.813-8.125-.53-.585-1.06-1.17-1.607-1.771A933.716 933.716 0 0 1 214 222c-.726-.812-1.451-1.624-2.2-2.46A495.24 495.24 0 0 1 207 214l-2.5-2.75c-1.5-2.25-1.5-2.25-1.34-4.137 1.089-2.74 2.634-4.164 4.778-6.175 2.407-2.277 4.21-4.16 6.062-6.938Z" />
<path fill="#121212" d="M124 28c-3.004 2.002-5.115 2.683-8.563 3.625-5.851 1.744-11.363 3.95-16.937 6.438l-2.319 1.031c-3.142 1.425-6.126 2.873-9.087 4.652C85 45 85 45 83 45v2c-1.637 1.178-1.637 1.178-3.91 2.54-5.585 3.598-9.95 8.056-14.528 12.835-1.577 1.637-3.159 3.27-4.746 4.898l-2.08 2.17C56 71 56 71 54 71l-.785 2.18c-1.272 2.952-2.792 5.328-4.653 7.945l-1.808 2.57C45.272 85.643 43.783 87.332 42 89c1.369-4.95 3.621-8.772 6.625-12.875l1.344-1.86C53.572 69.382 57.535 65.113 62 61l2.5-2.563C78.217 45.065 103.58 26.73 124 28Z" />
<path fill="#101010" d="M72 115c1 2 1 2 .293 4.406l-1.106 3.094C68.3 131.604 68.3 131.604 67 148H27c-2.1-10.498.043-20.845 3-31h1l-.434 3.84c-.581 5.237-1.11 10.479-1.628 15.722L28 146h38v-15c1.059-4.71 1.059-4.71 2.438-8.375l.697-1.938C70.77 116.23 70.77 116.23 72 115Z" />
<path fill="#161616" d="M69 162c1.462 2.924 1.81 5.999 2.402 9.2.708 3.317 1.655 6.542 2.598 9.8-4.284 1.964-8.57 3.92-12.86 5.872-1.457.663-2.912 1.329-4.367 1.996-2.1.963-4.204 1.919-6.308 2.874l-1.945.897c-4.186 1.89-8.026 3.077-12.52 4.361l-5-16h2l5 13c6.912-2.547 13.382-5.066 19.723-8.797 4.223-2.23 8.757-3.69 13.277-5.203l-.621-1.758c-1.52-4.404-2.784-8.599-3.379-13.242l-10 2-1-2 13-3Z" />
<path fill="#0F0F0F" d="M228 133h2c.887 4.546 1 8.234 1 13h37v-8h1v10l-41 1v-16Z" />
<path fill="#161616" d="M141 64a654.73 654.73 0 0 1 15 0l2.66.012C170.283 64.59 183.428 70.605 193 77l1 2c-3.542-1.366-6.973-2.913-10.415-4.513C169.307 67.96 155.532 66.48 140 66l1-2Z" />
<path fill="#141414" d="M188 217v3c-2.463 2.463-4.274 2.768-7.625 3.625-1.003.26-2.006.52-3.04.79L175 225l.813 2.438L177 231l.66 1.945c.793 2.348 1.569 4.7 2.34 7.055l1.082 3.293 1.106 3.457 1.042 3.234c.722 2.826.926 5.12.77 8.016-2.08-3.119-3.018-5.754-4.164-9.313l-1.211-3.757-.621-1.954a1141 1141 0 0 0-1.902-5.906C173 227.383 173 227.383 173 224l2.773-1.277 3.602-1.66 3.586-1.653A191.286 191.286 0 0 0 188 217Z" />
<path fill="#1A1A1A" d="M206 248h2l1 5a1117.97 1117.97 0 0 1-8.063 3.938l-2.279 1.13c-4.625 2.223-8.536 3.504-13.658 3.932l-1-4 3 2a63.93 63.93 0 0 0 7.438-2.688l2.025-.818c3.495-1.451 6.798-2.84 9.537-5.494v-3Z" />
<path fill="#151515" d="m106 217 5 2-1.813.188c-3.126 1.16-3.72 2.878-5.187 5.812l-.828 2.277c-1.42 3.3-3.276 6.069-5.297 9.036l-2.195 3.238L94 242l-1-2c1.08-2.338 1.08-2.338 2.746-5.227l1.787-3.125 1.904-3.273 1.893-3.297c1.55-2.697 3.107-5.39 4.67-8.078Z" />
<path fill="#121212" d="m226 162 7 2-1.852 1.652c-2.35 2.568-3.344 4.653-4.523 7.91l-1.086 2.88L225 179l2 3-4-1c.422-3.513.9-6.712 2.063-10.063 1.001-3.138 1.093-5.664.937-8.937Z" />
<path fill="#181818" d="M77 197v3c-1.62 1.502-1.62 1.502-3.867 3.066l-2.434 1.721-2.574 1.775a3518.53 3518.53 0 0 0-4.992 3.504l-2.254 1.561c-1.985 1.377-1.985 1.377-3.879 3.373l-3-1c2.52-1.897 5.041-3.793 7.563-5.688l2.134-1.607c4.392-3.298 8.821-6.53 13.303-9.705ZM47 167l1 2c-3.827 1.747-7.124 2.349-11.313 2.625l-3.238.227L31 172l1 8-2-1-1-8 18-4Z" />
<path fill="#191919" d="M113 74a900.633 900.633 0 0 1-6.375 4.063l-1.828 1.181c-1.562.98-3.177 1.875-4.797 2.756l-2-1 2.313-1.813c2.592-2.005 2.592-2.005 4.25-3.874C107.397 72.724 109.46 72.82 113 74Z" />
<path fill="#161616" d="M214 220c3.297 1.099 4.047 1.946 6.188 4.563l1.605 1.94L223 228l-1 2a679.453 679.453 0 0 1-4-3.875l-2.25-2.18C214 222 214 222 214 220Z" />
<path fill="#101010" d="M188 217v3c-2.36 2.36-3.779 2.491-7 3 1-3 1-3 4.063-4.688L188 217Z" />
<path fill="#121212" d="M62 208v3c-2.313 2.25-2.313 2.25-5 4l-3-1 8-6Z" />
<path d="M88 93v3l-2 1 2-4ZM55 65v3l-2 1 2-4ZM82 222v3l-2-1 2-2ZM68 52l2 1-3 2 1-3ZM98 226l2 1-2 2v-3ZM242 225v3ZM246 220v3ZM212 193v3ZM63 236l2 2h-2v-2ZM206 214l2 2h-2v-2ZM93 210l1 2-2-1 1-1ZM203 203l2 1-2 1v-2ZM83 193l2 2h-2v-2ZM84 98l1 2-2-1 1-1ZM91 90l1 2-2-1 1-1ZM205 255l2 1ZM244 214l2 1ZM50 214l2 1ZM240 211l2 1ZM236 208l2 1ZM91 203l2 1ZM65 203l2 1ZM71 199l2 1ZM75 196l2 1ZM221 181l2 1ZM198 85l2 1ZM96 85l2 1ZM194 82l2 1ZM100 82l2 1ZM65 55l2 1ZM226 52l2 1ZM72 49l2 1ZM76 46l2 1ZM79 44l2 1Z" />

  </svg>,
    href: "/recipes/bridge-onramp",
    description: "Learn how to implement bridge onramp functionality."
  }, {
    title: "Optimize your setup",
    icon: "lightbulb",
    href: "/recipes/dashboard/optimizing",
    description: "Best tips and tricks to optimize your setup."
  }, {
    title: "Trading apps homepage",
    icon: "chart-simple",
    href: "/recipes/trading-apps-homepage",
    description: "Quickstart guide to building a trading app."
  }, {
    title: "Abstract Global Wallet",
    icon: <svg xmlns="http://www.w3.org/2000/svg" width={24} height={22} viewBox="0 0 141 128" fill="none">
<path d="M93.1166 85.8201L121.195 113.914L108.021 127.096L79.9417 99.0022C77.5343 96.5935 74.361 95.2796 70.9469 95.2796C67.5328 95.2796 64.3594 96.5935 61.952 99.0022L33.8732 127.096L20.6983 113.914L48.7771 85.8201H93.0947H93.1166Z" fill="black" />
<path d="M97.8 77.7181L136.143 87.9879L140.958 69.9665L102.615 59.6968C99.332 58.8209 96.5963 56.7188 94.8892 53.7626C93.1822 50.8284 92.7445 47.3906 93.6199 44.106L103.884 5.74218L85.8725 0.924805L75.6083 39.2886L97.7781 77.6962L97.8 77.7181Z" fill="black" />
<path d="M44.1155 77.7181L5.77252 87.9879L0.957764 69.9665L39.3007 59.6968C42.5835 58.8209 45.3192 56.7188 47.0262 53.7626C48.7333 50.8284 49.171 47.3906 48.2956 44.106L38.0314 5.74218L56.043 0.924805L66.3072 39.2886L44.1374 77.6962L44.1155 77.7181Z" fill="black" />
</svg>,
    href: "/recipes/ecosystem/abstract-global-wallet",
    description: "Integrate Abstract Global Wallet into your app."
  }];
  const filteredPopular = popularCards.filter(card => card.title.toLowerCase().includes(search.toLowerCase()) || card.description.toLowerCase().includes(search.toLowerCase()));
  return <>
  <div className="recipes">
    <div className="text-center">
      <h1>Recipes</h1>
    </div>
    <div id="recipes-search" className="search">
      <input type="text" placeholder="Search recipes..." value={search} onChange={e => setSearch(e.target.value)} className="search-input" style={{
    width: '100%',
    maxWidth: 400,
    margin: '0 auto',
    display: 'block'
  }} />
    </div>
  </div>
  <div className="card-group-wrapper">
    <h2 className="font-semibold text-3xl pb-2 text-center text-black mb-4">Popular</h2>
    <CardGroup cols={2} horizontal>
      {filteredPopular.map(card => <Card key={card.title} title={card.title} icon={card.icon} href={card.href} horizontal>
          {card.description}
        </Card>)}
    </CardGroup>
  </div>
  <div className="card-group-wrapper">
    <h2 className="font-semibold text-3xl pb-2 text-center text-black mb-6">All recipes</h2>
    <div className="link-card-grid">
      <LinkCard title="Authentication" links={[{
    text: 'Configure SMS and WhatsApp login',
    href: '/recipes/dashboard/login-methods/sms-whatsapp'
  }, {
    text: 'Guest accounts',
    href: '/recipes/react/guest-accounts'
  }, {
    text: 'Using OAuth tokens',
    href: '/recipes/react/oauth-tokens'
  }, {
    text: 'Worldcoin SIWE guide',
    href: '/recipes/react/worldcoin-siwe-guide'
  }, {
    text: 'Mocking tokens for testing',
    href: '/recipes/mock-jwt'
  }, {
    text: 'Configure cookies',
    href: '/recipes/react/cookies'
  }, {
    text: 'Using test accounts',
    href: '/recipes/using-test-accounts'
  }, {
    text: 'Chrome extension guide',
    href: '/recipes/react/chrome-extension'
  }, {
    text: 'Using Supabase for custom auth',
    href: '/recipes/authentication/using-supabase-for-custom-auth'
  }]} search={search} />
      <LinkCard title="Wallet infrastructure" links={[{
    text: 'HD wallets',
    href: '/recipes/hd-wallets'
  }, {
    text: 'Pregenerating wallets',
    href: '/recipes/pregenerate-wallets'
  }, {
    text: 'Treasury wallets',
    href: '/recipes/wallets/treasury-wallets'
  }, {
    text: 'Agentic wallets',
    href: '/recipes/wallets/agentic-wallets'
  }, {
    text: 'Passkey wallets',
    href: '/recipes/passkey-server-wallets'
  }, {
    text: 'TEE wallet migration guide',
    href: '/recipes/tee-wallet-migration-guide'
  }, {
    text: 'Server-side self-custodial user wallets',
    href: '/recipes/wallets/server-side-user-wallets'
  }, {
    text: 'Using tier 2 chains',
    href: '/recipes/use-tier-2'
  }, {
    text: 'Integrating smart accounts with Wagmi',
    href: '/recipes/account-abstraction/wagmi'
  }]} search={search} />
      <LinkCard title="UI customization and whitelabeling" links={[{
    text: 'Whitelabel homepage',
    href: '/recipes/react/whitelabel'
  }, {
    text: 'Configure wallet confirmation modals',
    href: '/recipes/react/manage-wallet-UIs'
  }, {
    text: 'System theme',
    href: '/recipes/system-theme'
  }, {
    text: 'Brand customization',
    href: '/recipes/dashboard/customization'
  }]} search={search} />
      <LinkCard title="Dashboard" links={[{
    text: 'Configure account transfer',
    href: '/recipes/dashboard/account-transfer'
  }, {
    text: 'Configure allowed domains',
    href: '/recipes/dashboard/allowed-domains'
  }, {
    text: 'Configure allowed OAuth redirects',
    href: '/recipes/react/allowed-oauth-redirects'
  }, {
    text: 'Airtable integration',
    href: '/recipes/dashboard/airtable'
  }, {
    text: 'Single sign-on (SSO)',
    href: '/basics/get-started/dashboard/sso'
  }]} search={search} />
      <LinkCard title="Social integrations" links={[{
    text: 'Farcaster Mini App guide',
    href: '/recipes/farcaster/mini-apps'
  }, {
    text: 'Seamless Telegram login',
    href: '/recipes/react/seamless-telegram'
  }, {
    text: 'Login with Farcaster',
    href: '/recipes/farcaster/login'
  }, {
    text: 'Farcaster writes guide',
    href: '/recipes/farcaster/writes'
  }]} search={search} />
      <LinkCard title="Payments and gas sponsorship" links={[{
    text: 'Custom fiat onramp',
    href: '/recipes/react/custom-fiat-onramp'
  }, {
    text: 'Off-ramp guide',
    href: '/recipes/off-ramp-guide'
  }, {
    text: 'x402',
    href: '/recipes/x402'
  }, {
    text: 'Using Privy and Due for On/Off Ramping',
    href: '/recipes/due-on-off-ramp'
  }, {
    text: 'Funding wallets with Relay deposit addresses',
    href: '/recipes/relay-deposit-addresses'
  }, {
    text: 'Integrating OneBalance',
    href: '/recipes/one-balance'
  }, {
    text: 'Swap with 0x',
    href: '/recipes/swap-with-0x'
  }, {
    text: 'EIP-7702',
    href: '/recipes/react/eip-7702'
  }, {
    text: 'Card-based funding',
    href: '/recipes/card-based-funding'
  }, {
    text: 'Custom gas sponsorship rate limits',
    href: '/recipes/gas-sponsorship-rate-limits'
  }]} search={search} />
      <LinkCard title="Trading integrations" links={[{
    text: 'Trading apps homepage',
    href: '/recipes/trading-apps-homepage'
  }, {
    text: 'Request server-side access to user wallets',
    href: '/recipes/wallets/session-signer-use-cases/server-side-access'
  }, {
    text: 'Execute limit orders while users are offline',
    href: '/recipes/wallets/session-signer-use-cases/limit-orders'
  }, {
    text: 'Bankr Twitter bot guide',
    href: '/recipes/bankr-bot-guide'
  }, {
    text: 'Telegram trading bot guide',
    href: '/recipes/telegram-bot'
  }]} search={search} />
      <LinkCard title="Hyperliquid" links={[{
    text: 'Getting started',
    href: '/recipes/hyperliquid-guide'
  }, {
    text: 'Agents and Subaccounts',
    href: '/recipes/hyperliquid/agents-and-subaccounts'
  }, {
    text: 'Trading patterns',
    href: '/recipes/hyperliquid/trading-patterns'
  }, {
    text: 'Policies and offline actions',
    href: '/recipes/hyperliquid/policies-and-offline-actions'
  }, {
    text: 'Builder codes and HIP-3',
    href: '/recipes/hyperliquid/builder-codes-and-hip3'
  }, {
    text: 'HyperEVM',
    href: '/recipes/hyperliquid/hyperevm'
  }]} search={search} />
      <LinkCard title="Mobile" links={[{
    text: 'Swift Apple login guide',
    href: '/recipes/swift/apple'
  }, {
    text: 'Deeplinking Solana wallets',
    href: '/recipes/react-native/deeplinking-wallets'
  }, {
    text: 'Clearing state on fresh installs',
    href: '/recipes/react-native/clearing-state-on-fresh-installs'
  }, {
    text: 'OAuth with Capacitor and Ionic',
    href: '/recipes/capacitor-oauth'
  }]} search={search} />
      <LinkCard title="Tooling" links={[{
    text: 'Core JS',
    href: '/recipes/core-js'
  }, {
    text: 'Flashbots protect',
    href: '/recipes/flashbots-protect'
  }, {
    text: 'Lens protocol',
    href: '/recipes/lens'
  }, {
    text: 'TRPC integration',
    href: '/recipes/trpc'
  }]} search={search} />
      <LinkCard title="EVM" links={[{
    text: 'Integrating the Base App',
    href: '/recipes/react/external-wallets/base-app'
  }, {
    text: 'Using Flashblocks with Privy',
    href: '/recipes/evm/flashblocks'
  }, {
    text: 'Using Privy with Hyperliquid',
    href: '/recipes/hyperliquid-guide'
  }, {
    text: 'Integrating Morpho Vaults',
    href: '/recipes/morpho-guide'
  }, {
    text: 'Integrating Aave protocol',
    href: '/recipes/aave-guide'
  }, {
    text: 'Base Sub Accounts',
    href: '/recipes/react/external-wallets/base-sub-accounts'
  }, {
    text: 'Speeding up transactions',
    href: '/recipes/speeding-up-transactions'
  }]} search={search} />
      <LinkCard title="Solana" links={[{
    text: 'Configuring external connectors',
    href: '/recipes/react/configuring-external-connectors'
  }, {
    text: 'Standard wallets',
    href: '/recipes/solana/standard-wallets'
  }, {
    text: 'Sending a SOL transaction',
    href: '/recipes/solana/send-sol'
  }, {
    text: 'Sending an SPL transaction',
    href: '/recipes/solana/send-spl-tokens'
  }]} search={search} />
      <LinkCard title="Ecosystem" links={[{
    text: 'Abstract Global Wallet',
    href: '/recipes/ecosystem/abstract-global-wallet'
  }]} search={search} />
      <div className="link-card link-card-bottom">
        <h2 className="link-card-title">Did we miss something?</h2>
        <div style={{
    display: 'flex',
    flexDirection: 'column',
    height: '100%'
  }}>
          <div style={{
    marginBottom: 16,
    fontSize: 16,
    flex: 1
  }}>
            Reach out to us on Slack and someone from our team will get back to you.
          </div>
          <a href="https://privy.io/slack" target="_blank" rel="noopener noreferrer" className="link-card-bottom-btn">
            Reach out
          </a>
        </div>
      </div>
    </div>

  </div>
</>;
}


# Using passkeys with wallets
Source: https://docs.privy.io/recipes/passkey-server-wallets



Passkeys provide a secure way to authorize actions on Privy wallets. This guide shows how to integrate your existing passkey implementation as an authorization mechanism for Privy wallets, combining modern authentication with powerful onchain actions.

## Overview

Authorization keys provide a way to ensure that actions taken by your app's wallets can only be authorized by an explicit user request. When you specify an `owner` of a resource, all requests to update that resource **must be signed** with this key. This security measure verifies that each request comes from your authorized passkey owner and helps prevent unauthorized operations.

## Setting up passkeys

If you need a passkey implementation set up for your application, we recommend using the [simpleWebAuthn SDKs](https://simplewebauthn.dev/docs), which provides simple passkey registration and authentication flows.

<Accordion title="Sample passkey registration flow">
  If you have not already done so, install the dependencies necessary for a simple passkey integration.
  `sh npm install @simplewebauthn/server @simplewebauthn/browser `

  ### Server-side registration endpoints

  First, create the registration begin endpoint:

  ```typescript {skip-check} theme={"system"}
  // /api/register-passkey/begin
  import {generateRegistrationOptions} from '@simplewebauthn/server';
  import type {NextApiRequest, NextApiResponse} from 'next';
  import {passkeyStorage} from '@/lib/passkey-storage';

  // This would typically come from your database
  const rpName = 'Your App Name';
  const rpID = 'yourdomain.com';
  const origin = 'https://yourdomain.com';

  export default async function handler(req: NextApiRequest, res: NextApiResponse) {
    if (req.method !== 'POST') {
      return res.status(405).json({error: 'Method not allowed'});
    }

    try {
      const {userId} = req.body;

      if (!userId) {
        return res.status(400).json({error: 'userId is required'});
      }

      // Generate registration options
      const options = await generateRegistrationOptions({
        rpName,
        rpID,
        userID: Buffer.from(userId),
        userName: `user-${userId}`, // This would typically be the user's email or username
        attestationType: 'none', // For demo purposes, we don't need attestation
        authenticatorSelection: {
          residentKey: 'preferred',
          userVerification: 'preferred'
        },
        supportedAlgorithmIDs: [-7] // ES256
      });

      // Store the options temporarily (in production, store in database with expiration)
      passkeyStorage.set(userId, {options});

      // Clean up old entries (older than 5 minutes)
      // passkeyStorage.cleanup();

      return res.status(200).json(options);
    } catch (error) {
      console.error('Error generating registration options:', error);
      return res.status(500).json({error: 'Internal server error'});
    }
  }
  ```

  Next, create the registration verify endpoint:

  ```typescript {skip-check} theme={"system"}
  // /api/register-passkey/verify
  import {verifyRegistrationResponse} from '@simplewebauthn/server';
  import type {NextApiRequest, NextApiResponse} from 'next';
  import {passkeyStorage} from '@/lib/passkey-storage';

  const rpID = 'yourdomain.com';
  const origin = 'https://yourdomain.com';

  export default async function handler(req: NextApiRequest, res: NextApiResponse) {
    if (req.method !== 'POST') {
      return res.status(405).json({error: 'Method not allowed'});
    }

    try {
      const {userId, attestationResponse} = req.body;

      if (!userId || !attestationResponse) {
        return res.status(400).json({error: 'userId and attestationResponse are required'});
      }

      // Retrieve the stored registration options
      const storedData = passkeyStorage.get(userId);
      if (!storedData) {
        return res.status(400).json({error: 'Registration options not found or expired'});
      }

      const {options} = storedData;

      // Verify the registration response
      const verification = await verifyRegistrationResponse({
        response: attestationResponse,
        expectedRPID: rpID,
        expectedOrigin: origin,
        expectedChallenge: options.challenge,
        requireUserVerification: false // For demo purposes
      });

      if (verification.verified) {
        // Registration successful - store the passkey credentials
        // In production, you would store this in your database
        const {credentialID, credentialPublicKey} = verification.registrationInfo;

        // Clean up temporary storage
        passkeyStorage.delete(userId);

        return res.status(200).json({
          verified: true,
          credentialID: Buffer.from(credentialID).toString('base64'),
          publicKey: Buffer.from(credentialPublicKey).toString('base64')
        });
      } else {
        return res.status(400).json({error: 'Registration verification failed'});
      }
    } catch (error) {
      console.error('Error verifying registration:', error);
      return res.status(500).json({error: 'Internal server error'});
    }
  }
  ```

  ### Client-side registration

  ```typescript  theme={"system"}
  import {startRegistration} from '@simplewebauthn/browser';

  // Client-side registration
  async function registerPasskey(userId: string) {
    // Step 1: Get registration options from server
    const optionsResponse = await fetch('/api/register-passkey/begin', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({userId})
    });

    const options = await optionsResponse.json();

    // Step 2: Start the registration process in the browser
    const attestationResponse = await startRegistration(options);

    // Step 3: Send the response to your server for verification
    const verificationResponse = await fetch('/api/register-passkey/verify', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        userId,
        attestationResponse
      })
    });

    const verification = await verificationResponse.json();

    if (verification.verified) {
      // Passkey registration successful!
      return {
        credentialID: verification.credentialID,
        publicKey: verification.publicKey
      };
    } else {
      throw new Error('Passkey registration failed');
    }
  }
  ```
</Accordion>

## Creating and registering wallets with passkey authorization

Follow these steps to create a wallet and register it with a user's passkey for authorization.

1. Retrieve the user's passkey P-256 PEM-formatted public key and send it to your backend.

<Accordion title="Converting WebAuthn public key to PEM format (if using simpleWebAuthn)">
  After registering a passkey, you'll need to convert the WebAuthn public key from COSE format to PEM format that Privy expects:

  ```typescript  theme={"system"}
  const coseToJwk = require('cose-to-jwk');

  async function convertCoseToPem(coseKey: Uint8Array): Promise<string> {
    // Convert COSE to JWK format
    const jwk = coseToJwk(coseKey);

    // Import the JWK using Web Crypto API
    const cryptoKey = await crypto.subtle.importKey(
      'jwk',
      jwk,
      {
        name: 'ECDSA',
        namedCurve: 'P-256'
      },
      true, // extractable
      ['verify'] // only need verify for public keys
    );

    // Export the key in SPKI format (DER-encoded)
    const spkiDer = await crypto.subtle.exportKey('spki', cryptoKey);

    // Convert to base64 and format as PEM
    const base64Key = Buffer.from(spkiDer).toString('base64');

    // Split into 64-character lines
    const lines = [];
    for (let i = 0; i < base64Key.length; i += 64) {
      lines.push(base64Key.slice(i, i + 64));
    }

    // Create PEM format
    const pemKey = `-----BEGIN PUBLIC KEY-----\n${lines.join('\n')}\n-----END PUBLIC KEY-----`;

    return pemKey;
  }
  ```

  Use this function after successful passkey registration to get the PEM-formatted public key that Privy requires.
</Accordion>

2. From your backend, call the Privy API to create a wallet with that P-256 public key as the owner. You can do this via the Privy SDK (below) or by hitting the [Privy API](/api-reference/wallets/create) directly.

<CodeGroup>
  ```ts @privy-io/node theme={"system"}
  import {PrivyClient} from '@privy-io/node';

  const passkeyP256PublicKey = 'your-p256-public-key';

  const privy = new PrivyClient({appId: 'your-app-id', appSecret: 'your-app-secret'});

  const wallet = await privy.wallets().create({
    owner: {
      public_key: passkeyP256PublicKey
    },
    chain_type: 'ethereum' // or another supported chain type
  });
  ```

  ```ts @privy-io/server-auth theme={"system"}
  import {PrivyClient} from '@privy-io/server-auth';

  const passkeyP256PublicKey = 'your-p256-public-key';

  const privy = new PrivyClient('your-app-id', 'your-app-secret');

  const wallet = await privy.walletApi.createWallet({
    owner: {
      publicKey: passkeyP256PublicKey
    },
    chainType: 'ethereum' // or another supported chain type
  });
  ```
</CodeGroup>

3. Associate the returned wallet ID with the user on your backend for use in future requests.

## Sending transactions with passkey authorization

Below are the steps necessary to create a transaction request, have the user sign it with their passkey using WebAuthn, and submit the signed request to Privy:

1. **Create and format the transaction request payload**

Create your transaction and format it into the required request payload structure:

```typescript  theme={"system"}
import canonicalize from 'canonicalize';
import {startAuthentication} from '@simplewebauthn/browser';

// Your transaction details
const transaction = {
  to: '0x...',
  value: '1000000000000000000', // 1 ETH in wei
  chain_id: 1, // Ethereum mainnet
  data: '0x',
  gas_limit: '21000',
  nonce: 42,
  type: 2
};

const serverWallet = {id: 'your-wallet-id'}; // The wallet created earlier

// Format the request payload for Privy API
const requestPayload = {
  version: 1,
  method: 'POST',
  url: `https://api.privy.io/v1/wallets/${serverWallet.id}/rpc`,
  body: {
    method: 'eth_signTransaction',
    params: {
      transaction: {
        to: transaction.to,
        value: transaction.value,
        chain_id: transaction.chain_id,
        data: transaction.data,
        gas_limit: transaction.gas_limit,
        nonce: transaction.nonce,
        type: 2
      }
    }
  },
  headers: {
    'privy-app-id': process.env.NEXT_PUBLIC_PRIVY_APP_ID!
  }
};

// Canonicalize the payload for consistent signing
const canonicalPayload = canonicalize(requestPayload) as string;

// Convert to base64url as required by Privy's specification
function base64UrlEncode(str: string) {
  return btoa(str).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}

const payloadBase64Url = base64UrlEncode(canonicalPayload);
```

2. **Sign the payload with the user's passkey**

Use the WebAuthn authentication flow to sign the formatted payload:

```typescript  theme={"system"}
import {startAuthentication} from '@simplewebauthn/browser';

// Sign the payload using simpleWebAuthn
const authResponse = await startAuthentication({
  optionsJSON: {
    challenge: '$PAYLOAD_BASE64_URL',
    allowCredentials: [], // Empty to discover available credentials
    userVerification: 'preferred',
    rpId: 'yourdomain.com', // Must match the rpID from registration
    timeout: 60000 // 60 seconds
  }
});

// Extract the WebAuthn response components
const signature = authResponse.response.signature;
const authenticatorData = authResponse.response.authenticatorData;
const clientDataJSON = authResponse.response.clientDataJSON;
```

3. **Format the authorization signature**

Create the specially formatted authorization signature that Privy expects:

```typescript {skip-check} theme={"system"}
// Format the authorization signature for Privy
const authorizationSignature = `webauthn:${authenticatorData}:${clientDataJSON}:${signature}`;
```

4. **Send the transaction to Privy**

Send the transaction request with the WebAuthn authorization signature:

```typescript  theme={"system"}
import fetch from 'node-fetch'; // or use global fetch

const accessToken = 'your-access-token'; // Your app's access token
const serverWallet = {id: 'your-wallet-id'}; // The wallet created earlier
const authorizationSignature = 'formatted-authorization-signature'; // From previous step
const transaction = {
  to: '0x...',
  value: '1000000000000000000', // 1 ETH in wei
  chain_id: 1, // Ethereum mainnet
  data: '0x',
  gas_limit: '21000',
  nonce: 42,
  type: 2
};

// Send the transaction to Privy API
const response = await fetch(`https://api.privy.io/v1/wallets/${serverWallet.id}/rpc`, {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'privy-app-id': process.env.NEXT_PUBLIC_PRIVY_APP_ID!,
    'privy-authorization-signature': authorizationSignature,
    Authorization: `Bearer ${accessToken}` // Your app's access token
  },
  body: JSON.stringify({
    method: 'eth_signTransaction',
    params: {
      transaction: {
        to: transaction.to,
        value: transaction.value,
        chain_id: transaction.chain_id,
        data: transaction.data,
        gas_limit: transaction.gas_limit,
        nonce: transaction.nonce,
        type: 2
      }
    }
  })
});

const result = await response.json();
console.log('Transaction result:', result);
```

**That's it! Your users can now securely authorize transactions on wallets using their passkeys with WebAuthn standard authentication.** 🎉


# Pregenerating wallets
Source: https://docs.privy.io/recipes/pregenerate-wallets



With Privy, you can **pregenerate self-custodial Ethereum and Solana wallets** for existing users, or create a new user with other login methods, like an email address or phone number, without requiring the user to login.
You can even send assets to the wallet before the user logs in to your app for the first time.

Once the user associated with the account logs in, they will be able to access the pregenerated wallet and any assets sent to them.

Wallet pregeneration is useful for:

* **Airdrops and rewards**: Distribute tokens or NFTs to users before they sign up
* **Web2 to web3 migrations**: Import existing users from a database and provision wallets for them
* **Frictionless onboarding**: Allow users to receive assets before creating an account
* **Server-side provisioning**: Generate wallets programmatically based on off-chain events or criteria

This recipe covers three scenarios: creating wallets for new users, adding wallets to existing users, and batch importing users with wallets.

## Pregenerating wallets for new users

Create new users with pregenerated wallets in a single operation. This is useful for airdrops, migrations, or any scenario where wallets need to exist before authentication.

<Tabs>
  <Tab title="NodeJS">
    To pregenerate embedded wallets for a new user, use the `create` method on the `users()` interface of the Privy client.

    ### Usage

    ```tsx [expandable] theme={"system"}
    const privy = new PrivyClient({ appId: 'your-app-id', appSecret: 'your-app-secret' });

    const user = await privy.users().create({
        linked_accounts: [
            {
                type: 'email',
                address: 'batman@privy.io',
            },
        ],
        wallets: [
            {
                chain_type: 'ethereum',
                wallet_index: 0,
                additional_signers: [
                    {
                        signer_id: '<signer-id>',
                        // Policies specific to this signer
                        override_policy_ids: ['<policy-id>']
                    }
                ],
                // Policies for all transactions on the wallet, no matter the signer
                policy_ids: ['<policy-id>']
            },
            {
                chain_type: 'solana',
                wallet_index: 0,
                additional_signers: [
                    {
                        signer_id: '<signer-id>',
                        override_policy_ids: ['<policy-id>']
                    }
                ],
                policy_ids: []
            }
        ],
        create_direct_signer: true
    });
    ```

    ### Params and returns

    Check out the [API reference](/api-reference/users/create) for more details.
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    To pregenerate embedded wallets for a new user, use the `importUser` method from `PrivyClient`.

    ```javascript  theme={"system"}
    importUser: ({linkedAccounts: LinkedAccountType[], customMetadata?: CustomMetadataType, wallets?: WalletCreateRequestType[], createDirectSigner?: boolean}) => Promise<User>
    ```

    ### Usage

    ```tsx [expandable] theme={"system"}
    const privy = new PrivyClient('your-app-id', 'your-app-secret');

    const user = await privy.importUser({
        linkedAccounts: [
            {
                type: 'email',
                address: 'batman@privy.io',
            },
        ],
        wallets: [
            {
                chainType: 'ethereum',
                walletIndex: 0,
                additionalSigners: [
                    {
                        signerId: '<signer-id>',
                        // Policies specific to this signer
                        overridePolicyIds: ['<policy-id>']
                    }
                ],
                // Policies for all transactions on the wallet, no matter the signer
                policyIds: ['<policy-id>']
            },
            {
                chainType: 'solana',
                walletIndex: 0,
                additionalSigners: [
                    {
                        signerId: '<signer-id>',
                        overridePolicyIds: ['<policy-id>']
                    }
                ],
                policyIds: []
            }
        ],
        createDirectSigner: true
    });
    ```

    ### Params

    <ParamField path="linkedAccounts" type="LinkedAccountType[]" required>
      An array of linked accounts to associate with the user.
    </ParamField>

    <ParamField path="customMetadata" type="CustomMetadataType">
      Custom metadata to associate with the user.
    </ParamField>

    <ParamField path="wallets" type="WalletCreateRequestType[]">
      An array of wallets to create for the user.

      <Expandable defaultOpen="true">
        <ParamField path="chainType" type="'ethereum' | 'solana' | 'stellar' | 'cosmos' | 'sui' | 'tron' | 'bitcoin-segwit' | 'near' | 'ton' | 'starknet' | 'movement'" required>
          The chain type of the wallet to create.
        </ParamField>

        <ParamField path="walletIndex" type="number">
          The HD wallet index to use for wallet generation. Defaults to `0`.
        </ParamField>

        <ParamField path="additionalSigners" type="object[]">
          <Expandable defaultOpen="true">
            <ParamField path="signerId" type="string">
              The ID of the signer.
            </ParamField>

            <ParamField path="overridePolicyIds" type="string[]">
              List of policy IDs for policies that should be enforced on the wallet. Currently, only one policy is supported per wallet.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField path="createSmartAccount" type="boolean">
          Set to `true` to create a smart account with the user's wallet as the signer. Can only be set on wallets where `chainType` is `ethereum`.
        </ParamField>
      </Expandable>
    </ParamField>

    <ParamField path="createDirectSigner" type="boolean">
      Set to `true` to create a UserSigner for custom JWT authentication for all wallets. Requires a custom JWT linked account.
    </ParamField>

    ### Returns

    <ResponseField name="user" type="User">
      The user with the newly created wallets.
    </ResponseField>
  </Tab>

  <Tab title="Java">
    To pregenerate embedded wallets for a new user, use the `createUser` method.

    <Tip>
      Take a look at the [guide on creating users](/user-management/migrating-users-to-privy/create-or-import-a-user)
      for more information on creating users with particular linked accounts and
      metadata before they sign in to the application.
    </Tip>

    ```java  theme={"system"}
    try {
        List<LinkedAccountInput> createUserLinkedAccounts = List.of(/* Some linked accounts... */);

        // Pregenerate an Ethereum and Solana wallet for the user
        List<UserWalletRequest> wallets = List.of(
            UserWalletRequest.builder()
                .chainType(WalletChainType.ETHEREUM)
                .walletIndex(0)
                .build(),
            UserWalletRequest.builder()
                .chainType(WalletChainType.SOLANA)
                .walletIndex(0)
                .build()
        );

        UserCreateRequestBody requestBody = UserCreateRequestBody.builder()
            .linkedAccounts(createUserLinkedAccounts)
            .wallets(wallets)
            .createDirectSigner(true)
            .build();
        UserCreateResponse response = privyClient.users().create(requestBody);

        // Check if the user was created successfully.
        // The application can now use the address of their generated wallet.
        if (response.user().isPresent()) {
            User user = response.user().get();

            // Extract Ethereum wallet from User response
            LinkedAccountEthereumEmbeddedWallet ethereumWallet = user.getFirstLinkedAccountByType(
                LinkedAccountEthereumEmbeddedWallet.class
            );

            // Grab the generated wallet address
            String ethereumAddress = ethereumWallet.address();

            // Extract Solana wallet from User response
            LinkedAccountSolanaEmbeddedWallet solanaWallet = user.getFirstLinkedAccountByType(
                LinkedAccountSolanaEmbeddedWallet.class
            );

            // Grab the generated wallet address
            String solanaAddress = solanaWallet.address();
        }
    } catch (APIException e) {
        String errorBody = e.bodyAsString();
        System.err.println(errorBody);
    } catch (Exception e) {
        System.err.println(e.getMessage());
    }
    ```
  </Tab>

  <Tab title="REST API">
    To pregenerate embedded wallets for a new user, make a POST request to `https://auth.privy.io/api/v1/users`.

    ### Usage

    Below is a sample cURL command for creating a new user with pregenerated wallets:

    ```sh  theme={"system"}
    $ curl --request POST https://auth.privy.io/api/v1/users \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H "Content-Type: application/json" \
    -d '{
            "linked_accounts": [
                {
                    "address": "batman@privy.io",
                    "type": "email"
                }
            ],
            "wallets": [
                {
                    "chain_type": "ethereum",
                    "wallet_index": 0,
                    "policy_ids": ["<policy-id>"],
                    "additional_signers": [
                        {
                            "signer_id": "<signer-id>",
                            "override_policy_ids": ["<policy-id>"]
                        }
                    ]
                },
                {
                    "chain_type": "solana",
                    "wallet_index": 0,
                    "additional_signers": [
                        {
                            "signer_id": "<signer-id>",
                            "override_policy_ids": ["<policy-id>"]
                        }
                    ]
                }
            ],
            "create_direct_signer": true
        }'
    ```

    A successful response will include the new user object along with their user ID and embedded wallet addresses:

    ```json  theme={"system"}
        {
            "id": "did:privy:clddy332f002tyqpq3b3lv327",
            "created_at": 1674788927,
            "linked_accounts": [
                {
                    "address": "batman@privy.io",
                    "type": "email"
                },
                {
                    "address": "0x3DAF84b3f09A0E2092302F7560888dBc0952b7B7",
                    "type": "wallet",
                    "wallet_client": "privy",
                    "chain_type": "ethereum"
                },
                {
                    "address": "9KnvxKTx...",
                    "type": "wallet",
                    "wallet_client": "privy",
                    "chain_type": "solana"
                }
            ]
        }
    ```

    ### Parameters

    <ParamField path="linked_accounts" type="LinkedAccountType[]" required>
      An array of linked accounts to associate with the user.
    </ParamField>

    <ParamField path="custom_metadata" type="CustomMetadataType">
      Custom metadata to associate with the user.
    </ParamField>

    <ParamField path="wallets" type="WalletCreateRequestType[]">
      An array of wallets to create for the user.

      <Expandable defaultOpen="true">
        <ParamField path="chain_type" type="'ethereum' | 'solana' | 'stellar' | 'cosmos' | 'sui' | 'tron' | 'bitcoin-segwit' | 'near' | 'ton' | 'starknet' | 'movement'" required>
          The chain type of the wallet to create.
        </ParamField>

        <ParamField path="wallet_index" type="number">
          The HD wallet index to use for wallet generation. Defaults to `0`.
        </ParamField>

        <ParamField path="policy_ids" type="string[]">
          List of policy IDs for policies that should be enforced on all transactions on the wallet, regardless of signer.
        </ParamField>

        <ParamField path="additional_signers" type="object[]">
          <Expandable defaultOpen="true">
            <ParamField path="signer_id" type="string">
              The ID of the signer.
            </ParamField>

            <ParamField path="override_policy_ids" type="string[]">
              List of policy IDs for policies specific to this signer. Currently, only one policy is supported per wallet.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField path="create_smart_account" type="boolean">
          Set to `true` to create a smart account with the user's wallet as the signer. Can only be set on wallets where `chain_type` is `ethereum`.
        </ParamField>
      </Expandable>
    </ParamField>

    <ParamField path="create_direct_signer" type="boolean">
      Set to `true` to create a UserSigner for custom JWT authentication for all wallets. Requires a custom JWT linked account.
    </ParamField>
  </Tab>
</Tabs>

## Creating wallets for existing users

Add additional embedded wallets to users who already have Privy accounts. This is useful when expanding to support new chains or creating wallets based on in-app actions.

<Tabs>
  <Tab title="NodeJS">
    To create embedded wallets for an existing user, use the `pregenerateWallets` method from the `users()` interface of the Privy client.

    ### Usage

    ```tsx  theme={"system"}
    const user = await privy.users().pregenerateWallets('did:privy:clddy332f002tyqpq3b3lv327', {
        wallets: [
            {
                chain_type: 'ethereum',
                wallet_index: 0,
            },
            {
                chain_type: 'solana',
                wallet_index: 0,
            }
        ],
        create_direct_signer: true
    });
    ```

    Check out the [API reference](/api-reference/users/pregenerate-wallets) for more details.
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    To create embedded wallets for an existing user, use the `createWallets` method from `PrivyClient`.

    ```javascript  theme={"system"}
    createWallets: ({userId: string, wallets?: WalletCreateRequestType[], createDirectSigner?: boolean}) => Promise<User>
    ```

    ### Usage

    ```tsx  theme={"system"}
    const user = await privy.createWallets({
        userId: 'did:privy:clddy332f002tyqpq3b3lv327',
        wallets: [
            {
                chainType: 'ethereum',
                walletIndex: 0,
            },
            {
                chainType: 'solana',
                walletIndex: 0,
            }
        ],
        createDirectSigner: true
    });
    ```

    ### Params

    <ParamField path="userId" type="string" required>
      The Privy user ID to create wallets for.
    </ParamField>

    <ParamField path="wallets" type="WalletCreateRequestType[]">
      An array of wallets to create for the user.

      <Expandable defaultOpen="true">
        <ParamField path="chainType" type="'ethereum' | 'solana' | 'stellar' | 'cosmos' | 'sui' | 'tron' | 'bitcoin-segwit' | 'near' | 'ton' | 'starknet' | 'movement'" required>
          The chain type of the wallet to create.
        </ParamField>

        <ParamField path="walletIndex" type="number">
          The HD wallet index to use for wallet generation. Defaults to `0`.
        </ParamField>

        <ParamField path="additionalSigners" type="object[]">
          <Expandable defaultOpen="true">
            <ParamField path="signerId" type="string">
              The ID of the signer.
            </ParamField>

            <ParamField path="overridePolicyIds" type="string[]">
              List of policy IDs for policies that should be enforced on the wallet. Currently, only one
              policy is supported per wallet.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField path="createSmartAccount" type="boolean">
          Set to `true` to create a smart account with the user's wallet as the signer. Can only be set
          on wallets where `chainType` is `ethereum`.
        </ParamField>
      </Expandable>
    </ParamField>

    <ParamField path="createDirectSigner" type="boolean">
      Set to `true` to create a UserSigner for custom JWT authentication for all wallets. Requires a custom JWT linked account.
    </ParamField>

    ### Returns

    <ResponseField name="user" type="User">
      The user with the newly created wallets.
    </ResponseField>
  </Tab>

  <Tab title="REST API">
    To pregenerate embedded wallets for an existing user, make a POST request to `https://auth.privy.io/api/v1/apps/<your-app-id>/users/wallet`.

    ### Usage

    Below is a sample cURL command for creating wallets for an existing user:

    ```sh  theme={"system"}
    $ curl --request POST https://auth.privy.io/api/v1/apps/<your-privy-app-id>/users/wallet \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H "Content-Type: application/json" \
    -d '{
    "user_id": "did:privy:clddy332f002tyqpq3b3lv327",
    "wallets": [
        {
            "chain_type": "ethereum",
            "wallet_index": 0,
            "policy_ids": ["<policy-id>"],
            "additional_signers": [
                {
                    "signer_id": "<signer-id>",
                    "override_policy_ids": ["<policy-id>"]
                }
            ]
        },
        {
            "chain_type": "solana",
            "wallet_index": 0
        }
    ],
    "create_direct_signer": true
    }'
    ```

    A successful response will include the updated user object with their newly created wallet addresses:

    ```json  theme={"system"}
        {
            "id": "did:privy:clddy332f002tyqpq3b3lv327",
            "created_at": 1674788927,
            "linked_accounts": [
                {
                    "address": "batman@privy.io",
                    "type": "email"
                },
                {
                    "address": "0x3DAF84b3f09A0E2092302F7560888dBc0952b7B7",
                    "type": "wallet",
                    "wallet_client": "privy",
                    "chain_type": "ethereum"
                },
                {
                    "address": "9KnvxKTx...",
                    "type": "wallet",
                    "wallet_client": "privy",
                    "chain_type": "solana"
                }
            ]
        }
    ```

    ### Parameters

    <ParamField path="user_id" type="string" required>
      The Privy user ID to create wallets for.
    </ParamField>

    <ParamField path="wallets" type="WalletCreateRequestType[]">
      An array of wallets to create for the user.

      <Expandable defaultOpen="true">
        <ParamField path="chain_type" type="'ethereum' | 'solana' | 'stellar' | 'cosmos' | 'sui' | 'tron' | 'bitcoin-segwit' | 'near' | 'ton' | 'starknet' | 'movement'" required>
          The chain type of the wallet to create.
        </ParamField>

        <ParamField path="wallet_index" type="number">
          The HD wallet index to use for wallet generation. Defaults to `0`.
        </ParamField>

        <ParamField path="policy_ids" type="string[]">
          List of policy IDs for policies that should be enforced on all transactions on the wallet, regardless of signer.
        </ParamField>

        <ParamField path="additional_signers" type="object[]">
          <Expandable defaultOpen="true">
            <ParamField path="signer_id" type="string">
              The ID of the signer.
            </ParamField>

            <ParamField path="override_policy_ids" type="string[]">
              List of policy IDs for policies specific to this signer. Currently, only one policy is supported per wallet.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField path="create_smart_account" type="boolean">
          Set to `true` to create a smart account with the user's wallet as the signer. Can only be set on wallets where `chain_type` is `ethereum`.
        </ParamField>
      </Expandable>
    </ParamField>

    <ParamField path="create_direct_signer" type="boolean">
      Set to `true` to create a UserSigner for custom JWT authentication for all wallets. Requires a custom JWT linked account.
    </ParamField>
  </Tab>
</Tabs>

## Batch importing users with wallets

Import multiple users with pregenerated wallets in a single batch operation. This is more efficient than creating users individually when provisioning wallets for hundreds or thousands of users at once.

<Tabs>
  <Tab title="REST API">
    To batch import multiple users with pregenerated wallets, make a POST request to `https://auth.privy.io/api/v1/apps/<your-app-id>/users/import`.

    ### Usage

    Below is a sample cURL command for batch importing users with pregenerated wallets:

    ```sh  theme={"system"}
    $ curl --request POST https://auth.privy.io/api/v1/apps/<your-privy-app-id>/users/import \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H "Content-Type: application/json" \
    -d '{
        "users": [
            {
                "linked_accounts": [
                    {
                        "address": "user1@example.com",
                        "type": "email"
                    }
                ],
                "wallets": [
                    {
                        "chain_type": "ethereum",
                        "wallet_index": 0,
                        "policy_ids": ["<policy-id>"],
                        "additional_signers": [
                            {
                                "signer_id": "<signer-id>",
                                "override_policy_ids": ["<policy-id>"]
                            }
                        ]
                    }
                ],
                "create_direct_signer": true
            },
            {
                "linked_accounts": [
                    {
                        "address": "user2@example.com",
                        "type": "email"
                    }
                ],
                "wallets": [
                    {
                        "chain_type": "solana",
                        "wallet_index": 0
                    }
                ],
                "create_direct_signer": false
            }
        ]
    }'
    ```

    A successful response will include an array of the newly created users with their wallet addresses:

    ```json  theme={"system"}
    {
        "users": [
            {
                "id": "did:privy:abc123",
                "created_at": 1674788927,
                "linked_accounts": [
                    {
                        "address": "user1@example.com",
                        "type": "email"
                    },
                    {
                        "address": "0x3DAF84b3f09A0E2092302F7560888dBc0952b7B7",
                        "type": "wallet",
                        "wallet_client": "privy",
                        "chain_type": "ethereum"
                    }
                ]
            },
            {
                "id": "did:privy:def456",
                "created_at": 1674788928,
                "linked_accounts": [
                    {
                        "address": "user2@example.com",
                        "type": "email"
                    },
                    {
                        "address": "9KnvxKTx...",
                        "type": "wallet",
                        "wallet_client": "privy",
                        "chain_type": "solana"
                    }
                ]
            }
        ]
    }
    ```

    ### Parameters

    <ParamField path="users" type="UserImportRequest[]" required>
      An array of user objects to import. Each object has the following fields:

      <Expandable defaultOpen="true">
        <ParamField path="linked_accounts" type="LinkedAccountType[]" required>
          An array of linked accounts to associate with the user.
        </ParamField>

        <ParamField path="custom_metadata" type="CustomMetadataType">
          Custom metadata to associate with the user.
        </ParamField>

        <ParamField path="wallets" type="WalletCreateRequestType[]">
          An array of wallets to create for the user.

          <Expandable defaultOpen="true">
            <ParamField path="chain_type" type="'ethereum' | 'solana' | 'stellar' | 'cosmos' | 'sui' | 'tron' | 'bitcoin-segwit' | 'near' | 'ton' | 'starknet' | 'movement'" required>
              The chain type of the wallet to create.
            </ParamField>

            <ParamField path="wallet_index" type="number">
              The HD wallet index to use for wallet generation. Defaults to `0`.
            </ParamField>

            <ParamField path="policy_ids" type="string[]">
              List of policy IDs for policies that should be enforced on all transactions on the wallet, regardless of signer.
            </ParamField>

            <ParamField path="additional_signers" type="object[]">
              <Expandable defaultOpen="true">
                <ParamField path="signer_id" type="string">
                  The ID of the signer.
                </ParamField>

                <ParamField path="override_policy_ids" type="string[]">
                  List of policy IDs for policies specific to this signer. Currently, only one policy is supported per wallet.
                </ParamField>
              </Expandable>
            </ParamField>

            <ParamField path="create_smart_account" type="boolean">
              Set to `true` to create a smart account with the user's wallet as the signer. Can only be set on wallets where `chain_type` is `ethereum`.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField path="create_direct_signer" type="boolean">
          Set to `true` to create a UserSigner for custom JWT authentication for all wallets. Requires a custom JWT linked account.
        </ParamField>
      </Expandable>
    </ParamField>
  </Tab>
</Tabs>

## What happens when users log in

When users log in for the first time after wallets have been pregenerated, the wallets automatically appear in their account. Users can immediately access these wallets and any assets that were sent to them.

These wallets work identically to wallets created during login. Users can sign transactions, view balances, and manage their assets through the standard application interface.


# null
Source: https://docs.privy.io/recipes/react-native/clearing-state-on-fresh-installs



The React Native SDK for Privy stores session state in the Expo Secure Store, powered by the Keychain on iOS.
This means that when a user reinstalls your app, Privy is able to restore their existing session.

This is great for user experience, and is standard behavior for iOS apps throughout.
However, there are some cases where you may want to clear the state on a fresh install.

## Log out the user on a fresh install

To do this, you should keep a flag in your app's storage, one that you can check to see if the app has been reinstalled, and set it on first launch.

First, install the `@react-native-async-storage/async-storage` package, as a way to store the flag in your app's storage in a way that it does not persist across app reinstalls.

```sh  theme={"system"}
npx expo install @react-native-async-storage/async-storage
```

Then, in your app, you can check for a fresh install and clear the state on a fresh install.
Make sure to run this code in the root of your app, so it runs as soon as the app is launched, like so:

```ts  theme={"system"}
import {useEffect} from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import {usePrivy} from '@privy-io/expo';

// ...

const {logout} = usePrivy();

useEffect(() => {
  const checkForFreshInstall = async () => {
    const hasLaunchedBefore = await AsyncStorage.getItem('hasLaunchedBefore');
    if (!hasLaunchedBefore) {
      await AsyncStorage.setItem('hasLaunchedBefore', 'true');
      await logout();
    }
  };
  checkForFreshInstall();
}, [logout]);
```

This will clear the state on a fresh install, but ensure state is restored on subsequent launches.

### My app is already in production

If your application is already deployed in production, note that this will also **log out every user the first time** they launch after this update, as if it were a fresh install.

This can be circumvented by doing an intermediate release first, that includes the `setItem` logic only, but not the `logout` call yet.

```ts  theme={"system"}
import AsyncStorage from '@react-native-async-storage/async-storage';

const checkForFreshInstall = async () => {
  const hasLaunchedBefore = await AsyncStorage.getItem('hasLaunchedBefore');
  if (!hasLaunchedBefore) {
    await AsyncStorage.setItem('hasLaunchedBefore', 'true');
    // No logout in this release, add it in the next release.
  }
};
```

This ensures that no users are logged out on the first launch after this update, and that they will be ready for the next update.


# Deeplinking Solana wallets in React Native applications
Source: https://docs.privy.io/recipes/react-native/deeplinking-wallets



If your Expo mobile app uses Privy, you can implement wallet deeplinking to allow your users to connect their existing mobile wallets (like Phantom) with a seamless experience. This guide will walk you through the steps to set up wallet deeplinking in your Privy Expo app.

## 0. Setup

This guide assumes that you have already integrated Privy into your React native app. If you have not yet set up the basic integration, please first follow the [Privy quickstart](/basics/react-native/quickstart).

## 1. Install required packages

First, make sure you have the necessary dependencies:

```bash  theme={"system"}
npm install @privy-io/expo @privy-io/expo/connectors
```

## 2. Import the wallet connector hooks

Import the wallet connector hooks in your component:

```tsx  theme={"system"}
import {
  useDeeplinkWalletConnector,
  usePhantomDeeplinkWalletConnector,
  useBackpackDeeplinkWalletConnector
} from '@privy-io/expo/connectors';
```

Privy Expo provides several hooks for wallet deeplinking:

| Hook                                 | Description                                                                       |
| ------------------------------------ | --------------------------------------------------------------------------------- |
| `useDeeplinkWalletConnector`         | A generic wallet deeplinking connector that you can configure for various wallets |
| `usePhantomDeeplinkWalletConnector`  | A pre-configured connector specifically for Phantom wallet                        |
| `useBackpackDeeplinkWalletConnector` | A pre-configured connector specifically for Backpack wallet                       |

## 3. Set up the wallet connector

<Tabs>
  <Tab title="Phantom">
    To set up the Phantom wallet connector, use the `usePhantomDeeplinkWalletConnector` hook in your component:

    ```tsx  theme={"system"}
    export default function LoginScreen() {
      const {
        address,
        connect,
        disconnect,
        isConnected,
        signMessage,
        signTransaction,
        signAllTransactions,
        signAndSendTransaction
      } = usePhantomDeeplinkWalletConnector({
        appUrl: 'https://yourdapp.com',
        redirectUri: '/sign-in'
      });

      // Your component code here
    }
    ```

    ### Configuration options

    The `usePhantomDeeplinkWalletConnector` hook accepts the following configuration:

    | Parameter     | Type     | Description                                                                                                |
    | ------------- | -------- | ---------------------------------------------------------------------------------------------------------- |
    | `appUrl`      | `string` | The URL of your app that will be displayed in the wallet app as the requesting dapp, for metadata purposes |
    | `redirectUri` | `string` | The path in your app that the wallet should redirect to after completing an action                         |
  </Tab>

  <Tab title="Backpack">
    To set up the Backpack wallet connector, use the `useBackpackDeeplinkWalletConnector` hook in your component:

    ```tsx  theme={"system"}
    export default function LoginScreen() {
      const {
        address,
        connect,
        disconnect,
        isConnected,
        signMessage,
        signTransaction,
        signAllTransactions,
        signAndSendTransaction
      } = useBackpackDeeplinkWalletConnector({
        appUrl: 'https://yourdapp.com',
        redirectUri: '/sign-in'
      });

      // Your component code here
    }
    ```

    ### Configuration options

    The `useBackpackDeeplinkWalletConnector` hook accepts the following configuration:

    | Parameter     | Type     | Description                                                                                                |
    | ------------- | -------- | ---------------------------------------------------------------------------------------------------------- |
    | `appUrl`      | `string` | The URL of your app that will be displayed in the wallet app as the requesting dapp, for metadata purposes |
    | `redirectUri` | `string` | The path in your app that the wallet should redirect to after completing an action                         |
  </Tab>

  <Tab title="Other wallet providers">
    If you want to integrate with wallets other than Phantom or Backpack, you can use the generic `useDeeplinkWalletConnector` hook and configure it for your specific wallet:

    ```tsx  theme={"system"}
    export default function LoginScreen() {
      const {
        address,
        connect,
        disconnect,
        isConnected,
        signMessage,
        signTransaction,
        signAllTransactions,
        signAndSendTransaction
      } = useDeeplinkWalletConnector({
        // Base URL for the wallet
        baseUrl: 'https://solflare.com',
        // The name of the public key used for encryption
        encryptionPublicKeyName: 'solflare_encryption_public_key',
        // Other wallet-specific configuration
        appUrl: 'https://yourdapp.com',
        redirectUri: '/sign-in'
      });

      // Your component code here
    }
    ```

    ### Configuration options

    The generic `useDeeplinkWalletConnector` hook accepts the following wallet-specific configuration parameters:

    | Parameter                 | Type     | Description                                                                                                                                                   |
    | ------------------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | `baseUrl`                 | `string` | The base URL for the wallet's deeplink protocol. This is typically the wallet's website URL or a custom URL scheme (e.g., `https://solflare.com`).            |
    | `encryptionPublicKeyName` | `string` | The name of the key in localStorage where the wallet stores its encryption public key. This is used for secure communication between your app and the wallet. |
    | `appUrl`                  | `string` | The URL of your app that will be displayed in the wallet app as the requesting dapp, for metadata purposes                                                    |
    | `redirectUri`             | `string` | The path in your app that the wallet should redirect to after completing an action                                                                            |

    <Info>
      Always refer to the wallet provider's documentation for the specific deeplink protocol
      implementation and required parameters. Each wallet may implement deeplinking differently and
      require specific configuration values.
    </Info>
  </Tab>
</Tabs>

## 4. Using the connector in your UI

Now you can implement UI components to interact with the wallet:

```tsx  theme={"system"}
return (
  <View>
    <H4>Wallet Deeplinking</H4>
    <Text>Connected: {isConnected ? 'true' : 'false'}</Text>

    {!isConnected && <Button onPress={() => connect()}>Connect Wallet</Button>}

    {isConnected && (
      <>
        <Text>Address: {address}</Text>
        <Button onPress={() => disconnect()}>Disconnect</Button>
        <Button onPress={handleSignMsg}>Sign message</Button>
        <Button onPress={handleSignTx}>Sign transaction</Button>
        <Button onPress={handleSignAndSendTx}>Sign and send transaction</Button>
        <Button onPress={handleSignAllTxs}>Sign all transactions</Button>
      </>
    )}
  </View>
);
```

## 5. Implementing the wallet functions

Here are examples of how to implement the handler functions for various wallet actions:

```tsx  theme={"system"}
// Function to handle message signing
const handleSignMsg = async () => {
  try {
    const message = 'Hello, Privy Expo!';
    const signature = await signMessage(message);
    console.log('Message signed:', signature);
  } catch (error) {
    console.error('Error signing message:', error);
  }
};

// Function to handle transaction signing
const handleSignTx = async () => {
  try {
    // Create a transaction
    const transaction = new Transaction().add(
      SystemProgram.transfer({
        fromPubkey: new PublicKey(address),
        toPubkey: new PublicKey('DESTINATION_ADDRESS'),
        lamports: LAMPORTS_PER_SOL * 0.01
      })
    );

    const signedTx = await signTransaction(transaction);
    console.log('Transaction signed:', signedTx);
  } catch (error) {
    console.error('Error signing transaction:', error);
  }
};

// Function to handle signing and sending a transaction
const handleSignAndSendTx = async () => {
  try {
    const transaction = new Transaction().add(
      SystemProgram.transfer({
        fromPubkey: new PublicKey(address),
        toPubkey: new PublicKey('DESTINATION_ADDRESS'),
        lamports: LAMPORTS_PER_SOL * 0.01
      })
    );

    const signature = await signAndSendTransaction(transaction);
    console.log('Transaction sent:', signature);
  } catch (error) {
    console.error('Error sending transaction:', error);
  }
};

// Function to handle signing multiple transactions
const handleSignAllTxs = async () => {
  try {
    const transactions = [
      new Transaction().add(
        SystemProgram.transfer({
          fromPubkey: new PublicKey(address),
          toPubkey: new PublicKey('DESTINATION_ADDRESS_1'),
          lamports: LAMPORTS_PER_SOL * 0.01
        })
      ),
      new Transaction().add(
        SystemProgram.transfer({
          fromPubkey: new PublicKey(address),
          toPubkey: new PublicKey('DESTINATION_ADDRESS_2'),
          lamports: LAMPORTS_PER_SOL * 0.01
        })
      )
    ];

    const signedTxs = await signAllTransactions(transactions);
    console.log('Transactions signed:', signedTxs);
  } catch (error) {
    console.error('Error signing transactions:', error);
  }
};
```

<Info>
  The configuration for the generic connector will depend on the specific wallet you're integrating
  with. Refer to each wallet's documentation for their deeplinking protocol.
</Info>

## How deeplinking works

When a user interacts with your app:

1. Your app initiates a connection request using the `connect()` function
2. The user is directed to their installed wallet app
3. The user approves or denies the action in their wallet
4. The wallet redirects back to your app with the result
5. Your app updates its state based on the wallet's response

This flow provides a seamless experience for users, allowing them to interact with your dApp using their preferred wallet without having to switch contexts or manually copy addresses.

**That's it! You've successfully integrated wallet deeplinking in your Privy React Native app 🎉**

<Info>
  For the best user experience, consider implementing fallbacks for when a user doesn't have the
  wallet installed. You might prompt them to install the wallet or offer them an alternative login
  method.
</Info>


# Configure allowed OAuth redirect URLs
Source: https://docs.privy.io/recipes/react/allowed-oauth-redirects



Similar to allowed domains, you can configure **allowed OAuth redirect URLs** to restrict where users can be redirected after they log in with an external OAuth provider. This is a **security best practice** that prevents users from being redirected to malicious sites with their authentication token. To configure allowed OAuth redirect URLs, navigate to **Configuration > App settings** > **Advanced** on the [dashboard](https://dashboard.privy.io?page=settings\&tab=advanced\&setting=advanced). Add the OAuth providers are allowed to redirect to after authentication.

Please note:

* The URL must be an exact match for the redirect URL; query params and trailing slashes will error.
* The URL must be at a domain listed in allowed domains.
* The protocol (`https`) is required.
* Wildcards (`*`) are not supported.
* If no URLs are listed, users can be redirected to any URL.


# Chrome extension authentication
Source: https://docs.privy.io/recipes/react/chrome-extension



This guide shows you how to implement Privy authentication and wallets in your Chrome extension using Privy's React SDK. Chrome extensions offer a unique application experience for your users, but come with some unique nuances specifically around social login.

## Resources

<CardGroup cols={3}>
  <Card title="Chrome Extension Starter" icon="github" href="https://github.com/privy-io/examples/tree/main/examples/privy-react-chrome-extension" arrow>
    Complete starter repository with Privy authentication and wallet management.
  </Card>
</CardGroup>

## Set up your Chrome extension project

First, create a React app and install Privy:

```bash  theme={"system"}
npm create react-app my-extension
cd my-extension
npm install @privy-io/react-auth
```

Create your `manifest.json` file in the `public` directory:

```json  theme={"system"}
{
  "manifest_version": 3,
  "name": "My Extension with Privy",
  "version": "1.0",
  "description": "Chrome extension with Privy authentication",
  "permissions": ["identity"],
  "host_permissions": ["https://auth.privy.io/*"],
  "action": {
    "default_popup": "index.html",
    "default_title": "My Extension"
  },
  "options_page": "options.html",
  "content_security_policy": {
    "extension_pages": "script-src 'self'; object-src 'self'; frame-ancestors 'none';"
  }
}
```

<Warning>
  The `identity` permission is required for OAuth flows, and `storage` is recommended for persisting
  user sessions.
</Warning>

### Security Guidelines

Below are comprehensive security guidelines for Chrome extensions. You can find more information in the [Chrome extension security documentation](https://developer.chrome.com/docs/extensions/develop/security-privacy/stay-secure).

<Accordion title="Security best practices">
  #### Content Security Policy

  Add a strict CSP to your manifest to prevent code injection and framing attacks. You can see our broader CSP guidance [here](/security/implementation-guide/content-security-policy).

  ```json  theme={"system"}
  {
    "content_security_policy": {
      "extension_pages": "script-src 'self'; object-src 'self'; frame-ancestors 'none';"
    }
  }
  ```

  <Warning>
    The `frame-ancestors 'none'` directive prevents your extension from being embedded in frames,
    protecting against clickjacking attacks.
  </Warning>

  #### Minimal permissions

  Only request permissions your extension actually needs. Limiting permissions reduces attack surface if compromised:

  ```json  theme={"system"}
  {
    "permissions": ["identity"],
    "host_permissions": ["https://auth.privy.io/*"]
  }
  ```

  **Cross-origin fetch() restrictions:**
  Extensions can only use `fetch()` and `XMLHttpRequest()` to access domains specified in `host_permissions`. If the extension were compromised, it would still only have permission to interact with websites that meet the match pattern. The attacker would only have limited ability to access sites not in this list.

  ```json  theme={"system"}
  {
    "host_permissions": ["https://auth.privy.io/*", "https://api.yourservice.com/*"]
  }
  ```

  <Tip>
    Remove unused permissions like `tabs`, `activeTab`, or broad host permissions to reduce your
    extension's attack surface and improve user trust.
  </Tip>

  #### Externally connectable

  Restrict which external extensions and web pages can communicate with your extension:

  ```json  theme={"system"}
  {
    "externally_connectable": {
      "ids": ["allowedextensionidheredata"],
      "matches": ["https://yourtrustedsite.com/*"],
      "accepts_tls_channel_id": false
    }
  }
  ```

  <Warning>
    Only include trusted sources in `externally_connectable`. This prevents malicious sites from
    communicating with your extension.
  </Warning>

  #### Web-accessible resources

  Minimize web-accessible resources as they make your extension detectable and create attack vectors:

  ```json  theme={"system"}
  {
    "web_accessible_resources": [
      {
        "resources": ["images/icon.png"],
        "matches": ["https://yourtrustedsite.com/*"]
      }
    ]
  }
  ```

  <Tip>
    Keep web-accessible resources to a minimum. Each exposed resource increases potential attack
    surface.
  </Tip>

  #### Secure DOM manipulation

  Avoid `document.write()` and `innerHTML` which can lead to script injection:

  #### Validate all inputs

  Always validate and sanitize inputs, especially from content scripts:

  ```javascript  theme={"system"}
  chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    // Validate sender is from your extension
    if (sender.id !== chrome.runtime.id) return;

    // Validate and sanitize request data
    if (request.action === 'updateUser' && typeof request.userData === 'object') {
      // Process validated data
      updateUser(request.userData);
    }
  });
  ```

  <Info>
    Content scripts can be compromised by malicious websites, so treat all messages from content
    scripts as potentially malicious.
  </Info>
</Accordion>

***

## Configure your Privy dashboard

<Info>
  You'll get your extension ID after loading the extension in Chrome's developer mode at
  `chrome://extensions/`.
</Info>

In the [Privy dashboard](https://dashboard.privy.io/apps?setting=domains\&page=settings), configure OAuth settings for your extension:

**1. Add allowed origins**

Go to **App Settings > Domains** and add:

```
chrome-extension://<your-extension-id>
```

**2. (Optional) Configure redirect URLs**

<Tip>Use `chrome.identity.getRedirectURL()` to get the exact redirect URL programmatically.</Tip>

If your extension uses social login, you'll need to configure redirect URLs.

In your allowed domains, add the following redirect URL, and additionally in your [allowed redirect URLs](https://dashboard.privy.io/apps?setting=advanced\&page=settings)

```
https://<your-extension-id>.chromiumapp.org/
```

***

## Enabling social login in your extension

Chrome extensions can't handle social OAuth flows directly in the popup due to security restrictions. **Social login requires opening either the options page or a popup window.** This provides the full browser context needed for OAuth redirects.

Both approaches follow the same flow:

1. User clicks "Sign in with social" in extension
2. Open authentication context (options page or popup window)
3. Privy handles the OAuth flow
4. User is redirected back to the extension authenticated

<Steps>
  <Step title="User initiates social login">
    ### Approach 1: Options page

    **Setup:** Add to your manifest:

    ```json  theme={"system"}
    {"options_page": "options.html"}
    ```

    **Implementation:**

    ```tsx  theme={"system"}
    // In your popup component
    const openOptionsForLogin = () => {
      chrome.tabs.create({
        url: chrome.runtime.getURL('options.html')
      });
    };
    ```

    ### Approach 2: Popup window

    **Implementation:**

    ```tsx  theme={"system"}
    // In your popup component
    const openAuthWindow = () => {
      chrome.windows.create({
        url: chrome.runtime.getURL('auth.html'),
        type: 'popup',
        width: 400,
        height: 600
      });
    };
    ```
  </Step>

  <Step title="Open authentication context (options page or popup window)">
    Both approaches use the same authentication logic:

    <Tip>
      You can use the same `AuthComponent` for both approaches - just render it in different HTML files
      (options.html or auth.html).
    </Tip>

    ```tsx  theme={"system"}
    // src/auth/AuthComponent.tsx
    import {PrivyProvider, usePrivy, useLogin} from '@privy-io/react-auth';
    import {useEffect} from 'react';

    const AuthContent = () => {
      const {authenticated, ready} = usePrivy();
      const {login} = useLogin({
        onComplete: () => {
          // Open the extension popup after authentication
          chrome.tabs.query({active: true, currentWindow: true}, (tabs) => {
            if (tabs[0]) {
              // Open the extension popup
              chrome.action.openPopup();
            }
          });
        }
      });

      // Auto-trigger login when opened for authentication
      useEffect(() => {
        if (ready && !authenticated) {
          login();
        }
      }, [authenticated, ready]);

      return null;
    };

    export const AuthComponent = () => (
      <PrivyProvider
        appId="<INSERT_YOUR_APP_ID_HERE>"
        config={{
          appearance: {
            loginMethods: ['google', 'apple', 'email', 'sms', 'twitter']
          }
        }}
      >
        <AuthContent />
      </PrivyProvider>
    );
    ```
  </Step>

  <Step title="Redirect back to the extension">
    Redirect the user back to the extension after authentication.

    ```tsx  theme={"system"}
        onComplete: () => {
          // Open the extension popup after authentication
          chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
            if (tabs[0]) {
              // Open the extension popup
              chrome.action.openPopup();
            }
          });
        },
    ```
  </Step>
</Steps>

***

## That's it! 🎉

You've now implemented Privy authentication in your Chrome extension.

***

## Production considerations

Before publishing to the Chrome Web Store:

1. **Remove unnecessary permissions** from manifest
2. **Limit host permissions** to only required domains
3. **Minimize web-accessible resources** to reduce attack surface
4. **Implement strict CSP** with `frame-ancestors 'none'`
5. **Validate all inputs** from content scripts and external sources
6. **Update OAuth configuration** with production URLs in Privy dashboard
7. **Review externally connectable** settings for trusted domains only

<Tip>
  Chrome extensions with OAuth require Google's review. Document your authentication flow and
  privacy practices clearly in your Web Store listing. Follow the [Chrome Web Store security best
  practices](https://developer.chrome.com/docs/extensions/develop/security-privacy/stay-secure) for
  faster approval.
</Tip>


# Configuring external connectors
Source: https://docs.privy.io/recipes/react/configuring-external-connectors



Privy supports connecting external wallet on both EVM networks (e.g. MetaMask, Rainbow) and Solana (e.g. Phantom, Solflare) to your application to request signatures and transactions.

## Configuring connectors

<Tabs>
  <Tab title="EVM">
    To connect external wallets on EVM networks, there is **no additional configuration** required for your app. Simply continue with the instructions below to prompt connections to external EVM wallets, like MetaMask or Coinbase Wallet.
  </Tab>

  <Tab title="Solana">
    To connect external wallets on Solana, your application must first explicitly **configure Solana connectors** for Privy. To do so:

    1. Import and configure the `toSolanaWalletConnectors` function from `@privy-io/react-auth/solana`
    2. Enable `'solana-only'` or `'ethereum-and-solana'` as the `config.appearance.walletChainType` prop of your `PrivyProvider`

    <Info>
      You do not need to configure `config.solana.rpcs` for external wallets. RPC clients under
      `solana.rpcs` are only required when using Privy's embedded wallet UIs (UI `signTransaction` and
      `signAndSendTransaction`).
    </Info>

    As an example, you might set up your `PrivyProvider` like so:

    ```tsx  theme={"system"}
    import {toSolanaWalletConnectors} from '@privy-io/react-auth/solana';
    import {createSolanaRpc, createSolanaRpcSubscriptions} from '@solana/kit';

    const solanaConnectors = toSolanaWalletConnectors({
      // By default, shouldAutoConnect is enabled
      shouldAutoConnect: true
    });

    const Provider: React.FC<PropsWithChildren> = ({children}) => {
      return (
        <PrivyProvider
          config={{
            solana: {
              rpcs: {
                // Only needed if you need to use Privy wallets for sending transactions
                'solana:mainnet': {
                  rpc: createSolanaRpc('https://api.mainnet-beta.solana.com'), // or your custom RPC endpoint
                  rpcSubscriptions: createSolanaRpcSubscriptions('wss://api.mainnet-beta.solana.com') // or your custom RPC endpoint
                }
              }
            },
            appearance: {
              // Use 'solana-only' or 'ethereum-and-solana'
              walletChainType: 'solana-only'
            },
            externalWallets: {
              solana: {
                connectors: solanaConnectors
              }
            }
          }}
        >
          {children}
        </PrivyProvider>
      );
    };
    ```

    Note that some Solana wallet connectors do not gracefully support `autoConnect`, which will result in an extension pop-up on page load. If you would like to disable this feature, set it to `false` in the `toSolanaWalletConnectors` function.
  </Tab>
</Tabs>

## Connecting the wallet

To prompt a user to connect an external wallet (on EVM networks or Solana) to your app, use Privy's **`connectWallet`** method:

```tsx  theme={"system"}
import {usePrivy} from '@privy-io/react-auth';

const {connectWallet} = usePrivy();
```

This method will prompt the user to select the wallet they want to connect, and will show users EVM and/or Solana external wallet options based off of the `config.appearance.walletChainType` configured in your app's `PrivyProvider`. You can prompt users to connect as many wallets as you'd like to your app.

For example, you might have a "Connect" button in your app that prompts users to connect their wallet, like so:

```tsx  theme={"system"}
import {usePrivy} from '@privy-io/react-auth';

export default function ConnectWalletButton() {
  const {connectWallet} = usePrivy();
  // Prompt user to connect a wallet with Privy modal
  return <button onClick={connectWallet}>Connect wallet</button>;
}
```

As an optional parameter to `connectWallet`, you may pass an object with the following optional fields:

| Field         | Type                | Description                                                                            |
| ------------- | ------------------- | -------------------------------------------------------------------------------------- |
| `description` | `string`            | A description for the wallet connection prompt, which will be displayed in Privy's UI. |
| `walletList`  | `WalletListEntry[]` | A list of wallet optionsthat you would like Privy to display in the connection prompt. |

<Tabs>
  <Tab title="EVM">
    ```tsx  theme={"system"}
    connectWallet({
      description: 'Connect your wallet to access the app',
      walletList: ['metamask', 'safe']
    });
    ```
  </Tab>

  <Tab title="Solana">
    ```tsx  theme={"system"}
    connectWallet({
      description: 'Connect your wallet to access the app',
      walletList: ['phantom', 'solflare']
    });
    ```
  </Tab>
</Tabs>

Once a user has connected their external wallet to your app, the wallet will appear in either of Privy's **`useWallets`** arrays, which you can then use to request signatures and transactions from the connected wallet.

## Connecting or creating a wallet

You can also use Privy to connect a user's external wallet if they have one, or to create an embedded wallet for them if they do not. To do so, use the **`connectOrCreateWallet`** method of the **`usePrivy`** hook:

```tsx  theme={"system"}
const {connectOrCreateWallet} = usePrivy();
```

This method will prompt the user to connect an external wallet, or log in with email, SMS, or socials, depending on your configured `loginMethods`, to create an embedded wallet.

<Info>
  Privy's `connectOrCreate` interface currently only supports external and embedded wallets on EVM
  networks.
</Info>

For example, you might have a "Connect" button in your app that prompts users to connect their wallet, like so:

```tsx  theme={"system"}
import {usePrivy} from '@privy-io/react-auth';

export default function ConnectWalletButton() {
  const {connectOrCreateWallet} = usePrivy();
  // Prompt user to connect a wallet with Privy modal
  return <button onClick={connectOrCreateWallet}>Connect wallet</button>;
}
```

<Tip>
  This method functions exactly the same as Privy's `login` method, except when users connect their
  external wallet, they will not automatically be prompted to authenticate that wallet by signing a
  message
</Tip>

## Authenticating a connected wallet

Once a user has connected their wallet to your app, and the wallet is available in either of the **`useWallets`** arrays, you can also prompt them to **login** with that wallet or **link** that wallet to their existing account, instead of prompting the entire **`login`** or **`linkWallet`** flow.

To do so, find the **`ConnectedWallet`** or **`ConnectedStandardSolanaWallet`** object from Privy, and call the object's **`loginOrLink`** method for EVM wallets and use the **`useLoginWithSiws`** or **`useLinkWithSiws`** hooks for the Solana wallets:

<Tabs>
  <Tab title="EVM">
    ```tsx  theme={"system"}
    import {useWallets} from '@privy-io/react-auth';

    const {wallets} = useWallets();

    wallets[0].loginOrLink();
    ```
  </Tab>

  <Tab title="Solana">
    ```tsx  theme={"system"}
    import {useWallets} from '@privy-io/react-auth/solana';

    const {wallets} = useWallets();
    const {generateSiwsMessage, loginWithSiws} = useLoginWithSiws();

    const message = await generateSiwsMessage({address: wallets[0].address});
    const encodedMessage = new TextEncoder().encode(message);
    const results = await wallets[0].signMessage({message: encodedMessage});
    const signatureBase64 = Buffer.from(results.signature).toString('base64');
    await loginWithSiws({message, signature: signatureBase64});
    ```
  </Tab>
</Tabs>

When called, **`loginOrLink`** will directly request a [SIWE](https://docs.login.xyz/general-information/siwe-overview/eip-4361) signature from the user's connected wallet to authenticate the wallet.

If the user was not **`authenticated`** when the method was called, the user will become **`authenticated`** after signing the message.

If the user was already **`authenticated`** when the method was called, the user will remain **`authenticated`** after signing the message, and the connected wallet will become one of the user's **`linkedAccounts`** in their **`user`** object.

You might use the methods above to "split up" the connect and sign steps of external wallet login, like so:

<Tabs>
  <Tab title="EVM">
    ```tsx  theme={"system"}
    import {useConnectWallet, useWallets} from '@privy-io/react-auth';

    export default function WalletButton() {
      const {connectWallet} = useConnectWallet();
      const {wallets} = useWallets();

      // Prompt user to connect a wallet with Privy modal
      return (
        <>
          {/* Button to connect wallet */}
          <button onClick={connectWallet}>
              Connect wallet
          </button>
          {/* Button to login with or link the most recently connected wallet */}
          <button
            disabled={!wallets[0]}
            onClick={() => { wallets[0].loginOrLink() }}
          >
            Login with wallet
          </button>
        </>
      );
    }
    ```
  </Tab>

  <Tab title="Solana">
    ```tsx  theme={"system"}
    import {useConnectWallet, useLoginWithSiws} from '@privy-io/react-auth';
    import {useWallets} from '@privy-io/react-auth/solana';

    export default function WalletButton() {
      const {connectWallet} = useConnectWallet();
      const {wallets} = useWallets();
      const {generateSiwsMessage, loginWithSiws} = useLoginWithSiws()

      // Prompt user to connect a wallet with Privy modal
      return (
        {/* Button to connect wallet */}
        <button onClick={connectWallet}>
          Connect wallet
        </button>
        {/* Button to login with or link the most recently connected wallet */}
        <button
          disabled={!wallets[0]}
          onClick={async () => {
            const message = await generateSiwsMessage({address: wallets[0].address})
            const encodedMessage = new TextEncoder().encode(message)
            const results = await wallets[0].signMessage({message: encodedMessage})
            const signatureBase64 = Buffer.from(results.signature).toString('base64');
            await loginWithSiws({message, signature: signatureBase64})
          }}
        >
          Login with wallet
        </button>
      );
    }
    ```
  </Tab>
</Tabs>


# Configure cookies
Source: https://docs.privy.io/recipes/react/cookies



When a user logs in to your app, Privy issues that user an access token that stores their authenticated session. **You can configure Privy to store a user's access token either with a browser's [local storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage) or as a [`HttpOnly` cookie](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies) set on your app's base domain**.

By default, Privy will store the user's access token in local storage. Configuring cookies requires that your app have a stable base domain and that you set a DNS record for this domain. In kind, **cookies are recommended for production applications only**.

While developing your integration, you can use Privy's default setup of local storage to get started.

## Enabling cookies

To configure your app to use cookies, follow the steps below:

### 1. Create separate development and production Privy app IDs

In the [**Privy Dashboard**](https://dashboard.privy.io/), create (at minimum) **two** Privy apps. Concretely, you should create one app for use in **production** environments only, and one app for use in **development** environments only.

This step is critical, as once you enable cookies, your production app ID will **only** work in your production environment, and will error in all other environments.

<Info>
  The development process for all environments (production and development) will be the same on your
  end. The only difference is that you **must** use separate app IDs for each environment.
</Info>

Next, follow the steps below, **only for your production app ID**. Do not complete them for your development app.

### 2. For your production app, register your production domain in the Privy Dashboard

In the [**Privy Dashboard**](https://dashboard.privy.io/), find your **production app** in the App Dropdown of the left sidebar. Then, navigate to the **Configuration > App settings** page > **Domains** tab for that app.

Toggle on **HttpOnly cookies**. You'll be prompted to add an app domain. This is the domain root of your web app (e.g. example.com). Do not include the protocol or [www](http://www).

**Do not list a domain that is not a production domain.** As a general rule, our team will not automatically approve domains that appear to be scoped to a sandbox environment. Example of such unsupported domains include `*.vercel.app`, `*.railway.app`, `*.herokuapp.com`, and `*.amazonaws.com`.

### 3. For your production domain, set the necessary DNS records

Once you've set your app's domain in **Configuration >> App settings >> Domains**, Privy will display any required DNS records you must set for that for that domain. **Go to the admin dashboard of your domain registrar and set the required DNS records.**

Once done, return to the **HttpOnly cookies** section in the **Privy Dashboard** and click the **Refresh** button on your domain. This will force Privy to re-verify if the correct DNS records have been set for that domain or not. Please note that it may take a few hours for DNS records to propagate before Privy can confirm that it is verified.

This allows Privy's servers to set a first-party cookie on your production domain.

**Once you've finished the steps above, Privy will review your request and update servers to begin setting cookies on your production app's domain.**

<Info>
  Once your domain is verified, the corresponding App ID can only be used on that **exact**
  production domain.
</Info>

<Info>
  If using Cloudflare as your DNS records provider, make sure that the registered DNS record is
  **not** set to **Proxied**, and is set to **DNS Only** until the domain verification is complete.
</Info>

### App clients and cookies

Each app can only have one **cookie domain**. If you share an app ID across web and mobile environments, you can use app clients to conditionally enforce cookies depending on the environment. For example, you can have an app client that enforces cookies for your web app, and an app client that does not enforce it for your mobile app.

To toggle cookie settings for different app clients, first set your **HttpOnly Cookies** and an app domain. Then, go to the **Configuration > App settings** page > **Clients** tab, and find the **App client** you’d like to enable cookies for. Select “edit”, set the cookies toggle to **Enabled**, and save.

If you enable cookies in an app client, but no base domain is set on your app, no cookies will be set.

<Tip>
  Within an app client, you can choose to enable or disable cookies. If you enable cookies for any
  client, they will be set on the domain that is configured as your app’s **domain**.
</Tip>

### Debugging DNS issues

#### CAA records block issuance

Some providers may require extra configuration in order to set up SSL for your base domain to work with Privy. If you are seeing the error "CAA records block issuance" in the Privy dashboard or you keep trying to set an `acme_challenge` and state resets, you might either:

1. Already have CAA record that does not include one of the CAs Privy uses to issue SSL certs
2. Need to explicitly set a CAA record

To resolve this, go to your provider and create a `CAA` record on your root domain (ie `example.com`, not including any subdomains). If there are already contents in the `CAA` record, append the following, otherwise create a new record containing the following:

```
# Let's Encrypt
0 issue "letsencrypt.org"
0 issuewild "letsencrypt.org"

# Google Trust Services
0 issue "pki.goog; cansignhttpexchanges=yes"
0 issuewild "pki.goog; cansignhttpexchanges=yes"
```

#### The hostname is associated with a held zone

If you use Cloudflare as a DNS provider and have "held" your zone for security reasons, you will need to temporarily [release the hold](https://developers.cloudflare.com/fundamentals/setup/account/account-security/zone-holds/#release-zone-holds).

## Using cookies in development

In **both production and development** (local, preview, staging) environments, Privy will set a cookie with the name `privy-token` to store your user's session. **Your app logic for handling the cookie (e.g. in your authorization middleware) does not need to handle different environments differently.**

The mechanics of *how the cookie is set* is the key difference between production and development environments. This is why you **must only use your production App ID within your production environment**.

Concretely:

* For your **production** app ID, once you have completed the steps above, Privy's **servers** will set a cookie, only on the domain you have verified and any subdomains. Cookies will not be set on localhost.
* For your **development** app ID(s), Privy's **client** will automatically set a cookie on *any* domain you use this App ID on, including localhost. This allows you to use the same app logic around cookies across various environments. As a security precaution, client-set cookies for development have a shorter lifetime (7 days, versus 30 days for server-set cookies).

We recommend maintaining two apps, one for development and one for production. However, if you need to develop with your production App ID in a `localhost` environment, you can do so by using [App Clients](/basics/get-started/dashboard/app-clients).

## Server-side rendering

With cookies, when an authenticated user visits a page of your app, the request to fetch the page from your server will automatically include the user's access token as a **`privy-token`** cookie.

If your app uses **server-side rendering (SSR)**, you can use the presence of this cookie (and other Privy cookies) to determine if the user is authenticated *before* your page is rendered on the client.

### When the `privy-token` is present

Concretely, if the request to your server includes a valid **`privy-token`**, you should consider the user as authenticated and should handle them accordingly.

### When the `privy-token` is absent

If the request to your server does *not* include a valid **`privy-token`**, the user might either:

* be unauthenticated, and will need to **`login`** to become unauthenticated.
* *appear* as unauthenticated, and will need to wait for the page to be rendered in their client before you can determine if they are authenticated.

The latter case generally occurs when an authenticated user steps away from your app for more than an hour, allowing the access token to expire, and returns to your app for the first time. In this case, the request to fetch the page from your server will **not** include a valid **`privy-token`**, as it has expired, but the **`privy-token`** will be refreshed imminently as soon as the page loads in the user's browser.

To handle this case, when the **`privy-token`** is missing in the request, you should **instead wait for your app to load in the client, to allow their user's authentication status to update correctly, before taking any actions based on their authentication status.** This most commonly occurs in middleware setups that perform server-side routing.

One solution for handling this flow is to set up your app and middleware like so:

#### Client-side setup

In your client, add a new page (e.g. **`/refresh`**) that implements the following:

1. Call Privy’s **`getAccessToken`** method when the page loads. This ensures that whenever the user visits this page, their session is refreshed if they are authenticated.
2. If **`getAccessToken`** returns a valid token, redirect the user to the path specified in a **`redirect_uri`** query parameter. Your middleware will populate this query parameter later.
3. If **`getAccessToken`** returns `null`, redirect the user to your login page as they are not authenticated.

#### Middleware setup

In your middleware, when your backend receives a request to fetch a given page:

1. If the request includes a **`privy-token`** that is valid, you can consider the user authenticated and apply your normal middleware.
2. If the request does not include a **`privy-token`** but does include a **`privy-session`** cookie, the user may be authenticated, and you’ll need to refresh their session from the client before applying your middleware.
3. To refresh the user’s session from the client, you can redirect the user to the **`/refresh`** page you set up above. As part of this, you should also pass the original route the user intended to visit as a query param (e.g. **`redirect_url`**) when you redirect them to **`/refresh`**. Per the client-side setup, this allows the user's session to be refreshed and for them to be correctly redirected based on their authentication status.

Make sure to exclude the following from the above redirect middleware:

1. The page at the `/refresh` path you setup: in this case, the user should be allowed to visit the `/refresh` page as their authentication status and redirect will be handled *on that page* in the client. Redirecting away from this page in your middleware may result in an infinite redirecting loop.
2. Any page that includes the query parameter `privy_oauth_code`, `privy_oauth_state`, or `privy_oauth_provider`: these parameters are a required component of Privy's [OAuth login flow](/authentication/user-authentication/login-methods/oauth) and applying a redirect will destructively erase them.

As an example, if you're using NextJS, you might setup your middleware like so:

```tsx  theme={"system"}
// Replace this array with an array of paths for pages in your app that do not require the
// user to be authenticated, e.g. a login page
const UNAUTHENTICATED_PAGES = [];

export const config = {
  // necessary to ensure that you are redirected to the refresh page
  matcher: '/'
};

export async function middleware(req: NextRequest) {
  const cookieAuthToken = req.cookies.get('privy-token');
  const cookieSession = req.cookies.get('privy-session');

  // Bypass middleware when `privy_oauth_code` is a query parameter, as
  // we are in the middle of an authentication flow
  if (req.nextUrl.searchParams.get('privy_oauth_code')) return NextResponse.next();

  // Bypass middleware when the /refresh page is fetched, otherwise
  // we will enter an infinite loop
  if (req.url.includes('/refresh')) return NextResponse.next();

  // If the user has `privy-token`, they are definitely authenticated
  const definitelyAuthenticated = Boolean(cookieAuthToken);
  // If user has `privy-session`, they also have `privy-refresh-token` and
  // may be authenticated once their session is refreshed in the client
  const maybeAuthenticated = Boolean(cookieSession);

  if (!definitelyAuthenticated && maybeAuthenticated) {
    // If user is not authenticated, but is maybe authenticated
    // redirect them to the `/refresh` page to trigger client-side refresh flow
    return NextResponse.redirect(new URL('/refresh', req.url));
  }

  return NextResponse.next();
}
```

<Info>
  By design, Privy does **not** permit apps to refresh a user's access token from the app's server
  via the user's refresh token. This is a standard security protection to limit the surface area of
  exposure of the refresh token.
</Info>

### Setting SameSite to Lax

Cookies set by Privy are by default set with the `SameSite` attribute set to `Strict`.
This ensures that cookies are only sent on requests originating from the same site that set the cookie.

However, you may wish to receive cookies on cross-site top-level navigations or [safe requests methods](https://developer.mozilla.org/en-US/docs/Glossary/Safe/HTTP) (e.g. `GET`, `HEAD`, `OPTIONS`).
In this case, you can toggle setting the `SameSite` attribute to `Lax` in the [**Privy Dashboard**](https://dashboard.privy.io/?page=settings\&setting=domains).

<Warning>
  Setting SameSite=Lax sends your cookies on cross-site top-level navigations. If your app has any
  unprotected state-changing endpoints an attacker could leverage this to lure your users into
  making changes to their accounts.
</Warning>

In the [**Privy Dashboard**](https://dashboard.privy.io/?page=settings\&setting=domains), find your **production app** in the App Dropdown of the left sidebar.
Then, navigate to the **Configuration > App settings** page > **Domains** tab for that app.
Check the box next to **Set SameSite to Lax** under **HttpOnly cookies**.


# null
Source: https://docs.privy.io/recipes/react/custom-fiat-onramp



## Integrating a custom fiat on-ramp into your app

<Tip>
  Privy offers out of the box support for fiat on-ramp providers like Moonpay and Coinbase
  [here](/wallets/funding/overview). If you're looking to integrate a custom fiat on-ramp provider,
  you can follow the instructions below.
</Tip>

**Privy makes it easy to integrate a fiat on-ramp alongside our SDK, helping your users fund their wallets with the tokens they need to engage with your app.**

If your app involves on-chain actions like sending transactions or calling smart contracts, your users likely need some way to fund their wallet(s) with crypto, in order to pay gas and make purchases. Fiat on-ramps allow your users to purchase crypto via traditional payment methods, such credit/debit cards and ACH transfers.

In this guide, you'll find instructions for:

* how to choose the right fiat on-ramp provider for your app
* how to integrate a fiat on-ramp provider
* a complete demo implementation of a fiat on-ramp integrated alongside Privy

## Choosing a fiat on-ramp provider

**To start, you'll need to choose a fiat on-ramp provider that meets your app's requirements.** Different on-ramp providers vary in their support of:

* different tokens (ETH, USDC, Dai, POL, etc.)
* different networks (Ethereum, Polygon, Optimism, etc.)
* different regions (US, Europe, Brazil, South Korea, India, etc.).
* different payment methods (credit cards, debit cards, ACH, instant ACH, etc. )

You should choose a fiat on-ramp provider based on your needs across the categories listed above. You can check each provider's documentation to determine if it can support the requirements of your app and your user base. Some providers we recommend working with include [Moonpay](https://dev.moonpay.com/docs/on-ramp-overview), [Sardine](https://docs.payments.sardine.ai/products/onRamp), [Stripe](https://docs.stripe.com/crypto/onramp/embedded-quickstart), [Ramp Network](https://rampnetwork.com/), and [Onramper](https://www.onramper.com/).

Once you have chosen an on-ramp provider for your app, **set up an account with that provider and retrieve your sandbox API keys to build an integration**.

Most providers will provision you with a **public API key** that can be exposed to your frontend, and a **secret API key** that should only exist on your server. Some providers may also offer a **webhook API key** so you can subscribe to updates on your users' transactions.

## Integrating the provider

For the remainder of this guide, we will assume **Moonpay** is our chosen fiat on-ramp provider (though you should choose the provider that is best for your app).

The overall integration shape is roughly the same across different providers, and generally looks like:

1. In your **frontend**, collect details about your user (wallet address, email, etc.) and the assets they want to purchase (which tokens, what network, amount, etc.). Make a request to your **backend** with these details.
2. In your **backend**, once you receive the request from step (1), construct a fiat on-ramp URL for your user. Each provider will give you a base URL for a generic on-ramp flow, and you can tailor the flow to be specific to your user by setting the details from step (1) as query parameters. Send this URL back to your **frontend**.
3. In you **frontend**, once you receive the URL from step (2), you can either redirect your user to that URL or embed it in an `iframe` within your site. Within the new page/`iframe`, your user will complete their purchase flow and any required identity verification steps.

Below is a guide of how to implement steps (1)-(3) with Moonpay as a concrete example. For the sake of this demo, assume that, in this app, users are able to login with their email address and are prompted to create a Privy embedded wallet upon logging in (which they will need to fund).

### 1. Collect information about the user's on-ramp flow in your frontend

To start, we'll add a `fundWallet` method to our frontend that collects information about our user and our desired on-ramp flow, and sends it to our backend.

In this example app, users login with their email address and create a Privy embedded wallet upon logging in. Thus, we can get the user's email and wallet address from their [`user`](/user-management/users/the-user-object) object and include it in this request. This ensures the user doesn't have to enter this manually when completing the on-ramp flow later.

```tsx Getting the email and wallet address of the user theme={"system"}
const walletAddress = user?.wallet?.address;
const emailAddress = user?.email?.address;
```

In this example app, we also want to *redirect* the user to the on-ramp URL instead of embedding it in an `iframe`. Thus, we can get the URL of the current page (`window.location.href`) and include it in this request. This allows the on-ramp provider to redirect the user back to this page once they have completed their purchase.

```tsx Getting the URL of the current page theme={"system"}
const currentUrl = window.location.href;
```

Depending on your app, you can configure more information about the on-ramp flow as well. For instance:

* If users of your app only ever need to pay gas on Ethereum mainnet, you can pre-populate the asset to be purchased to always be 'eth' and the network to always be 'ethereum'.
* If your app is cross-chain and needs users to have different assets on different chains, you can instead surface UI elements to allow the user to select which asset and network they'd like to fund their wallet with.

<Tip>
  When completing the on-ramp flow, your user will have to manually enter/select any information
  that you do not pre-fill here (e.g. wallet address, which asset to purchase, etc.).
</Tip>

We'll now implement the `fundWallet` method to send this data to our backend, [authorizing the request](/authentication/user-authentication/access-tokens) with the user's Privy auth token.

```tsx Requesting the on-ramp URL from the server theme={"system"}
const {user, getAccessToken} = usePrivy();

...

const fundWallet = async () => {
    const walletAddress = user?.wallet?.address; // Get user's wallet address
    if (!walletAddress) return; // If user does not have a wallet, no-op
    const emailAddress = user?.email?.address; // Get user's email address
    const currentUrl = window.location.href; // Get URL of current page
    const authToken = await getAccessToken(); // Get Privy auth token

    // Send request to server with these details
    // Feel free to swap out `axios` for `fetch` or your preferred HTTP library
    try {
      const onrampResponse = await axios.post(
        // Replace this with the API route you implement in step (2)
        "/api/onramp",
        // Add any additional on-ramp configurations you'd like, such as network, asset, amount, etc.
        {
          address: user!.wallet!.address,
          email: user?.email?.address,
          redirectUrl: currentUrl,
        },
        {
          headers: {
            Authorization: `Bearer ${authToken}`,
          },
        }
      );
      return onrampResponse.data.url as string;
    } catch (error) {
      console.error(error);
      return undefined;
    }
  };
```

In this example, `fundWallet` parses the response returned by the server (we'll implement this below) and returns the fiat on-ramp URL as a string.

### 2. Construct the on-ramp URL in your backend

Now, we'll implement the logic in our backend to construct the fiat on-ramp URL based on the configuration we collected in step (1). In particular, we'll implement a `POST /api/onramp` handler that receives the request from step (1) and responds with the on-ramp URL.

In our handler, we'll start by parsing the request body for the user's wallet `address`, `email`, and `redirectUrl`. If you included additional information in your request (e.g. asset type, amount), you should parse the request body for those values as well.

```tsx Parsing the request body theme={"system"}
const {address, email, redirectUrl} = req.body;
```

Next, we'll construct the fiat on-ramp URL where our user can complete their purchase. We'll start with the base URL given to use by our fiat on-ramp provider (Moonpay):

```tsx Initializing the on-ramp with our base URL theme={"system"}
const onrampUrl = https://buy-sandbox.moonpay.com?apiKey=YOUR_MOONPAY_PUBLIC_KEY;
```

This generally is a URL at the provider's domain with your account's public key appended as a query parameter.

We can then pre-populate details about the user's on-ramp flow as URL query parameters, based on what we parsed from the request.

```tsx Configuring our on-ramp via URL query parameters theme={"system"}
onrampUrl.searchParams.set('walletAddress', address);
onrampUrl.searchParams.set('redirectURL', redirectUrl);
onrampUrl.searchParams.set('email', email);
onrampUrl.searchParams.set('currencyCode', 'eth');
```

For Moonpay, you can find the exact query parameters that can be pre-populated [here](https://docs.moonpay.com/moonpay/implementation-guide/on-ramp/browser-integration/customize-the-widget).

Lastly, after we've configured the on-ramp URL for our user, we'll authorize the URL using the secret key given to us by our fiat on-ramp provider. For Moonpay, we'll authorize the URL by signing it with the secret key, and appending the signature as a query parameter to the URL:

```tsx Authorizing the on-ramp URL with a signature theme={"system"}
import crypto from "crypto";
...
// Produce signature on URL
const urlSignature = crypto
    .createHmac("sha256", YOUR_MOONPAY_SECRET_KEY)
    .update(onrampUrl.search)
    .digest("base64");

// Set signature as URL query parameter
onrampUrl.searchParams.set("signature", urlSignature);
```

Other providers may have other ways of authorizing the URL, such as requesting a client token from their API and appending that token as a query parameter in place of a signature. You should check each provider's documentation to determine the correct mechanism for authorization.

We can finally send the completely configured, authorized on-ramp URL back to our front-end!

```tsx Returning the on-ramp URL to the client theme={"system"}
return res.status(200).json({url: onrampUrl.toString()});
```

### 3. Redirect your user to the on-ramp URL in your frontend

With steps (1) and (2) completed, our `fundWallet` method in our front-end should now return a configured, authorized on-ramp URL where our user can complete their purchase.

```tsx Getting the on-ramp URL theme={"system"}
const onrampUrl = await fundWallet();
```

In this example, we will *redirect* our user to this URL, so that they can complete their purchase in a new tab:

```tsx Redirecting our user to complete the on-ramp flow theme={"system"}
window.open(onrampUrl, '_blank');
```

Once the user completes their purchase, they will be redirected back to the `redirectUrl` we configured in steps (1) and (2). On this redirect, Moonpay will also append a `transactionId` that we can optionally use to monitor the status of the user's transaction.

<Tip>
  If you redirect your user to the fiat on-ramp URL, as we have done here, we suggest that you show
  them some introductory context about the fiat on-ramp (e.g. in a modal) provider and why they need
  to purchase crypto for your app.
</Tip>

Alternatively, if you do not want to redirect the user to a new tab, you can instead surface the on-ramp URL within an `iframe` embedded within your site:

```tsx Embedding the on-ramp URL in an iframe theme={"system"}
<iframe
    // These are necessary for proper identity verification
    allow="accelerometer; autoplay; camera; gyroscope; payment"
    frameborder="0"
    height="100%"
    width="100%"
    src={onrampUrl}
>
```

\*\*That's it! Your users can now fund the wallets they've connected/created through Privy and take on-chain actions in your app. 💪 \*\*

## NFT Checkout

If your app needs users to fund their wallets specifically so they can **purchase NFTs**, you should consider integrating an **NFT Checkout** flow in addition to, or instead of, a generic fiat on-ramp flow. NFT checkout flows generally offer a smoother user experience, due to less rigid identity verification requirements, higher payment success rates, and clearer context about what the user gets by purchasing crypto.

Many fiat on-ramp providers, including Moonpay and Sardine, offer NFT checkout integrations as well. The shape of this integration is much like that of the generic fiat on-ramp (outlined in this guide), but you will have to configure additional information about your NFT sale (contract address, token type, payments) in each provider's dashboard.

See each provider's documentation for more details, or [reach out](https://privy.io/slack) with any questions.

## Demo integration

Check out our **[fiat on-ramp demo app](https://fiat-onramp-demo.privy.io/)** to see an end-to-end integration of a fiat on-ramp alongside Privy. Take a look at the **[source code](https://github.com/privy-io/examples/tree/main/examples/privy-next-fiat-onramp)** to see how the code snippets from this guide fit into a real app.

This demo app uses a sandbox instance of Moonpay, and you should use certain test values when completing the purchase flow as a user:

* When entering in payment details, **do not use a real payment method**. Use the test credit card listed [here](https://dev.moonpay.com/docs/faq-sandbox-testing#add-a-payment-method).
* When completing identity verification, you will not be prompted to actually submit identity documents (as you would in production). Instead, you will be able to choose whether you'd like to simulate a successful or failed identity verification.


# Integrating with EIP-7702
Source: https://docs.privy.io/recipes/react/eip-7702



[EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) is an upgrade to EVM blockchains that enables externally owned accounts (EOAs) to set their code to that of a smart contract. In practical terms, this means that EOA wallets will gain AA (account abstraction) capabilities such as transaction bundling, gas sponsorship, and custom permissions.

Privy supports all low level interfaces required by 7702 - signing authorizations and sending type 4 transactions, allowing you to use any implementation of EIP-7702. Use the following guides to get started with EIP-7702 in your application:

### Signing EIP-7702 authorizations

Privy provides methods to sign EIP-7702 authorizations using the user's embedded wallet. This authorization is a cryptographic signature that allows an EOA to set its code to that of a smart contract, enabling the EOA to behave like a smart account.

Learn more about signing EIP-7702 authorizations in our [dedicated guide](/wallets/using-wallets/ethereum/sign-7702-authorization).

Learn more about using the signed authorization in the integration guides below!

### Detect current 7702 authorization state and implementation address

You can determine whether an EOA is currently delegated via EIP-7702 and read the authorized implementation address with a single `eth_getCode` call on the EOA address.

Under EIP-7702, an authorized EOA temporarily exposes a small bytecode stub that begins with the magic prefix `0xef0100`, followed immediately by the 20-byte implementation address. If `eth_getCode` returns empty code (`0x` or `0x0`), the EOA is not currently delegated on that chain. The snippets below return the current implementation address or `null`.

<Tabs>
  <Tab title="Viem">
    ```ts  theme={"system"}
    import {createPublicClient, http} from 'viem';
    import {mainnet} from 'viem/chains'; // replace with your chain

    const publicClient = createPublicClient({
      chain: mainnet,
      transport: http('your RPC URL here')
    });
    const address = '0x...'; // the EOA address here

    const code = (await publicClient.getCode({address}))?.toLowerCase() ?? '0x';
    const prefixIndex = code.indexOf('0xef0100');
    const authorizedImplementationAddress =
      prefixIndex === -1
        ? null
        : (`0x${code.slice(prefixIndex + 8, prefixIndex + 48)}` as `0x${string}`);
    ```

    <Expandable title="Full helper function (robust & typed)">
      ```ts  theme={"system"}
      export function parseEip7702AuthorizedAddress(
        code: string | null | undefined
      ): `0x${string}` | null {
        if (!code || code === '0x' || code === '0x0') return null;
        const normalized = code.toLowerCase();
        const MAGIC = '0xef0100';
        const idx = normalized.indexOf(MAGIC);
        if (idx === -1) return null;
        return ('0x' + normalized.slice(idx + MAGIC.length, idx + MAGIC.length + 40)) as `0x${string}`;
      }
      ```
    </Expandable>
  </Tab>

  <Tab title="Ethers">
    ```ts  theme={"system"}
    import {ethers} from 'ethers';

    const provider = new ethers.JsonRpcProvider('your RPC URL here');
    const address = 'the EOA address here';

    const code = (await provider.getCode(address))?.toLowerCase() ?? '0x';
    const prefixIndex = code.indexOf('0xef0100');
    const authorizedImplementationAddress =
      prefixIndex === -1
        ? null
        : (`0x${code.slice(prefixIndex + 8, prefixIndex + 48)}` as `0x${string}`);
    ```

    <Expandable title="Full helper function (robust)">
      ```ts  theme={"system"}
      function parseEip7702AuthorizedAddress(code?: string | null) {
        if (!code || code === '0x' || code === '0x0') return null;
        const MAGIC = '0xef0100';
        const idx = code.toLowerCase().indexOf(MAGIC);
        if (idx === -1) return null;
        return ('0x' + code.slice(idx + MAGIC.length, idx + MAGIC.length + 40)) as `0x${string}`;
      }
      ```
    </Expandable>
  </Tab>
</Tabs>

<Info>
  Authorization state is per-chain. Under 7702, an authorized EOA will return non-empty code with
  the `0xef0100` prefix; other non-empty code indicates a deployed contract account.
</Info>

### Using EIP-7702 capabilities

<Tabs>
  <Tab title="Alchemy">
    In this guide, we will transform your Privy embedded wallet into a smart wallet with features like gas sponsorship, batch transactions, granular permissions, and more [using EIP-7702](https://www.alchemy.com/docs/wallets/react/using-7702) support from Alchemy.

    ### 0. Install dependencies

    In your app's repository, install the required dependencies from Privy, Alchemy Account Kit, and [`viem`](https://www.npmjs.com/package/viem):

    ```sh  theme={"system"}
    npm i @privy-io/react-auth @account-kit/infra @account-kit/wallet-client @account-kit/smart-contracts @aa-sdk/core viem@2.29.3
    ```

    ### 1. Create an Alchemy account and get your API key

    * **Create an app:** visit the Alchemy [dashboard](https://dashboard.alchemy.com/apps) to create a new app, if you don't already have one.
      * Make sure to enable networks that support EIP-7702 such as Ethereum Mainnet or Sepolia.
      * Save the app's **API Key** that will be used later.

    * **Enable gas sponsorship:** visit the [Gas Manager](https://dashboard.alchemy.com/gas-manager) dashboard and create a new sponsorship policy for the app you created in step 1. This policy will be used to set rules on how much of user's gas you want to sponsor.
      * Make sure to enable gas sponsorship on a chain that support EIP-7702 such as Ethereum Mainnet or Sepolia.
      * Save the **Policy ID** that will be used later.

    Now that you have your API key and Policy ID, you can set up your smart wallets.

    ### 2. Configure Privy settings

    If you're already using a Privy embedded wallet, update your configuration to support EIP-7702 with embedded wallets. If you don't yet have authentication configured, you can follow [this](https://www.alchemy.com/docs/wallets/react/using-7702) guide to get set up.

    Make sure your `PrivyProvider` has the following `embeddedWallets` settings and ensure you set the `defaultChain` and `supportedChains` to the 7702 supported chain you chose in step 1.

    ```tsx  theme={"system"}
    import { sepolia } from "@account-kit/infra";
    <PrivyProvider
    	appId={process.env.NEXT_PUBLIC_PRIVY_APP_ID || ""}
    	config={{
    	  embeddedWallets: {
    	    showWalletUIs: false,
    	    createOnLogin: "all-users",
    	  },
    	  defaultChain: sepolia,
    	  supportedChains: [sepolia],
    	}}
    >
    ```

    ### 3. Adapt Privy signer to a smart account signer

    Now that you have authentication working, adapt the Privy signer to be able to sign 7702 authorizations to upgrade to smart accounts.

    **1. Get the Privy embedded wallet**

    ```tsx  theme={"system"}
    import {useWallets} from '@privy-io/react-auth';

    const {wallets} = useWallets();
    const embeddedWallet = wallets.find((x) => x.walletClientType === 'privy');
    ```

    **2. Create a `SmartAccountSigner` instance**

    ```tsx  theme={"system"}
    import {sepolia, alchemy} from '@account-kit/infra'; // make sure to import your chain from account-kit, not viem
    import {useSign7702Authorization} from '@privy-io/react-auth';
    import {SmartAccountSigner, WalletClientSigner} from '@aa-sdk/core';
    import {createWalletClient, custom, Hex} from 'viem';
    import {Authorization} from 'viem/experimental';

    const {signAuthorization} = useSign7702Authorization();

    async function create7702signer() {
      const baseSigner = new WalletClientSigner(
        createWalletClient({
          account: embeddedWallet!.address as Hex,
          chain: sepolia,
          transport: custom(await embeddedWallet!.getEthereumProvider())
        }),
        'privy'
      );

      const signer: SmartAccountSigner = {
        getAddress: baseSigner.getAddress,
        signMessage: baseSigner.signMessage,
        signTypedData: baseSigner.signTypedData,
        signerType: baseSigner.signerType,
        inner: baseSigner.inner,
        signAuthorization: async (
          unsignedAuth: Authorization<number, false>
        ): Promise<Authorization<number, true>> => {
          const signature = await signAuthorization(unsignedAuth);

          return {
            ...unsignedAuth,
            ...{
              r: signature.r!,
              s: signature.s!,
              v: signature.v!
            }
          };
        }
      };

      return signer;
    }
    ```

    ### 4. Upgrade to smart accounts and send sponsored transactions

    Now that you have a `SmartAccountSigner` instance, follow [this guide](https://www.alchemy.com/docs/wallets/transactions/using-eip-7702#third-party-signers) to create a smart account client (`createModularAccountV2Client` ) and start sending sponsored transactions. You'll need:

    * the `SmartAccountSigner` instance defined in step 3
    * the API key and the policy ID from step 1

    Once you define the client, you can send sponsored transactions with your embedded EOA and access other advanced smart account features! This client will handle all of the logic of delegating to a new smart account, if not already, and signing transactions. If you don't yet have a signer, follow [this guide](https://www.alchemy.com/docs/wallets/react/using-7702) to get set up.

    Looking for a complete working example? See this [working example integrating Privy embedded EOAs with EIP-7702 and Alchemy Smart Wallets](https://github.com/alchemyplatform/alchemy-wallets-7702-thirdparty-example).

    ### Next steps

    You just upgraded your EOA and sent your first sponsored transaction using EIP-7702!

    If you want to leverage other smart account capabilities such as batching and permissions, check out the [Alchemy docs](https://www.alchemy.com/docs/wallets).
  </Tab>

  <Tab title="Biconomy">
    In this guide we'll see a quick example of using the [Biconomy's](https://biconomy.io/) Modular Execution Environment (MEE) stack with Privy!

    <Info>
      To keep things short, this guide will show you a simple example of *single-chain orchestration*
      with cross-chain gas. However, the Biconomy MEE stack supports multi-chain orchestration cases. If
      you're looking to build a multi-chain DeFi strategy - read the [Biconomy
      Docs](https://docs.biconomy.io)
    </Info>

    ## Project Setup

    Create your project using Vite:

    ```bash  theme={"system"}
    bun create vite biconomy-mee-embedded-example --template react-ts
    cd biconomy-mee-embedded-example
    ```

    Add the following to your `package.json`:

    ```json  theme={"system"}
    "dependencies": {
      "@biconomy/abstractjs": "^1.0.17",
      "@privy-io/react-auth": "^2.14.2",
      "@privy-io/wagmi": "^1.0.4",
      "@tanstack/react-query": "^5.80.7",
      "react": "^19.1.0",
      "react-dom": "^19.1.0",
      "viem": "^2.31.3",
      "wagmi": "^2.15.6"
    }
    ```

    Install dependencies:

    ```bash  theme={"system"}
    bun install
    ```

    Set up your `main.tsx`:

    ```tsx  theme={"system"}
    import React from 'react';
    import ReactDOM from 'react-dom/client';
    import App from './App.tsx';
    import './index.css';

    import {PrivyProvider} from '@privy-io/react-auth';
    import {WagmiProvider} from 'wagmi';
    import {wagmiConfig} from './wagmi.ts';
    import {QueryClient, QueryClientProvider} from '@tanstack/react-query';

    const appId = 'your-privy-app-id';
    const queryClient = new QueryClient();

    ReactDOM.createRoot(document.getElementById('root')!).render(
      <React.StrictMode>
        <PrivyProvider
          appId={appId}
          config={{
            embeddedWallets: {
              ethereum: {
                createOnLogin: 'all-users'
              }
            }
          }}
        >
          <QueryClientProvider client={queryClient}>
            <WagmiProvider config={wagmiConfig}>
              <App />
            </WagmiProvider>
          </QueryClientProvider>
        </PrivyProvider>
      </React.StrictMode>
    );
    ```

    In `wagmi.ts`:

    ```ts  theme={"system"}
    import {createConfig} from '@privy-io/wagmi';
    import {http} from 'wagmi';
    import {baseSepolia, optimismSepolia} from 'viem/chains';

    export const wagmiConfig = createConfig({
      chains: [optimismSepolia, baseSepolia],
      transports: {
        [optimismSepolia.id]: http(),
        [baseSepolia.id]: http()
      }
    });
    ```

    ## ⬇Get the Embedded Wallet Instance

    After logging in the user with Privy, you can find the embedded wallet as follows:

    ```ts  theme={"system"}
    import {useWallets} from '@privy-io/react-auth';

    const {wallets} = useWallets();
    const wallet = wallets.find((wallet) => wallet.walletClientType === 'privy');
    ```

    ## Authorizing with EIP-7702

    To install the Biconomy Nexus 1.2.0 smart account on the address of your Privy embedded
    wallet EOA, you need to sign the following authorization. Note: This is using the
    `signAuthorization` method exposed by the `useSignAuthorization` Privy hook.

    ```ts  theme={"system"}
    import {useSign7702Authorization} from '@privy-io/react-auth';
    import {baseSepolia} from '@privy-io/chains';

    const {signAuthorization} = useSign7702Authorization();
    const NEXUS_V120 = '0x000000004F43C49e93C970E84001853a70923B03';

    const authorization = await signAuthorization({
      contractAddress: NEXUS_V120,
      chainId: baseSepolia.id, // or 0 for universal
      nonce: 0
    });
    ```

    ## Execute a Cross-Chain Gas Abstracted Transaction

    After signing, you can submit a transaction through Biconomy MEE Relayers. Notice
    few things for this transaction:

    * Gas is paid with USDC
    * Gas is paid on a different chain than the instruction being executed
    * The `amount` arg in the ERC-20 `transfer` call is not fixed to a value, but uses
      `runtimeERC20BalanceOf` which will inject the full amount of USDC available.

    This demonstrates few key points of MEE:

    * Gas abstraction / gas sponsorship
    * Multi-chain execution/orchestration
    * Runtime parameter injection enabling multi-transaction composability

    ```ts {skip-check} theme={"system"}
    const orchestrator = await toMultichainNexusAccount({
      chains: [optimismSepolia, baseSepolia],
      transports: [http(), http()],
      signer: await wallet.getEthereumProvider(),
      accountAddress: wallet.address as Address
    });

    const meeClient = await createMeeClient({account: orchestrator});

    const sendUSDCBase = await orchestrator.buildComposable({
      type: 'default',
      data: {
        abi: erc20Abi,
        chainId: baseSepolia.id,
        to: usdcAddresses[baseSepolia.id],
        functionName: 'transfer',
        args: [
          wallet.address,
          runtimeERC20BalanceOf({
            tokenAddress: usdcAddresses[baseSepolia.id],
            targetAddress: orchestrator.addressOn(baseSepolia.id, true),
            constraints: [greaterThanOrEqualTo(1n)]
          })
        ]
      }
    });

    const quote = await meeClient.getQuote({
      instructions: [sendUSDCBase],
      authorization,
      delegate: true,

      // Paying for gas with USDC on Optimism, while
      // executing a transaction on Base!
      feeToken: {
        address: usdcAddresses[optimismSepolia.id],
        chainId: optimismSepolia.id
      }
    });

    const {hash} = await meeClient.executeQuote({quote});
    ```

    You can then link the user to MEE Scan to track:

    ```ts {skip-check} theme={"system"}
    const link = getMeeScanLink(hash);
    ```

    ## Storing the **Authorization**

    If you've used the `chainId === 0` for your authorization you can store it (e.g. in localStorage or DB) and
    replay it for other chains in the future. This gives your users an even more seamless UX.
  </Tab>

  <Tab title="Pimlico">
    In this guide, we'll demonstrate how to use Pimlico, a bundler and paymaster service for ERC-4337 accounts, to enable your users to send gasless transactions using EIP-7702 authorization.

    <Info>
      Want to see a full end to end example? Check out our starter repo
      [here](https://github.com/pimlicolabs/permissionless-privy-7702)
    </Info>

    ## 0. Install dependencies

    In your app's repository, install the required dependencies from Privy, Permissionless, and Viem:

    ```bash  theme={"system"}
    npm i @privy-io/react-auth @privy-io/wagmi permissionless viem wagmi
    ```

    ## 1. Sign up for a Pimlico account and get your API key

    Head to the Pimlico dashboard [here](https://dashboard.pimlico.io/) and create an account. Generate an API key and create a sponsorship policy for the network you plan to use (optional). Make note of your API key and sponsorship policy ID.

    ## 2. Configure Privy settings

    Configure your app to create embedded wallets for all users.

    ```jsx  theme={"system"}
    <PrivyProvider
      config={{
        embeddedWallets: {
          createOnLogin: 'all-users'
          showWalletUIs: false
        }
      }}
    >
      ...
    </PrivyProvider>
    ```

    ## 3. Create a simple smart account with Permissionless SDK

    Permissionless provides a simple way to create a smart account client that can send user operations with EIP-7702 authorization. All you need is the user's embedded wallet and the Pimlico API key.

    ```jsx  theme={"system"}
    import {useEffect} from 'react';
    import {usePrivy, useSign7702Authorization, useWallets} from '@privy-io/react-auth';
    import {useSetActiveWallet} from '@privy-io/wagmi';
    import {useWalletClient} from 'wagmi';
    import {createPublicClient, http, zeroAddress, Hex} from 'viem';
    import {sepolia} from 'viem/chains';
    import {createSmartAccountClient} from 'permissionless';
    import {createPimlicoClient} from 'permissionless/clients/pimlico';
    import {to7702SimpleSmartAccount} from 'permissionless/accounts';

    // Get the Privy embedded wallet
    const {wallets} = useWallets();
    const {data: walletClient} = useWalletClient();
    const embeddedWallet = wallets.find((wallet) => wallet.walletClientType === 'privy');

    // Set the embedded wallet as active
    const {setActiveWallet} = useSetActiveWallet();
    useEffect(() => {
      if (embeddedWallet) {
        setActiveWallet(embeddedWallet);
      }
    }, [embeddedWallet, setActiveWallet]);

    // Create a public client for the chain
    const publicClient = createPublicClient({
      chain: sepolia,
      transport: http(process.env.NEXT_PUBLIC_SEPOLIA_RPC_URL)
    });

    // Create a Pimlico client
    const pimlicoApiKey = process.env.NEXT_PUBLIC_PIMLICO_API_KEY;
    const pimlicoUrl = `https://api.pimlico.io/v2/${sepolia.id}/rpc?apikey=${pimlicoApiKey}`;
    const pimlicoClient = createPimlicoClient({
      chain: sepolia,
      transport: http(pimlicoUrl)
    });

    // Create a 7702 simple smart account
    const simple7702Account = await to7702SimpleSmartAccount({
      client: publicClient,
      owner: walletClient
    });

    // Create the smart account client
    const smartAccountClient = createSmartAccountClient({
      client: publicClient,
      chain: sepolia,
      account: simple7702Account,
      paymaster: pimlicoClient,
      bundlerTransport: http(pimlicoUrl)
    });
    ```

    ## 4. Sign the EIP-7702 authorization

    Privy provides methods to sign EIP-7702 authorizations using the user's embedded wallet. This authorization is a cryptographic signature that allows an EOA to set its code to that of a smart contract, enabling the EOA to behave like a smart account.

    ```jsx  theme={"system"}
    const {signAuthorization} = useSign7702Authorization();

    // Sign the EIP-7702 authorization
    const authorization = await signAuthorization({
      contractAddress: '0xe6Cae83BdE06E4c305530e199D7217f42808555B', // Simple account implementation address
      chainId: sepolia.id,
      nonce: await publicClient.getTransactionCount({
        address: walletClient.account.address
      })
    });
    ```

    ## 5. Send a gas-sponsored transaction

    With the smart account client configured and the authorization signed, you can now send gasless UserOperations:

    ```jsx  theme={"system"}
    const transactionHash = await smartAccountClient.sendTransaction({
      to: zeroAddress,
      value: 0n,
      data: '0x',
      authorization,
      paymasterContext: {
        sponsorshipPolicyId: process.env.NEXT_PUBLIC_SPONSORSHIP_POLICY_ID
      }
    });

    console.log(`Transaction hash: ${transactionHash}`);
    console.log(`View on Etherscan: https://sepolia.etherscan.io/tx/${transactionHash}`);
    ```

    ## Conclusion

    That's it! You've just executed a gasless transaction from a normal EOA upgraded with EIP-7702 using Pimlico as the bundler and paymaster service.

    Explore the rest of the [Pimlico docs](https://docs.pimlico.io/) to learn about advanced features like batching transactions, gas estimation, and more.

    <Info>
      Want to see a full end to end example? Check out our starter repo
      [here](https://github.com/pimlicolabs/permissionless-privy-7702)!
    </Info>
  </Tab>

  <Tab title="Porto">
    In this guide, we'll demonstrate how to use [Porto](https://porto.sh/), a universal blockchain account infrastructure with native cross-chain interoperability, together with Privy to upgrade your EOA wallets with EIP-7702.

    ### 0. Install dependencies

    In your app's repository, install the required dependencies from Privy, Porto, and [`viem`](https://www.npmjs.com/package/viem):

    ```sh  theme={"system"}
    npm i @privy-io/react-auth porto viem
    ```

    ### 1. Configure Privy settings

    Configure your app to create embedded wallets for all users. Update your `PrivyProvider` configuration:

    ```tsx  theme={"system"}
    <PrivyProvider
      config={{
        embeddedWallets: {
          createOnLogin: 'all-users',
          showWalletUIs: false
        }
      }}
    >
      ...
    </PrivyProvider>
    ```

    ### 2. Set up Porto client

    Create a Viem client configured for Porto:

    ```tsx  theme={"system"}
    import {createClient, http} from 'viem';
    import {Chains} from 'porto/viem';

    const client = createClient({
      chain: Chains.baseSepolia,
      transport: http('https://rpc.porto.sh')
    });
    ```

    ### 3. Create Porto account with Privy's embedded wallet

    Get the Privy embedded wallet and create a Porto account instance with custom signing:

    ```tsx  theme={"system"}
    import {useWallets} from '@privy-io/react-auth';
    import {Account} from 'porto/viem';
    import {Hex} from 'viem';

    // Get the Privy embedded wallet
    const {wallets} = useWallets();
    const embeddedWallet = wallets.find((wallet) => wallet.walletClientType === 'privy');

    // Create a Porto account with secp256k1 signing
    const account = Account.from({
      source: 'privateKey',
      address: embeddedWallet.address as Hex,
      async sign({hash}) {
        const provider = await embeddedWallet.getEthereumProvider();
        const signature = await provider.request({
          method: 'secp256k1_sign',
          params: [hash]
        });
        return signature;
      }
    });
    ```

    ### 4. Upgrade account to Porto

    Use Porto's `RelayActions` to upgrade the account:

    ```tsx  theme={"system"}
    import {RelayActions} from 'porto/viem';

    // Upgrade the account to Porto
    const upgradedAccount = await RelayActions.upgradeAccount(client, {
      account
    });
    ```

    ### 5. Send transactions with Porto

    With the account upgraded, you can now send transactions through Porto's relay infrastructure with advanced features like gas sponsorship and cross-chain capabilities:

    ```tsx  theme={"system"}
    import {encodeFunctionData} from 'viem';

    // Example: Send a transaction to mint an NFT
    const result = await RelayActions.sendCalls(client, {
      account,
      chain: Chains.baseSepolia,
      calls: [
        {
          to: nftContractAddress,
          data: encodeFunctionData({
            abi: nftAbi,
            functionName: 'mint',
            args: [account.address]
          })
        }
      ]
    });

    console.log('Transaction sent:', result);
    ```

    ### 6. Track transaction status

    Monitor the status of your transactions:

    ```tsx  theme={"system"}
    // Get the status of a transaction
    const status = await RelayActions.getCallsStatus(client, {
      account,
      callHash: result.hash
    });

    console.log('Transaction status:', status);
    ```

    ### Next steps

    You've successfully upgraded your EOA with EIP-7702 and Porto! Your users can now:

    * Send transactions with gas sponsorship
    * Execute cross-chain transactions seamlessly
    * Batch multiple operations in a single transaction
    * Benefit from native interoperability across chains

    Explore the [Porto documentation](https://porto.sh/) to learn about additional features.
  </Tab>

  <Tab title="ZeroDev">
    In this guide, we demonstrate using [ZeroDev](https://zerodev.app/), a toolkit for creating smart accounts, together with Privy to enable your users to send gasless (sponsored) transactions.

    <Info>
      Want to see a full end to end example? Check out our starter repo
      [here](https://github.com/privy-io/create-next-app/tree/7702/zerodev)!
    </Info>

    ### 0. Install dependencies

    In your app's repository, install the required dependencies from Privy, ZeroDev and [`viem`](https://www.npmjs.com/package/viem):

    ```sh  theme={"system"}
    npm i @privy-io/react-auth @zerodev/sdk viem
    ```

    ### 1. Sign up for a ZeroDev account and create a project

    Head to the [**ZeroDev dashboard**](https://dashboard.zerodev.app/) and create a project on a chain that supports EIP-7702.

    Set up a [gas sponsorship policy](https://dashboard.zerodev.app/paymasters) to enable sending sponsored transactions. Copy the **Bundler RPC** and **Paymaster RPC** for the network you plan to use.

    ### 2. Configure Privy settings

    Configure your app to create embedded wallets for all users. Also configure Privy to not show its default wallet UIs. Instead, we recommend you use your own custom UIs for showing users the user operations they sign.

    Update your `PrivyProvider` configuration to include the following properties:

    ```tsx  theme={"system"}
    <PrivyProvider
      config={{
        embeddedWallets: {
          showWalletUIs: false, // [!code ++]
          createOnLogin: 'all-users' // [!code ++]
        }
      }}
    >
      ...
    </PrivyProvider>
    ```

    ### 3. Create a 7702 Kernel account with the ZeroDev SDK

    ZeroDev exposes helper functions that take care of generating the 7702 authorization for you. All you need to provide is the signer for the user's embedded wallet and the Kernel version you want to use.

    ```tsx  theme={"system"}
    import {
      createZeroDevPaymasterClient,
      createKernelAccountClient,
      createKernelAccount
    } from '@zerodev/sdk';
    import {KERNEL_V3_3} from '@zerodev/sdk/constants';
    import {getEntryPoint} from '@zerodev/sdk/constants';
    import {createWalletClient, createPublicClient, custom, http, zeroAddress, Hex} from 'viem';
    import {odysseyTestnet} from 'viem/chains';

    // Select the chain and Kernel version you want to use
    const chain = odysseyTestnet;
    const kernelVersion = KERNEL_V3_3;
    const kernelAddresses = KernelVersionToAddressesMap[kernelVersion];

    const entryPoint = getEntryPoint('0.7');

    // Grab the embedded wallet created by Privy
    const {wallets} = useWallets();
    const embeddedWallet = wallets.find((wallet) => wallet.walletClientType === 'privy');

    // Build viem clients for the wallet & public RPC
    const walletClient = createWalletClient({
      account: embeddedWallet.address as Hex,
      chain,
      transport: custom(await embeddedWallet.getEthereumProvider())
    });

    const publicClient = createPublicClient({
      chain,
      transport: http()
    });

    // Sign the EIP-7702 authorization
    const authorization = await signAuthorization({
      contractAddress: kernelAddresses.accountImplementationAddress,
      chainId: chain.id
    });

    // Create the 7702 Kernel account (no deployment occurs!)
    const account = await createKernelAccount(publicClient, {
      eip7702Account: walletClient,
      entryPoint,
      kernelVersion,
      eip7702Auth: authorization
    });
    ```

    Behind the scenes ZeroDev generates the EIP-7702 authorization and binds the Kernel implementation code to the EOA, giving it smart-account super-powers while keeping the same address.

    ### 4. Configure the ZeroDev client for sponsored transactions

    ```tsx  theme={"system"}
    const paymasterRpc = 'YOUR_PAYMASTER_RPC_URL';
    const bundlerRpc = 'YOUR_BUNDLER_RPC_URL';

    // Create a paymaster client so the user does not need ETH
    const paymasterClient = createZeroDevPaymasterClient({
      chain,
      transport: http(paymasterRpc)
    });

    // Build a Kernel client that will create & submit UserOperations
    const kernelClient = createKernelAccountClient({
      account,
      chain,
      bundlerTransport: http(bundlerRpc),
      paymaster: paymasterClient,
      client: publicClient
    });
    ```

    ### 5. Send a gas-sponsored transaction

    With the client configured, you can now send gasless UserOperations. Below we send an empty call then wait for it to be mined:

    ```tsx  theme={"system"}
    // Send a simple UserOperation
    const userOpHash = await kernelClient.sendUserOperation({
      callData: await kernelClient.account.encodeCalls([
        {
          to: zeroAddress,
          value: BigInt(0),
          data: '0x'
        }
      ])
    });

    // Wait for the operation to be included
    const {receipt} = await kernelClient.waitForUserOperationReceipt({
      hash: userOpHash
    });

    console.log(
      'UserOp completed',
      `${chain.blockExplorers.default.url}/tx/${receipt.transactionHash}`
    );
    ```

    ### Conclusion

    That's it! You've just executed a gasless transaction from a normal EOA upgraded with EIP-7702.

    Explore the rest of the [ZeroDev docs](https://docs.zerodev.app/) to learn about batching, session keys, cross-chain actions and more.
  </Tab>
</Tabs>


# Integrating the Base App
Source: https://docs.privy.io/recipes/react/external-wallets/base-app



The **Base App** is an ERC-4337-compatible smart wallet by Coinbase that users can connect to your application. The Base App supports a variety of extended capabilities, like [spend permissions](https://docs.base.org/base-account/improve-ux/spend-permissions), [gas sponsorship](https://docs.base.org/base-account/improve-ux/sponsor-gas/paymasters), [sub accounts](https://docs.base.org/base-account/improve-ux/sub-accounts) and more.

Learn how to integrate the Base App with Privy in the guide below.

### 1. Set up your React app

First, follow the [React Quickstart](/basics/react/quickstart) to get your app instrumented with Privy's basic functionality. Make sure you have updated your `@privy-io/react-auth` SDK to the latest version.

Next, configure your React app to show the Base Account as one of the external wallet options that users can use to connect to your application.

To do so, pass `'base_account'` to the [`config.appearance.walletList`](/wallets/connectors/setup/configuring-external-connector-wallets) array.

```tsx highlight={5} theme={"system"}
<PrivyProvider
    appId='insert-app-id',
    config={{
        appearance: {
            walletList: ['base_account', ...insertOtherWalletListEntries],
            ...insertRestOfAppearanceConfig
        },
        ...insertRestOfPrivyProviderConfig
    }}
>
    {children}
</PrivyProvider>
```

### 2. Access the Base Account SDK

Next, in your React app, access the instance of the [Base Account SDK](https://github.com/base/account-sdk) using Privy's `useBaseAccountSdk` hook.

```tsx  theme={"system"}
import {useBaseAccountSdk} from '@privy-io/react-auth';
...
const {baseAccountSdk} = useBaseAccountSdk();
```

This SDK instance is your app's entrypoint to the features of the Base Account.

### 3. Use Base Account methods

Finally, use methods on the Base Account SDK such as `getProvider`, `pay`, `subaccount` methods, and more to leverage the capabilities of the Base App in your app.


# Using Base Sub Accounts
Source: https://docs.privy.io/recipes/react/external-wallets/base-sub-accounts



[Base Sub Accounts](https://docs.base.org/base-account/improve-ux/sub-accounts) are a feature of the [Base Account](https://docs.base.org/base-account/overview/what-is-base-account) (formerly known as Coinbase Smart Wallet) that allow you to streamline the user experience of using a Base Account in your app.

Follow the guide below to learn how to use Base Sub Accounts with Privy.

## Overview

By default, when a user uses their Base Account within their app, the user must authorize every signature and transaction via a passkey prompt. This may be interruptive for your app's user experience, particularly for use cases that require a high-volume of signatures or transactions, such as gaming.

[Sub Accounts](https://docs.base.org/base-account/improve-ux/sub-accounts) enable you to create an Ethereum account derived from the parent Base Account that is *specific to your app*, with its own address, signing capabilities, and transaction history. This Sub Account is owned by another wallet, such as an embedded wallet or a local account, and can be configured to *not* require an explicit (passkey) confirmation from the user on every signature and transaction.

Sub accounts can even transact with the balance of the parent account using Spend Permissions, allowing users to spend this balance without explicit passkey prompts.

## Usage

To set up Sub Accounts in your app that can be controlled by an embedded wallet, follow the guide below.

### 1. Set up your React app

First, follow the [React Quickstart](/basics/react/quickstart) to get your app instrumented with Privy's basic functionality. Make sure you have updated your `@privy-io/react-auth` SDK to the latest version.

Next, configure your React app to:

* Show the Base Account as one of the external wallet options that users can use to connect to your application. To do so, pass `'base_account'` to the [`config.appearance.walletList`](/wallets/connectors/setup/configuring-external-connector-wallets) array.
* Create embedded wallets automatically on login by setting [`config.embedded.ethereum.createOnLogin`](/basics/react/advanced/automatic-wallet-creation) to `'all-users'`.

```tsx  theme={"system"}
<PrivyProvider
    appId='insert-app-id',
    config={{
        appearance: {
            walletList: ['base_account', ...insertOtherWalletListEntries],
            ...insertRestOfAppearanceConfig
        },
        embedded: {
            ethereum: {
                createOnLogin: 'all-users'
            }
        },
        ...insertRestOfPrivyProviderConfig
    }}
>
    {children}
</PrivyProvider>
```

This will ensure that when users connect or login to your application, they have the option to use their Base Account.

### 2. Create or get a Sub Account

Next, after the user logs in, create a new Sub Account or get the existing Sub Account for the user that is tied to your app's domain.

To start, get the connected wallet instances for your user's embedded wallet and Base App by searching for the entries with `walletClientType: 'privy'` and `walletClientType: 'base_account'` respectively in your [`useWallets`](/wallets/wallets/get-a-wallet/get-connected-wallet#ethereum) array:

```tsx  theme={"system"}
import {useWallets} from '@privy-io/react-auth';

const {wallets} = useWallets();
const embeddedWallet = wallets.find((wallet) => wallet.walletClientType === 'privy');
const baseAccount = wallets.find((wallet) => wallet.walletClientType === 'base_account');
// `embeddedWallet` and `baseAccount` must be defined for users to use Sub Accounts
```

Next, switch the network of the Base Account to Base or Base Sepolia, and get the wallet's EIP-1193 provider:

```tsx  theme={"system"}
// Switching to Base Sepolia
await baseAccount.switchChain(84532);
const provider = await baseAccount.getEthereumProvider();
```

Lastly, check if the user has an existing Sub Account using the [`wallet_getSubAccounts`](https://docs.base.org/base-account/improve-ux/sub-accounts#get-existing-sub-account) RPC method. If the user does not have an existing Sub Account, create a new one for them using the [`wallet_addSubAccount`](https://docs.base.org/base-account/improve-ux/sub-accounts#create-a-new-sub-account) RPC:

```tsx  theme={"system"}
// Get existing Sub Account if it exists
const {
  subAccounts: [existingSubAccount]
} = await provider.request({
  method: 'wallet_getSubAccounts',
  params: [
    {
      account: baseAccount.address as `0x${string}`, // The address of your user's Base Account
      domain: window.location.origin // The domain of your app
    }
  ]
});

// Use the existing Sub Account if it exists, otherwise create a new sub account
const subaccount = existingSubAccount
  ? existingSubAccount
  : await provider.request({
      method: 'wallet_addSubAccount',
      params: [
        {
          version: '1',
          account: {
            type: 'create',
            keys: [
              {
                type: 'address',
                publicKey: embeddedWallet.address as Hex // Pass your user's embedded wallet address
              }
            ]
          }
        }
      ]
    });
```

### 3. Configure the SDK to use the embedded wallet for Sub Account operations

Next, configure the Base Account SDK to use the embedded wallet to control Sub Account operations. This allows the embedded wallet to sign messages and transactions on behalf of the Sub Account, avoiding the need for a separate passkey prompt.

Use the `useBaseAccountSdk` hook from Privy's React SDK to access the instance of the Base Account SDK directly, and use the SDK's `subAccount.setToOwnerAccount` method to configure the embedded wallet to sign on behalf of the Sub Account's operations.

As a parameter to this method, pass a function that returns a `Promise` for a viem [`LocalAccount`](https://viem.sh/docs/accounts/local.html) representing the user's embedded wallet. You can use Privy's `toViemAccount` utility method to do so.

```tsx  theme={"system"}
import {useBaseAccountSdk, toViemAccount} from '@privy-io/react-auth';

...

const {baseAccountSdk} = useBaseAccountSdk();
const toOwnerAccount = async () => {
    const account = await toViemAccount({wallet: embeddedWallet});
    return {account};
}
baseAccountSdk.subAccount.setToOwnerAccount(toOwnerAccount);
```

<Expandable title="the code for steps 3 & 4 together to create or get a Sub Account.">
  The code below showcases how to create or get an existing Sub Account for your user, and set the embedded wallet as the Sub Account's owner.

  ```tsx  theme={"system"}
  import {useWallets, useBaseAccountSdk, toViemAccount} from '@privy-io/react-auth';

  // In your React component
  const {wallets} = useWallets();
  const {baseAccountSdk} = useBaseAccountSdk();
  const embeddedWallet = wallets.find((wallet) => wallet.walletClientType === 'privy');
  const baseAccount = wallets.find((wallet) => wallet.walletClientType === 'base_account');

  // Call this function when needed, e.g. in a button's `onClick` handler
  const createOrGetSubAccount = async () => {
    if (!embeddedWallet) throw new Error('User does not have an embedded wallet');
    if (!baseAccount) throw new Error('User has not connected a Base Account');
    if (!baseAccountSdk) throw new Error('Base Account SDK not initialized');

    await baseAccount.switchChain(84532); // Use 8453 for Base Mainnet
    const provider = await baseAccount.getEthereumProvider();

    // Get existing Sub Account
    const {
      subAccounts: [existingSubAccount]
    } = await provider.request({
      method: 'wallet_getSubAccounts',
      params: [
        {
          account: baseAccount.address as `0x${string}`, // The address of your user's Base Account
          domain: window.location.origin // The domain of your app
        }
      ]
    });

    // Create new Sub Account if one does not exist
    const subaccount = existingSubAccount
      ? existingSubAccount
      : await provider.request({
          method: 'wallet_addSubAccount',
          params: [
            {
              version: '1',
              account: {
                type: 'create',
                keys: [
                  {
                    type: 'address',
                    publicKey: embeddedWallet.address as Hex // Pass your user's embedded wallet address
                  }
                ]
              }
            }
          ]
        });

    // Configure privy embedded wallets to power Sub Account operations
    const toOwnerAccount = async () => {
      const account = await toViemAccount({wallet: embeddedWallet});
      return {account};
    };
    baseAccountSdk.subAccount.setToOwnerAccount(toOwnerAccount);
  };
  ```
</Expandable>

### 4. Sign messages and send transactions with the Sub Account

Lastly, you can sign and send transactions with the Sub Account using the Base Account's EIP1193 provider. To ensure that signatures and transactions come from the Sub Account, for each of the following RPCs:

* `personal_sign`: pass the Sub Account's address, not the parent Base Account's address, as the second parameter.
* `eth_signTypedData_v4`: pass the Sub Account's address, not the parent Base Account's address, as the first parameter.
* `eth_sendTransaction`: set `from` in the transaction object to the Sub Account's address, not the parent Base Account's address.

When these methods are invoked, the embedded wallet will sign on behalf of the Sub Account, avoiding the need for an explicit passkey prompt from the user.

<Tabs>
  <Tab title="Sign a message">
    ```tsx  theme={"system"}
    import {toHex} from 'viem';

    const message = 'Hello world';
    const signature = await baseProvider.request({
        method: 'personal_sign',
        params: [toHex(message), subaccount.address] // Pass the Sub Account, not parent Base Account address
    });
    ```
  </Tab>

  <Tab title="Send a transaction">
    ```tsx  theme={"system"}
    import {parseEther} from 'viem';

    const txHash = await baseProvider.request({
        method: 'eth_sendTransaction',
        params: [{
            from: subaccount.address, // Use Sub Account address as sender
            to: 'insert-recipient-address',
            value: parseEther('0.01').toString(),
            data: '0x'
        }]
    });
    ```
  </Tab>

  <Tab title="Send a batch of transactions">
    ```tsx  theme={"system"}
    import {parseEther} from 'viem';

    const userOpHash = await baseProvider.request({
        method: 'wallet_sendCalls',
        params: [{
            from: subaccount.address, // Use Sub Account address
            calls: [{
                to: 'insert-recipient-address',
                value: parseEther('0.01').toString(),
                data: '0x'
            }]
        }]
    });
    ```
  </Tab>
</Tabs>

<Tip>
  You can combine Sub Accounts with [Spend
  Permissions](https://docs.base.org/base-account/improve-ux/spend-permissions) to allow the Sub
  Account to spend from the balance of the parent Base Account in `eth_sendTransaction` requests.
</Tip>


# Guest accounts
Source: https://docs.privy.io/recipes/react/guest-accounts



<Info>
  Privy enables developers to create Guest accounts for users, so that users can immediately use your app without going through a login flow.

  Guest accounts are available in @privy-io/react-auth\@1.77.0 and above.
</Info>

Privy guest accounts have powerful features:

* They are locally persisted, so guest users can leave and return to the same account on the same device.
* They have **fully functioning** embedded wallets that can transact and mint on-chain.
* They are upgradable to fully logged-in accounts by simply calling `login()`.
* They have stable user IDs that do not change once a user is fully logged in.
* They can be logged out and deleted as needed.

## Integration tips

* **Guest account creation:** If a user is not logged in at all (via guest or normal user account), we recommend showing guest account creation and normal user login side-by-side.
  * e.g. a “Continue as Guest” button next to a “Login or Create Account” button. This is so users do not create guest accounts unintentionally when they mean to log in with an existing account.
* **Guest account upgrade:** If a user is logged in as a guest, we recommend showing two options: upgrade or delete.
  * *Upgrade guest account*: When a guest upgrades to a full user, they must enter a new login credential. If they try to upgrade with a credential (e.g. email address) that already is associated with an existing account, they will see a “Could not link existing account” error message.
  * *Delete guest account*: If a guest prefers to use an existing account instead, they must delete their guest account first. We recommend surfacing a “delete” option explicitly so guests can opt-into abandoning their guest account in favor of an existing account.
* You can make use of [login and error callbacks](/authentication/user-authentication/login-methods/email) to customize your desired behavior when a user upgrades out of guest-mode.

## Please note

<Warning>
  Guest accounts are **valid for 30 days**. If the guest does not upgrade to a full user account
  within 30 days, the guest session will expire.
</Warning>

* User data and embedded wallets from guest sessions **cannot** be merged into an existing user account — guest accounts can only be *upgraded* into a new user account. If a guest user wants to log in with an existing account, you must delete the guest user session first.
* Note that Telegram is not available as an upgrade login method for guest accounts.

## Configure guest accounts

<Tip>
  Enable guest accounts in the [Privy
  Dashboard](https://dashboard.privy.io/apps?page=login-methods\&logins=advanced) before implementing
  this feature.
</Tip>

### Create guest accounts client-side

Use the `createGuestAccount` function from the `useGuestAccounts` hook in the React SDK to integrate guest accounts. The `createGuestAccount` function returns an [authenticated `User` object](/user-management/users/the-user-object).

```jsx  theme={"system"}
// createGuestAccount: () => Promise<User>
const {createGuestAccount} = useGuestAccounts();
```

`createGuestAccount` is an asynchronous call that will create and authenticate users as guests. If the user is already a guest, this call is idempotent. If the user is already *logged in* as a non-guest user, this will throw an error indicating as such.

### Check if a user is a guest

To check if a User is a guest account, use the `isGuest` property on the `User` object returned by the `usePrivy` hook.

```jsx  theme={"system"}
const {user} = usePrivy();

// isGuest: boolean
user.isGuest;
```

### Access a guest user ID

To access the guest’s user data including their stable user ID and wallet address, access the user object from the `usePrivy` hook.

```tsx  theme={"system"}
const {user} = usePrivy();

// Get the user's stable User ID and their wallet address.
user.id;
user.wallet.address;
```

### Access a guest user’s embedded wallet

To transact with the guest user’s embedded wallet, [use the appropriate wallet from the connected `wallets` array.](/wallets/wallets/get-a-wallet) All embedded wallet functionality that is available for logged-in users is also available to guest users.

```tsx  theme={"system"}
const {wallets} = useWallets();
const embeddedWallet = getEmbeddedConnectedWallet(wallets);

// Get the embedded wallet address or send a transaction.
embeddedWallet.address;
const provider = await embeddedWallet.getEthereumProvider()
provider.request({method: 'eth_sendTransaction', params: [...]});
```

### Upgrade a guest user to a logged-in user

Simply call `login()` to enable the guest user to upgrade their account to a logged-in account using any authentication method of their choice.

```tsx  theme={"system"}
// login: (options?) => void
const {login} = usePrivy();
```

### Enable a guest user to delete their guest session

Call `logout()` to enable the guest user to delete their guest session. This is an important interface to support so that users who start a guest session but would prefer to log in with a pre-existing account, are able to do so.

```tsx  theme={"system"}
// logout: (options?) => void
const {logout} = usePrivy();
```


# Configuring wallet confirmation modals
Source: https://docs.privy.io/recipes/react/manage-wallet-UIs



Privy allows you to customize showing wallet confirmation modals globally for your application in the Privy Dashboard or in your `PrivyProvider` configuration.

<Note>This is a guide for configuring wallet confirmation modals for the `react-auth` SDK.</Note>

## Dashboard configuration

To toggle displaying wallet confirmation modals navigate to the [Configuration > Authentication > Advanced](https://dashboard.privy.io/apps?logins=advanced\&page=login-methods) tab for your app.

Here you can toggle the `Disable confirmation modals` option across the entire application.

## `PrivyProvider` configuration

<Tip>The `showWalletUIs` option will override the dashboard configuration if one is set.</Tip>

In your `PrivyProvider` configuration, you can toggle the `showWalletUIs` option to enable or disable wallet confirmation modals across the entire application.

```tsx  theme={"system"}
<PrivyProvider
  config={{
    embeddedWallets: {
      showWalletUIs: false
    }
    /** ... */
  }}
>
  <App />
</PrivyProvider>
```

## Customizing wallet confirmation modals for individual function calls

<Tip>
  The `uiOptions.showWalletUIs` option will override the `PrivyProvider` configuration if one is
  set.
</Tip>

Privy allows you to further customize showing wallet confirmation modals for individual function calls by passing the `uiOptions.showWalletUIs` option to the respective function. Learn more in the following sections:

* Ethereum
  * [`signMessage`](/wallets/using-wallets/ethereum/sign-a-message#param-ui-options)
  * [`signTransaction`](/wallets/using-wallets/ethereum/sign-a-transaction#param-options-ui-options)
  * [`signTypedData`](/wallets/using-wallets/ethereum/sign-typed-data#param-ui-options)
  * [`sendTransaction`](/wallets/using-wallets/ethereum/send-a-transaction#param-options-ui-options)
* Solana
  * [`signAndSendTransaction`](/wallets/using-wallets/solana/send-a-transaction#param-ui-options)
  * [`signTransaction`](/wallets/using-wallets/solana/sign-a-transaction#param-ui-options)
  * [`signMessage`](/wallets/using-wallets/solana/sign-a-message#param-ui-options)


# Use tokens from OAuth providers
Source: https://docs.privy.io/recipes/react/oauth-tokens



<Tabs>
  <Tab title="React">
    **To configure callbacks for whenever a user successfully authorizes a third-party OAuth account, use the `useOAuthTokens` hook:**

    ```tsx  theme={"system"}
    import {useOAuthTokens, type OAuthTokens} from '@privy-io/react-auth';

    const {reauthorize} = useOAuthTokens({
      // Any logic you'd like to execute with the OAuth tokens
      onOAuthTokenGrant: ({oAuthTokens}) => {
        console.log(
          oAuthTokens.provider,
          oAuthTokens.accessToken,
          oAuthTokens.accessTokenExpiresInSeconds,
          oAuthTokens.refreshToken,
          oAuthTokens.refreshTokenExpiresInSeconds,
          oAuthTokens.scopes
        );
      }
    });

    // You may also call `getAccessToken` to get the user's current access token
    ```

    As parameters to **`useOAuthTokens`**, you may include an **`onOAuthTokenGrant`** callback.

    <Tip>
      The component where the **`useOAuthTokens`** hook is invoked **must** be mounted on the
      component/page the user returns to after authorizing an OAuth flow in order for this callback to
      execute. Note that having the page lazy load the component with the hook may interfere with
      execution of the callback.
    </Tip>

    ### onAccessTokenGranted

    If set, the **`onOAuthTokenGrant`** callback will execute after a user returns to the application from an OAuth flow authorization. This happens in 3 cases:

    * When the user logs in via an OAuth/social login method,
    * When a user links a new OAuth account to their user account,
    * When a successful **`reauthorize`** call is invoked, and the user authorizes an existing OAuth account.

    Within this callback, you can access:

    * **`provider`**: the OAuth provider, is one of `'apple'`, `'discord'`, `'github'`, `'google'`, `'linkedin'`, `'spotify'`, `'tiktok'`, `'instagram'`, and `'twitter'`.
    * **`accessToken`**: the OAuth access token
    * **`accessTokenExpiresInSeconds`**: the number of seconds until the OAuth access token expires
    * **`refreshToken`**: the OAuth refresh token
    * **`refreshTokenExpiresInSeconds`**: the number of seconds until the OAuth refresh token expires. If the refresh token is present and this field is undefined, it is assumed that the refresh token does not have an expiration date
    * **`scopes`**: the list of OAuth scopes the access token is approved for.

    Learn more about how to use OAuth access and refresh tokens [here.](https://www.oauth.com/oauth2-servers/access-tokens/)

    Within this callback, you can also access a `reauthorize` method, which will allow a user to re-authorize an existing OAuth account in order to retrieve more up-to-date OAuth tokens and account metadata.
  </Tab>

  <Tab title="React Native">
    **To configure callbacks for whenever a user successfully authorizes a third-party OAuth account in your React Native app, use the `useOAuthTokens` hook:**

    ```tsx  theme={"system"}
    import {useOAuthTokens} from '@privy-io/expo';

    // The hook takes a single callback that will be triggered when OAuth tokens are granted
    useOAuthTokens({
      onOAuthTokenGrant: (tokens: OAuthTokens) => {
        console.log(
          tokens.provider,
          tokens.accessToken,
          tokens.accessTokenExpiresInSeconds,
          tokens.refreshToken,
          tokens.refreshTokenExpiresInSeconds,
          tokens.scopes
        );
      }
    });
    ```

    <Tip>
      The component where the **`useOAuthTokens`** hook is invoked **must** be mounted on the
      component/page the user returns to after authorizing an OAuth flow in order for this callback to
      execute.
    </Tip>

    ### onOAuthTokenGrant

    The **`onOAuthTokenGrant`** callback will execute after a user returns to the application from an OAuth flow authorization. This happens in 3 cases:

    * When the user logs in via an OAuth/social login method,
    * When a user links a new OAuth account to their user account,
    * When a user re-authorizes an existing OAuth account.

    Within this callback, you can access:

    * **`provider`**: the OAuth provider, is one of `'apple'`, `'discord'`, `'github'`, `'google'`, `'linkedin'`, `'spotify'`, `'tiktok'`, `'instagram'`, and `'twitter'`.
    * **`accessToken`**: the OAuth access token
    * **`accessTokenExpiresInSeconds`**: the number of seconds until the OAuth access token expires
    * **`refreshToken`**: the OAuth refresh token
    * **`refreshTokenExpiresInSeconds`**: the number of seconds until the OAuth refresh token expires. If the refresh token is present and this field is undefined, it is assumed that the refresh token does not have an expiration date
    * **`scopes`**: the list of OAuth scopes the access token is approved for.

    <Info>
      In React Native, OAuth tokens are securely stored in the Expo Secure Store, which is backed by the
      Keychain on iOS and EncryptedSharedPreferences on Android. This ensures that sensitive OAuth
      tokens are properly protected on mobile devices.
    </Info>

    <Info>
      Unlike the React version, the React Native `useOAuthTokens` hook does not return a `reauthorize`
      method. To reauthorize an OAuth account in React Native, you should use the `login` method from
      the `usePrivy` hook.
    </Info>
  </Tab>
</Tabs>


# Seamless Telegram login
Source: https://docs.privy.io/recipes/react/seamless-telegram



Privy enables developers to quickly integrate Login with Telegram into their applications. With the Privy Telegram integration, users can log in with Telegram and link Telegram accounts.

From a web environment, Privy enables Telegram login via the [Telegram Login widget](https://core.telegram.org/widgets/login). Privy also enables seamless Telegram login directly from within a Telegram bot or within Telegram Mini-Apps!

## Configure Telegram

### Configure Telegram login

Follow [this](https://core.telegram.org/bots/tutorial#obtain-your-bot-token) guide to create a telegram bot. After creating a Telegram bot, you must set your domain using the `/setdomain` command in the `@BotFather` chat. You will need to provide the following to Privy via the Privy Dashboard upon completion:

* Bot token (eg: `1234567890:AzByCxDwEvFuGtHsIr1k2M4o5Q6s7U8w9Y0`)
* Bot handle (eg: `@MyBot_bot`)

Note that when configuring Telegram login:

* Your domain must be configured as your bot's allowed domain.
* **Important**: Telegram does not support `.xyz` domains for authentication. If your application uses a `.xyz` domain, you must use a different top-level domain (TLD) for Telegram authentication to function properly.
* If you have CSP enforcement, you’ll need to update these directives:
  * `script-src` must allow `https://telegram.org` in order to be able to download Telegram's widget script.
  * `frame-src` must allow `https://oauth.telegram.org` in order to be able to render Telegram's widget iframe.

<Tip>
  To use your app as a Telegram Mini-App in the Telegram web client, add `http://web.telegram.org`
  and `https://web.telegram.org` to your allowed domains in the dashboard [Configuration > App
  settings > Domains](https://dashboard.privy.io?page=settings) tab.
</Tip>

<Info>
  Since you need to set your bot's allowed domain you'll need to use a tunneling tool for local
  development such as [Cloudflare
  tunnels](https://developers.cloudflare.com/pages/how-to/preview-with-cloudflare-tunnel/) or
  [ngrok](https://ngrok.com/).
</Info>

### Essential: Secure your bot secret

<Warning>
  Telegram login requires developers to create a Telegram bot with a bot secret. This bot secret
  controls the Telegram bot and is also used as a symmetric key for authentication. Control over
  this key enables a developer to sign over authentication data, meaning compromise of this key puts
  your users (and their accounts) at risk.

  **Securing this symmetric key is essential for the security of all of your app’s Telegram logins.**
</Warning>

## Integration interfaces

### \[optional] Enable Telegram in your client-side `loginMethods`

You must enable Telegram in the Privy Dashboard to enable login with Telegram.

If you *additionally* have `loginMethods` configured client-side in your `PrivyProvider` config, make sure you add `"telegram"` to that list as well. Client-side login method configuration is only necessary if you want to restrict logins to a subset of those configured in the Dashboard.

```jsx  theme={"system"}
  <PrivyProvider
    appId={process.env.NEXT_PUBLIC_PRIVY_APP_ID || ""}
    config={{
      loginMethods: ["email", "google", "telegram"],
      ...
    }}
  >
```

### Seamless login with Telegram

You can integrate Privy to enable login directly from within a Telegram bot or Telegram mini-app.

* If enabled, Privy will automatically log your user in when your user initiates login from within Telegram. You *do not* have to call `login` from the `usePrivy` hook in this case!
* To enable seamless login, send your website URL using , [InlineKeyboardButton.web\_app](https://core.telegram.org/bots/api#inlinekeyboardbutton) or [InlineKeyboardButton.login\_url](https://core.telegram.org/bots/api#inlinekeyboardbutton) or use a direct link (ex: `t.me/xxx_bot/xxx`)
* For reference, see these docs:
  * [https://core.telegram.org/bots/api#keyboardbutton](https://core.telegram.org/bots/api#keyboardbutton)
  * [https://core.telegram.org/bots/api#inlinekeyboardbutton](https://core.telegram.org/bots/api#inlinekeyboardbutton)

```jsx  theme={"system"}
bot.send_message(chat_id, 'Log in to demo!', {
  reply_markup: {
    inline_keyboard: [
      [
        {
          text: 'Login',
          login_url: {url: 'https://your-website-url'}
        },
        {
          text: 'Mini App',
          web_app: {url: 'https://your-website-url'}
        }
      ]
    ]
  }
});
```

### Login with Telegram

Once Telegram is enabled, you will *automatically* see Telegram in the Privy login modal. You can also list `'telegram'` when [configuring login methods client-side](/basics/react/advanced/configuring-appearance), in the `PrivyProvider`.

### Link Telegram

You can use the `linkTelegram` and `unlinkTelegram` methods from the `usePrivy` hook to add or remove Telegram accounts from a user. See the SDK reference for more details:

```jsx  theme={"system"}
const {linkTelegram, unlinkTelegram} = usePrivy();
```

### Link Telegram seamlessly within a Telegram Mini app

You can use the `linkTelegram` methods from the `usePrivy` hook within a Telegram Mini App to add to a user seamlessly by passing `launchParams` as a parameter. See the SDK reference for more details:

```jsx  theme={"system"}
// Sample library to retrieve launchParams
import {retrieveLaunchParams} from '@telegram-apps/bridge';

const {linkTelegram} = usePrivy();
const launchParams = retrieveLaunchParams();
linkTelegram({launchParams});
```

<Warning>Telegram `launchParams` are treated as expired after five minutes for security.</Warning>

### TelegramAccount type

The `user` object contains information about [all of the accounts](/user-management/users/the-user-object) a user has linked with Privy.

```jsx  theme={"system"}
Use the fields:
- **`user.linkAccounts`** to get a list of all the user's linked accounts
- **`user.telegram`** to get the user's Telegram account
```

**`TelegramAccount` extends `LinkedAccount`**

| Field              | Type       | Description                                                      |
| ------------------ | ---------- | ---------------------------------------------------------------- |
| type               | 'telegram' | N/A                                                              |
| telegram\_user\_id | string     | ID of a user's telegram account.                                 |
| first\_name        | string     | The first name displayed on a user's telegram account.           |
| last\_name         | string     | (Optional) The last name displayed on a user's telegram account. |
| username           | string     | (Optional) The username displayed on a user's telegram account.  |
| photo\_url         | string     | (Optional) The url of a user's telegram account profile picture. |


# Whitelabel
Source: https://docs.privy.io/recipes/react/whitelabel



The Privy React SDK provides complete control over all interfaces for authentication, embedded wallets, and user management. You can customize the user experience to match your brand while maintaining the security and reliability of Privy's infrastructure.

<Tip>
  The fastest way to get started with whitelabeling is to fork our [whitelabel starter repository](https://github.com/privy-io/examples/tree/main/privy-react-whitelabel-starter). This template provides a fully customizable foundation that you can build upon.
</Tip>

## What you can customize

<CardGroup cols={2}>
  <Card title="Authentication flows" icon="user-check" href="/recipes/react/whitelabel#authentication" horizontal>
    Whitelabel login and MFA with your own UI and branding.
  </Card>

  <Card title="Embedded wallets" icon="wallet" href="/recipes/react/whitelabel#wallets" horizontal>
    Create seamless wallet interactions with your own UI components and styling.
  </Card>

  <Card title="User management" icon="users" href="/recipes/react/whitelabel#user-management" horizontal>
    Manage user profiles and connect social accounts your way.
  </Card>
</CardGroup>

## Whitelabeling your app

Privy allows developers to choose when to take advantage of Privy's UI and when to customize the experience with their own UI. This guide walks through how to whitelabel your app.

### Authentication

All of Privy's authentication flows can be whitelabeled, from email and SMS passwordless flows to social logins and passkeys.

<Accordion title="Email" defaultOpen>
  To whitelabel Privy's passwordless email flow, use the `useLoginWithEmail` hook. Then, call `sendCode` and `loginWithCode` with the desired email address.

  ```tsx  theme={"system"}
  import {useLoginWithEmail} from '@privy-io/react-auth';
  ```

  ```tsx  theme={"system"}
  const {sendCode, loginWithCode} = useLoginWithEmail();
  sendCode({email: 'test@test.com'});
  loginWithCode({code: '123456'});
  ```

  Learn more about [email authentication and tracking login flow state](/authentication/user-authentication/login-methods/email).
</Accordion>

<Accordion title="SMS">
  To whitelabel the passwordless SMS flow, use the `useLoginWithSms` hook. Then, call `sendCode` and `loginWithCode` with the desired phone number.

  ```tsx  theme={"system"}
  import {useLoginWithSms} from '@privy-io/react-auth';
  ```

  ```tsx  theme={"system"}
  const {sendCode, loginWithCode} = useLoginWithSms();
  sendCode({phoneNumber: '+1234567890'});
  loginWithCode({code: '123456'});
  ```

  Learn more about [SMS authentication and tracking login flow state](/authentication/user-authentication/login-methods/sms).
</Accordion>

<Accordion title="Social logins">
  To whitelabel social login, use the `useLoginWithSocial` hook and call `initOAuth` with your desired social login provider.

  ```tsx  theme={"system"}
  import {useLoginWithSocial} from '@privy-io/react-auth';
  ```

  ```tsx  theme={"system"}
  const {initOAuth} = useLoginWithSocial();
  initOAuth({provider: 'google'});
  ```

  Learn more about [social logins and tracking login flow state](/authentication/user-authentication/login-methods/oauth).
</Accordion>

<Accordion title="Passkeys">
  To whitelabel passkeys, use the `useLoginWithPasskey` hook and call `loginWithPasskey`.

  ```tsx  theme={"system"}
  import {useLoginWithPasskey} from '@privy-io/react-auth';
  ```

  ```tsx  theme={"system"}
  const {loginWithPasskey} = useLoginWithPasskey();
  loginWithPasskey();
  ```

  To sign up with a passkey:

  ```tsx  theme={"system"}
  import {useSignupWithPasskey} from '@privy-io/react-auth';
  ```

  ```tsx  theme={"system"}
  const {signupWithPasskey} = useSignupWithPasskey();
  signupWithPasskey();
  ```

  To link a passkey to an existing user:

  ```tsx  theme={"system"}
  import {useLinkWithPasskey} from '@privy-io/react-auth';
  ```

  ```tsx  theme={"system"}
  const {linkWithPasskey} = useLinkWithPasskey();
  linkWithPasskey();
  ```

  Learn more about [passkeys and tracking login flow state](/authentication/user-authentication/login-methods/passkey).
</Accordion>

<Accordion title="Telegram">
  To whitelabel the Telegram login flow, it's as simple as using the `useLoginWithTelegram` hook and calling `login`.

  ```tsx  theme={"system"}
  import {useLoginWithTelegram} from '@privy-io/react-auth';
  ```

  ```tsx  theme={"system"}
  const {login, state} = useLoginWithTelegram();
  login();
  ```

  Learn more about [Telegram authentication and tracking login flow state](/authentication/user-authentication/login-methods/telegram).
</Accordion>

<Accordion title="MFA">
  To whitelabel MFA with SMS, TOTP, or passkeys, follow the [custom UI guide](/authentication/user-authentication/mfa/custom-ui).
</Accordion>

### Wallets

Privy enables developers to whitelabel embedded wallet functionality. You can abstract away wallet UIs entirely or selectively use Privy's default UI for specific flows.

To whitelabel embedded wallets, you can configure this globally across your app in the `PrivyProvider` config, or selectively for specific flows at runtime.

<Accordion title="Provider config (globally)">
  In your `PrivyProvider` config you can control the default wallet UI for all flows in your app.

  ```tsx {5} theme={"system"}
  <PrivyProvider
    appId={process.env.NEXT_PUBLIC_PRIVY_APP_ID || ''}
    config={{
      embeddedWallets: {
        showWalletUIs: false,
        priceDisplay: {primary: 'native-token', secondary: null}
      }
    }}
  >
    <YourApp />
  </PrivyProvider>
  ```

  For more granular control, you can also control wallet UIs for specific flows in the sections below.
</Accordion>

<Accordion title="Create a wallet" defaultOpen>
  Privy supports whitelabeling wallet creation for Ethereum, Solana, and other chains.

  <Tabs>
    <Tab title="Ethereum">
      ```tsx  theme={"system"}
      import {useCreateWallet} from '@privy-io/react-auth';
      ```

      ```tsx  theme={"system"}
      const {createWallet} = useCreateWallet();
      createWallet();
      ```
    </Tab>

    <Tab title="Solana">
      ```tsx  theme={"system"}
      import {useWallets} from '@privy-io/react-auth/solana';
      ```

      ```tsx  theme={"system"}
      const {createWallet} = useWallets();
      createWallet();
      ```
    </Tab>

    <Tab title="Other chains">
      ```tsx  theme={"system"}
      import {useCreateWallet} from '@privy-io/react-auth/extended-chains';
      ```

      ```tsx  theme={"system"}
      const {createWallet} = useCreateWallet();
      const {user, wallet} = await createWallet({chainType: 'cosmos'}); // or 'stellar', 'sui', etc.
      ```
    </Tab>
  </Tabs>
</Accordion>

<Accordion title="Signing a message">
  To whitelabel Privy's message signing functionality, use the `useSignMessage` hook and call `signMessage` with your desired message.

  <Tabs>
    <Tab title="Ethereum">
      ```tsx  theme={"system"}
      import {useSignMessage} from '@privy-io/react-auth';
      ```

      ```tsx  theme={"system"}
      const {signMessage} = useSignMessage();
      const signature = await signMessage(
        {message: 'Hello, world!'},
        {uiOptions: {showWalletUIs: false}}
      );
      ```
    </Tab>

    <Tab title="Solana">
      ```tsx  theme={"system"}
      import {useSignMessage} from '@privy-io/react-auth/solana';
      ```

      ```tsx  theme={"system"}
      const {signMessage} = useSignMessage();
      signMessage({
        message: 'messageinUint8Array',
        options: {uiOptions: {showWalletUIs: false}}
      });
      ```
    </Tab>

    <Tab title="Other chains">
      ```tsx  theme={"system"}
      import {useSignRawHash} from '@privy-io/react-auth/extended-chains';
      ```

      ```tsx  theme={"system"}
      const {signature} = await signRawHash({
        address: 'insert-wallet-address',
        chainType: 'cosmos', // or 'stellar', 'sui', etc.
        hash: '0x1acab030f479bda7829de07e9db4138cec5d38574df17d65af1617b7268541c0'
      });
      ```
    </Tab>
  </Tabs>
</Accordion>

<Accordion title="Sending a transaction">
  To whitelabel Privy's transaction sending functionality, use the `useSendTransaction` hook and call `sendTransaction` with your desired transaction.

  <Tabs>
    <Tab title="Ethereum">
      ```tsx  theme={"system"}
      import {useSendTransaction} from '@privy-io/react-auth';
      ```

      ```tsx  theme={"system"}
      const {sendTransaction} = useSendTransaction();
      sendTransaction(
        {
          to: '0xE3070d3e4309afA3bC9a6b057685743CF42da77C',
          value: 100000
        },
        {
          uiOptions: {showWalletUIs: false}
        }
      );
      ```
    </Tab>

    <Tab title="Solana">
      ```tsx  theme={"system"}
      import {useSendTransaction} from '@privy-io/react-auth/solana';
      ```

      ```tsx  theme={"system"}
      const {sendTransaction} = useSendTransaction();
      sendTransaction({
        transaction: 'insert-solana-transaction',
        uiOptions: {showWalletUIs: false}
      });
      ```
    </Tab>
  </Tabs>
</Accordion>

### User management

Privy supports whitelabeling user management for linking and unlinking accounts.

<Accordion title="Linking a social account">
  To whitelabel linking social accounts, use the `useLinkAccount` hook and call `link<Provider>`.

  ```tsx  theme={"system"}
  import {useLinkAccount} from '@privy-io/react-auth';
  ```

  ```tsx  theme={"system"}
  const {linkGoogle, linkTwitter} = useLinkAccount();
  linkGoogle();
  linkTwitter();
  ```
</Accordion>

<Accordion title="Linking a wallet">
  To whitelabel linking wallets, use the `useLinkWithSiwe` hook for Ethereum wallets or `useLinkWithSiws` hook for Solana wallets. These hooks allow you to generate messages, request signatures, and link wallets without using Privy's modal UI.

  <Tabs>
    <Tab title="Ethereum (SIWE)">
      To link an Ethereum wallet to a user via [SIWE](https://eips.ethereum.org/EIPS/eip-4361), use the React SDK's `useLinkWithSiwe` hook.

      ### Generate SIWE message

      ```tsx  theme={"system"}
      generateSiweMessage({ address: string, chainId: string }) => Promise<string>
      ```

      <Expandable title="Parameters">
        <ParamField path="address" type="string" required>
          EIP-55 checksum-encoded wallet address performing the signing.
        </ParamField>

        <ParamField path="chainId" type="string" required>
          The chain ID to which the session is bound, in [CAIP-2 format](https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-2.md), e.g. `'eip155:1'`.
        </ParamField>
      </Expandable>

      ### Sign the SIWE message

      Request an EIP-191 `personal_sign` signature for the `message` returned by `generateSiweMessage` from the wallet.

      ```tsx  theme={"system"}
      import {useWallets} from '@privy-io/react-auth';

      const {wallets} = useWallets();
      const signature = await wallets[0].sign(message);
      ```

      Alternatively, you can request a signature from any external wallet or smart account:

      ```tsx  theme={"system"}
      const signature = await wallet.signMessage({message});
      ```

      ### Link with SIWE

      ```tsx  theme={"system"}
      linkWithSiwe({
        signature: string,
        message: string,
        chainId: string,
        walletClientType?: string,
        connectorType?: string
      }) => Promise<void>
      ```

      <Expandable title="Parameters">
        <ParamField path="signature" type="string" required>
          The EIP-191 signature corresponding to the message.
        </ParamField>

        <ParamField path="message" type="string" required>
          The EIP-4361 message returned by `generateSiweMessage`.
        </ParamField>

        <ParamField path="chainId" type="string" required>
          The same [CAIP-2 formatted](https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-2.md)
          chain ID you passed to `generateSiweMessage`, e.g. `'eip155:1'`.
        </ParamField>

        <ParamField path="walletClientType" type="string">
          Optional. The wallet client of the external wallet (e.g., `'metamask'`, `'coinbase_wallet'`).
          Defaults to `null` if not specified.
        </ParamField>

        <ParamField path="connectorType" type="string">
          Optional. The method used to connect the wallet to the application (e.g., `'injected'`, `'wallet_connect_v2'`). Defaults to `null` if not specified.
        </ParamField>
      </Expandable>

      ### Usage

      ```tsx  theme={"system"}
      import {useLinkWithSiwe, useWallets} from '@privy-io/react-auth';

      export function LinkWalletButton() {
        const {generateSiweMessage, linkWithSiwe} = useLinkWithSiwe();
        const {wallets} = useWallets();

        const handleLink = async () => {
          if (!wallets?.length) return;
          const activeWallet = wallets[0];

          const message = await generateSiweMessage({
            address: activeWallet.address,
            chainId: 'eip155:1'
          });

          const signature = await activeWallet.sign(message);
          await linkWithSiwe({
            message,
            chainId: 'eip155:1',
            signature
          });
        };

        return <button onClick={handleLink}>Link wallet</button>;
      }
      ```

      ### Callbacks

      You can optionally pass callbacks into `useLinkWithSiwe`:

      ```tsx  theme={"system"}
      const {generateSiweMessage, linkWithSiwe} = useLinkWithSiwe({
        onSuccess: ({user, linkMethod, linkedAccount}) => {
          console.log('Wallet linked successfully', linkedAccount);
        },
        onError: (error) => {
          console.error('Failed to link wallet', error);
        }
      });
      ```
    </Tab>

    <Tab title="Solana (SIWS)">
      To link a Solana wallet to a user via [SIWS](https://github.com/phantom/sign-in-with-solana), use the React SDK's `useLinkWithSiws` hook.

      ### Generate SIWS message

      ```tsx  theme={"system"}
      generateSiwsMessage({ address: string }) => Promise<string>
      ```

      <Expandable title="Parameters">
        <ParamField path="address" type="string" required>
          The Solana wallet address performing the signing.
        </ParamField>
      </Expandable>

      ### Sign the SIWS message

      Request a signature for the `message` returned by `generateSiwsMessage` from the Solana wallet. The message needs to be encoded as Uint8Array for signing.

      ```tsx  theme={"system"}
      import {useWallets} from '@privy-io/react-auth/solana';

      const {wallets} = useWallets();
      const encodedMessage = new TextEncoder().encode(message);
      const results = await wallets[0].signMessage({message: encodedMessage});
      ```

      ### Link with SIWS

      ```tsx  theme={"system"}
      linkWithSiws({
        message: string,
        signature: string,
        walletClientType?: string,
        connectorType?: string
      }) => Promise<{ user: User; linkedAccount: LinkedAccountWithMetadata | null }>
      ```

      <Expandable title="Parameters">
        <ParamField path="message" type="string" required>
          The SIWS message returned from `generateSiwsMessage`.
        </ParamField>

        <ParamField path="signature" type="string" required>
          The signature corresponding to the message. Convert the signature bytes from the wallet's
          `signMessage` method to a base64-encoded string using
          `Buffer.from(results.signature).toString('base64')`.
        </ParamField>

        <ParamField path="walletClientType" type="string">
          Optional. A string indicating the wallet client you'd like to associate with the wallet. Defaults
          to `'privy'`.
        </ParamField>

        <ParamField path="connectorType" type="string">
          Optional. A string indicating the connector type you'd like to associate with the wallet. Defaults to `'privy'`.
        </ParamField>
      </Expandable>

      ### Usage

      ```tsx  theme={"system"}
      import {useLinkWithSiws} from '@privy-io/react-auth';
      import {useWallets} from '@privy-io/react-auth/solana';

      export function LinkSolanaWalletButton() {
        const {generateSiwsMessage, linkWithSiws} = useLinkWithSiws();
        const {wallets} = useWallets();

        const handleLink = async () => {
          if (!wallets?.length) return;
          const activeWallet = wallets[0];

          const message = await generateSiwsMessage({
            address: activeWallet.address
          });

          const encodedMessage = new TextEncoder().encode(message);
          const results = await activeWallet.signMessage({message: encodedMessage});

          // Convert signature bytes to string (base64)
          const signatureBase64 = Buffer.from(results.signature).toString('base64');

          await linkWithSiws({
            message,
            signature: signatureBase64
          });
        };

        return <button onClick={handleLink}>Link Solana wallet</button>;
      }
      ```

      ### Callbacks

      You can optionally pass callbacks into `useLinkWithSiws`:

      ```tsx  theme={"system"}
      const {generateSiwsMessage, linkWithSiws} = useLinkWithSiws({
        onSuccess: ({user, linkMethod, linkedAccount}) => {
          console.log('Solana wallet linked successfully', linkedAccount);
        },
        onError: (error) => {
          console.error('Failed to link Solana wallet', error);
        }
      });
      ```
    </Tab>
  </Tabs>
</Accordion>

<Accordion title="Unlinking an account">
  To whitelabel unlinking an account, use the `usePrivy` hook and call `unlink<Provider>`.

  ```tsx  theme={"system"}
  import {usePrivy} from '@privy-io/react-auth';
  ```

  ```tsx  theme={"system"}
  const {unlinkEmail, unlinkGoogle, unlinkWallet} = usePrivy();
  unlinkEmail();
  unlinkGoogle();
  unlinkWallet();
  ```
</Accordion>

## Resources

<CardGroup cols={3}>
  <Card title="Whitelabel starter" icon="github" href="https://github.com/privy-io/examples/tree/main/privy-react-whitelabel-starter" arrow>
    Fork our starter repository to begin building your custom Privy integration.
  </Card>

  <Card title="Whitelabel demo" icon="arrow-up-right-from-square" href="https://whitelabel.privy.io" arrow>
    See a live demo of a whitelabeled app.
  </Card>
</CardGroup>


# Worldcoin Mini App SIWE with Privy
Source: https://docs.privy.io/recipes/react/worldcoin-siwe-guide



Privy offers a seamless integration with Worldcoin Mini Apps. This guide will walk you through integrating Sign-In With Ethereum (SIWE) using Privy in a Worldcoin Mini App. With this setup, you can offer secure wallet authentication for your users—combining the power of World App's native wallet with Privy's flexible authentication and wallet infrastructure.

### Resources

<CardGroup cols={3}>
  <Card title="Worldcoin Mini Apps Docs" icon="arrow-up-right-from-square" href="https://docs.world.org/mini-apps" arrow>
    Official documentation for building Worldcoin Mini Apps.
  </Card>

  <Card title="Worldcoin Developer Portal" icon="arrow-up-right-from-square" href="https://developer.worldcoin.org/" arrow>
    Register your mini app and manage API keys.
  </Card>

  <Card title="Privy React Setup" icon="arrow-up-right-from-square" href="/basics/react/setup" arrow>
    Learn how to set up Privy in your React app.
  </Card>
</CardGroup>

## Configure your Worldcoin developer portal

Create a Worldcoin developer account and mini app, learn more [here](https://docs.world.org/mini-apps/quick-start/installing).

<Expandable title="Create a Worldcoin developer account and mini app">
  <Steps>
    <Step title="Create a Worldcoin developer account and mini app">
      1. Go to the [Worldcoin Developer Portal](https://developer.worldcoin.org/).
      2. Sign in and create a new team if you haven't already.
      3. Create a new mini app for your project.
    </Step>

    <Step title="Get your appId and API key">
      1. In your team dashboard, select your mini app.
      2. Copy your **App ID** (you'll need this for your app config).
      3. Go to the [API Keys page](https://developer.worldcoin.org/teams/\{TEAM_ID}/api-keys) and create a new API key for your app.
      4. Save your API key securely.
    </Step>
  </Steps>
</Expandable>

## Get set up with Privy

<Note>
  If you haven't set up Privy yet, follow our [React quickstart guide](/basics/react/installation)
  to get your app ID and configure your app.
</Note>

Privy's React SDK provides a secure way to authenticate users and manage wallets in your frontend application. Learn more about [getting started with React](/basics/react/installation).

## Set up with Worldcoin Mini App

<Steps>
  <Step title="Create your mini app using the quickstart">
    Scaffold a new Worldcoin Mini App using the official template:

    ```
    npx @worldcoin/create-mini-app@latest my-mini-app
    ```

    Follow the prompts in the README to set up your app. Use the env variables from your Worldcoin developer portal to configure your app.
  </Step>

  <Step title="Explore the starter repo structure">
    Your new app will have a file at `src/components/AuthButton/index.tsx`—this is where you'll add
    Privy SIWE support.
  </Step>
</Steps>

## SIWE into mini app with Privy

We will be using the `useLoginWithSiwe` hook to handle the SIWE flow.

```typescript  theme={"system"}
import {useLoginWithSiwe} from '@privy-io/react-auth';
const {generateSiweNonce, loginWithSiwe} = useLoginWithSiwe();
```

<Steps>
  <Step title="Get the nonce from Privy">
    Use the `generateSiweNonce` function from Privy to get a unique nonce for the SIWE flow.

    ```typescript  theme={"system"}
    const privyNonce = await generateSiweNonce();
    ```

    This nonce will be used to ensure the SIWE message is unique and secure.
  </Step>

  <Step title="Pass the nonce to Worldcoin walletAuth">
    Use the Worldcoin MiniKit to trigger the wallet authentication flow, passing in the nonce you just received.

    ```typescript  theme={"system"}
    const { finalPayload } = await MiniKit.commandsAsync.walletAuth({
      nonce: privyNonce,
    });
    ```

    This will prompt the user to sign a SIWE message in their World App wallet.
  </Step>

  <Step title="Send the signed message and signature to Privy">
    Take the response from Worldcoin (the signed message and signature) and send it to Privy to complete authentication.

    ```typescript  theme={"system"}
    const { message, signature } = finalPayload;
    const user = await loginWithSiwe({ message, signature });
    ```

    This will log the user in via Privy using the SIWE flow.
  </Step>

  <Step title="Access the user session data">
    Once logged in, you can access the user's worldcoin information and wallet data. For example, to get user info from Worldcoin:

    ```typescript  theme={"system"}
    const userInfo = await MiniKit.getUserByAddress(user.wallet.address);
    ```
  </Step>
</Steps>

<Check>
  Your Worldcoin Mini App now supports SIWE authentication with Privy and World App! Enjoy seamless,
  secure onboarding for your users 🚀
</Check>


# Funding wallets with Relay deposit addresses
Source: https://docs.privy.io/recipes/relay-deposit-addresses



Relay deposit addresses allow users to bridge and swap assets instantly simply by sending tokens to a deposit address.

Request a deposit address for your bridging/swapping pair, send your source asset to that address, and Relay automatically bridges and swaps them to the target asset on the destination chain.

This works seamlessly for wallet funding with Privy's client-side SDKs, server-side SDKs, and REST API.

## Resources

<CardGroup cols={1}>
  <Card title="Relay docs" icon="arrow-up-right-from-square" href="https://docs.relay.link/features/deposit-addresses" arrow>
    Relay deposit address documentation.
  </Card>
</CardGroup>

***

## Prerequisites

If you have not set up Privy yet, [choose the SDK of your choice](/basics/get-started/platforms) to integrate Privy in your project.

***

## Integrating Relay deposit addresses

<Steps>
  <Step title="1. Request deposit address from Relay API">
    Request a deposit address from Relay's API by making a POST request to `https://api.relay.link/quote` with deposit address enabled. This generates a unique deposit address that cannot be reused.

    ```bash  theme={"system"}
    curl --request POST \
      --url 'https://api.relay.link/quote' \
      --header 'Content-Type: application/json' \
      --data '{
        "user": "0xF0AE622e463fa757Cf72243569E18Be7Df1996cd",
        "originChainId": 8453,
        "originCurrency": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
        "destinationChainId": 10,
        "destinationCurrency": "0x0b2C639c533813f4Aa9D7837CAf62653d097Ff85",
        "tradeType": "EXACT_INPUT",
        "recipient": "0xF0AE622e463fa757Cf72243569E18Be7Df1996cd",
        "amount": "100000000",
        "usePermit": false,
        "useExternalLiquidity": false,
        "referrer": "privy.io",
        "useDepositAddress": true,
        "refundTo": "0xF0AE622e463fa757Cf72243569E18Be7Df1996cd"
      }'
    ```

    See the body parameters for this request below.

    <Tip>
      When using deposit addresses, set `useDepositAddress` to `true`, `refundTo` to the refund
      recipient address, and `tradeType` to `EXACT_INPUT`. Only exact input bridging is supported for
      deposit addresses.
    </Tip>

    <Expandable title="Request body parameters">
      <ParamField body="originChainId" type="number" required>
        The chain ID of the source chain (e.g., `8453` for Base).
      </ParamField>

      <ParamField body="originCurrency" type="string" required>
        The token address to send. Use `0x0000000000000000000000000000000000000000` for native tokens
        (ETH, MATIC, etc.).
      </ParamField>

      <ParamField body="destinationChainId" type="number" required>
        The chain ID of the destination chain (e.g., `10` for Optimism).
      </ParamField>

      <ParamField body="destinationCurrency" type="string" required>
        The token address to receive. Use `0x0000000000000000000000000000000000000000` for native tokens.
      </ParamField>

      <ParamField body="recipient" type="string" required>
        The wallet address that will receive the bridged/swapped tokens.
      </ParamField>

      <ParamField body="amount" type="string" required>
        The amount to bridge/swap, in the smallest unit (wei for ETH, etc.).
      </ParamField>

      <ParamField body="tradeType" type="string" required>
        Must be set to `EXACT_INPUT` when using deposit addresses. Only exact input bridging is allowed
        for deposit addresses.
      </ParamField>

      <ParamField body="useDepositAddress" type="boolean" required>
        Must be set to `true` to enable deposit address flow.
      </ParamField>

      <ParamField body="refundTo" type="string" required>
        Required when using deposit addresses. Address that receives refunds if the bridge fails.
      </ParamField>
    </Expandable>
  </Step>

  <Step title="2. Extract deposit address and requestId">
    The quote response contains a `steps` array with information for how to execute your bridge/swap.

    Specifically, extract the `depositAddress` from `quote.steps[0].depositAddress` and the `requestId` from `quote.steps[0].requestId`. The `depositAddress` is where you send tokens, and the `requestId` is used to track the bridge status.

    ```tsx  theme={"system"}
    const depositAddress = quote.steps[0].depositAddress;
    const requestId = quote.steps[0].requestId;
    ```
  </Step>

  <Step title="3. Send funds to deposit address">
    Send tokens to the deposit address. They will be bridged or swapped and sent to the recipient address on the destination chain.
  </Step>
</Steps>

***

### Check bridge status

After sending funds to the deposit address, your app can monitor the bridge status using the `requestId` from the quote response.

<Expandable title="Status checking code example">
  ```tsx  theme={"system"}
  const checkBridgeStatus = async (requestId: string) => {
    const response = await fetch(`https://api.relay.link/intents/status?requestId=${requestId}`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) {
      throw new Error(`Failed to check bridge status: ${response.statusText}`);
    }

    return await response.json();
  };
  ```
</Expandable>

***

## Conclusion

With Privy and Relay deposit addresses, your app can enable seamless cross-chain funding for your users' embedded wallets. Users can fund wallets on any chain from any supported chain, making the onboarding and funding experience frictionless.

For limitations, edge cases, and advanced use cases, refer to the [Relay deposit addresses documentation](https://docs.relay.link/features/deposit-addresses), or reach out to us in [Slack](https://privy.io/slack).


# Sending USDC (or other ERC-20s)
Source: https://docs.privy.io/recipes/send-usdc



Sending USDC, or other ERC-20 tokens, is one of the most common actions taken by wallet users on Ethereum-based chains. This guide will walk you through how to format the transaction input data for these tokens, using USDC as an example.

## 1. Get the USDC contract address

To send USDC, you'll need the contract address for USDC. The address is different for each network, so make sure you get the correct address for the network you're targeting.
You can go to Circle's website to look up the USDC address on both [main networks](https://developers.circle.com/stablecoins/usdc-on-main-networks) and [test networks](https://developers.circle.com/stablecoins/usdc-on-test-networks).

## 2. Format the transaction send input data

USDC, and other ERC-20 tokens, are smart contracts. In order to send these tokens, your transaction needs to call the `transfer` function on the contract, which takes in two parameters:

* `to`: The address of the recipient
* `value`: The amount of tokens to send

When formatting the transaction input data, you must define the expected interface of the function you're calling by providing an ABI. You can use helper packages like `viem` to provide the ABI and encode the function parameters.

Additionally, each ERC-20 token defines a `decimals` value, which is the number of decimal places for the token. For USDC, the `decimals` value is usually 6, but for most other ERC-20 tokens, it's 18.

<Tabs>
  <Tab title="Typescript">
    First, install the `viem` package if it is not installed yet.

    ```bash  theme={"system"}
    npm install viem
    ```

    Then, build the transaction input data.

    ```typescript  theme={"system"}
    import {encodeFunctionData, erc20Abi} from 'viem';

    const recipientAddress = '0x...';
    const amountToSend = 1; // Sender wants to send 1 USDC
    const decimals = 6; // USDC has 6 decimals

    const encodedData = encodeFunctionData({
      abi: erc20Abi,
      functionName: 'transfer',
      args: [recipientAddress, BigInt(amountToSend * 10 ** decimals)]
    });
    ```
  </Tab>

  <Tab title="Python">
    First, install the `eth-abi` package.

    ```bash  theme={"system"}
    pip install eth-abi
    ```

    Then, build the transaction input data.

    ```python  theme={"system"}
    from eth_abi.abi import encode
    from eth_utils import function_signature_to_4byte_selector

    usdc_address = "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913" # address on base
    # Simplified ABI for the transfer function only
    function_signature = "transfer(address,uint256)"
    function_selector = function_signature_to_4byte_selector(function_signature)
    decimals = 6
    encoded_params = encode(
        ["address", "uint256"],
        [recipient_address, amount_to_send * 10**decimals],
    )
    data = "0x" + (function_selector + encoded_params).hex()

    ```
  </Tab>
</Tabs>

## 3. Send the transaction

You can send the transaction using the Privy API. Below are examples for React, React Native, and NodeJS; you can find other SDKs' send transaction examples in the [Send a transaction](/wallets/using-wallets/ethereum/send-a-transaction) guide.

<Tabs>
  <Tab title="React">
    ```typescript  theme={"system"}
    import {useSendTransaction} from '@privy-io/react-auth';
    const {sendTransaction} = useSendTransaction();

    const {hash} = await sendTransaction({
      to: '$USDC_CONTRACT_ADDRESS',
      data: '0x', // from the previous step
      chainId: 8453 // Base's chainId
    });
    ```
  </Tab>

  <Tab title="React Native">
    ```typescript  theme={"system"}
    import {useEmbeddedEthereumWallet} from '@privy-io/expo';

    const {wallets} = useEmbeddedEthereumWallet();
    const wallet = wallets[0];

    const provider = await wallet.getProvider();
    const accounts = await provider.request({
      method: 'eth_requestAccounts'
    });

    // Send transaction (will be signed and populated)
    const response = await provider.request({
      method: 'eth_sendTransaction',
      params: [
        {
          from: accounts[0],
          to: '$USDC_CONTRACT_ADDRESS',
          data: '0x' // from the previous step
        }
      ]
    });
    ```
  </Tab>

  <Tab title="NodeJS">
    ```typescript {skip-check} theme={"system"}
    import {PrivyClient} from '@privy-io/node';

    const privy = new PrivyClient({
      appId: 'insert-your-app-id',
      appSecret: 'insert-your-app-secret'
    });

    const usdcContractAddress = '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'; // on Base

    const {hash} = await privy
      .wallets()
      .ethereum()
      .sendTransaction('insert-wallet-id', {
        caip2: 'eip155:8453', // Base's caip2
        params: {
          transaction: {
            to: usdcContractAddress,
            data: encodedData, // from the previous step
            chain_id: 8453 // Base's chainId
          }
        }
      });
    ```
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    ```typescript  theme={"system"}
    import {PrivyClient} from '@privy-io/server-auth';

    const privy = new PrivyClient(process.env.PRIVY_APP_ID!, process.env.PRIVY_APP_SECRET!);

    const usdcContractAddress = '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'; // on Base

    const {hash} = await privy.walletApi.ethereum.sendTransaction({
      walletId: 'insert-wallet-id',
      caip2: 'eip155:8453', // Base's caip2
      transaction: {
        to: usdcContractAddress,
        data: '0x...', // from the previous step
        chainId: 8453 // Base's chainId
      }
    });
    ```
  </Tab>

  <Tab title="Python">
    ```python  theme={"system"}
    tx = client.wallets.rpc(
        wallet_id=user.wallet_id,
        method="eth_sendTransaction",
        caip2="eip155:8453", # Base's caip2
        params={
            "transaction": {
                "to": usdc_address,
                "data": data,
            },
        },
    )
    return {"response": tx.data}

    ```
  </Tab>
</Tabs>

You've successfully sent USDC!


# Integrating Solana Mobile Wallet Adapter
Source: https://docs.privy.io/recipes/solana/adding-solana-mwa



The Solana Mobile Wallet Adapter (MWA) is a library that allows apps to connect to mobile Solana wallets. This guide will walk you through the steps to integrate MWA into your Privy app.

<Tabs>
  <Tab title="React">
    ## Resources

    <CardGroup cols={1}>
      <Card title="Privy Solana setup" icon="wallet" href="/basics/react/setup#solana" arrow>
        Learn how to set up Solana in your React app with Privy.
      </Card>
    </CardGroup>

    ## Install dependencies

    Install the required dependencies:

    ```bash  theme={"system"}
    npm i @solana-mobile/wallet-standard-mobile
    ```

    ## Register the MWA adapter

    In your app's root component, register the MWA adapter with Privy.

    ```typescript  theme={"system"}
    import {
      createDefaultAuthorizationCache,
      createDefaultChainSelector,
      createDefaultWalletNotFoundHandler,
      registerMwa
    } from '@solana-mobile/wallet-standard-mobile';

    registerMwa({
      appIdentity: {
        name: 'My app',
        uri: 'https://myapp.io',
        icon: 'relative/path/to/icon.png' // resolves to https://myapp.io/relative/path/to/icon.png
      },
      authorizationCache: createDefaultAuthorizationCache(),
      chains: ['solana:mainnet'],
      chainSelector: createDefaultChainSelector(),
      onWalletNotFound: createDefaultWalletNotFoundHandler()
    });
    ```
  </Tab>

  <Tab title="React Native">
    <Note>
      Solana Mobile Wallet Adapter is only supported on Android devices.
    </Note>

    ## Resources

    <CardGroup cols={1}>
      <Card title="Mobile Wallet Adapter documentation" icon="wallet" href="https://docs.solanamobile.com/react-native/using_mobile_wallet_adapter#add-dependencies" arrow>
        Official documentation for integrating Solana Mobile Wallet Adapter in React Native apps.
      </Card>
    </CardGroup>

    ## Install dependencies

    Install the required dependencies:

    ```bash  theme={"system"}
    npm install @solana-mobile/mobile-wallet-adapter-protocol-web3js @solana-mobile/mobile-wallet-adapter-protocol
    ```

    ## Create a MWA session

    In order to connect and log in users with MWA wallets, you need to create a MWA session by calling the `transact` and `authorize` methods from the `@solana-mobile/mobile-wallet-adapter-protocol-web3js` package, you'll then need to log in the user with Privy using the `useLoginWithSiws` hook.

    You can do this in a custom login button component.

    ```tsx  theme={"system"}
    import {transact} from '@solana-mobile/mobile-wallet-adapter-protocol-web3js';
    import {useLoginWithSiws} from '@privy-io/expo';
    import {toByteArray} from 'react-native-quick-base64';
    import {PublicKey} from '@solana/web3.js';
    import {Buffer} from 'buffer';

    const MwaLoginButton = () => {
      const {generateMessage, login} = useLoginWithSiws();

      const handleLogin = async () => {
        try {
          await transact(async (wallet) => {
            // 1. Create a MWA session
            const authorizationResult = await wallet.authorize({
              chain: 'mainnet-beta',
              identity: {
                name: 'My app',
                uri: 'https://myapp.io',
                icon: 'https://myapp.io/icon.png'
              }
            });
            const desiredAccount = authorizationResult.accounts[0];

            // 2. Convert base64 address to base58 (Privy expects base58)
            const addressBytes = toByteArray(desiredAccount.address);
            const publicKey = new PublicKey(addressBytes);
            const base58Address = publicKey.toBase58();

            // 3. Generate a Privy SIWS message for the wallet address
            const siwsMessage = await generateMessage({
              wallet: {address: base58Address}, // Use base58 for Privy
              from: {domain: 'com.myapp.app', uri: 'https://myapp.io'}
            });

            // 4. Convert the SIWS message to Uint8Array for signing
            const encodedSiwsMessage = new TextEncoder().encode(siwsMessage.message);

            // 5. Request user to sign the SIWS message with their wallet
            const [signatureBytes] = await wallet.signMessages({
              addresses: [desiredAccount.address], // Use base64 for MWA
              payloads: [encodedSiwsMessage]
            });
            const signatureBase64 = Buffer.from(signatureBytes).toString('base64');

            // 6. Authenticate with Privy using the signed message
            const user = await login({
              signature: signatureBase64,
              message: siwsMessage.message
            });

            return {mwaResult: authResult, user};
          });
        } catch (error) {
          console.error('Login failed', error);
        }
      };

      return <Button title="Login with MWA" onPress={handleLogin} />;
    };
    ```

    ## Next steps

    You can now use MWA wallets within your app. For more information on how to sign and send transactions using MWA wallets, refer to the [Solana Mobile Wallet Adapter guide](https://docs.solanamobile.com/react-native/using_mobile_wallet_adapter#signing-and-sending-a-transaction).
  </Tab>
</Tabs>

## Conclusion

That's it! Your Privy app is now set up to connect to Solana wallets using the Solana Mobile Wallet Adapter. You can now use Privy's [wallet connection](/wallets/connectors/usage/connecting-external-wallets) and [transaction signing](/wallets/using-wallets/solana/sign-a-message) features with Solana wallets that support MWA.


# Getting started with Privy and Solana
Source: https://docs.privy.io/recipes/solana/getting-started-with-privy-and-solana



This guide will demonstrate how to integrate Privy with Solana to enable wallet login as well as message and transaction signing.

### Resources

<CardGroup cols={2}>
  <Card title="Github starter repository" icon="arrow-up-right-from-square" href="https://github.com/privy-io/examples/tree/main/examples/privy-next-solana" arrow>
    A starter repository for building an app with Privy and Solana.
  </Card>

  <Card title="Privy Solana Wallets" icon="wallet" href="/wallets/using-wallets/solana/sign-a-message" arrow>
    Privy Solana wallets can be a user's EOA or an embedded wallet. This guide shows how to use them
    to sign messages and transactions.
  </Card>
</CardGroup>

## Creating your Privy app

<Info>
  If you haven’t set up Privy yet, follow our [React quickstart guide](/basics/react/installation)
  to get your app ID and configure your app.
</Info>

Privy’s React SDK provides a secure way to authenticate users and manage wallets in your frontend application. Learn more about [getting started with React](/basics/react/installation).

## Configuring Privy

<Accordion title="Solana dependencies on yarn">
  For the Privy React SDK to work with Next.js using webpack, you need to add a custom webpack configuration. If you are not using Yarn, you can skip this step. Add the code below to your `next.config.ts` file:

  ```ts  theme={"system"}
  // next.config.ts
  import type {NextConfig} from 'next';

  const nextConfig: NextConfig = {
    /* config options here */
    webpack: (config) => {
      config.externals['@solana/kit'] = 'commonjs @solana/kit';
      config.externals['@solana-program/memo'] = 'commonjs @solana-program/memo';
      config.externals['@solana-program/system'] = 'commonjs @solana-program/system';
      config.externals['@solana-program/token'] = 'commonjs @solana-program/token';
      return config;
    }
  };

  export default nextConfig;
  ```
</Accordion>

In order to detect external Solana wallets, your app needs to enable Solana connectors.
If you also wish to use Privy wallets to send transactions, then you must define solana RPC clients for Privy to use.

```tsx {29} {14-21} theme={"system"}
// components/providers.tsx
'use client';

import {PrivyProvider} from '@privy-io/react-auth';
import {toSolanaWalletConnectors} from '@privy-io/react-auth/solana';
import {createSolanaRpc, createSolanaRpcSubscriptions} from '@solana/kit';
import {ReactNode} from 'react';

export function Providers({children}: {children: ReactNode}) {
  return (
    <PrivyProvider
      appId={process.env.NEXT_PUBLIC_PRIVY_APP_ID}
      config={{
        solana: {
          rpcs: {
            'solana:mainnet': {
              rpc: createSolanaRpc('https://api.mainnet-beta.solana.com'), // or your custom RPC endpoint
              rpcSubscriptions: createSolanaRpcSubscriptions('wss://api.mainnet-beta.solana.com') // or your custom RPC endpoint
            }
          }
        },
        appearance: {
          showWalletLoginFirst: true,
          walletChainType: 'solana-only'
        },
        loginMethods: ['wallet', 'email'],
        externalWallets: {
          solana: {
            connectors: toSolanaWalletConnectors() // For detecting EOA browser wallets
          }
        },
        embeddedWallets: {
          createOnLogin: 'all-users'
        }
      }}
    >
      {children}
    </PrivyProvider>
  );
}
```

<Info>
  `config.solana.rpcs` is only required when using Privy's embedded wallet UIs (UI `signTransaction`
  and `signAndSendTransaction`). If your app only uses external Solana wallets, you can omit the
  `solana.rpcs` configuration and prepare/send transactions directly via your chosen RPC client.
</Info>

## Using Privy in your app

With Privy now integrated into your app, you can leverage its hooks to authenticate users, generate embedded wallets, and facilitate message and transaction signing.

### Log in with Privy

To log in users with Privy, you can use the `useLogin` hook from the `@privy-io/react-auth` package. This hook provides a function to log in users.

```tsx {8} theme={"system"}
// components/loginButton.tsx
'use client';
import {useLogin} from '@privy-io/react-auth';
import {useRouter} from 'next/navigation';

export function LoginButton() {
  const router = useRouter();
  const {login} = useLogin({
    onError: (error) => {
      console.error('Login error:', error);
    },
    onComplete: (user) => {
      console.log('User logged in:', user);
      // Redirect to the dashboard or another page after login
      router.replace('/dashboard');
    }
  });

  return <button onClick={login}>Log in with Privy</button>;
}
```

### Creating a Solana embedded wallet

To create a Solana embedded wallet, you can use the `useWallets` hook from `@privy-io/react-auth/solana`. This hook provides a `createWallet` function to create an embedded wallet.

```tsx  theme={"system"}
// components/createWalletButton.tsx
'use client';
import {useWallets, useCreateWallet} from '@privy-io/react-auth/solana';

export function CreateWalletButton(props: {createAdditional: boolean}) {
  const {ready} = useWallets();
  const {createWallet} = useCreateWallet();

  if (!ready) {
    return <div>Loading...</div>;
  }

  const handleCreateWallet = async () => {
    try {
      // If createAdditional is true, it will create an additional HD wallet for the user.
      const wallet = await createWallet({createAdditional: props.createAdditional});
      console.log('Embedded wallet created:', wallet);
    } catch (error) {
      console.error('Error creating embedded wallet:', error);
    }
  };

  return <button onClick={handleCreateWallet}>Create Embedded Wallet</button>;
}
```

### Using wallets

Privy provides the `useSignMessage`, `useSignTransaction`, and `useSignAndSendTransaction` hooks to sign messages and transactions with embedded wallets. You can also use linked EOA wallets directly for signing messages and transactions.

#### Signing a message

To sign a message with an embedded wallet, use the `useSignMessage` hook:

```tsx  theme={"system"}
import {useSignMessage, useWallets} from '@privy-io/react-auth/solana';

const {signMessage} = useSignMessage();
const {wallets} = useWallets(); // This hook provides access to both embedded and EOA wallets
const wallet = wallets.find((w) => w.standardWallet.name === 'Privy'); // Find the first embedded wallet

const handleSignMessage = async () => {
  try {
    if (!wallet) throw new Error('No embedded wallet found');
    const signature = await signMessage({
      message: new TextEncoder().encode('Hello from Privy!'), // Solana messages are typically encoded as Uint8Array
      wallet
    });
    console.log('Message signed:', signature);
  } catch (error) {
    console.error('Error signing message:', error);
  }
};
```

This function signs a message using the first embedded wallet.

#### Preparing a transaction

Before signing or sending a transaction, you need to prepare it. Here's how you can create a simple SOL transfer transaction:

```tsx  theme={"system"}
import type {ConnectedStandardSolanaWallet} from '@privy-io/react-auth/solana';
import {
  pipe,
  createSolanaRpc,
  getTransactionEncoder,
  createTransactionMessage,
  setTransactionMessageFeePayer,
  setTransactionMessageLifetimeUsingBlockhash,
  appendTransactionMessageInstructions,
  compileTransaction,
  address,
  createNoopSigner
} from '@solana/kit';
import {getTransferSolInstruction} from '@solana-program/system';

const generateTransaction = async (wallet: ConnectedStandardSolanaWallet) => {
  // Simple SOL transfer transaction
  const amount = 1;

  const transferInstruction = getTransferSolInstruction({
    amount: BigInt(parseFloat(amount) * 1_000_000_000), // Convert SOL to lamports
    destination: address('RecipientAddressHere'),
    source: createNoopSigner(address(wallet.address))
  });

  // Configure your RPC connection to point to the correct Solana network
  const {getLatestBlockhash} = createSolanaRpc('https://api.mainnet-beta.solana.com'); // Replace with your Solana RPC endpoint
  const {value: latestBlockhash} = await getLatestBlockhash().send();

  // Create transaction using @solana/kit
  const transaction = pipe(
    createTransactionMessage({version: 0}),
    (tx) => setTransactionMessageFeePayer(address(wallet.address), tx), // Set the message fee payer
    (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx), // Set recent blockhash
    (tx) => appendTransactionMessageInstructions([transferInstruction], tx), // Add your instructions to the transaction
    (tx) => compileTransaction(tx), // Compile the transaction
    (tx) => new Uint8Array(getTransactionEncoder().encode(tx)) // Finally encode the transaction
  );
  return transaction;
};
```

This code creates a transaction object that can be signed or sent later. Replace the placeholder values with actual addresses.

#### Signing a transaction

To sign a transaction, use the `useSignTransaction` hook:

```tsx  theme={"system"}
import {useSignTransaction, useWallets} from '@privy-io/react-auth/solana';

const {signTransaction} = useSignTransaction();
const {wallets} = useWallets(); // This hook provides access to both embedded and EOA wallets

const handleSignTransaction = async () => {
  try {
    const wallet = wallets.find((w) => w.standardWallet.name === 'Privy'); // Find the first embedded wallet
    if (!wallet) throw new Error('No wallet found');

    const transaction = await generateTransaction(wallet); // The transaction prepared earlier
    const transactionSignature = await signTransaction({
      transaction,
      wallet
    });
    console.log('Transaction signed:', transactionSignature);
  } catch (error) {
    console.error('Error signing transaction:', error);
  }
};
```

This function signs the prepared transaction using the embedded wallet and a specified Solana RPC endpoint.

#### Sending a transaction

To send a signed transaction to the Solana network, use the `useSignAndSendTransaction` hook:

```tsx  theme={"system"}
import {useSignAndSendTransaction, useWallets} from '@privy-io/react-auth/solana';

const {signAndSendTransaction} = useSignAndSendTransaction();
const {wallets} = useWallets(); // This hook provides access to both embedded and EOA wallets

const handleSendTransaction = async () => {
  try {
    const wallet = wallets.find((w) => w.standardWallet.name === 'Privy'); // Find the first embedded wallet
    if (!wallet) throw new Error('No wallet found');

    const transaction = await generateTransaction(); // The transaction prepared earlier
    const transactionSignature = await signAndSendTransaction({
      transaction,
      wallet
    });
    console.log('Transaction sent:', transactionSignature);
  } catch (error) {
    console.error('Error sending transaction:', error);
  }
};
```

This function sends the signed transaction to the Solana network and logs the transaction signature.

### Conclusion

This guide has shown you how to integrate Privy with Solana into an application. You can now log in users, create embedded wallets, and sign messages and transactions using the Privy React SDK.


# Sending a SOL transaction
Source: https://docs.privy.io/recipes/solana/send-sol



Sending SOL is the most common transaction on the Solana blockchain. This recipe walks you through creating and sending SOL transfer transactions using `@solana/web3.js` with Privy wallets.

<Info>
  Before following this recipe, make sure you have [configured Privy for
  Solana](/recipes/solana/getting-started-with-privy-and-solana) in your app.
</Info>

## Overview

This recipe demonstrates how to:

* Create a SOL transfer transaction using `@solana/web3.js`
* Sign and send the transaction using Privy wallets

## Prerequisites

Install the required dependencies:

<Tabs>
  <Tab title="TypeScript">`bash npm install @solana/web3.js `</Tab>
  <Tab title="Python">`bash pip install solders solana `</Tab>
</Tabs>

## 1. Create the SOL transfer transaction

Create a SOL transfer transaction using your preferred language:

<Tabs>
  <Tab title="TypeScript">
    ```typescript  theme={"system"}
    import {Connection, PublicKey, SystemProgram, Transaction, LAMPORTS_PER_SOL} from '@solana/web3.js';

    const createSOLTransferTransaction = async (
      fromAddress: string,
      toAddress: string,
      amount: number // Amount in SOL
    ) => {
      // Set up connection to Solana network
      const connection = new Connection('https://api.devnet.solana.com', 'confirmed');

      // Create public key objects
      const fromPubkey = new PublicKey(fromAddress);
      const toPubkey = new PublicKey(toAddress);

      // Convert SOL to lamports (1 SOL = 1,000,000,000 lamports)
      const lamports = amount * LAMPORTS_PER_SOL;

      // Create transfer instruction
      const transferInstruction = SystemProgram.transfer({
        fromPubkey,
        toPubkey,
        lamports
      });

      // Create transaction and add instruction
      const transaction = new Transaction().add(transferInstruction);

      // Get recent blockhash
      const {blockhash} = await connection.getLatestBlockhash();
      transaction.recentBlockhash = blockhash;
      transaction.feePayer = fromPubkey;

      return {transaction, connection};
    };
    ```
  </Tab>

  <Tab title="Python">
    ```python  theme={"system"}
    import base64
    from solana.rpc.api import Client
    from solders.pubkey import Pubkey
    from solders.system_program import TransferParams, transfer
    from solders.transaction import Transaction

    def create_sol_transfer_transaction(
        from_address: str,
        to_address: str,
        amount: float,  # Amount in SOL
        rpc_url: str = "https://api.devnet.solana.com",
    ) -> dict:
        from_pubkey = Pubkey.from_string(from_address)
        to_pubkey = Pubkey.from_string(to_address)

        client = Client(rpc_url)

        lamports = int(amount * 1_000_000_000)

        transfer_instruction = transfer(
            TransferParams(
                from_pubkey=from_pubkey, to_pubkey=to_pubkey, lamports=lamports
            )
        )

        blockhash_resp = client.get_latest_blockhash()
        recent_blockhash = blockhash_resp.value.blockhash

        transaction = Transaction(
            instructions=[transfer_instruction],
            recent_blockhash=recent_blockhash,
            fee_payer=from_pubkey,
        )

        # Serialize and encode the transaction to base64
        serialized_tx = base64.b64encode(transaction.serialize()).decode('utf-8')

        return {"transaction": serialized_tx}
    ```
  </Tab>
</Tabs>

## 2. Send the transaction

You can send the transaction using Privy's different SDKs. Below are examples for React, React Native, NodeJS, and Python:

<Tabs>
  <Tab title="React">
    ```typescript {skip-check} theme={"system"}
    import {useSignAndSendTransaction, useWallets} from '@privy-io/react-auth/solana';

    const {wallets} = useWallets();
    const {signAndSendTransaction} = useSignAndSendTransaction();

    const {transaction, connection} = await createSOLTransferTransaction(
      wallets[0].address, // fromAddress
      'recipient-wallet-address', // toAddress
      0.01 // amount in SOL
    );

    // Assuming you have a transaction created from the previous step
    const signature = await signAndSendTransaction({
      transaction.serialize(), // from createSOLTransferTransaction
      wallet: wallets[0]
    });
    ```
  </Tab>

  <Tab title="React Native">
    ```typescript {skip-check} theme={"system"}
    import {useEmbeddedSolanaWallet} from '@privy-io/expo';

    const {wallets} = useEmbeddedSolanaWallet();
    const wallet = wallets[0];
    const provider = await wallet.getProvider();

    const {transaction, connection} = await createSOLTransferTransaction(
      wallet.address, // fromAddress
      'recipient-wallet-address', // toAddress
      0.01 // amount in SOL
    );

    // Send transaction using the provider's request method
    const {signature} = await provider.request({
      method: 'signAndSendTransaction',
      params: {
        transaction: transaction, // from createSOLTransferTransaction
        connection: connection // from createSOLTransferTransaction
      }
    });
    ```
  </Tab>

  <Tab title="NodeJS">
    ```typescript {skip-check} theme={"system"}
    import {PrivyClient} from '@privy-io/node';

    const privy = new PrivyClient({
      appId: process.env.PRIVY_APP_ID!,
      appSecret: process.env.PRIVY_APP_SECRET!
    });

    const {transaction} = await createSOLTransferTransaction(
      'insert-wallet-address', // fromAddress
      'recipient-wallet-address', // toAddress
      0.01 // amount in SOL
    );

    // Send transaction using Privy API
    const response = await privy
      .wallets()
      .solana()
      .signAndSendTransaction('insert-wallet-id', {
        // Devnet's caip2
        caip2: 'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1',
        // from createSOLTransferTransaction
        transaction: Buffer.from(transaction.serialize()).toString('base64')
      });
    ```
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    ```typescript {skip-check} theme={"system"}
    import {PrivyClient} from '@privy-io/server-auth';

    const privy = new PrivyClient(process.env.PRIVY_APP_ID!, process.env.PRIVY_APP_SECRET!);

    const {transaction} = await createSOLTransferTransaction(
      'insert-wallet-address', // fromAddress
      'recipient-wallet-address', // toAddress
      0.01 // amount in SOL
    );

    // Send transaction using Privy API
    const response = await privy.walletApi.solana.signAndSendTransaction({
      walletId: 'insert-wallet-id',
      address: 'insert-wallet-address',
      caip2: 'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1', // Devnet's caip2
      transaction: transaction // from createSOLTransferTransaction
    });
    ```
  </Tab>

  <Tab title="Python">
    ```python  theme={"system"}
    from privy import PrivyClient

    client = PrivyClient(
        app_id="your-app-id",
        app_secret="your-app-secret"
    )

    base_64_encoded_transaction = create_sol_transfer_transaction(
        from_address="insert-wallet-address",  # fromAddress
        to_address="recipient-wallet-address",  # toAddress
        amount=0.01  # amount in SOL
    )["transaction"]

    # Send transaction using Privy API
    tx_response = client.wallets.rpc(
        wallet_id="insert-wallet-id",
        method="signAndSendTransaction",
        params={
            "transaction": "insert-base-64-encoded-serialized-transaction",
            "encoding": "base64",
        }
    )
    ```
  </Tab>
</Tabs>

You've successfully sent SOL!

## Next steps

Now that you can send SOL, you might want to explore:

* [Sending SPL tokens](/recipes/solana/send-spl-tokens) - Learn how to send other tokens on Solana
* [Web3 integrations](/wallets/using-wallets/solana/web3-integrations) - Advanced integration patterns with Solana libraries


# Sending SPL tokens
Source: https://docs.privy.io/recipes/solana/send-spl-tokens



Sending SPL tokens is a common transaction on the Solana blockchain. This recipe walks you through creating and sending SPL token transfer transactions using `@solana/spl-token` and `@solana/web3.js` with Privy wallets. In this example, we'll use USDC as the SPL token, but you can adapt it for any SPL token by changing the mint address and decimals.

<Info>
  Before following this recipe, make sure you have [configured Privy for
  Solana](/recipes/solana/getting-started-with-privy-and-solana) in your app.
</Info>

## Overview

This recipe demonstrates how to:

* Create an SPL token transfer transaction using `@solana/spl-token`
* Handle token accounts and decimals properly
* Sign and send the transaction using Privy wallets

## Prerequisites

Install the required dependencies:

<Tabs>
  <Tab title="TypeScript">`bash npm install @solana/web3.js @solana/spl-token `</Tab>
  <Tab title="Python">`bash pip install solders solana spl-token `</Tab>
</Tabs>

## 1. Create the SPL token transfer transaction

Create an SPL token transfer transaction using your preferred language:

<Tabs>
  <Tab title="TypeScript">
    ```typescript  theme={"system"}
    import {Connection, PublicKey, Transaction} from '@solana/web3.js';
    import {getAssociatedTokenAddress, createTransferInstruction} from '@solana/spl-token';

    const createSPLTransferTransaction = async (
      fromAddress: string,
      toAddress: string,
      tokenMintAddress: string,
      amount: number,
      decimals: number = 6 // Default for USDC, adjust for your token
    ) => {
      // Set up connection to Solana network
      const connection = new Connection('https://api.mainnet-beta.solana.com', 'confirmed');

      // Create public key objects
      const fromPubkey = new PublicKey(fromAddress);
      const toPubkey = new PublicKey(toAddress);
      const mintPubkey = new PublicKey(tokenMintAddress);

      // Get associated token accounts
      const fromTokenAccount = await getAssociatedTokenAddress(mintPubkey, fromPubkey);

      const toTokenAccount = await getAssociatedTokenAddress(mintPubkey, toPubkey);

      // Convert amount to token units (considering decimals)
      const tokenAmount = amount * Math.pow(10, decimals);

      // Create transfer instruction
      const transferInstruction = createTransferInstruction(
        fromTokenAccount,
        toTokenAccount,
        fromPubkey,
        tokenAmount
      );

      // Create transaction and add instruction
      const transaction = new Transaction().add(transferInstruction);

      // Get recent blockhash
      const {blockhash} = await connection.getLatestBlockhash();
      transaction.recentBlockhash = blockhash;
      transaction.feePayer = fromPubkey;

      return {transaction, connection};
    };
    ```
  </Tab>

  <Tab title="Python">
    ```python  theme={"system"}
    import base64
    from solana.rpc.api import Client
    from solders.pubkey import Pubkey
    from solders.transaction import Transaction
    from solders.hash import Hash
    from spl.token.constants import TOKEN_PROGRAM_ID
    from spl.token.instructions import transfer, TransferParams
    from spl.token.client import get_associated_token_address

    def create_spl_transfer_transaction(
        from_address: str,
        to_address: str,
        token_mint_address: str,
        amount: float,
        decimals: int,
        rpc_url: str = "https://api.mainnet-beta.solana.com",
    ) -> dict:
        from_pubkey = Pubkey.from_string(from_address)
        to_pubkey = Pubkey.from_string(to_address)
        mint_pubkey = Pubkey.from_string(token_mint_address)

        client = Client(rpc_url)

        from_token_account = get_associated_token_address(from_pubkey, mint_pubkey)
        to_token_account = get_associated_token_address(to_pubkey, mint_pubkey)

        token_amount = int(amount * (10**decimals))

        transfer_instruction = transfer(
            TransferParams(
                program_id=TOKEN_PROGRAM_ID,
                source=from_token_account,
                dest=to_token_account,
                owner=from_pubkey,
                amount=token_amount,
                signers=[],
            )
        )

        blockhash_resp = client.get_latest_blockhash()
        recent_blockhash = blockhash_resp.value.blockhash

        transaction = Transaction(
            instructions=[transfer_instruction],
            recent_blockhash=recent_blockhash,
            fee_payer=from_pubkey,
        )

        # Serialize transaction to base64
        serialized_tx = base64.b64encode(transaction.serialize()).decode("utf-8")

        return {"transaction": serialized_tx}
    ```
  </Tab>
</Tabs>

## 2. Send the transaction

You can send the transaction using Privy's different SDKs. Below are examples for React, React Native, NodeJS, and Python:

<Tabs>
  <Tab title="React">
    ```typescript {skip-check} theme={"system"}
    import {useSignAndSendTransaction, useWallets} from '@privy-io/react-auth/solana';

    const {wallets} = useWallets();
    const {signAndSendTransaction} = useSignAndSendTransaction();

    const {transaction, connection} = await createSPLTransferTransaction(
      wallets[0].address,
      'recipient-wallet-address', // Replace with recipient's token account address
      'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC mint address
      10 // Amount to send
    );

    // Assuming you have a transaction created from the previous step
    const signature = await sendTransaction({
      transaction.serialize(), // from createSPLTransferTransaction
      wallet: wallets[0],
    });
    ```
  </Tab>

  <Tab title="React Native">
    ```typescript {skip-check} theme={"system"}
    import {useEmbeddedSolanaWallet} from '@privy-io/expo';

    const {wallets} = useEmbeddedSolanaWallet();
    const wallet = wallets[0];
    const provider = await wallet.getProvider();

    const {transaction, connection} = await createSPLTransferTransaction(
      wallet.address,
      'recipient-wallet-address', // Replace with recipient's token account address
      'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC mint address
      10 // Amount to send
    );

    // Send transaction using the provider's request method
    const {signature} = await provider.request({
      method: 'signAndSendTransaction',
      params: {
        transaction: transaction,
        connection: connection // from createSPLTransferTransaction
      }
    });
    ```
  </Tab>

  <Tab title="NodeJS">
    ```typescript {skip-check} theme={"system"}
    import {PrivyClient} from '@privy-io/node';

    const privy = new PrivyClient({
      appId: process.env.PRIVY_APP_ID!,
      appSecret: process.env.PRIVY_APP_SECRET!
    });

    const {transaction} = await createSPLTransferTransaction(
      'insert-wallet-address',
      'recipient-wallet-address', // Replace with recipient's token account address
      'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC mint address
      10 // Amount to send
    );

    // Send transaction using Privy API
    const response = await privy
      .wallets()
      .solana()
      .signAndSendTransaction('insert-wallet-id', {
        // Mainnet's caip2
        caip2: 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',
        // from createSPLTransferTransaction
        transaction: Buffer.from(transaction.serialize()).toString('base64')
      });
    ```
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    ```typescript {skip-check} theme={"system"}
    import {PrivyClient} from '@privy-io/server-auth';

    const privy = new PrivyClient(process.env.PRIVY_APP_ID!, process.env.PRIVY_APP_SECRET!);

    const {transaction} = await createSPLTransferTransaction(
      'insert-wallet-address',
      'recipient-wallet-address', // Replace with recipient's token account address
      'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC mint address
      10 // Amount to send
    );

    // Send transaction using Privy API
    const response = await privy.walletApi.solana.signAndSendTransaction({
      walletId: 'insert-wallet-id',
      address: 'insert-wallet-address',
      caip2: 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp', // Mainnet's caip2
      transaction: transaction
    });
    ```
  </Tab>

  <Tab title="Python">
    ```python  theme={"system"}
    from privy import PrivyClient

    client = PrivyClient(
        app_id="your-app-id",
        app_secret="your-app-secret"
    )

    base_64_encoded_transaction = create_spl_transfer_transaction(
        "insert-wallet-address",
        "recipient-wallet-address",  # Replace with recipient's token account address
        "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",  # USDC mint address
        10  # Amount to send
    )["transaction"]

    # Send transaction using Privy API
    tx_response = client.wallets.rpc(
        wallet_id="insert-wallet-id",
        method="signAndSendTransaction",
        params={
            "transaction": base_64_encoded_transaction,
            "encoding": "base64",
        }
    )
    ```
  </Tab>
</Tabs>

You've successfully sent SPL tokens!

## Token account considerations

<Warning>
  Before sending SPL tokens, ensure that the recipient has a token account for the specific token
  mint.
</Warning>

### Getting token account information

You can check if token accounts exist and get their addresses:

```typescript  theme={"system"}
import {Connection, PublicKey} from '@solana/web3.js';
import {getAssociatedTokenAddress} from '@solana/spl-token';

const connection = new Connection('https://api.mainnet-beta.solana.com', 'confirmed');

// Check if token account exists
const tokenAccountAddress = await getAssociatedTokenAddress(
  new PublicKey('tokenMintAddress'),
  new PublicKey('walletAddress')
);

const accountInfo = await connection.getAccountInfo(tokenAccountAddress);
const accountExists = accountInfo !== null;
```

Token mint addresses are different on each network, so make sure you're using the correct addresses for your target environment.

## Next steps

Now that you can send SPL tokens, you might want to explore:

* [Sending SOL](/recipes/solana/send-sol) - Learn how to send native SOL tokens
* [Web3 integrations](/wallets/using-wallets/solana/web3-integrations) - Advanced integration patterns with Solana libraries


# Using Solana Standard Wallets
Source: https://docs.privy.io/recipes/solana/standard-wallets

A comprehensive guide to integrating and using Solana standard wallets in your application

# Using Solana Standard Wallets

This guide will help you integrate and use Solana standard wallets in your application. We'll cover everything from basic setup to advanced features like message signing and transaction handling.
To learn more about the wallet standard, you can read more about it [here!](https://docs.phantom.com/developer-powertools/wallet-standard)

<Tabs>
  <Tab title="React">
    ## Basic Setup

    First, import the necessary hooks and types from Privy:

    ```typescript {skip-check} theme={"system"}
    import {useSolanaStandardWallets, type SolanaStandardWallet} from '@privy-io/react-auth/solana';
    ```

    ## Available Features

    Standard wallets provide these core features:

    * `standard:connect`: Connect the wallet
    * `standard:disconnect`: Disconnect the wallet
    * `solana:signMessage`: Sign messages
    * `solana:signTransaction`: Sign transactions
    * `solana:signAndSendTransaction`: Sign and send transactions

    ## Core Wallet Features

    Here's how to use the core features of any Solana standard wallet:

    ```typescript {skip-check} theme={"system"}
    function WalletComponent() {
      const {ready, wallets} = useSolanaStandardWallets();

      // Connect/Disconnect
      const connect = (wallet: SolanaStandardWallet) => wallet.features['standard:connect']!.connect();
      const disconnect = (wallet: SolanaStandardWallet) =>
        wallet.features['standard:disconnect']!.disconnect();

      // Sign Message
      const signMessage = async (
        wallet: SolanaStandardWallet,
        address: string,
        message: Uint8Array
      ) => {
        const account = wallet.accounts.find((a) => a.address === address)!;
        const [result] = await wallet.features['solana:signMessage']!.signMessage({
          account,
          message
        });
        return result;
      };

      // Sign Transaction
      const signTransaction = async (
        wallet: SolanaStandardWallet,
        address: string,
        transaction: Uint8Array
      ) => {
        const account = wallet.accounts.find((a) => a.address === address)!;
        const [result] = await wallet.features['solana:signTransaction']!.signTransaction({
          transaction,
          chain: 'solana:devnet',
          account
        });
        return result;
      };

      // Sign and Send Transaction
      const signAndSendTransaction = async (
        wallet: SolanaStandardWallet,
        address: string,
        transaction: Uint8Array
      ) => {
        const account = wallet.accounts.find((a) => a.address === address)!;
        return wallet.features['solana:signAndSendTransaction']!.signAndSendTransaction({
          transaction,
          chain: 'solana:devnet',
          account
        });
      };
    }
    ```

    ## Registering the Privy Embedded Wallet

    To make your Privy embedded wallet compatible with other Solana applications, register it with the window object.

    The registration function dispatches the appropriate events to make the wallet available to other applications:

    ```typescript  theme={"system"}
    // This is copied from @wallet-standard/wallet

    import type {
      Wallet,
      WalletEventsWindow,
      WindowRegisterWalletEvent,
      WindowRegisterWalletEventCallback
    } from '@wallet-standard/base';

    class RegisterWalletEvent
      extends CustomEvent<WindowRegisterWalletEventCallback>
      implements WindowRegisterWalletEvent
    {
      readonly #detail: WindowRegisterWalletEventCallback;

      get detail() {
        return this.#detail;
      }

      get type() {
        return 'wallet-standard:register-wallet' as const;
      }

      constructor(callback: WindowRegisterWalletEventCallback) {
        super('wallet-standard:register-wallet', {
          bubbles: false,
          cancelable: false,
          detail: callback
        });
        this.#detail = callback;
      }

      preventDefault(): never {
        throw new Error('preventDefault is not supported');
      }

      stopPropagation(): never {
        throw new Error('stopPropagation is not supported');
      }

      stopImmediatePropagation(): never {
        throw new Error('stopImmediatePropagation is not supported');
      }
    }

    export function registerWallet(wallet: Wallet): void {
      const callback: WindowRegisterWalletEventCallback = ({register}) => register(wallet);
      try {
        (window as WalletEventsWindow).dispatchEvent(new RegisterWalletEvent(callback));
      } catch (error) {
        console.error('wallet-standard:register-wallet event could not be dispatched\n', error);
      }
      try {
        (window as WalletEventsWindow).addEventListener('wallet-standard:app-ready', ({detail: api}) =>
          callback(api)
        );
      } catch (error) {
        console.error('wallet-standard:app-ready event listener could not be added\n', error);
      }
    }
    ```

    After this code is implemented in your application, you can then register the Privy embedded wallet by calling:

    ```typescript {skip-check} theme={"system"}
    registerWallet(wallets.find((wallet) => wallet.name === 'Privy' && 'privy:' in wallet.features));
    ```

    **That's it!** You now have a fully functional Solana standard wallet integration in your application. You can use these features to connect wallets, sign messages, and handle transactions in a standardized way.
  </Tab>
</Tabs>


# Using Spark BTC with Privy wallets
Source: https://docs.privy.io/recipes/spark-btc-guide



Spark is a Bitcoin scaling solution that enables instant, low-cost transfers while maintaining Bitcoin's security. Privy offers BTC support This guide walks through creating a Spark wallet, transferring BTC, and claiming pending transfers using Privy's API.

Privy's Spark integration utilizes the [Spark Wallet SDK](https://github.com/buildonspark/spark/blob/63c51c9b15d8ce8498365f9f471c57eae5608007/sdks/js/packages/spark-sdk/src/spark-wallet/spark-wallet.ts). For more information on the Spark wallet methods, check out the [Spark docs](https://docs.spark.money/wallet/introduction).

## 1. Create a Spark wallet

Create a Spark wallet by calling the [wallet creation endpoint](/api-reference/wallets/create) with `chain_type: 'spark'`. Learn more about creating wallets [here](/wallets/wallets/create/create-a-wallet).

<Tabs>
  <Tab title="React">
    ```tsx  theme={"system"}
    import {useCreateWallet} from '@privy-io/react-auth/extended-chains';

    const {createWallet} = useCreateWallet();

    const {user, wallet} = await createWallet({chainType: 'spark'});
    ```
  </Tab>

  <Tab title="React Native">
    ```tsx  theme={"system"}
    import {useCreateWallet} from '@privy-io/expo/extended-chains';

    const {createWallet} = useCreateWallet();

    const {user, wallet} = await createWallet({chainType: 'spark'});
    ```
  </Tab>

  <Tab title="REST API">
    ```bash  theme={"system"}
    curl --request POST https://api.privy.io/v1/wallets \
        -u "<your-privy-app-id>:<your-privy-app-secret>" \
        -H "privy-app-id: <your-privy-app-id>" \
        -H 'Content-Type: application/json' \
        -d '{
        "owner": {
            "user_id": "did:privy:xxxxxx"
        },
        "chain_type": "spark"
        }'
    ```
  </Tab>
</Tabs>

The response will include your new Spark wallet with a unique Spark address format (e.g., `sprt1pgss...`).

<Info>
  Spark supports both mainnet and testnet environments:

  * `MAINNET`: Production Bitcoin network
  * `REGTEST`: Test network for development

  When you create a wallet, the `MAINNET` address is automatically returned. To get the `REGTEST` address, you can use the returned public key and the [`encodeSparkAddress`](https://github.com/buildonspark/spark/blob/63c51c9b15d8ce8498365f9f471c57eae5608007/sdks/js/packages/spark-sdk/src/utils/address.ts#L44) method from the Spark SDK.

  On subsequent wallet requests, your request will need to include the network you want to take the operation on.
</Info>

## 2. Transfer BTC

Transfer Bitcoin to another Spark address using the [`transfer`](/api-reference/wallets/spark/transfer) endpoint. The amount is specified in satoshis.

<Info>
  Most Spark wallet operations (transferring BTC and checking balances) require authorization
  signatures using user keys. Only wallet creation can be done without authorization signatures.
  Learn more about [signing requests with user
  keys](/controls/authorization-keys/using-owners/sign#react%2C-expo).
</Info>

<Tabs>
  <Tab title="React">
    ```typescript  theme={"system"}
    import {useAuthorizationSignature} from '@privy-io/react-auth';

    const {generateAuthorizationSignature} = useAuthorizationSignature();

    // Build the request input for authorization signature
    const input = {
      version: 1,
      url: `https://api.privy.io/v1/wallets/${'$WALLET_ID'}/rpc`,
      method: 'POST',
      headers: {
        'privy-app-id': 'your-app-id'
      },
      body: {
        method: 'transfer',
        network: 'MAINNET',
        params: {
          receiver_spark_address: 'sprt1pgss8z35rpycv4duqdk5u3sclhjnztjunv5yajlwk69tyv5fsvwwe9mg8n4d49',
          amount_sats: 16
        }
      }
    } as const;

    // Generate authorization signature
    const {signature: authorizationSignature} = await generateAuthorizationSignature(input);

    // Make the transfer request
    const transferResponse = await fetch(input.url, {
      method: input.method,
      headers: {
        ...input.headers,
        Authorization: `Bearer ${'$ACCESS_TOKEN'}`,
        'Content-Type': 'application/json',
        'privy-authorization-signature': authorizationSignature
      },
      body: JSON.stringify(input.body)
    });

    const transfer = await transferResponse.json();
    ```
  </Tab>

  <Tab title="React Native">
    ```typescript  theme={"system"}
    import {useAuthorizationSignature} from '@privy-io/expo';

    const {generateAuthorizationSignature} = useAuthorizationSignature();

    // Build the request input for authorization signature
    const input = {
      version: 1,
      url: `https://api.privy.io/v1/wallets/${'$WALLET_ID'}/rpc`,
      method: 'POST',
      headers: {
        'privy-app-id': 'your-app-id'
      },
      body: {
        method: 'transfer',
        network: 'MAINNET',
        params: {
          receiver_spark_address: 'sprt1pgss8z35rpycv4duqdk5u3sclhjnztjunv5yajlwk69tyv5fsvwwe9mg8n4d49',
          amount_sats: 16
        }
      }
    } as const;

    // Generate authorization signature
    const {signature: authorizationSignature} = await generateAuthorizationSignature(input);

    // Make the transfer request
    const transferResponse = await fetch(input.url, {
      method: input.method,
      headers: {
        ...input.headers,
        Authorization: `Bearer ${'$ACCESS_TOKEN'}`,
        'Content-Type': 'application/json',
        'privy-authorization-signature': authorizationSignature
      },
      body: JSON.stringify(input.body)
    });

    const transfer = await transferResponse.json();
    ```
  </Tab>
</Tabs>

The transfer response includes the transfer ID, status, and detailed transaction information.

## 3. Check balance and claim transfers

Use the [`getBalance`](/api-reference/wallets/spark/get-balance) endpoint to retrieve your wallet balance and automatically claim any pending transfers.

<Tabs>
  <Tab title="React">
    ```typescript  theme={"system"}
    import {useAuthorizationSignature} from '@privy-io/react-auth';

    const {generateAuthorizationSignature} = useAuthorizationSignature();

    // Build the request input for authorization signature
    const input = {
      version: 1,
      url: `https://api.privy.io/v1/wallets/${'$WALLET_ID'}/rpc`,
      method: 'POST',
      headers: {
        'privy-app-id': 'your-app-id'
      },
      body: {
        method: 'getBalance',
        network: 'MAINNET'
      }
    } as const;

    // Generate authorization signature
    const {signature: authorizationSignature} = await generateAuthorizationSignature(input);

    // Make the balance request
    const balanceResponse = await fetch(input.url, {
      method: input.method,
      headers: {
        ...input.headers,
        Authorization: `Bearer ${'$ACCESS_TOKEN'}`,
        'Content-Type': 'application/json',
        'privy-authorization-signature': authorizationSignature
      },
      body: JSON.stringify(input.body)
    });

    const balance = await balanceResponse.json();
    console.log(`Balance: ${balance.data.balance} satoshis`);
    ```
  </Tab>

  <Tab title="React Native">
    ```typescript  theme={"system"}
    import {useAuthorizationSignature} from '@privy-io/expo';

    const {generateAuthorizationSignature} = useAuthorizationSignature();

    // Build the request input for authorization signature
    const input = {
      version: 1,
      url: `https://api.privy.io/v1/wallets/${'$WALLET_ID'}/rpc`,
      method: 'POST',
      headers: {
        'privy-app-id': 'your-app-id'
      },
      body: {
        method: 'getBalance',
        network: 'MAINNET'
      }
    } as const;

    // Generate authorization signature
    const {signature: authorizationSignature} = await generateAuthorizationSignature(input);

    // Make the balance request
    const balanceResponse = await fetch(input.url, {
      method: input.method,
      headers: {
        ...input.headers,
        Authorization: `Bearer ${'$ACCESS_TOKEN'}`,
        'Content-Type': 'application/json',
        'privy-authorization-signature': authorizationSignature
      },
      body: JSON.stringify(input.body)
    });

    const balance = await balanceResponse.json();
    console.log(`Balance: ${balance.data.balance} satoshis`);
    ```
  </Tab>
</Tabs>

The balance response includes:

* Your native Spark balance in satoshis
* Any token balances with metadata
* Automatically claims pending incoming transfers

## 4. Execute more wallet requests

This guide demonstrates how to use `transfer` and `getBalance`, but Privy supports many Spark wallet methods including:

* [`transfer`](/api-reference/wallets/spark/transfer) - Transfer satoshis from a Spark wallet to another Spark address
* [`getBalance`](/api-reference/wallets/spark/get-balance) - Retrieve wallet balance and token holdings, automatically claims pending transfers
* [`transferTokens`](/api-reference/wallets/spark/transfer-tokens) - Transfer Spark tokens to another Spark address
* [`createLightningInvoice`](/api-reference/wallets/spark/create-lightning-invoice) - Create a Lightning invoice to receive funds via Lightning Network
* [`payLightningInvoice`](/api-reference/wallets/spark/pay-lightning-invoice) - Pay a Lightning Network invoice
* [`getStaticDepositAddress`](/api-reference/wallets/spark/get-static-deposit-address) - Get a static Bitcoin address for deposits
* [`getClaimStaticDepositQuote`](/api-reference/wallets/spark/get-static-deposit-quote) - Get a quote for claiming a static deposit
* [`claimStaticDeposit`](/api-reference/wallets/spark/claim-static-deposit) - Claim funds from a static Bitcoin deposit
* [`signMessageWithIdentityKey`](/api-reference/wallets/spark/sign-message-with-identity-key) - Sign a message using the wallet's identity key

All methods (except wallet creation) require authorization signatures using the same pattern shown in the examples above.

For additional Spark functionality and advanced features, see the [Spark developer documentation](https://docs.spark.money/wallet/developer-guide/send-receive-spark).


# Speeding up transactions on EVM chains
Source: https://docs.privy.io/recipes/speeding-up-transactions

Learn how to use webhooks to trigger replacement transactions to speed up transaction confirmation.

# Overview

When you send a transaction using Privy, we broadcast it to the specified blockchain. However, in periods of high network congestion, the transaction may take longer than expected to be confirmed, or occasionally even never make it to confirmation.
This is due to transaction fee ("gas") estimates becoming outdated as high blockchain activity puts upward pressure on fees. In order to increase the likelihood of your transaction being confirmed, you can send a transaction that replaces the original one and sets higher gas fees.

**This guide will show you how to use the webhooks feature to know when a transaction is taking longer than expected, and trigger a replacement transaction to speed up confirmation.**

## Prerequisites

* A Privy EVM wallet
* Webhooks enabled for your app

## Step 1: Set up webhooks for `transaction.still_pending`

To start, follow the setup instructions for [Webhooks](/wallets/gas-and-asset-management/assets/transaction-event-webhooks) From the dropdown menu, select the `transaction.still_pending` event.

## Step 2: Implement the webhook handler

When a transaction is taking longer than expected, Privy will emit a webhook to the destination URL you provided. Here is an example of the webhook payload:

```json  theme={"system"}
{
  "caip2": "eip155:8453",
  "transaction_hash": "0x28f0ae628c08b7a341cd49ea40225d54ddd5acfe5f7ccfb44ee0be154d17bab0",
  "transaction_id": "b2ua14lrsfj2kq8r8mlm9z07",
  "transaction_request": {
    "chain_id": 8453,
    "gas_limit": "0x5208",
    "max_fee_per_gas": "0xadc0e",
    "max_priority_fee_per_gas": "0xf4240",
    "data": "0x....",
    "nonce": 0,
    "to": "0x38Bc05d7b69F63D05337829fA5Dc4896F179B5fA",
    "type": 2,
    "value": "0x0"
  },
  "type": "transaction.still_pending",
  "wallet_id": "<wallet-id-from-payload>"
}
```

## Step 3: Trigger a replacement transaction

Once you receive the webhook, you can trigger a replacement transaction by submitting a new transaction with the same nonce as the still pending transaction. If you leave out the gas fields, Privy will automatically set them based on the current network conditions.
Below is an example of sending a replacement transaction using Privy's Node SDK. For other ways to send a transaction, see the [guide](/wallets/using-wallets/ethereum/send-a-transaction).

<Info>
  Although you are sending a new transaction, there is **no risk of both transactions getting
  executed** (unintentionally) if the nonce is set to be the same in each. On EVM chains, the nonce
  is an internal counter that is incremented for each transaction sent by a wallet to avoid replay
  and other attack vectors.
</Info>

<CodeGroup>
  ```ts @privy-io/node {skip-check} theme={"system"}
  // payload is from the webhook

  const {hash, transactionId, caip2} = await privy
    .wallets()
    .ethereum()
    .sendTransaction(payload.wallet_id, {
      caip2: payload.caip2,
      params: {
        transaction: {
          to: payload.transaction_request.to,
          value: payload.transaction_request.value,
          data: payload.transaction_request.data,
          nonce: payload.transaction_request.nonce
        }
      }
    });
  ```

  ```ts @privy-io/server-auth {skip-check} theme={"system"}
  // payload is from the webhook

  const {hash, transactionId, caip2} = await privy.walletApi.ethereum.sendTransaction({
    walletId: payload.wallet_id,
    caip2: payload.caip2,
    transaction: {
      to: payload.transaction_request.to,
      value: payload.transaction_request.value,
      data: payload.transaction_request.data,
      nonce: payload.transaction_request.nonce
    }
  });
  ```
</CodeGroup>

This transaction will replace the original transaction and return a new transaction hash and transaction id.

Optionally, to increase the likelihood of the replacement transaction being confirmed, you can set the `max_priority_fee_per_gas` to be a higher value than the original transaction.

## \[Optional] Step 4: Monitor the status of the replacement via webhooks

Subscribe to `transaction.replaced`, `transaction.failed`, and `transaction.confirmed` webhooks to get notified on the success of the speedup.

Once the replacement succeeds, the following webhooks will trigger:

* `transaction.replaced` for the original transaction ID
* `transaction.confirmed` for the speedup transaction

If the replacement failed, a `transaction.failed` webhook would trigger.
For more information on transaction webhooks, see the [correspondent docs](/wallets/gas-and-asset-management/assets/transaction-event-webhooks).


# Swapping crypto using Privy and 0x
Source: https://docs.privy.io/recipes/swap-with-0x



To enable crypto asset swapping (e.g. convert USDC to ETH), you can integrate with the exchange of your choice. In this case, we use [0x](https://0x.org/) which offers a huge amount of swapping pairs and great rates. This guide will enable a Privy wallet to convert USDC to ETH.

This guide assumes that the Privy wallet has already been created and funded with ETH to pay for transaction fees. Code examples are in Javascript.

## Step 1: Register with 0x and retrieve API keys

Go the 0x dashboard and create an account. Save your API keys in your local `.env` file.

## Step 2: Approve the Permit2 contract to enable asset movement from your wallet

In order to facilitate a sale of USDC, 0x needs to be able to move USDC from your wallet to the buyer based on the trade. To do so, the wallet owner (user) must approve of this via a signature, which is then verified onchain. All of this can be done invisibly for the user.

This is a one time action that won’t have to be done again for any future swapping for this wallet.

```tsx  theme={"system"}
import {maxUint256, erc20Abi, encodeFunctionData, createPublicClient, http} from 'viem';

const PERMIT2_ADDRESS = '0x000000000022D473030F116dDEE9F6B43aC78BA3';

// USDC contract on Base
const USDC_ADDRESS = '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913';

// Provider is an instance of an EIP-1193 provider exposed from a Privy SDK
const provider = await wallet.getProvider();

// get Privy wallet

// prepre transaction to give USDC approval
const data = encodeFunctionData({
  abi: erc20Abi,
  functionName: 'approve',
  args: [PERMIT2_ADDRESS, maxUint256]
});

// execute transaction
const tx = await provider.request({
  method: 'eth_sendTransaction',
  params: [
    {
      from: wallets[0].address,
      to: USDC_ADDRESS,
      data
    }
  ]
});
```

## Step 3: Get quote from 0x

Next, you want to fetch a quote from 0x to sell your USDC for ETH.

```tsx  theme={"system"}
const USDC_ADDRESS = '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913';
const ETH_ADDRESS = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE';

// Base network chain ID
const CHAIN_ID = 8453;
const USDC_DECIMALS = 6;

const amountInUSD = 100;
const formattedAmount = 100 * 10 ** 6;
const quoteResponse = await fetch(
  `https://api.0x.org/swap/permit2/quote?chainId=${CHAIN_ID}&sellToken=${USDC_ADDRESS}&buyToken=${ETH_ADDRESS}&sellAmount=${formattedAmount}&taker=${wallet.address}`,
  {
    headers: {
      '0x-api-key': process.env.API_KEY_0X,
      '0x-version': 'v2'
    }
  }
);
```

## Step 4: Prepare the transaction and execute

Finally, you will prepare the transaction to fulfill the order and execute the swap. The user should see additional ETH in their wallet in exchange for their USDC.

```tsx  theme={"system"}
import {numberToHex, concat} from 'viem';

// Provider is an instance of an EIP-1193 provider exposed from a Privy SDK
const provider = await wallet.getProvider();

// Sign an off-chain signature for the permit
const signature = await provider.request({
  method: 'eth_signTypedData_v4',
  params: [wallet.address, quoteResult.permit2.eip712]
});
const signatureLengthInHex = numberToHex(size(signature), {
  signed: false,
  size: 32
});

// Pack the transaction for the trade fulfillment, including the off-chain signature
const transactionData = concat([quoteResult.transaction.data, signatureLengthInHex, signature]);
const params = {
  from: wallet.address,
  to: quoteResult.transaction.to,
  data: transactionData,
  gas: !!quoteResult.transaction.gas ? BigInt(quoteResult.transaction.gas) : undefined
};

// send the signed permit to be on-chain
const tx = await provider.request({
  method: 'eth_sendTransaction',
  params: [params]
});
```


# Login with Apple
Source: https://docs.privy.io/recipes/swift/apple



Privy supports native [Apple login](https://developer.apple.com/sign-in-with-apple/) on iOS. Apple is an OAuth2.0 compliant authentication provider, but requires a specific implementation of Apple sign-in within iOS apps.

<Tip>
  Prior to integrating Sign in with Apple, make sure your app's `Bundle ID` rather than the `Service
    ID`, is configured as the `Client ID` within the [Privy
  Dashboard](/basics/get-started/dashboard/app-clients) for the Apple Social login credentials.
</Tip>

## The "Sign in with Apple" button

Apple's [Human Interface Guidelines](https://developer.apple.com/design/human-interface-guidelines/sign-in-with-apple) has a clear definition of how the Sign in with Apple button should look.
In order to ensure compliance with Apple's guidelines, we recommend you use the `ASAuthorizationAppleIDButton` class from Apple's `AuthenticationServices` framework.

**Take a look at the snippet below** if you wish to use the `ASAuthorizationAppleIDButton` in SwiftUI.

```swift  theme={"system"}
struct SignInWithApple: UIViewRepresentable {
  typealias UIViewType = ASAuthorizationAppleIDButton
  func makeUIView(context: Context) -> ASAuthorizationAppleIDButton {
    return ASAuthorizationAppleIDButton()
  }

  func updateUIView(_ uiView: ASAuthorizationAppleIDButton, context: Context) {
  }
}
```

<Warning>
  Apple's `AuthenticationServices` framework also offers the [`SignInWithAppleButton` SwiftUI
  View](https://developer.apple.com/documentation/authenticationservices/signinwithapplebutton/),
  but relying on `ASAuthorizationAppleIDButton` instead allows the PrivySDK to handle the whole
  authentication process for you.
</Warning>

## Initializing Apple login

Privy automatically implements and launches Apple's native `ASAuthorizationController` after calling `privy.oAuth.login(with: OAuthProvider.apple)`. Add the `SignInWithApple` button to your view as described above, and trigger the login method when tapped.

```swift  theme={"system"}
// Add the SignInWithApple button with your view and register the tap gesture
SignInWithApple()
    .onTapGesture {
        // Ideally this is called in a view model, but showcasing logic here for brevity
        Task {
            do {
                // The `appUrlScheme` param is not necessary for using Sign in with Apple.
                // Privy will use the first valid app URL scheme from your app's info.plist.
                // Ensure your client's url schemes are registered in the Privy dashboard
                let authSession = try await privy.oAuth.login(with: OAuthProvider.apple)
            } catch {
                debugPrint("Error: \(error)")
                // Handle errors
            }
        }
    }
```


# Setting a system theme for the Privy modal
Source: https://docs.privy.io/recipes/system-theme



**With Privy, you can style your login modal to match your user's system preferences for light or dark mode.** Below is a short guide for how to configure your login modal to match your user's system settings.

### 1. Get your user's system preferences

To start, you should determine if your user's system preferences are configured for light mode, or for dark mode.Based on their system preferences, your user's device will automatically set the [`prefers-color-scheme`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme) CSS media feature in your website to indicate their light/dark preference. You can simply query this media feature to determine if your user prefers light or dark mode.

Below is a sample React hook to determine if your user prefers light or dark mode; feel free to use this directly in your app!

```tsx  theme={"system"}
import {useEffect, useState} from 'react';

// Returns true if the user prefers dark mode, and false otherwise
export default function useDarkMode() {
  const [darkMode, setDarkMode] = useState(false);

  const modeMe = (e: MediaQueryListEvent) => {
    setDarkMode(!!e.matches);
  };

  useEffect(() => {
    // Query the `prefers-color-scheme` media feature
    const matchMedia = window.matchMedia('(prefers-color-scheme: dark)');
    setDarkMode(matchMedia.matches);
    // Listen to changes in the `prefers-color-scheme` media feature
    matchMedia.addEventListener('change', modeMe);
    return () => matchMedia.removeEventListener('change', modeMe);
  }, []);

  return darkMode;
}
```

### 2. Construct a light and dark theme

Next, in your frontend code, [create an `appearance` configuration object](/basics/react/advanced/configuring-appearance) for both light *and* dark mode. You can use the default Privy light and dark themes, e.g.:

<Tabs>
  <Tab title="Light">
    ```tsx  theme={"system"}
    const lightModeConfig = {
      appearance: {
        theme: 'light',
        logo: 'light-logo-url',
      },
    };
    ```
  </Tab>

  <Tab title="Dark">
    ```tsx  theme={"system"}
    const darkModeConfig = {
      appearance: {
        theme: 'dark',
        logo: 'dark-logo-url'
      }
    };
    ```
  </Tab>
</Tabs>

Or, you can create custom `lightModeConfig` and `darkModeConfig` objects (with custom [`theme`](/basics/react/advanced/configuring-appearance#theme)s and [`accentColor`](/basics/react/advanced/configuring-appearance#accent-color)s) to match the modal's light and dark modes with your app's branding.

### 3. Conditionally set your theme based on the user's system preferences

Lastly, in your `PrivyProvider`, conditionally pass in the `lightModeConfig` (your light mode configuration object) or `darkModeConfig` (your dark mode configuration object) depending on the user's system preferences from step 1.

```tsx  theme={"system"}
// 1. Query the user's system preferences for light or dark mode
const darkMode = useDarkMode();

// 2. Construct your light mode and dark mode configuration objects
const lightModeConfig = {
  /* your light mode configuration object */
};
const darkModeConfig = {
  /* your dark mode configuration object */
};

// 3. When you render your `PrivyProvider`, change the `config` property based on the user's system preferences
return (
  <PrivyProvider appId={'your-app-ID'} config={darkMode ? darkModeConfig : lightModeConfig}>
    {children}
  </PrivyProvider>
);
```

**That's it!** Your Privy modal's theme will now automatically match the user's system preference for light or dark mode.


# Migrating wallets from on-device to TEEs
Source: https://docs.privy.io/recipes/tee-wallet-migration-guide



Privy's security architecture leverages secure execution environments to protect your users' assets. Wallet private keys are only temporarily reconstructed within these strictly isolated, secure execution environments when needed for sensitive operations.

Privy provides two types of secure execution environments: 1) via TEEs and 2) on the user's device.

* With **[TEE execution](/security/wallet-infrastructure/architecture)**, wallets are reassembled within trusted execution environments (TEEs), also known as secure enclaves.
* With **[on-device execution](/security/wallet-infrastructure/advanced/user-device)**, wallets are reassembled directly on user devices.

Each environment ensures that private keys are never stored in complete form and are only temporarily reconstructed when needed.

### Feature support

Your app must enable TEE execution in order to access the following features:

* Support for **[Tier 2 and Tier 1 chains](/wallets/overview/chains)**, such as Bitcoin, SUI, Cosmos, and more.
* **[Policy engine](/controls/policies/overview)** in order to restrict Ethereum and Solana transactions.
* Server-side access to wallets, using **[session signers](/wallets/using-wallets/session-signers)**.

#### Unsupported features

Support for the following features is in active development for TEE-based execution:

* Farcaster signers

## Migration guide

The following guide details how to migrate from on-device to TEE execution. When you enable TEE execution, all new wallets will be created within **trusted execution environments (TEEs)**, and existing on-device wallets will be migrated to TEEs as users next visit your app. This is a one-way change.

**To be eligible to migrate from on-device to TEE execution:**

* Your app cannot be using Farcaster signers
* If your app is using delegated actions, migrating to TEE execution will reset all delegations and you will need to re-enable these delegated permissions using session signers
* If your app is built on the Unity SDK, your users' wallets will not be migrated to TEE execution until the user logs into an app built on the React SDK or React Native SDK
* Your app cannot be built on the Android SDK, Flutter SDK, or Swift SDK

### Step 1: Identify your app's execution environment

Navigate to the [Privy Dashboard](https://dashboard.privy.io/apps?tab=advanced\&page=wallets) to verify your app's wallet execution environment. On the **Wallets** page, navigate to the **Advanced** tab.

Your app's wallet environment will be shown here as either "On-device" (with an option to "Request access to migrate to TEE") or "TEE enabled". Apps may only enable one execution environment.

### Step 2: Upgrade your SDKs

TEE execution is supported by the following SDK versions or later:

**Client SDKs**:

* **React**: `@privy-io/react-auth@2.14.0`
* **Expo**: `@privy-io/expo@0.54.0`
* **iOS (Swift)**: `2.0.0-beta.11`
* **Android (Kotlin)**: `0.1.0-beta.1`
* **Flutter**: `0.1.0-beta.1`

**Server SDKs**:

* **Node**: `@privy-io/node@0.1.0`
* **Node (legacy)**: `@privy-io/server-auth@1.26.0`

### Step 3: Enable TEE execution in the Dashboard and contact us

In the [Privy Dashboard](https://dashboard.privy.io/apps?tab=advanced\&page=wallets), navigate to the **Wallets** page and then the **Advanced** tab. Select **"Request access to migrate to TEE"** and follow the instructions.

When you enable TEE execution, all new wallets will be created within trusted execution environments (TEEs). Existing user wallets will be migrated from on-device to TEEs via end-to-end encryption as users next visit your app.

Please note that:

* Because the migration occurs automatically, all client-side features will be immediately available.
* Only wallets that have been migrated to TEEs will support server-side features. Some users may not return to your app, so their wallets will remain on-device.
* User-managed recovery (like cloud recovery) will no longer be prompted on new devices and will be disabled after migration.
* This is a one-way change, and on-device execution is disabled once migration occurs.

<Accordion title=" (Optional) Manually control when wallets are migrated">
  Once TEE execution is enabled, existing user wallets will be migrated from
  on-device to TEEs via end-to-end encryption as users next visit your app.

  However, if you prefer to manually control **when** wallets are migrated,
  you can do so by disabling automatic migration and instead manually triggering
  the migration process.

  <Warning>
    Automatic migration is enabled by default and is the recommended approach.

    If you are opting for manual migration, make sure that the migration is
    triggered as soon as possible. Avoid giving the option to opt-out to ensure a
    uniform experience across your userbase.
  </Warning>

  <Tabs>
    <Tab title="React">
      Begin by disabling automatic migration by setting the
      `disableAutomaticMigration` flag to `true` in the provider config.

      ```tsx  theme={"system"}
      <PrivyProvider
        appId="your-privy-app-id"
        config={{
          ...theRestOfYourConfig,
          embeddedWallets: {
            disableAutomaticMigration: true
          }
        }}
      >
        {/* your app's content */}
      </PrivyProvider>
      ```

      Then, manually trigger the migration process by calling the `migrate`
      method returned by the `useMigrateWallets` hook.

      ```ts  theme={"system"}
      import {useMigrateWallets} from '@privy-io/react-auth';

      const {migrate} = useMigrateWallets();

      await migrate();
      ```

      ### Returns

      <ResponseField name="success" type="boolean">
        A promise that resolves to an object with a success property indicating
        if the user's wallets were migrated successfully.

        The promise will reject otherwise.
      </ResponseField>
    </Tab>

    <Tab title="React Native">
      Begin by disabling automatic migration by setting the
      `disableAutomaticMigration` flag to `true` in the provider config.

      ```tsx  theme={"system"}
      <PrivyProvider
        appId="your-privy-app-id"
        config={{
          ...theRestOfYourConfig,
          embedded: {
            disableAutomaticMigration: true
          }
        }}
      >
        {/* your app's content */}
      </PrivyProvider>
      ```

      Then, manually trigger the migration process by calling the `migrate`
      method returned by the `useMigrateWallets` hook.

      ```ts  theme={"system"}
      import {useMigrateWallets} from '@privy-io/expo';

      const {migrate} = useMigrateWallets();

      await migrate();
      ```

      ### Returns

      <ResponseField name="success" type="boolean">
        A promise that resolves to an object with a success property indicating
        if the user's wallets were migrated successfully.

        The promise will reject otherwise.
      </ResponseField>
    </Tab>
  </Tabs>
</Accordion>

## Breaking changes

Enabling TEE-based execution involves a limited set of breaking changes. These breaking changes do not apply to most apps.

### Unsupported features

A small number of features are not yet supported with TEE-based execution: [list of unsupported features](/recipes/tee-wallet-migration-guide#unsupported-features).

### useSessionSigners

TEE execution enables deeper configurability for clients to provision server-side access to user wallets. In particular, the advanced interface enables your app to specify policies or multiple session signers on a wallet.

To provision server-side access to user wallets, use the `useSessionSigner` hook instead of the previous `useDelegatedActions` hook.

#### Adding session signers (previous)

```javascript {1,4,7} theme={"system"}
import { useHeadlessDelegatedActions, ConnectedWallet } from '@privy-io/react-auth';

function SessionSignersButton(wallet: ConnectedWallet) {
  const { delegateWallet } = useHeadlessDelegatedActions();

  const handleAddSessionSigner = async () => {
    await delegateWallet({ address: wallet.address, chainType: wallet.type });
  }

  return (
    <div>
      <button onClick={() => handleAddSessionSigner()}>
        Add Session Signer
      </button>
    </div>
  );
}
```

Learn more about the previous interface [here](/wallets/using-wallets/session-signers/delegate-wallet).
The previous interface for revoking access can be found [here](/wallets/using-wallets/session-signers/revoke-wallets).

#### Adding session signers (updated)

The updated interface allows a signer ID to be specified and for policies to be set which constrain that session signer.

```javascript {1, 4,7-15} theme={"system"}
import {useSessionSigners, ConnectedWallet} from '@privy-io/react-auth';

function SessionSignersButton(wallet: ConnectedWallet) {
  const {addSessionSigners} = useSessionSigners();

  const handleAddSessionSigner = async () => {
    await addSessionSigners({
      address: wallet.address,
      signers: [
          {
            signerId: "<insert-signer-id>",
            policyIds: ["<insert-policy-id"],
          },
        ],
    });
}

  return (
    <div>
      <button onClick={() => handleAddSessionSigner()}>
        Add Session Signer
      </button>
    </div>
  );
}
```

Learn more about the updated interface [here](/wallets/using-wallets/session-signers/add-session-signers).
The updated interface for revoking access can be found [here](/wallets/using-wallets/session-signers/remove-session-signers).

## New advanced interfaces

### Server-side wallet creation

TEE execution enables deeper configurability for server-side wallet creation. In particular, the advanced interface enables your app to specify policies and session signers when you create a wallet from your server.

The following interface update applies to [importing a single user](/user-management/migrating-users-to-privy/create-or-import-a-user), [batch importing users](/user-management/migrating-users-to-privy/create-or-import-a-batch-of-users), and [pregenerating wallets for existing users](/recipes/pregenerate-wallets) via the [`/users`](/api-reference/users), `/users/import` and `/users/[user_id]/wallets` endpoints.

#### Wallet creation (previous)

<ParamField path="create_ethereum_wallet" type="boolean">
  (Optional) Whether to create an Ethereum wallet for the user.
</ParamField>

<ParamField path="create_solana_wallet" type="boolean">
  (Optional) Whether to create a Solana wallet for the user.
</ParamField>

<ParamField path="create_ethereum_smart_wallet" type="boolean">
  (Optional) Whether to create an Ethereum smart wallet for the user.
</ParamField>

<ParamField path="number_of_ethereum_wallets_to_create" type="number">
  (Optional) The number of Ethereum wallets to pregenerate for the user. Defaults to `1`.
</ParamField>

#### Wallet creation (updated)

<ParamField path="wallets" type="object[]" required>
  The wallets to create for the user.

  <Expandable defaultOpen="true">
    <ParamField path="chain_type" type="ethereum | solana | cosmos | stellar | sui | bitcoin-segwit | near | ton | starknet | aptos" required>
      Chain type of the wallet. "ethereum" supports any EVM-compatible network.
    </ParamField>

    <ParamField path="policy_ids" type="string[]">
      List of policy IDs for policies that should be enforced on the wallet. Currently, only one policy is supported per wallet.
    </ParamField>

    <ParamField path="additional_signers" type="object[]">
      <Expandable defaultOpen="true">
        <ParamField path="signer_id" type="string">
          The key ID of the signer.
        </ParamField>

        <ParamField path="override_policy_ids" type="string[]">
          List of policy IDs for policies that should be enforced on the wallet. Currently, only one policy is supported per wallet.
        </ParamField>
      </Expandable>
    </ParamField>

    <ParamField path="create_smart_wallet" type="boolean" required>
      Set to `true` to create a smart wallet with the user's wallet as the signer. Can only be set on wallets where `chain_type` is `ethereum`.
    </ParamField>
  </Expandable>
</ParamField>

#### Example usage

The following request body:

```json  theme={"system"}
{
  "create_ethereum_wallet": true,
  "create_smart_wallet": true,
  "create_solana_wallet": true
}
```

can be updated to:

```json  theme={"system"}
{
  "wallets": [{"chain_type": "ethereum", "create_smart_wallet": true}, {"chain_type": "solana"}]
}
```

In the updated interface, wallets may also set policies and session signers, e.g.:

```json  theme={"system"}
{
  "wallets": [
    {"chain_type": "ethereum", "policy_ids": ["<policy-id>"], "create_smart_wallet": true},
    {
      "chain_type": "solana",
      "additional_signers": [
        {"signer_id": "<signer-id-1>", "override_policy_ids": ["policy-id-1"]},
        {"signer_id": "<signer-id-2>"}
      ]
    }
  ]
}
```


# Building a Telegram trading bot
Source: https://docs.privy.io/recipes/telegram-bot



Privy can power **Telegram trading bots** that trade on behalf of users. These bots can be controlled via commands in the Telegram app, natural language commands to LLMs, or purely agentic trading.

## Resources

<CardGroup cols={1}>
  <Card title="Telegram trading bot starter" icon="github" href="https://github.com/privy-io/examples/tree/main/examples/privy-node-telegram-trading-bot" arrow>
    Complete starter repository showcasing a Telegram trading bot with Privy and Solana integration.
  </Card>
</CardGroup>

At a high-level, there are two approaches to building a Telegram trading bot:

* [**Bot-first**](/recipes/telegram-bot#bot-first-setup): Users first create and interact with their wallet via Telegram commands to the bot in the Telegram app itself. Later, the user can "claim" their wallet by logging into a web or mobile app to send transactions and export their private key from that interface. Users can also eventually revoke permissions for the bot to transact on their behalf.
* [**App-first**](/recipes/telegram-bot#app-first-setup): Users first create and interact with their wallet by logging into a web or mobile app with their Telegram account, or logging in with an alternate method and then linking their Telegram account. They can send transactions and export their private key from the app, and can also grant permissions to the bot to transact on their behalf.

Follow the guide below to learn how to build Telegram trading bots with Privy. Make sure to follow the appropriate section depending on if your app uses the **bot-first** or **app-first** setup.

## Configuring your bot

To start, we'll cover the basics of creating and setting up your Telegram bot that can send transactions.

### Creating a bot

First, create a new Telegram bot if you haven't already following the instructions below.

<Expandable title="how to create a new bot">
  <Steps>
    <Step title="Create a new bot">
      1. Create a new chat with @BotFather
      2. Create a new bot with the command `/newbot`
      3. Choose a name for your bot
      4. Choose a username for your bot
      5. Safely store your bot token. It should be in the format of, `BOT_ID:BOT_SECRET`
    </Step>

    <Step title="Set up Node.js Telegram bot server">
      1. For this example, we will use Node.js to create a bot server, and specifically use the `node-telegram-bot-api` library.
      2. Install the Telegram bot API library:

      <CodeGroup>
        ```bash npm theme={"system"}
        npm install node-telegram-bot-api
        ```

        ```bash pnpm theme={"system"}
        pnpm install node-telegram-bot-api
        ```

        ```bash yarn theme={"system"}
        yarn add node-telegram-bot-api
        ```
      </CodeGroup>

      3. Create a new file called `bot.js` and add the following code:

      <CodeGroup>
        ```ts @privy-io/node theme={"system"}
        const TelegramBot = require('node-telegram-bot-api');
        const {PrivyClient} = require('@privy-io/node');

        // replace the value below with the Telegram token you receive from @BotFather
        const token = 'YOUR_TELEGRAM_BOT_TOKEN';

        // Create a bot that uses 'polling' to fetch new updates
        const bot = new TelegramBot(token, { polling: true });

        const privy = new PrivyClient({
          appId: 'insert-app-id',
          appSecret: 'insert-app-secret'
        });
        ```

        ```ts @privy-io/server-auth theme={"system"}
        const TelegramBot = require('node-telegram-bot-api');
        const {PrivyClient} = require('@privy-io/server-auth');

        // replace the value below with the Telegram token you receive from @BotFather
        const token = 'YOUR_TELEGRAM_BOT_TOKEN';

        // Create a bot that uses 'polling' to fetch new updates
        const bot = new TelegramBot(token, { polling: true });

        const privy = new PrivyClient('insert-app-id', 'insert-app-secret');
        ```
      </CodeGroup>

      4. Your app is now ready to receive messages from Telegram!
    </Step>
  </Steps>
</Expandable>

### Setting up commands

Next, enable your users to interact with the bot via the Telegram app by configuring your bot to respond to Telegram commands. Use the bot's `onText` interface to register Telegram commands and the actions they should execute.

For example, you might register a `/createwallet` command for users to create wallets via the Telegram app, or a `/transact` command for users to be able to transact.

<Expandable title="how to set up a command">
  You can create a new command via the bot's `onText` method like so:

  <CodeGroup>
    ```ts @privy-io/node {skip-check} theme={"system"}
    bot.onText(/\/insert_command_name/, async (msg) => {
        await privy.wallets().ethereum().sendTransaction(...)
    });
    ```

    ```ts @privy-io/server-auth {skip-check} theme={"system"}
    bot.onText(/\/insert_command_name/, async (msg) => {
        await privy.walletApi.solana.sendTransaction(...)
    });
    ```
  </CodeGroup>

  As an example, you might have a `/transact` command that allows users to send transactions like so.

  <CodeGroup>
    ```ts @privy-io/node {skip-check} theme={"system"}
    bot.onText(/\/transact/, async (msg) => {
      // Custom logic to infer the transaction to send from the user's message
      const transaction = getTransactionDetailsFromMsg(msg);

      // Get the Privy user object using the user's Telegram user ID (`msg.from.id`)
      const user = await privy.users().getByTelegramUserID({
        telegram_user_id: msg.from.id
      });

      // Search the user's linked accounts for their wallet
      const wallet = user.linked_accounts.find(
        (account) => account.type === 'wallet' && 'id' in account
      );

      // Get the wallet ID from the wallet
      const walletId = wallet?.id;

      if (!walletId) throw new Error('Cannot determine wallet ID for user');

      // Send transaction
      await privy.wallets().ethereum().sendTransaction(walletId, {
        caip2: 'eip155:1',
        params: {transaction}
      });
    });
    ```

    ```ts @privy-io/server-auth {skip-check} theme={"system"}
    import type {WalletWithMetadata} from '@privy-io/server-auth';

    bot.onText(/\/transact/, async (msg) => {
      // Custom logic to infer the transaction to send from the user's message
      const transaction = getTransactionDetailsFromMsg(msg);

      // Get the Privy user object using the user's Telegram user ID (`msg.from.id`)
      const user = await privy.getUserByTelegramUserId(msg.from.id);

      // Search the user's linked accounts for their wallet
      const wallet = user?.linkedAccounts.find(
        (account): account is WalletWithMetadata =>
          account.type === 'wallet' && account.walletClientType === 'privy'
      );

      // Get the wallet ID from the wallet
      const walletId = wallet?.id;

      if (!walletId) throw new Error('Cannot determine wallet ID for user');

      // Send transaction
      await privy.walletApi.solana.sendTransaction({walletId, ...transaction});
    });
    ```
  </CodeGroup>
</Expandable>

### Associating your user's wallet ID with their Telegram user ID

In order for the Telegram bot to interact with a user's wallet, the bot must be able to determine what the user's wallet ID is.

<Expandable title="how to get the wallet ID for the Telegram user">
  Within the command, you can access the user's Telegram user ID via the message's `from.id` property. You can then use the Privy client's `getByTelegramUserID` method to get their full Privy user object, as well as their wallet ID.

  <CodeGroup>
    ```ts @privy-io/node {skip-check} theme={"system"}
    bot.onText(/\/log_wallet_id/, async (msg) => {
      // Get the Privy user object using the user's Telegram user ID (`msg.from.id`)
      const user = await privy.users().getByTelegramUserID({
        telegram_user_id: msg.from.id
      });

      // Search the user's linked accounts for their wallet
      const wallet = user.linked_accounts.find(
        (account) => account.type === 'wallet' && 'id' in account
      );

      // Get the wallet ID from the wallet
      const walletId = wallet?.id;
      console.log('Wallet ID', walletId);
    });
    ```

    ```ts @privy-io/server-auth {skip-check} theme={"system"}
    import type {WalletWithMetadata} from '@privy-io/react-auth';
    import {PrivyClient} from '@privy-io/server-auth';

    const privy = new PrivyClient('insert-app-id', 'insert-app-secret');

    bot.onText(/\/log_wallet_id/, async (msg) => {
      // Get the Privy user object using the user's Telegram user ID (`msg.from.id`)
      const user = await privy.getUserByTelegramUserId(msg.from.id);

      // Search the user's linked accounts for their wallet
      const wallet = user?.linkedAccounts.find(
        (account): account is WalletWithMetadata =>
          account.type === 'wallet' && account.walletClientType === 'privy'
      );

      // Get the wallet ID from the wallet
      const walletId = wallet?.id;
      console.log('Wallet ID', walletId);
    });
    ```
  </CodeGroup>
</Expandable>

## Bot-first setup

At a high-level, the **bot-first** setup works by creating a wallet associated with your user's Telegram handle, allowing them to transact with the wallet via commands made to your bot, and enabling users to claim their wallet or control it from a web or mobile app if desired.

Follow the steps below for more concrete guidance.

<Steps>
  <Step title="Create a wallet associated with your user">
    First, create a user in Privy and a wallet owned by that user. To allow your bot to transact on behalf of the user, create an [authorization key](/controls/authorization-keys/keys/create/key) and add it as an [additional signer](/wallets/using-wallets/session-signers/overview) on the wallet.

    <CodeGroup>
      ```ts @privy-io/node theme={"system"}
      bot.onText(/\/start/, async (msg) => {
        const telegramUserId = msg.from.id;
        // Create Privy user with Telegram user ID
        const privyUser = await privy.users().create({
          linked_accounts: [
            {type: 'telegram', telegram_user_id: telegramUserId}
          ]
        });

        // Create wallet with user owner and the bot as an additional signer
        const wallet = await privy.wallets().create({
          chain_type: 'ethereum',
          owner: { user_id: privyUser.id },
          additional_signers: [{ signer_id: 'insert-signer-id', override_policy_ids: [] }],
        });
      });
      ```

      ```ts @privy-io/server-auth theme={"system"}
      bot.onText(/\/start/, async (msg) => {
          const telegramUserId = msg.from.id;
          // Create Privy user with Telegram user ID
          const privyUser = await privy.importUser({
              linkedAccounts: [{
                  type: 'telegram',
                  telegramUserId
              }]
          });

          // Create wallet with user owner and the bot as an additional signer
          const wallet = await privy.walletApi.createWallet({
              chainType: 'solana',
              owner: {
                  userId: privyUser.id
              },
              additionalSigners: [{
                  signerId: 'id-of-authorization-key-from-dashboard'
              }]
          });
      });
      ```
    </CodeGroup>
  </Step>

  <Step title="Send transactions with the wallet">
    Next, allow the user to transact with commands send to the bot. You might implement a `/transact` command that takes input on the user to transact on their behalf.

    <Tip>
      Make sure to [configure your Privy client](/controls/authorization-keys/using-owners/sign) with the private key for the authorization key you created in the Dashboard.
    </Tip>

    <CodeGroup>
      ```ts @privy-io/node theme={"system"}
      bot.onText(/\/transact/, async (msg) => {
          // Custom logic to infer the transaction to send from the user's message
          const transaction = getTransactionDetailsFromMsg(msg);

          // Determine user's wallet ID from their telegram ID
          const user = await privy.users().getByTelegramUserID({
            telegram_user_id: msg.from.id
          });
          const wallet = user.linked_accounts.find(
            (account) => account.type === 'wallet' && 'id' in account
          );
          const walletId = wallet?.id;

          if (!walletId) throw new Error('Cannot determine wallet ID for user');

          // Send transaction
          await privy.wallets().ethereum().sendTransaction(walletId, {
            caip2: 'eip155:1',
            params: {transaction}
          });
      });
      ```

      ```ts @privy-io/server-auth theme={"system"}
      import type {WalletWithMetadata} from '@privy-io/server-auth';

      bot.onText(/\/transact/, async (msg) => {
          // Custom logic to infer the transaction to send from the user's message
          const transaction = getTransactionDetailsFromMsg(msg);

          // Determine user's wallet ID from their telegram ID
          const user = await privy.getUserByTelegramUserId(msg.from.id);
          const wallet = user?.linkedAccounts.find((account): account is WalletWithMetadata => (account.type === 'wallet' && account.walletClientType === 'privy'));
          const walletId = wallet?.id;

          if (!walletId) throw new Error('Cannot determine wallet ID for user');

          // Send transaction
          await privy.walletApi.solana.sendTransaction({walletId, ...transaction});
      });
      ```
    </CodeGroup>
  </Step>

  <Step title="Allow the user to claim their wallet and use it from your app">
    If you'd like users to be able to claim their wallet via a web or mobile app, configure your web app with Privy's [React SDK](/basics/react/quickstart) or your mobile app with Privy's [React Native SDK](/basics/react-native/quickstart) and enable [Telegram login](/authentication/user-authentication/login-methods/telegram).

    Then, when users login to your app via Telegram, they can [send transactions](/wallets/using-wallets/ethereum/send-a-transaction) or [export their private keys](/wallets/wallets/export).
  </Step>
</Steps>

## App-first setup

At a high-level, the **app-first** setup works by creating a wallet associated with your user when they login to your app with Telegram (or alternatively, link a Telegram account) and then adding a [session signer](/wallets/using-wallets/session-signers/overview) to the wallet to allow the bot to transact on behalf of your user.

Follow the steps below for more concrete guidance.

<Steps>
  <Step title="Instrument your app with Privy">
    If you have not already done so, instrument your web app with Privy's [React SDK](/basics/react/quickstart) or your mobile app with Privy's [React Native SDK](/basics/react-native/quickstart) and enable [Telegram login](/authentication/user-authentication/login-methods/telegram).
  </Step>

  <Step title="Create wallets for your users">
    When your users login to your app with Telegram or link a Telegram account, [create a wallet](/wallets/wallets/create/create-a-wallet) for them. Store a mapping between the ID of the created wallet and the user's Telegram ID so that you can determine the user's wallet within the bot's code.
  </Step>

  <Step title="Add a session signer to the user's wallet">
    After the wallet has been created, add a session signer to the user's wallet, which the bot can use to transact on the user's behalf.

    Make sure to store the private key(s) associated with your signer ID securely in your server. Your Telegram bot or agent will need this to execute transaction requests.

    Follow the linked quickstart below to learn how to add a session signer to the user's wallet.

    <CardGroup cols={1}>
      <Card title="Session signer quickstart" href="/wallets/using-wallets/session-signers/quickstart">
        Request access to user wallets with session signers.
      </Card>
    </CardGroup>
  </Step>

  <Step title="Execute actions with your signer">
    Finally, the bot can use the session signer to execute transactions on the user's behalf when prompted. For instance, you might implement a `/transact` command that takes input on the user to transact on their behalf.

    <Tip>
      Make sure to [configure your Privy client](/controls/authorization-keys/using-owners/sign) with the private key for the session signer (authorization key) you created in the Dashboard.
    </Tip>

    <CodeGroup>
      ```ts @privy-io/node theme={"system"}
      import {isEmbeddedWalletLinkedAccount} from '@privy-io/node';

      bot.onText(/\/transact/, async (msg) => {
          // Custom logic to infer the transaction to send from the user's message
          const transaction = getTransactionDetailsFromMsg(msg);

          // Determine user's wallet ID from their Telegram user ID
          const user = await privy.users().getByTelegramUserID({
            telegram_user_id: msg.from.id
          });
          const wallet = user.linked_accounts.find(isEmbeddedWalletLinkedAccount);
          const walletId = wallet?.id;

          if (!walletId) throw new Error('Cannot determine wallet ID for user');

          // Send transaction
          await privy.wallets().ethereum().sendTransaction(walletId, {
            caip2: 'eip155:1',
            params: {transaction}
          });
      });
      ```

      ```ts @privy-io/server-auth theme={"system"}
      bot.onText(/\/transact/, async (msg) => {
          // Custom logic to infer the transaction to send from the user's message
          const transaction = getTransactionDetailsFromMsg(msg);

          // Determine user's wallet ID from their Telegram user ID
          const user = await privy.getUserByTelegramUserId(msg.from.id);
          const wallet = user?.linkedAccounts.find((account): account is WalletWithMetadata => (account.type === 'wallet' && account.walletClientType === 'privy'));
          const walletId = wallet?.id;

          if (!walletId) throw new Error('Cannot determine wallet ID for user');

          // Send transaction
          await privy.walletApi.solana.sendTransaction({walletId, ...transaction});
      });
      ```
    </CodeGroup>

    <CardGroup cols={3}>
      <Card title="Sign requests" href="/controls/authorization-keys/using-owners/sign">
        Sign requests to the Privy API with your session signer.
      </Card>

      <Card title="EVM" href="/wallets/using-wallets/ethereum/send-a-transaction">
        Take actions on EVM chains with Privy's NodeJS SDK or REST API.
      </Card>

      <Card title="Solana" href="/wallets/using-wallets/solana/send-a-transaction">
        Take actions on Solana with Privy's NodeJS SDK or REST API.
      </Card>
    </CardGroup>
  </Step>
</Steps>


# Trading apps resource page
Source: https://docs.privy.io/recipes/trading-apps-homepage



Privy gives you all the tools you need to build world-class trading experiences—securely, seamlessly, and at scale. Whether you're launching a new DEX, building a trading bot, or integrating on-chain swaps, Privy's infrastructure lets you focus on building great user experiences.

## Trusted by leading trading apps

Privy powers leading trading apps such as [Hyperliquid](https://hyperliquid.xyz), [pump.fun](https://pump.fun), [dYdX](https://dydx.trade), [Vector](https://apps.apple.com/us/app/vector-buy-memecoins-crypto/id6502968192), [Jupiter](https://jup.ag), and [BananaGun](https://www.bananagun.io/).

From instant wallet creation and flexible authentication to robust transaction controls and automated gas management, Privy's platform powers every step of the trading journey. With support for embedded and external wallets, cross-chain transactions, and granular transaction policy controls, you can deliver the features your users expect—without compromise.

***

## Common trading flows

* **[Create a wallet](/wallets/wallets/create/create-a-wallet)**: Learn how to create and manage wallets for your users on any chain.
* **[On-ramp funds](/wallets/funding/overview)**: Let users buy crypto with fiat, Apple Pay, or Google Pay.
* **[Send a transaction](/wallets/using-wallets/ethereum/send-a-transaction)**: Sign and send transactions from your app backend or client.
* **[Off-ramp](/recipes/off-ramp-guide)**: Let users cash out to fiat with top providers.

Our battle-tested infrastructure, rich on-chain integrations, and developer-friendly APIs make it easy to build, customize, and scale your trading experience. Security and compliance are built in from day one, so you can launch with confidence.

***

## Build your own trading app

Privy makes it easy to build, customize, and scale your trading experience. Check out some of our guides to help you get started building your own trading app.

<CardGroup cols={2}>
  <Card title="Telegram trading bot guide" icon="robot" href="/recipes/telegram-bot" arrow>
    Guide to building a Solana trading bot for Telegram.
  </Card>

  <Card title="Flashbots integration" icon="robot" href="/recipes/flashbots-protect" arrow>
    Learn how to integrate with Flashbots to avoid bot attacks.
  </Card>

  <Card title="Hyperliquid Guide" icon="lightning" href="/recipes/hyperliquid-guide" arrow>
    Integrate with the Hyperliquid SDKs to make trades on Hyperliquid.
  </Card>

  <Card title="Morpho Guide" icon="bank" href="/recipes/morpho-guide" arrow>
    Learn how to integrate with Morpho lending protocol using Privy wallets.
  </Card>

  <Card title="Request server-side access to user wallets" icon="server" href="/recipes/wallets/session-signer-use-cases/server-side-access" arrow>
    Configure custom control models where both users and your server can execute transactions with
    specific permissions.
  </Card>

  <Card title="Execute limit orders" icon="chart-candlestick" href="/recipes/wallets/session-signer-use-cases/limit-orders" arrow>
    Request server-side access to user wallets to execute limit orders when users are offline.
  </Card>

  <Card title="Onramp with Apple Pay" icon="credit-card" href="/recipes/card-based-funding" arrow>
    Enable users to fund wallets directly with Apple Pay.
  </Card>

  <Card title="Configure confirmation modals" icon="forward-fast" href="/recipes/react/manage-wallet-UIs" arrow>
    Learn how to disable transaction confirmations for faster trading.
  </Card>

  <Card title="Implement robust policies" icon="shield-check" href="/controls/overview" arrow>
    Set up transaction policies to protect users and control spending limits on Ethereum and Solana.
  </Card>
</CardGroup>


# Integrating with tRPC
Source: https://docs.privy.io/recipes/trpc



**[tRPC](https://trpc.io) is an end-to-end typesafe API built in Typescript.** This guide shows how to integrate Privy into any tRPC application.

There are two steps to enable auth in tRPC with Privy:

* in your [client](/recipes/trpc.mdx#configuring-your-client), include the user's access token on requests
* in your [server](/recipes/trpc.mdx#protecting-routes-on-your-server), secure procedures by validating the token included on requests

<Tip>
  If you're using tRPC with [zod](https://github.com/colinhacks/zod), check out [this transformation
  tool](https://transform.tools/typescript-to-zod) to automatically generate zod schemas from
  Privy's types (e.g. **`user.email`**).
</Tip>

## Configuring your client

**When your client (frontend) makes a request to one of your tRPC procedures, you should include the Privy auth token, so that your server can verify that the user is authenticated.**

<Info>
  The following works for both
  [`createTRPCProxyClient`](https://trpc.io/docs/typedoc/client/functions/createTRPCProxyClient-1)
  (vanilla) or [`createTRPCNextClient`](https://trpc.io/docs/nextjs#createtrpcnext-options)
  (Next.js). Note that while the configuration method signature is different between the two, the
  inner configuration object/strategy will remain the same. The example shown is for NextJS.
</Info>

When [scaffolding the tRPC client](https://trpc.io/docs/vanilla), pass the Privy auth token through the header of every request, via an [`httpBatchLink`](https://trpc.io/docs/links/httpBatchLink) within the `links` configuration. Below is an example:

```tsx  theme={"system"}
import {httpBatchLink} from '@trpc/client';
import {createTRPCNext} from '@trpc/next';

import {getAccessToken} from '@privy-io/react-auth';

export const api = createTRPCNext<AppRouter>({
  config() {
    return {
      links: [
        httpBatchLink({
          url: `your_base_url`,
          // apply the privy token to each request
          async headers() {
            return {
              Authorization: `Bearer ${(await getAccessToken()) || ''}`
            };
          }
        })
      ]
    };
  }
});
```

## Protecting routes on your server

**When your server receives a request from the client, it should validate the Privy auth token to confirm included in the request to ensure that it is authenticated.**

First, parse the passed token using jose where you create your tRPC context:

<CodeGroup>
  ```ts @privy-io/node theme={"system"}
  import * as trpc from '@trpc/server';
  import {inferAsyncReturnType} from '@trpc/server';
  import * as trpcNext from '@trpc/server/adapters/next';

  import {PrivyClient, VerifyAuthTokenResponse} from '@privy-io/node';

  // configure your privy server auth client

  const privy = new PrivyClient({
    appId: process.env.NEXT_PUBLIC_PRIVY_APP_ID || '',
    appSecret: process.env.PRIVY_APP_SECRET || ''
  });

  export async function createContext({req, res}: trpcNext.CreateNextContextOptions) {
    const authToken = req.headers.authorization.replace('Bearer ', '');
    let userClaim: VerifyAuthTokenResponse | undefined = undefined;

    if (authToken) {
      try {
        userClaim = await privy.utils().auth().verifyAuthToken(authToken);
        // the claim contains all details about the validated privy token and can be passed
        // via the context for use in all server routes
        // if you want to pull additional details about the user via your api / db, such as whether the user is an
        // admin, here's your chance!
      } catch (_) {
        // this is an expected error for tRPC procedures that don't need to be authenticated
        // if privy is expected, we will throw a 403 at the middleware level, shown in the next step
      }
    }
    return {
      userClaim
    };
  }
  export type Context = inferAsyncReturnType<typeof createContext>;
  ```

  ```ts @privy-io/server-auth theme={"system"}
  import * as trpc from '@trpc/server';
  import {inferAsyncReturnType} from '@trpc/server';
  import * as trpcNext from '@trpc/server/adapters/next';

  import {PrivyClient, AuthTokenClaims} from '@privy-io/server-auth';

  // configure your privy server auth client

  const privy = new PrivyClient(
    process.env.NEXT_PUBLIC_PRIVY_APP_ID || '',
    process.env.PRIVY_APP_SECRET || ''
  );

  export async function createContext({req, res}: trpcNext.CreateNextContextOptions) {
    const authToken = req.headers.authorization.replace('Bearer ', '');
    let userClaim: AuthTokenClaims | undefined = undefined;

    if (authToken) {
      try {
        userClaim = await privy.verifyAuthToken(authToken);
        // the claim contains all details about the validated privy token and can be passed
        // via the context for use in all server routes
        // if you want to pull additional details about the user via your api / db, such as whether the user is an
        // admin, here's your chance!
      } catch (_) {
        // this is an expected error for tRPC procedures that don't need to be authenticated
        // if privy is expected, we will throw a 403 at the middleware level, shown in the next step
      }
    }
    return {
      userClaim
    };
  }
  export type Context = inferAsyncReturnType<typeof createContext>;
  ```
</CodeGroup>

Next, create a middleware procedure for protecting routes:

```typescript {skip-check} theme={"system"}
const isPrivyAuthed = t.middleware(async ({ctx, next}) => {
  // check to make sure that the token was valid.
  // you can add further logic here, such as checking if the user is an admin,
  // if you added more user context within `createContext` above.
  if (!ctx.userClaim) {
    throw new TRPCError({
      code: 'UNAUTHORIZED',
      message: 'Not authenticated'
    });
  }
  return next({
    ctx
  });
});
export const privyProtectedProcedure = t.procedure.use(isPrivyAuthed);
```

Finally, when defining routes, you can use your procedure middleware to ensure the user is properly authenticated.

```typescript {skip-check} theme={"system"}
t.router({
  // this is accessible for everyone
  hello: t.procedure
    .input(z.string().nullish())
    .query(({input, ctx}) => `hello ${input ?? ctx.user?.name ?? 'world'}`),
  admin: t.router({
    // this is accessible only to admins
    secret: privyProtectedProcedure.query(({ctx}) => {
      return {
        secret: 'sauce'
      };
    })
  })
});
```


# Using chains with Tier 2 support
Source: https://docs.privy.io/recipes/use-tier-2

Build an integration with Privy wallets on chains such as Tron, Sui, etc.

<Info>
  This guide covers integration with chains that have Tier 2 support. For a complete list of
  supported chains, refer to the [chains overview](/wallets/overview/chains).
</Info>

To integrate Privy with chains that have Tier 2 support (e.g., Sui, Tron), follow these steps:

1. [Create a wallet](/wallets/wallets/create/create-a-wallet) with the appropriate chain type specified.
2. Utilize Privy's ["raw sign"](/wallets/using-wallets/other-chains) functionality to sign transaction hashes or message hashes.

# Implementation Examples

Note that the "raw sign" functionality signs the provided hash directly without any additional byte manipulation. Ensure that your hash includes any required prefixes or suffixes before signing.

## Stellar

Stellar implements the EdDSA signing algorithm using the Ed25519 curve. The following example demonstrates hash signing for Stellar transactions:

<Expandable title="Code example">
  ```typescript  theme={"system"}
  import {Keypair} from '@stellar/stellar-sdk';

  // Initialize with the wallet's Stellar address
  const address = "<the wallet's stellar address>";
  const keypair = Keypair.fromPublicKey(address);

  // Prepare the hash for signing
  const hash = '0x6503b027a625549f7be691646404f275f149d17a119a6804b855bac3030037aa';

  // Obtain the raw signature from Privy's raw_sign endpoint
  const rawSignature = '...'; // call privy raw_sign on `hash`

  // Verify the signature
  const hashBytes = Buffer.from(hash.slice(2), 'hex');
  const signatureBytes = Buffer.from(rawSignature.slice(2), 'hex');
  const verified = keypair.verify(hashBytes, signatureBytes);
  console.log(verified); // true
  ```
</Expandable>

## Cosmos

Cosmos utilizes the ECDSA signing algorithm with the secp256k1 curve. Below is an implementation example for signing hashes on Cosmos:

<Expandable title="Code example">
  ```typescript  theme={"system"}
  import {Secp256k1, Secp256k1Signature} from '@cosmjs/crypto';

  // Prepare the hash for signing
  const hash = '0x6503b027a625549f7be691646404f275f149d17a119a6804b855bac3030037aa';

  // Obtain the raw signature from Privy's raw_sign endpoint
  const rawSignature = '...'; // call privy raw_sign on `hash`

  // Retrieve the wallet's public key from Privy
  const publicKey = '...'; // the wallet's public key from Privy

  // Verify the signature
  const signatureBytes = Secp256k1Signature.fromFixedLength(
    Buffer.from(rawSignature.slice(2), 'hex')
  );

  const verified = await Secp256k1.verifySignature(
    signatureBytes,
    Buffer.from(hash.slice(2), 'hex'),
    Buffer.from(publicKey, 'hex')
  );
  console.log('Signature valid?', verified); // true
  ```
</Expandable>

## Sui

Sui supports multiple cryptographic schemes, with Privy's implementation utilizing the Ed25519 curve and EdDSA signing algorithm. The following example demonstrates transaction signing for Sui:

<Expandable title="Code example">
  ```typescript  theme={"system"}
  import {messageWithIntent, toSerializedSignature, PublicKey} from '@mysten/sui/cryptography';
  import {blake2b} from '@noble/hashes/blake2b';
  import {Transaction} from '@mysten/sui/transactions';
  import {verifyTransactionSignature, publicKeyFromRawBytes} from '@mysten/sui/verify';
  import {toHex} from '@mysten/sui/utils';
  import {getFullnodeUrl, SuiClient} from '@mysten/sui/client';
  import {base58} from '@scure/base';

  // see Network Interactions with SuiClient for more info on creating clients
  const client = new SuiClient({url: getFullnodeUrl('testnet')});
  const tx = new Transaction();
  // ... add some transactions...
  const bytes = await tx.build({client});

  const intentMessage = messageWithIntent('TransactionData', bytes);
  const digest = blake2b(intentMessage, {dkLen: 32});

  // Convert the digest to a hex string for signing
  const hashToSign = '0x' + toHex(digest);

  const address = '';
  // get public key from privy wallet and decode to Uint8Array
  const publicKey = publicKeyFromRawBytes('ED25519', base58.decode('<public key string>'));

  // Obtain the raw signature from Privy's raw_sign endpoint
  // call privy raw_sign on `hashToSign` and decode as Uint8Array
  const rawSignature = new Uint8Array();

  // Create and verify the transaction signature
  const txSignature = toSerializedSignature({
    signature: rawSignature,
    signatureScheme: 'ED25519',
    publicKey
  });
  const signer = await verifyTransactionSignature(bytes, txSignature, {address});
  console.log(signer.toSuiAddress() === address); // true
  ```
</Expandable>

## Tron

Tron implements the ECDSA signing algorithm using the secp256k1 curve. Privy's implementation returns 64-byte ECDSA signatures (r || s), while Tron requires 65-byte signatures that include a recovery ID (v) as the final byte.

The recovery ID is essential because a 64-byte signature could correspond to two different addresses/private keys. The 65th byte, which can be either 0x1b or 0x1c (derived from 0 or 1 plus 27, following Ethereum standards), resolves this ambiguity.

The following example demonstrates message signing and verification for Tron:

<Expandable title="code example of message signing and verification">
  ```typescript  theme={"system"}
  import {TronWeb} from 'tronweb';
  import {hashMessage} from 'tronweb/utils';

  // Initialize with the wallet's Tron address
  const address = "<the wallet's tron address>";

  // Determine the recovery ID for signature verification
  const getRecoveryId = async ({message, rawSignature}: {message: string; rawSignature: string}) => {
    return (await tronWeb.trx.verifyMessageV2(message, rawSignature + '1b')) === address
      ? '1b'
      : '1c';
  };

  // Initialize TronWeb
  const tronWeb = new TronWeb({
    fullHost: 'xxx'
  });

  // Prepare and sign the message
  const message = 'Hello world';
  const hash = hashMessage(message);

  // Obtain the raw signature from Privy's raw_sign endpoint
  const rawSignature = '...'; // call privy raw_sign on `hash`

  // Verify the signature with the recovery ID
  const signerAddress = await tronWeb.trx.verifyMessageV2(
    message,
    rawSignature + (await getRecoveryId({message, rawSignature}))
  );
  console.log(signerAddress === address); // true
  ```
</Expandable>

<Expandable title="code example of sending and signing a transaction">
  ```typescript  theme={"system"}
  import {TronWeb, Types} from 'tronweb';

  const tronWeb = new TronWeb({
    fullHost: 'https://api.shasta.trongrid.io'
  });

  const walletId = "<wallet's wallet ID>";

  const from = "<wallet's tron address>";
  const to = "<recipient's tron address>";
  const amount = 1;

  const tx = (await tronWeb.transactionBuilder.sendTrx(
    to,
    amount,
    from
  )) as Types.SignedTransaction<Types.TransferContract>;

  const rawTxBytes = tronWeb.utils.code.hexStr2byteArray(tx.txID);
  const rawTxHex = '0x' + tronWeb.utils.code.byteArray2hexStr(rawTxBytes);

  const signature = '...'; // call Privy's raw sign function with rawTxHex, returns '0x...'
  (tx as Types.SignedTransaction<Types.TransferContract>).signature = [signature + '1b'];
  if (tronWeb.trx.ecRecover(tx) !== from) {
    (tx as Types.SignedTransaction<Types.TransferContract>).signature = [signature + '1c'];
  }

  const result = await tronWeb.trx.sendRawTransaction(tx);
  console.log('result', result);
  ```
</Expandable>

## Bitcoin (segwit)

Bitcoin (segwit) supports the ECDSA signing algorithm using the secp256k1 curve. Use Privy's raw sign functionality to sign each input utxo for your Bitcoin segwit transaction. Note that segwit support is separate from Bitcoin taproot or legacy transactions.

<Expandable title="Code example">
  ```typescript  theme={"system"}
  import {p2wpkh, OutScript, getInputType, Transaction} from '@scure/btc-signer';
  import {getPrevOut} from '@scure/btc-signer/transaction.js';
  import {concatBytes} from '@scure/btc-signer/utils.js';
  import secp256k1 from 'secp256k1';

  const publicKey = "<the wallet's public key>";

  const publicKeyBuffer = Buffer.from(publicKey, 'hex');
  const tx = new Transaction({version: 1, allowLegacyWitnessUtxo: true});

  // add as many outputs as needed, in this example there is only one
  // note that the relay fee is sum(input amounts) - sum(output amounts)
  const outputAddress = '';
  const outputAmount = 0n;
  tx.addOutputAddress(outputAddress, outputAmount);

  const inputAmount = 0n;
  tx.addInput({
    txid: '', // buffer of utxo txid
    index: 0, // index of the output in the tx
    witnessUtxo: {
      amount: inputAmount, // this must match the amount of the input exactly
      script: p2wpkh(publicKeyBuffer).script
    }
  });

  for (let i = 0; i < tx.inputsLength; i++) {
    const input = tx.getInput(i);
    const inputType = getInputType(input, tx.opts.allowLegacyWitnessUtxo);
    const prevOut = getPrevOut(input);
    let script = inputType.lastScript;
    // P2WPKH sighash uses the "pkh" script for signing
    if (inputType.last.type === 'wpkh') {
      script = OutScript.encode({type: 'pkh', hash: inputType.last.hash});
    }
    const hash = tx.preimageWitnessV0(i, script, inputType.sighash, prevOut.amount);
    const signature = ''; // call Privy's raw sign function with bytesToHex(hash), returns '0x...'
    const signatureBuffer = Buffer.from(signature.slice(2), 'hex');
    // convert to DER format
    const derSig = secp256k1.signatureExport(signatureBuffer);
    tx.updateInput(
      i,
      {
        partialSig: [[publicKeyBuffer, concatBytes(derSig, new Uint8Array([inputType.sighash]))]]
      },
      true
    );
  }

  tx.finalize();
  // return tx
  ```
</Expandable>

## Near

With Privy, you can create [Near-implicit accounts](https://docs.near.org/protocol/account-model) and sign over arbitrary data. Below is an example of how to create, sign, and send a Near transaction using Privy. (Note that Near requires accounts to be funded sending transactions.)

<Expandable title="code example of creating, signing, and sending a transaction">
  ```typescript  theme={"system"}
  import {utils, transactions, providers} from 'near-api-js';
  import {sha256} from '@noble/hashes/sha256';
  import {base58} from '@scure/base';
  import {toHex} from 'viem';

  const nodeUrl = 'https://rpc.mainnet.near.org';
  const provider = new providers.JsonRpcProvider({url: nodeUrl});
  const receiverId = 'receiver.near';
  const amount = '1.5';
  const nonce = 0; // If this is not the wallet's first transaction, set as current nonce

  const {
    header: {hash}
  } = await provider.block({finality: 'final'});
  const blockHash = utils.serialize.base_decode(hash);

  const accountId = "<wallet's near-implicit address / account ID>";

  const base58PublicKey = base58.encode(Buffer.from(accountId, 'hex'));
  const publicKey = utils.PublicKey.fromString(`ed25519:${base58PublicKey}`);

  const amountYocto = utils.format.parseNearAmount(amount);
  const actions = [transactions.transfer(BigInt(amountYocto ?? 0))];
  const tx = transactions.createTransaction(
    accountId,
    publicKey,
    receiverId,
    nonce,
    actions,
    blockHash
  );

  const serializedTx = utils.serialize.serialize(transactions.SCHEMA.Transaction, tx);

  const txHash = toHex(sha256(serializedTx));

  const signature = '...'; // call Privy's raw sign function with txHash, returns '0x...'

  const signedTx = new transactions.SignedTransaction({
    transaction: tx,
    signature: new transactions.Signature({
      keyType: tx.publicKey.keyType,
      data: Buffer.from(signature.slice(2), 'hex')
    })
  });

  const signedSerializedTx = signedTx.encode();
  const result = await provider.sendJsonRpc('broadcast_tx_commit', [
    Buffer.from(signedSerializedTx).toString('base64')
  ]);
  ```
</Expandable>

## Ton

All wallets on Ton are smart contract accounts, and Ed25519 keypairs are used to sign transactions on behalf of the smart contracts. When creating a wallet via Privy, Privy will generate the Ed25519 keypair and predetermine the address of the wallet contract, assuming that the wallet uses `WalletContractV4` with a `workchain` of `0`. Privy will *not* deploy the contract itself; that is the responsibility of the developer.
If you'd like to deploy a different wallet contract with the same keypair, the address will be different, but the request to Privy's API will remain the same.

<Expandable title="code example of creating and signing a transfer">
  ```typescript  theme={"system"}
  import {Cell, TonClient, WalletContractV4, internal} from '@ton/ton';
  import {toHex} from 'viem';

  // Create Client
  const client = new TonClient({
    endpoint: 'https://toncenter.com/api/v2/jsonRPC'
  });

  const walletId = "<wallet's wallet ID>";
  const publicKey = "<wallet's public key>";

  const trimmedPublicKey = Buffer.from(publicKey.slice(2), 'hex');
  // Create wallet contract
  let workchain = 0; // Usually you need a workchain 0
  let wallet = WalletContractV4.create({
    workchain,
    publicKey: trimmedPublicKey
  });
  let contract = client.open(wallet);

  // Create a transfer
  let seqno: number = await contract.getSeqno();
  const transfer = await contract.createTransfer({
    seqno,
    messages: [
      internal({
        value: '1',
        to: 'to_address',
        body: 'Hello world'
      })
    ],
    signer: async (msg: Cell) => {
      let hash = msg.hash();
      let signature = '...'; // call Privy's raw sign function with toHex(hash), returns '0x...'
      return Buffer.from(signature.slice(2), 'hex');
    }
  });
  ```
</Expandable>

## Spark

Checkout this [recipe](/recipes/spark-btc-guide) to get started with Spark wallets.

## Starknet

On Starknet, all wallets are smart contract accounts. The wallet address is the contract address, and therefore is derived from account-specific data--namely, the account class hash, the constructor data, and the public key returned from the Privy API.
The address returned from the Privy API assumes the use of [Ready's v0.5.0 account](https://github.com/argentlabs/argent-contracts-starknet/blob/6243bcf39fac0df25cff183056a9bc8f1e15ef28/deployments/account.txt#L1) class hash and the constructor call data, as shown below in the example.
After creating a starknet wallet with Privy, STRK tokens must be sent to the address for the wallet. Then, the developer must deploy the account.

If you wish to use a different account contract than Ready 0.5.0, we suggest maintaining the address-to-Privy-wallet mapping yourself at this time and ignoring the address returned from the Privy API.

<Expandable title="code example of deploying your Starknet account and sending a transfer">
  ```typescript  theme={"system"}
  import {
    RpcProvider,
    SignerInterface,
    hash,
    CallData,
    CairoOption,
    CairoOptionVariant,
    CairoCustomEnum,
    Account,
    cairo,
    TypedData,
    Signature,
    Call,
    InvocationsSignerDetails,
    DeployAccountSignerDetails,
    DeclareSignerDetails
  } from 'starknet';

  // connect RPC 0.8 provider
  const provider = new RpcProvider({
    nodeUrl: 'https://starknet-sepolia.public.blastapi.io/rpc/v0_8'
  });

  //new Argent X account v0.5.0
  const ARGENT_X_ACCOUNT_CLASS_HASH_V0_5_0 =
    '0x073414441639dcd11d1846f287650a00c60c416b9d3ba45d31c651672125b2c2';

  const publicKey = 'your public key';

  // Calculate future address of the ArgentX account
  const axSigner = new CairoCustomEnum({Starknet: {pubkey: publicKey}});
  const axGuardian = new CairoOption<unknown>(CairoOptionVariant.None);
  const AXConstructorCallData = CallData.compile({
    owner: axSigner,
    guardian: axGuardian
  });
  const AXcontractAddress = hash.calculateContractAddressFromHash(
    publicKey,
    ARGENT_X_ACCOUNT_CLASS_HASH_V0_5_0,
    AXConstructorCallData,
    0
  );

  // Use a RawSigner wrapper class around Signer. Example: https://github.com/argentlabs/argent-contracts-starknet/blob/6243bcf39fac0df25cff183056a9bc8f1e15ef28/lib/signers/signers.ts#L38
  export abstract class RawSigner extends SignerInterface {
    abstract signRaw(messageHash: string): Promise<string[]>;

    public async getPubKey(): Promise<string> {
      throw new Error('Example');
    }

    public async signMessage(
      typedDataArgument: TypedData,
      accountAddress: string
    ): Promise<Signature> {
      throw new Error('Example');
    }

    public async signTransaction(
      transactions: Call[],
      details: InvocationsSignerDetails
    ): Promise<Signature> {
      throw new Error('Example');
    }

    public async signDeployAccountTransaction(
      details: DeployAccountSignerDetails
    ): Promise<Signature> {
      throw new Error('Example');
    }

    public async signDeclareTransaction(details: DeclareSignerDetails): Promise<Signature> {
      throw new Error('Example');
    }
  }

  const account = new Account(
    provider,
    AXcontractAddress,
    new (class extends RawSigner {
      public async signRaw(messageHash: string): Promise<string[]> {
        console.log('messageHash=', messageHash);
        // Get the signature using the privy raw sign method
        const sig = '..';
        const sigWithout0x = sig.slice(2);
        const r = `0x${sigWithout0x.slice(0, 64)}`;
        const s = `0x${sigWithout0x.slice(64)}`;
        return [r, s];
      }
    })()
  );

  // The account address must hold STRK tokens to deploy the account.

  const accountDeployResult = await account.deployAccount({
    classHash: ARGENT_X_ACCOUNT_CLASS_HASH_V0_5_0,
    contractAddress: AXcontractAddress,
    constructorCalldata: AXConstructorCallData,
    addressSalt: publicKey
  });

  console.log('accountDeployResult=', accountDeployResult);

  // Transfer 1 STRK unit to your recipient address
  const STRK_TOKEN_ADDRESS = '0x04718f5a0fc34cc1af16a1cdee98ffb20c31f5cd61d6ab07201858f4287c938d';

  const amount = cairo.uint256(1);

  // Simple transfer call using account.execute
  const transferCall = {
    contractAddress: STRK_TOKEN_ADDRESS,
    entrypoint: 'transfer',
    calldata: CallData.compile({
      recipient: 'your recipient address',
      amount: amount
    })
  };

  const result = await account.execute(transferCall);
  await provider.waitForTransaction(result.transaction_hash);
  ```
</Expandable>

## Aptos

Aptos is a Move VM chain which uses ed25519 keypairs for signing transactions. Below is an example of how to sign and send a transaction using Privy. See more developer docs [here](https://aptos.dev/build/sdks/ts-sdk/building-transactions).

<Expandable title="code example of signing and sending a transaction">
  ```typescript  theme={"system"}
  import {
    Aptos,
    AptosConfig,
    Network,
    AccountAddress,
    AccountAuthenticatorEd25519,
    Ed25519PublicKey,
    Ed25519Signature,
    generateSigningMessageForTransaction
  } from '@aptos-labs/ts-sdk';
  import {toHex} from 'viem';

  // 1) Wire up the client for the chain
  const aptos = new Aptos(
    new AptosConfig({
      network: Network.MAINNET
    })
  );
  const walletId = '<wallet ID from Privy>';
  const publicKey = '<public key of wallet>'; // 32-byte ed25519 public key hex
  const address = AccountAddress.from('<wallet address>');

  // 2) Build the raw transaction (SDK fills in seq#, chainId, gas if you let it)
  const rawTxn = await aptos.transaction.build.simple({
    sender: address,
    data: {
      function: '0x1::coin::transfer',
      typeArguments: ['0x1::aptos_coin::AptosCoin'],
      functionArguments: ['<recipient address>', 1] // amount in Octas
    }
  });

  const message = generateSigningMessageForTransaction(rawTxn);

  const signature = '...'; // call Privy's raw sign function with txHash, returns '0x...'

  // 5) Wrap pk + signature in an authenticator and submit
  const senderAuthenticator = new AccountAuthenticatorEd25519(
    new Ed25519PublicKey(publicKey),
    new Ed25519Signature(signature.slice(2))
  );

  const pending = await aptos.transaction.submit.simple({
    transaction: rawTxn,
    senderAuthenticator
  });

  const executed = await aptos.waitForTransaction({
    transactionHash: pending.hash
  });
  console.log('Executed:', executed.hash);
  ```
</Expandable>

## Movement

Movement is a Move VM chain that uses the Aptos chain standards. Below is an example of how to sign and send a transaction using Privy. See more developer docs [here](https://docs.movementnetwork.xyz/devs/interactonchain/wallet-adapter/aptos_wallet_standard#13-supporting-multiple-accounts-the-advanced-route).

<Expandable title="code example of signing and sending a transaction">
  ```typescript  theme={"system"}
  import {
    Aptos,
    AptosConfig,
    Network,
    AccountAddress,
    AccountAuthenticatorEd25519,
    Ed25519PublicKey,
    Ed25519Signature,
    generateSigningMessageForTransaction
  } from '@aptos-labs/ts-sdk';
  import {toHex} from 'viem';
  import {PrivyClient} from '@privy-io/node';

  // Initialize your Privy client
  const privy = new PrivyClient({
    appId: 'your-privy-app-id',
    appSecret: 'your-privy-app-secret'
  });

  // 1) Wire up the client for the Movement chain
  const aptos = new Aptos(
    new AptosConfig({
      network: Network.TESTNET,
      fullnode: 'https://full.testnet.movementinfra.xyz/v1'
    })
  );
  const walletId = '<wallet ID from Privy>';
  const publicKey = '<public key of wallet>'; // 32-byte ed25519 public key hex
  const address = AccountAddress.from('<wallet address>');

  // 2) Build the raw transaction (SDK fills in seq#, chainId, gas if you let it)
  const rawTxn = await aptos.transaction.build.simple({
    sender: address,
    data: {
      function: '0x1::coin::transfer',
      typeArguments: ['0x1::aptos_coin::AptosCoin'],
      functionArguments: ['<recipient address>', 1] // amount in Octas
    }
  });

  const message = generateSigningMessageForTransaction(rawTxn);
  const signatureResponse = await privy.wallets().rawSign(walletId, {params: {hash: toHex(message)}});
  const signature = signatureResponse as unknown as string;

  // 5) Wrap pk + signature in an authenticator and submit
  const senderAuthenticator = new AccountAuthenticatorEd25519(
    new Ed25519PublicKey(publicKey),
    new Ed25519Signature(signature.slice(2))
  );

  const pending = await aptos.transaction.submit.simple({
    transaction: rawTxn,
    senderAuthenticator
  });

  const executed = await aptos.waitForTransaction({
    transactionHash: pending.hash
  });
  console.log('Executed:', executed.hash);
  ```
</Expandable>


# null
Source: https://docs.privy.io/recipes/using-test-accounts



Test accounts can be used to build automated tests, for local development, or to reduce friction during Apple's [App Store review](https://developer.apple.com/app-store/review/) process for mobile apps. A new set of credentials are created each time you enable the test account, and the old one is revoked to keep your account secure.

<Info>
  To use these test accounts, your app must support email or SMS login. Testing other login flows
  can either be automated with a library like [Playwright](https://playwright.dev/), or by
  completing the flow manually, as it requires authorization with other APIs *(such as social
  providers)*.
</Info>

## Enabling test accounts

To enable a test account for your app and get its login credentials:

1. Go to the **User management > Authentication > Advanced** tab of the Privy Dashboard
2. Turn on the **Enable test accounts** toggle

Once enabled, you will see the login credentials for your test account that you can use for your app ID.

All test credentials follow the same format, where `XXXX`/`XXXXXX` in the credentials below should be substituted with the values you see in the **User management > Authentication > Advanced** page of the Dashboard. You **cannot** substitute arbitrary values for `XXXX`/`XXXXXX` or use [plus addressing](https://learn.microsoft.com/en-us/exchange/recipients-in-exchange-online/plus-addressing-in-exchange-online); you **must** use the credentials from the Dashboard exactly.

| email                | phone             | OTP *(for either)* |
| -------------------- | ----------------- | ------------------ |
| `test-XXXX@privy.io` | `+1 555 555 XXXX` | `XXXXXX`           |

Once enabled, a test user can log into your app with the provided email or phone number and the provided OTP code to review and test your app.

<Info>
  Depending on when you created your Privy app, you may have a legacy test account enabled with the
  login credentials `test@privy.io` or `+1 555 555 5555`. Please see the **User management >
  Authentication > Advanced** page of the Privy Dashboard to determine if this is the case for your
  app.
</Info>

<Tip>
  Test accounts have a lighter authentication rate limit for apps in development. While all accounts
  in production apps and non-test accounts in development apps are limited to 5 requests every 5
  minutes for email and 5 requests every 10 minutes for SMS, test accounts in development apps are
  limited to 10 requests every 10 seconds for either.
</Tip>

## Getting a test access token programmatically

You can programmatically get an access token for your app's test account using the `getTestAccessToken` method:

```typescript {skip-check} theme={"system"}
getTestAccessToken(): Promise<{accessToken: string}>
```

This method returns a `Promise` that resolves to an object containing the `accessToken` string for the test account.

<Warning>
  `getTestAccessToken` will throw an error if:

  * You have not enabled test credentials in the Privy Dashboard
  * Allowed origins or base domain are enabled for your app
</Warning>


# Agentic wallets
Source: https://docs.privy.io/recipes/wallets/agentic-wallets



Privy enables developers to create wallets for AI agents and autonomous systems that can execute onchain transactions independently while maintaining strict policy controls and security guardrails.

Agentic wallets are designed for use cases where autonomous systems need to make decisions and execute transactions without human intervention, such as trading agents, portfolio managers, automated market makers, and autonomous service providers.

At a high-level, this recipe will teach developers how to set up wallets that AI agents can control, implement policies to constrain agent behavior, and enable secure autonomous transaction execution.

<Steps>
  <Step title="Choose your control model">
    Privy supports two primary models for agentic wallets depending on your custody and control requirements:

    **Model 1: Agent-controlled, developer-owned wallets**

    * Your application backend controls the wallet via authorization keys
    * Suitable for fully autonomous agents where users delegate complete control
    * Agent can execute transactions within policy constraints without user approval

    **Model 2: User-owned wallets with agent signers**

    * Users maintain ownership while granting limited permissions to agents
    * Agent operates as an [additional signer](/controls/authorization-keys/owners/overview#signers) with scoped policies
    * Users retain ultimate control and can revoke agent access at any time

    For this recipe, we'll focus on **Model 1** for fully autonomous agents. For Model 2, see the [session signers guide](/wallets/using-wallets/session-signers/overview).
  </Step>

  <Step title="Create authorization keys">
    Set up authorization keys that your application backend will use to control agent wallets.

    To start, create [authorization keys](/controls/authorization-keys/owners/types#authorization-keys) in the Privy Dashboard and securely store the corresponding private keys. Your backend will use these keys to sign requests to Privy's API on behalf of agents.

    For enhanced security, register the authorization keys in a [key quorum](/controls/authorization-keys/owners/types#key-quorums). This enables multi-party approval for critical actions like updating policies or exporting wallets.

    <CardGroup cols={2}>
      <Card title="Create authorization keys" href="/controls/authorization-keys/keys/create/key">
        Create authorization keys in your Privy Dashboard.
      </Card>

      <Card title="Key quorums quickstart" href="/controls/key-quorum/create#nodejs">
        Set up a key quorum for enhanced security.
      </Card>
    </CardGroup>
  </Step>

  <Step title="Define agent policies">
    Policies are critical as they define the boundaries within which your AI agents can operate. Well-designed policies prevent agents from taking unintended or harmful actions while allowing them to function effectively.

    Common policy constraints for agents include:

    * **Transfer limits**: Maximum amounts per transaction or within time windows
    * **Allowlisted contracts**: Restrict agents to interact only with approved protocols
    * **Recipient restrictions**: Limit where funds can be sent
    * **Time-based controls**: Define when agents can operate
    * **Action-specific rules**: Control parameters for swaps, trades, or other operations

    Follow the guide below to create policies for your desired use case. After creating your policy, save the `id` to assign the policy to the wallet(s) you create later.

    <CardGroup cols={2}>
      <Card title="Policies overview" href="/controls/policies/overview">
        Learn how to construct policies with Privy's policy language.
      </Card>

      <Card title="Create a policy" href="/controls/policies/create-a-policy#nodejs">
        Create policies for your agents.
      </Card>
    </CardGroup>
  </Step>

  <Step title="Create the agent wallet">
    Create a wallet owned by your authorization key, with the policies you previously defined attached. Make sure to:

    * Set the `owner_id` of the wallet to the `id` of the authorization key you created earlier
    * Set the `policy_ids` array of the wallet to a singleton containing the `id` of the policy you created earlier

    You can reuse the same policy ID to provision additional wallets so every agent in your fleet is subject to these controls.

    <CardGroup cols={1}>
      <Card title="Wallets quickstart" href="/wallets/wallets/create/create-a-wallet#nodejs">
        Create a wallet.
      </Card>
    </CardGroup>
  </Step>

  <Step title="Execute transactions">
    You can now send transactions, sign transactions, or sign messages with Privy's API. Follow the guide below to send a transaction.

    <CardGroup cols={3}>
      <Card title="Send EVM transaction" href="/wallets/using-wallets/ethereum/send-a-transaction#nodejs">
        Execute transactions on Ethereum and EVM chains.
      </Card>

      <Card title="Send Solana transaction" href="/wallets/using-wallets/solana/send-a-transaction#nodejs">
        Execute transactions on Solana.
      </Card>

      <Card title="Tier 2 chains" href="/wallets/using-wallets/other-chains#nodejs">
        Execute transactions on other supported chains.
      </Card>
    </CardGroup>
  </Step>

  <Step title="Monitor and observe agent behavior">
    Implement monitoring and logging to track your agent's actions and ensure it operates as intended. Privy provides webhooks for transaction events and balance changes.

    <CardGroup cols={2}>
      <Card title="Transaction webhooks" href="/wallets/gas-and-asset-management/assets/transaction-event-webhooks">
        Monitor transaction status and completion.
      </Card>

      <Card title="Balance webhooks" href="/wallets/gas-and-asset-management/assets/balance-event-webhooks">
        Track deposits and withdrawals.
      </Card>
    </CardGroup>
  </Step>
</Steps>

## Learn more

<CardGroup cols={3}>
  <Card title="x402 payments quickstart" href="/recipes/x402">
    Set up your agent to pay for APIs and content.
  </Card>

  <Card title="Hyperliquid quickstart" href="/recipes/hyperliquid-guide">
    Set up your agent to trade on Hyperliquid.
  </Card>

  <Card title="Gas sponsorship" href="/wallets/gas-and-asset-management/gas/overview">
    Automatically sponsor gas fees for agent transactions.
  </Card>
</CardGroup>


# Server-side user wallets
Source: https://docs.privy.io/recipes/wallets/server-side-user-wallets



Privy enables creating **self-custodial** wallets for your users that can be used from your servers.

Privy enforces self-custody of the wallet by requiring a valid access token from the user for any wallet actions, ensuring the user is authenticated in your app. This guarantees that the **user must be in the loop** for any transaction invoked by your server.

At a high-level, you can create self-custodial wallets that can be used from your servers by:

<Steps>
  <Step title="Configure authentication settings">
    Configure the authentication settings from your existing authentication provider in the Privy
    Dashboard. Privy will use these settings to verify a user's access token.
  </Step>

  <Step title="Create your user">
    [Create a user](/user-management/migrating-users-to-privy/create-or-import-a-user) user in Privy
    using the user ID from your authentication provider. This user will be assigned as the owner of
    their wallet.
  </Step>

  <Step title="Create a wallet owned by your user">
    Create a wallet [owned](/controls/authorization-keys/owners/overview) by your user using their
    Privy user ID. When creating the wallet, you can optionally attach
    [policies](/controls/policies/overview) to the wallet to configure which kinds of transactions
    can be sent by your user.
  </Step>

  <Step title="Request a user key with a user's access token">
    While your user is authenticated in your app, use your user's access token to request an
    ephemeral [user key](/controls/authorization-keys/keys/create/user/overview) for your user. This
    key is required to sign requests to execute transactions, ensuring the user stays in the loop
    for all transactions.
  </Step>

  <Step title="Execute transactions from your server">
    Compute the user key's signature over your API request and execute transactions from your
    server.
  </Step>
</Steps>

Follow the guide below for more concrete instructions.

## 1. Configure authentication settings

Privy ensures that users are in the loop for all wallet actions by requiring a valid **access token** for your user issued by your authentication provider. This ensures your user is authenticated for all transactions executed by your server.

To verify a user's access token, Privy requires that your app register details of your authentication setup in the Privy Dashboard. Namely:

1. Get your **JWKS.json** endpoint from your authentication provider (e.g. Auth0, Firebase, Stytch). Privy will use this endpoint to verify access tokens for your users.
2. In the **Authentication** page of the **Configuration** section of the Privy Dashboard, enable **JWT-based authentication**.
3. Once JWT-based authentication has been enabled:
   1. Determine whether your app will be authenticating requests that contain your provider's JWTs from a **server side or client side environment**.
      {/* prettier-ignore */}
   2. Register the **JWKS.json** endpoint from your authentication provider and the name of the **JWT claim** that specifies the user's ID (typically `sub`).
      Privy can now verify access tokens issued by your authentication provider to authenticate users, and issue user keys for users.

## 2. Create your user

Next, [create a user](/user-management/migrating-users-to-privy/create-or-import-a-user) in Privy that will own your wallet. Pass the user ID from your authentication provider in the request to associate the user in Privy with the user in your authentication provider.

<Tabs>
  <Tab title="NodeJS">
    Use the Privy client's `create` method on the `users()` interface to create a user.

    ```ts  theme={"system"}
    const user = await privy.users().create({
        linked_accounts: [{
            type: 'custom_auth',
            custom_user_id: 'insert-user-id-from-authentication-provider'
        }]
    });

    // Save the Privy user ID
    const id = user.id;
    ```

    Make sure to save the `id` of the returned Privy user for the next step.
  </Tab>

  <Tab title="NodeJS (server-auth)">
    Use the Privy client's `importUser` method to create a user.

    ```ts  theme={"system"}
    const user = await privy.importUser({
        linkedAccounts: [{
            type: 'custom_auth',
            customUserId: 'insert-user-id-from-authentication-provider'
        }]
    });

    // Save the Privy user ID
    const id = user.id;
    ```

    Make sure to save the `id` of the returned Privy user for the next step.
  </Tab>

  <Tab title="REST API">
    Make a `POST` request to:

    ```sh  theme={"system"}
    https://auth.privy.io/api/v1/users
    ```

    with the body:

    ```json  theme={"system"}
    {
        "linked_accounts": [{
            "type": "custom_auth",
            "custom_user_id": "insert-user-id-from-authentication-provider"
        }]
    }
    ```

    Below is a **sample cURL command** for importing a new user into Privy:

    ```bash  theme={"system"}
    $ curl --request POST https://auth.privy.io/api/v1/users \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H 'Content-Type: application/json' \
    -d '{
        "linked_accounts": [{
                "type": "custom_auth",
                "custom_user_id": "insert-user-id-from-authentication-provider"
        }]
    }'
    ```

    Make sure to save the `id` field returned in the response body for the next step
  </Tab>
</Tabs>

## 3. Create a wallet owned by your user

Next, given your Privy user ID from step 3, create a wallet [owned](/controls/authorization-keys/owners/overview) by your user. This ensures that the user is the only party that is allowed to authorize transactions from the wallet.

<Tip>
  When creating a wallet, you can also associate [policies](/controls/policies/overview) with the
  wallet to configure which kinds of transactions are allowed to be sent.
</Tip>

<Tabs>
  <Tab title="NodeJS">
    Use the Privy client's `create` method on the `wallets()` interface to create a wallet.

    ```ts  theme={"system"}
    const {id, address} = await privy.wallets().create({
        chain_type: 'ethereum',
        owner: {user_id: 'insert-privy-user-id'},
        policy_ids: ['insert-any-policy-ids-to-associate-with-wallet']
    });
    ```

    Make sure to save the `id` of the returned wallet, to allow your server to transact with this wallet in the next step.
  </Tab>

  <Tab title="NodeJS (server-auth)">
    Use the `createWallet` method of the Privy client's `walletApi` class to create a user:

    ```ts  theme={"system"}
    const {id, address} = await privy.walletApi.createWallet({
        chainType: 'ethereum',
        owner: {userId: 'insert-privy-user-id'},
        policyIds: ['insert-any-policy-ids-to-associate-with-wallet']
    });
    ```

    Make sure to save the `id` of the returned wallet, to allow your server to transact with this wallet in the next step.
  </Tab>

  <Tab title="REST API">
    To create a new wallet for a user, make a `POST` request to:

    ```sh  theme={"system"}
    https://api.privy.io/v1/wallets
    ```

    with the body:

    ```json  theme={"system"}
    {
        "owner": [{
            "user_id": "insert-privy-user-id"
        }],
        "chain_type": "specify-'ethereum'-or-'solana'"
    }
    ```

    Below is a **sample cURL command** for creating a wallet owned by your user.

    ```bash  theme={"system"}
    curl --request POST https://api.privy.io/v1/wallets \
        -u "<your-privy-app-id>:<your-privy-app-secret>" \
        -H "privy-app-id: <your-privy-app-id>" \
        -H 'Content-Type: application/json' \
        -d '{
        "owner": {
            "user_id": "did:privy:xxxxxx"
        },
        "chain_type": "ethereum"
        }'
    ```

    Make sure to save the `id` of the wallet in the response body, to execute transactions with the wallet in your next step.
  </Tab>
</Tabs>

## 4. Request a user key

When your user is authenticated in your application and wants to take action with their wallet, first make a request from your frontend to your server with the user's access token.

You will use this access token to request an ephemeral [user key](/controls/authorization-keys/keys/create/user/overview). This key is required to sign requests to the Privy API to ensure that users authorize transactions that are being sent.

Next, once your server has the user's access token, make a request to Privy to get the user key.

<Tabs>
  <Tab title="NodeJS">
    The NodeJS SDK will automatically handle requesting the user key when required whenever you set
    a `user_jwt` on the [authorization context](/controls/authorization-keys/using-owners/sign/signing-on-the-server) object.

    ```ts  theme={"system"}
    const authorizationContext: AuthorizationContext = {
      user_jwts: ['insert-user-jwt']
    };
    ```
  </Tab>

  <Tab title="NodeJS (server-auth)">
    To request a user key, use the `generateUserSigner` method of the Privy client's `walletApi` class:

    ```ts  theme={"system"}
    const {authorizationKey} = await privy.walletApi.generateUserSigner({
        userJwt: 'insert-user-jwt-from-authentication-provider'
    });
    ```

    Next, update the Privy client to use the returned user key using the `updateAuthorizationKey` method:

    ```ts  theme={"system"}
    privy.walletApi.updateAuthorizationKey('insert-user-key-from-above');
    ```

    Your Privy client will now automatically use this user key to sign requests to Privy's API.
  </Tab>

  <Tab title="REST API">
    Make a `POST` request to:

    ```sh  theme={"system"}
    https://api.privy.io/v1/wallets/authenticate
    ```

    with the body:

    ```json  theme={"system"}
    {
        "user_jwt": "insert-user-jwt-from-authentication-provider",
    }
    ```

    Below is a sample cURL command for requesting a user key.

    ```bash  theme={"system"}
    curl -X POST "https://api.privy.io/v1/wallets/authenticate" \
    -H "Authorization: Basic <insert-basic-auth-header>" \
    -H "Content-Type: application/json" \
    -H "privy-app-id: <insert-your-app-id>" \
    -d '{
        "user_jwt": <insert-user-jwt>,
    }'
    ```

    Save the `authorization_key` returned in the response body to be used in the next step.

    <Tip>
      In production environments, we strongly recommend using asymmetric encryption when requesting user keys from Privy's API. View [this guide](/controls/authorization-keys/keys/create/user/request) to learn more.
    </Tip>
  </Tab>
</Tabs>

## 5. Execute transactions from your server

Lastly, execute transactions from your server with the user key. All requests to the Privy API to execute a transaction must be signed by the user key to ensure the user authorizes the transaction. Follow the steps below to sign a request and execute a transaction with the REST API.

<Tip>
  You can also enable [key export of a user's wallet](/wallets/wallets/export) with a valid access
  token from the user.
</Tip>

<Tabs>
  <Tab title="NodeJS">
    Provided you've set the `user_jwt` on the [authorization context](/controls/authorization-keys/using-owners/sign/signing-on-the-server)
    object as shown in step 4, the Privy client will automatically sign requests to the Privy API
    with user's key.
    You can simply use the
    [`privy.wallets().ethereum()`](/wallets/using-wallets/ethereum/send-a-transaction)
    and
    [`privy.wallets().solana()`](/wallets/using-wallets/solana/send-a-transaction)
    interfaces to take actions with wallets, and the SDK will automatically sign requests under the
    hood.
  </Tab>

  <Tab title="NodeJS (server-auth)">
    The Privy client will automatically sign requests to the Privy API with the key you provided in the step above. You can simply use the [`privy.walletApi.ethereum.*`](/wallets/using-wallets/ethereum/send-a-transaction) and [`privy.walletApi.solana.*`](/wallets/using-wallets/solana/send-a-transaction) interfaces to take actions with wallets, and the SDK will automatically sign requests under the hood.
  </Tab>

  <Tab title="REST API">
    Follow [this guide](/controls/authorization-keys/using-owners/sign) to learn how to sign requests to the Privy API. Make sure to include the signature as a `privy-authorization-signature` header on all transaction requests.

    Then, follow the respective guides for executing transactions on [Ethereum](/wallets/using-wallets/ethereum/send-a-transaction) and [Solana](/wallets/using-wallets/solana/send-a-transaction).
  </Tab>
</Tabs>


# Using session signers to execute limit orders with wallets
Source: https://docs.privy.io/recipes/wallets/session-signer-use-cases/limit-orders



Session signers allow your app to execute limit orders or other transactions while a user is offline. You can also configure session signers such that you can only execute certain orders restricted by specific [policies](/controls/policies/overview) that you define.

At a high-level, you can use session signers to execute limit orders.

<Steps>
  <Step title="Add a session signer to the user's wallet">
    Follow the session signer quickstart to first request access to a user's wallet. Store the private key(s) associated with your signer ID securely in your server. Your Telegram bot or agent will need this to execute transaction requests.

    <CardGroup cols={1}>
      <Card title="Session signer quickstart" href="/wallets/using-wallets/session-signers/quickstart">
        Request access to user wallets with session signers.
      </Card>
    </CardGroup>
  </Step>

  <Step title="Execute the limit order from your server">
    Next, use Privy's NodeJS SDK or REST API to execute the limit order from your server. When making the request to Privy's API, you must sign the request with the private key(s) associated with your signer ID.

    Follow the guides below to learn how to sign requests and execute transactions on EVM and Solana.

    <CardGroup cols={3}>
      <Card title="Sign requests" href="/controls/authorization-keys/using-owners/sign">
        Sign requests to the Privy API with your session signer.
      </Card>

      <Card title="EVM" href="/wallets/using-wallets/ethereum/send-a-transaction">
        Take actions on EVM chains with Privy's NodeJS SDK or REST API.
      </Card>

      <Card title="Solana" href="/wallets/using-wallets/solana/send-a-transaction">
        Take actions on Solana with Privy's NodeJS SDK or REST API.
      </Card>
    </CardGroup>
  </Step>
</Steps>


# Enabling server-side access to user wallets
Source: https://docs.privy.io/recipes/wallets/session-signer-use-cases/server-side-access



Session signers allow your app to request server-side access to user wallets. This enables your app to execute transactions from user wallets from your servers directly, giving you more control and the ability to execute transactions even when the user is offline (e.g., for limit orders or agentic trading).

You can also configure session signers to have specific permissions via [policies](/controls/policies/overview), such that you can request server-side access for only certain transaction types.

At a high-level, you can use session signers to request server-side access to user wallets.

<Steps>
  <Step title="Add a session signer to the user's wallet">
    Follow the session signer quickstart to first request access to a user's wallet. Store the private key(s) associated with your signer ID securely in your server.

    <CardGroup cols={1}>
      <Card title="Session signer quickstart" href="/wallets/using-wallets/session-signers/quickstart">
        Request access to user wallets with session signers.
      </Card>
    </CardGroup>
  </Step>

  <Step title="Execute actions with your signer">
    Next, execute actions with your session signer by signing requests with the private key(s) of your signer ID. Follow the guides below to learn how to sign requests and execute actions with wallets.

    <CardGroup cols={3}>
      <Card title="Sign requests" href="/controls/authorization-keys/using-owners/sign">
        Sign requests to the Privy API with your session signer.
      </Card>

      <Card title="EVM" href="/wallets/using-wallets/ethereum/send-a-transaction">
        Take actions on EVM chains with Privy's NodeJS SDK or REST API.
      </Card>

      <Card title="Solana" href="/wallets/using-wallets/solana/send-a-transaction">
        Take actions on Solana with Privy's NodeJS SDK or REST API.
      </Card>
    </CardGroup>
  </Step>
</Steps>


# Using session signers to create Telegram trading bots for users
Source: https://docs.privy.io/recipes/wallets/session-signer-use-cases/telegram-bot



Session signers allow your app to create Telegram bots or other agents that can execute transactions on behalf of users. You can use session signers to execute transactions given natural language commands from users in Telegram, or execute transactions on the user's behalf while they are offline.

You can also configure session signers such that your Telegram bot or agent has specific permissions via [policies](/controls/policies/overview), such that the agent can only execute certain transaction types.

At a high-level, you can use session signers to create Telegram bots and other trading agents like so.

<Tip>
  Looking to build a Telegram trading bot without a web or mobile app to start? View our overall
  [Telegram trading bot guide](/recipes/telegram-bot) to learn how to set up your bot for different
  configurations.
</Tip>

<Steps>
  <Step title="Instrument your app with Privy">
    If you have not already done so, instrument your web app with Privy's [React SDK](/basics/react/quickstart) or your mobile app with Privy's [React Native SDK](/basics/react-native/quickstart) and enable [Telegram login](/authentication/user-authentication/login-methods/telegram).
  </Step>

  <Step title="Create wallets for your users">
    When your users login to your app with Telegram or link a Telegram account, [create a wallet](/wallets/wallets/create/create-a-wallet) for them. Store a mapping between the ID of the created wallet and the user's Telegram ID so that you can determine the user's wallet within the bot's code.
  </Step>

  <Step title="Add a session signer to the user's wallet">
    After the wallet has been created, add a session signer to the user's wallet, which the bot can use to transact on the user's behalf.

    Make sure to store the private key(s) associated with your signer ID securely in your server. Your Telegram bot or agent will need this to execute transaction requests.

    Follow the linked quickstart below to learn how to add a session signer to the user's wallet.

    <CardGroup cols={1}>
      <Card title="Session signer quickstart" href="/wallets/using-wallets/session-signers/quickstart">
        Request access to user wallets with session signers.
      </Card>
    </CardGroup>
  </Step>

  <Step title="Execute actions with your signer">
    Finally, the bot can use the session signer to execute transactions on the user's behalf when prompted. For instance, you might implement a `/transact` command that takes input on the user to transact on their behalf.

    <Tip>
      Make sure to [configure your Privy client](/controls/authorization-keys/using-owners/sign) with the private key for the session signer (authorization key) you created in the Dashboard.
    </Tip>

    <CodeGroup>
      ```ts @privy-io/node theme={"system"}
      import {isEmbeddedWalletLinkedAccount} from '@privy-io/node';

      bot.onText(/\/transact/, async (msg) => {
          // Custom logic to infer the transaction to send from the user's message
          const transaction = getTransactionDetailsFromMsg(msg);

          // Determine user's wallet ID from their Telegram user ID
          const user = await privy.users().getByTelegramUserID({
            telegram_user_id: msg.from.id
          });
          const wallet = user.linked_accounts.find(isEmbeddedWalletLinkedAccount);
          const walletId = wallet?.id;

          if (!walletId) throw new Error('Cannot determine wallet ID for user');

          // Send transaction
          await privy.wallets().ethereum().sendTransaction(walletId, {
            caip2: 'eip155:1',
            params: {transaction}
          });
      });
      ```

      ```ts @privy-io/server-auth theme={"system"}
      bot.onText(/\/transact/, async (msg) => {
          // Custom logic to infer the transaction to send from the user's message
          const transaction = getTransactionDetailsFromMsg(msg);

          // Determine user's wallet ID from their Telegram user ID
          const user = await privy.getUserByTelegramUserId(msg.from.id);
          const wallet = user?.linkedAccounts.find((account): account is WalletWithMetadata => (account.type === 'wallet' && account.walletClientType === 'privy'));
          const walletId = wallet?.id;

          if (!walletId) throw new Error('Cannot determine wallet ID for user');

          // Send transaction
          await privy.walletApi.solana.sendTransaction({walletId, ...transaction});
      });
      ```
    </CodeGroup>

    <CardGroup cols={3}>
      <Card title="Sign requests" href="/controls/authorization-keys/using-owners/sign">
        Sign requests to the Privy API with your session signer.
      </Card>

      <Card title="EVM" href="/wallets/using-wallets/ethereum/send-a-transaction">
        Take actions on EVM chains with Privy's NodeJS SDK or REST API.
      </Card>

      <Card title="Solana" href="/wallets/using-wallets/solana/send-a-transaction">
        Take actions on Solana with Privy's NodeJS SDK or REST API.
      </Card>
    </CardGroup>
  </Step>
</Steps>


# Treasury wallets
Source: https://docs.privy.io/recipes/wallets/treasury-wallets



Privy enables developers to create, own, and control wallets for various use cases including [treasury management](https://privy.io/blog/reimagining-treasury-management-with-stablecoins), trading, and commerce.

A common configuration is to set up [key quorum-owned wallets](/controls/authorization-keys/owners/overview), which require authorizations from multiple parties before taking important actions. These setups typically also implement [policies](/controls/overview) to define what actions can be taken with a wallet.

At a high-level, this recipe will teach developers how to create a key quorum, implement a policy, generate a wallet that is subject to these controls, and send a transaction.

<Steps>
  <Step title="Create an m-of-n key quorum">
    Key quorums make it possible for organizations to require multiple authorizations before taking critical actions, such as updating owners, policies, and signers, exporting a wallet, or using a wallet to send a transaction.

    To start, create [authorization keys](/controls/authorization-keys/owners/types#authorization-keys) in the Privy Dashboard and save the corresponding private keys. Your app will use these private keys to sign requests to Privy's API.

    Next, register the authorization keys in a [key quorum](/controls/authorization-keys/owners/types#key-quorums). Set the authorization threshold to the number of members of the quorum that must sign a given wallet request. For example, in a 2-of-3 quorum, authorization signatures must be provided by at least 2 of the keys in the quorum to authorize requests to the Privy API.

    You will later register this key quorum as the owner of a wallet, and a sufficient number of members of the key quorum must sign requests to use the wallet.

    Follow the guide below to create your authorization key(s) and key quorum.

    <CardGroup cols={2}>
      <Card title="Create authorization keys" href="/controls/authorization-keys/keys/create/key">
        Create authorization keys in your Privy Dashboard.
      </Card>

      <Card title="Key quorums quickstart" href="/controls/key-quorum/create">
        Create a key quorum in your Privy Dashboard.
      </Card>
    </CardGroup>
  </Step>

  <Step title="Implement a policy">
    Privy’s policy engine allows your application to restrict the actions that can be taken with wallets. These policies include critical controls such as transfer limits, time-bound signers, allowlists and denylists of smart contracts and programs, and restricting smart contract parameters and calldata.

    Follow the guide below to create policies for your desired use case. After creating your policy, save the `id` to assign the policy to the wallet(s) you create later.

    <CardGroup cols={2}>
      <Card title="Policies overview" href="/controls/policies/overview">
        Learn how to construct policies with Privy's policy language.
      </Card>

      <Card title="Policies quickstart" href="/controls/policies/create-a-policy">
        Create a policy.
      </Card>
    </CardGroup>
  </Step>

  <Step title="Create a wallet">
    Create a wallet with the following configuration:

    * Set the `owner_id` of the wallet to the `id` of the key quorum you created earlier
    * Set the `policy_ids` array of the wallet to a singleton containing the `id` of the policy you created earlier

    As the owner, the key quorum must sign requests to update the wallet's configuration or execute transactions. The wallet is also subject to the policy you created.

    Follow the guide below to create a wallet with your desired configuration.

    <CardGroup cols={1}>
      <Card title="Wallets quickstart" href="/wallets/wallets/create/create-a-wallet">
        Create a wallet.
      </Card>
    </CardGroup>

    <Info>In addition to the owner, you can also set [additional signers](/wallets/using-wallets/session-signers/overview) on the wallet that can take actions with the wallet subject to their own policies. This allows multiple parties to authorize requests to the Privy API, with different policies and permissions over the wallet.</Info>
  </Step>

  <Step title="Generate authorization signatures for a request">
    When taking action with the wallet, the wallet's owner must sign requests to the Privy API.

    For your key quorum to authorize this request, m-of-n of the authorization private keys in the quorum must sign the request. These signatures must then be included in the `privy-authorization-signature` header when making a request to take action with a wallet.

    Follow the guide below to learn how to sign requests to the Privy API.

    <Tip>Privy strongly recommends using Privy’s [server-side SDKs](/controls/authorization-keys/using-owners/sign/signing-on-the-server) to generate and include authorization signatures in your requests automatically.</Tip>

    <CardGroup cols={1}>
      <Card title="Authorization signature quickstart" href="/controls/authorization-keys/using-owners/sign/overview">
        Sign requests to the Privy API.
      </Card>
    </CardGroup>
  </Step>

  <Step title="Send a transaction">
    You can now send transactions, sign transactions, or sign messages with Privy's API. Follow the guide below to send a transaction.

    <CardGroup cols={3}>
      <Card title="Send an EVM transaction" href="/wallets/using-wallets/ethereum/sign-a-transaction">
        Learn how to send an EVM transaction.
      </Card>

      <Card title="Send a Solana transaction" href="/wallets/using-wallets/solana/send-a-transaction">
        Learn how to send a Solana transaction.
      </Card>

      <Card title="Send transactions on Tier 2 chains" href="/wallets/using-wallets/other-chains">
        Learn how to send transactions on Tier 2 chains.
      </Card>
    </CardGroup>
  </Step>
</Steps>

### Learn more

Visit the following pages to continue integrating Privy's full feature suite with your wallet.

<CardGroup cols={3}>
  <Card title="Transaction status and webhooks" href="/wallets/gas-and-asset-management/assets/fetch-a-transaction">
    Learn how to check the status of a transaction.
  </Card>

  <Card title="Deposit and withdrawal webhooks" href="/wallets/gas-and-asset-management/assets/balance-event-webhooks">
    Learn how to fetch balances.
  </Card>

  <Card title="Wallet funding" href="/recipes/bridge-onramp">
    Learn how to fund your wallet using Bridge.
  </Card>
</CardGroup>


# Enabling users or servers to execute transactions
Source: https://docs.privy.io/recipes/wallets/user-and-server-signers



A common setup for Privy apps is to configure wallets such that both users and apps themselves can execute transactions from user wallets. This serves a variety of use cases:

* Allowing apps to execute limit orders on behalf of a user, even when a user is offline
* Allowing apps to rebalance user portfolios based on market data, even when the user is offline
* Creating Telegram trading bots or other agents controlled by your app's server that can execute transactions on behalf of users

You can accomplish these use cases via [session signers](/wallets/using-wallets/session-signers/overview), which enable user to grant specific permissions to your app to transact on their behalf. Follow the guide below to learn how to integrate session signers for your use case.

<Tip>
  View an [implementation of session
  signers](https://github.com/privy-io/examples/blob/main/privy-next-starter/src/components/sections/session-signers.tsx)
  in Privy's NextJS starter repo to learn about how to use session signers end-to-end.
</Tip>

## 0. Prerequisites

Prior to following this guide, follow the quickstart for Privy's [React SDK](/basics/react/quickstart) or [React Native SDK](/basics/react-native/quickstart) to get your app instrumented with Privy's basic functionality.

<Tip>
  If you plan to use this setup as part of a Telegram trading bot, check out the guide to integrate
  [Telegram seamless login](/recipes/react/seamless-telegram) with the React SDK for a smoother user
  experience when signing into Telegram mini-apps.
</Tip>

## 1. Create an app authorization key

To allow your app to be send transactions from user wallets, you must first create an **app authorization key**. Your app's server will sign API requests with this key to authorize sending transactions from user wallets.

Create an authorization key locally on your machine like so:

```sh  theme={"system"}
openssl ecparam -name prime256v1 -genkey -noout -out private.pem && \
openssl ec -in private.pem -pubout -out public.pem
```

Retrieve the public key from the `public.pem` file and the private key from the `private.pem` file in your working directory.

**Make sure to save both files securely.** Privy does not store your private key and cannot help you recover it.

## 2. Register the app authorization key in a key quorum

Next, register the public key you created with Privy so that Privy can appropriately verify signed requests from your app.

To do so, visit the [**Authorization keys**](https://dashboard.privy.io/apps?authorization-keys) page of the Privy Dashboard and click the **New key** button in the top right. Then, click the **Register key quorum instead** option.

In the modal that pops up, enter the public key you generated in step 1 in the **Public keys** field. Set the **Authorization threshold** to 1, to allow that single key to sign on behalf of the key quorum, and set the **Quorum name** to a human readable name of your choice.

Save the `id` of the key quorum that is created. You will need this value later.

This creates a 1-of-1 [key quorum](/controls/quorum-approvals/overview) that can be granted permission to execute actions from a user's wallet.

<Tip>
  You can also register the public key with Privy programmatically via the [REST
  API](/api-reference/key-quorums/create).
</Tip>

## 3. Configure your Privy app to create embedded wallets on login

Next, configure your Privy app to automatically create embedded wallets when users login.

This ensures that all users have an embedded wallet, regardless of whether they login via a web app, a Telegram mini app, or a native mobile app.

<Tabs>
  <Tab title="React (web apps and Telegram mini apps)">
    In your `PrivyProvider` component, set the `config.embeddedWallets.ethereum.createOnLogin` property to `'all'` to automatically create embedded wallets for users, regardless of what login method they use.

    ```tsx  theme={"system"}
    <PrivyProvider
      appId="your-privy-app-id"
      config={{
        embeddedWallets: {
          ethereum: {
            createOnLogin: 'all'
          }
        }
      }}
    >
      {children}
    </PrivyProvider>
    ```
  </Tab>

  <Tab title="React Native (mobile apps)">
    In your `PrivyProvider` component, set the `config.embeddedWallets.ethereum.createOnLogin` property to `'all'` to automatically create embedded wallets for users, regardless of what login method they use.

    ```tsx  theme={"system"}
    <PrivyProvider
      appId="your-privy-app-id"
      clientId="your-app-client-id"
      config={{
        embedded: {
          ethereum: {
            createOnLogin: 'all'
          }
        }
      }}
    >
      {children}
    </PrivyProvider>
    ```
  </Tab>
</Tabs>

## 4. (Optional) Create a policy for your signer

If you'd like your signer to only have specific permissions on users' wallets, [create a policy](/controls/policies/overview) for your signer based on the transaction it needs to execute. For example, you might create a policy that [expires the signer's permissions after a certain date](/controls/policies/example-policies/timebound), or limits only allows transacting under a certain amount with a specific contract, in order to execute a limit order when a user is offline. You can also create multiple policies to allow your signer to execute a set of actions.

Once you've created your desired policy for the signer, make sure to save the policy ID. You will need this when adding your signer to users' wallets.

<Tip>
  See example policies for [Ethereum](/controls/policies/example-policies/ethereum) and
  [Solana](/controls/policies/example-policies/solana) that you can modify for your use case.
</Tip>

## 5. Add a session signer to the user's wallet

Once a user logs in, an embedded wallet will automatically be created for them.

Once a user has an embedded wallet, add the key quorum you created in step 3 as a [session signer](/wallets/using-wallets/session-signers/overview) to the user's wallet. This allows your app to sign transaction requests from the user's wallet via your app's authorization key.

<Tabs>
  <Tab title="React (web apps and Telegram mini apps)">
    Once a user logs in, you can use the [`addSessionSigners`](/wallets/using-wallets/session-signers/add-session-signers) method of `useSessionSigners` hook to add your app's authorization key as a session signer on the wallet.

    ```tsx  theme={"system"}
    import {useSessionSigners} from '@privy-io/react-auth';

    ...

    const {addSessionSigners} = useSessionSigners();
    // Call this method after a user logs in and has an embedded wallet
    await addSessionSigners({
        address: 'insert-user-embedded-wallet-address',
        signers: [{
            signerId: 'insert-key-quorum-id-from-step-2',
            // Replace the `policyIds` array with an array of valid policy IDs if you'd like the session signer to only be able to execute certain transaction requests allowed by a policy. If you'd like the session signer to have full permission, pass an empty array ([]).
            policyIds: ['insert-policy-id-1', 'insert-policy-id-2']
        }]
    })
    ```

    <AccordionGroup>
      <Accordion title="Add a session signer to a user's wallet immediately after they login.">
        If you'd like to immediately add your session signer to a user's wallet when they login, use the `onComplete` callback of the `useLogin` hook:

        ```tsx  theme={"system"}
        import {useLogin} from '@privy-io/react-auth';

        const {login} = useLogin({
          onComplete: () => {
            console.log(
              "Execute any logic you'd like to run after a user logs in, such as adding a session signer"
            );
          }
        });
        ```

        All together, you can add a session signer after a user logs in like so:

        ```tsx  theme={"system"}
        import {useLogin} from '@privy-io/react-auth';
        import {useSessionSigners} from '@privy-io/react-auth';

        ...

        const {addSessionSigners} = useSessionSigners();
        const {login} = useLogin({
            onComplete: (user, isNewUser) => {
                if (isNewUser) {
                  await addSessionSigners({
                    address: user.wallet.address,
                    signers: [{
                        signerId: 'insert-key-quorum-id-from-step-2',
                        // Replace the empty `policyIds` array with an array of valid policy IDs if you'd like the session signer to only be able to execute certain transaction requests allowed by a policy
                        policyIds: []
                    }]
                 });
                }
            }
        })

        // Call login somewhere in your app
        ```
      </Accordion>

      <Accordion title="Add a session signer for limit orders.">
        If your app offers limit orders to users, we recommend the following flow for using session signers to execute limit orders.

        <Steps>
          <Step title="Create your limit order policy">
            Create a policy that allows your session signer to execute the limit order from the user's wallet.
          </Step>

          <Step title="Add your session signer">
            Add your session signer to the user's wallet via the `addSessionSigner` method, using the policy from step 1.
          </Step>

          <Step title="Execute the limit order">
            When the conditions to execute the limit order are met, see step 6 of this guide to learn how to send transactions with your session signer.
          </Step>
        </Steps>
      </Accordion>
    </AccordionGroup>
  </Tab>

  <Tab title="React Native (mobile apps)">
    Once a user logs in, you can use the [`addSessionSigners`](/wallets/using-wallets/session-signers/add-session-signers#react-native) method of `useSessionSigners` hook to add your app's authorization key as a session signer on the wallet.

    ```tsx  theme={"system"}
    import {useSessionSigners} from '@privy-io/expo';

    ...

    const {addSessionSigners} = useSessionSigners();
    // Call this method after a user logs in and has an embedded wallet
    await addSessionSigners({
        address: 'insert-user-embedded-wallet-address',
        signers: [{
            signerId: 'insert-key-quorum-id-from-step-2',
            // Replace the empty `policyIds` array with an array of valid policy IDs if you'd like the session signer to only be able to execute certain transaction requests allowed by a policy
            policyIds: []
        }]
    })
    ```

    <Accordion title="Add a session signer for limit orders.">
      If your app offers limit orders to users, when a user places an order, we recommend:

      1. Create a policy that allows your session signer to execute the limit order from the user's wallet.
      2. Add your session signer to the user's wallet via the `addSessionSigner` method, using the policy from step 1.
      3. When the conditions to execute the limit order are met, execute the transaction with your session signer. See step 6 of this guide to learn how to use session signers to execute transactions via the NodeJS SDK or REST API.
    </Accordion>
  </Tab>
</Tabs>

## 6. Send transactions from the user's wallet

That's it! Now, both users and your app can send transactions from a user's wallet.

### User-initiated transactions

Users can send transactions from your app's frontend by taking actions in a web app (via Privy's React SDK), a mobile app (via Privy's React Native SDK), or a Telegram mini-app (via Privy's React SDK).

Follow the guides below to learn how to send [transactions](/wallets/using-wallets/ethereum/send-a-transaction) from these environments.

#### Ethereum

<CardGroup>
  <Card title="React" href="/wallets/using-wallets/ethereum/send-a-transaction">
    Send Ethereum transactions from a web app or a Telegram mini-app using Privy's React SDK.
  </Card>

  <Card title="React Native" href="/wallets/using-wallets/ethereum/send-a-transaction#react-native">
    Send Ethereum transactions from a mobile app or a Telegram mini-app using Privy's React Native
    SDK.
  </Card>
</CardGroup>

#### Solana

<CardGroup>
  <Card title="React" href="/wallets/using-wallets/solana/send-a-transaction">
    Send Solana transactions from a web app or a Telegram mini-app using Privy's React SDK.
  </Card>

  <Card title="React Native" href="/wallets/using-wallets/solana/send-a-transaction#react-native">
    Send Solana transactions from a mobile app or a Telegram mini-app using Privy's React Native
    SDK.
  </Card>
</CardGroup>

### App-initiated transactions

Your app can also now initiate transactions from users' wallets via Privy's NodeJS SDK or REST API. This allows your app to send transactions from users' wallets even when the user is offline, allowing for various use cases:

* Executing limit orders
* Rebalancing portfolios
* Having a Telegram trading bot execute transactions on behalf of users

Follow the guides below to send transactions from your app's server using your app's authorization key.

<Info>
  Using Privy's REST API directly is an advanced integration. If your app uses a JavaScript or
  TypeScript backend, we strongly recommend using Privy's [NodeJS
  SDK](/basics/nodeJS-server-auth/setup).
</Info>

<Tabs>
  <Tab title="NodeJS (server-auth)">
    To start, initialize your `PrivyClient` with the private key of the authorization key you created in step 1. Pass this value into the `walletApi.authorizationPrivateKey` field of the third positional parameter to the client's constructor.

    ```tsx  theme={"system"}
    const privy = new PrivyClient('insert-your-app-id', 'insert-your-app-secret', {
        walletApi: {
            authorizationPrivateKey: 'insert-the-private-key-from-step-1'
        }
    })
    ```

    Next, follow the guides to send transactions on [Ethereum](/wallets/using-wallets/ethereum/send-a-transaction#nodejs) and [Solana](/wallets/using-wallets/solana/send-a-transaction#nodejs) with the NodeJS SDK.
  </Tab>

  <Tab title="REST API">
    Since your app is a session signer on the user's wallet, your app must sign transaction requests to Privy's API with the private key of the authorization key you generated in step 1. Your app must then include this signature in the `privy-authorization-signature` header of the request.

    Follow [this guide](/controls/authorization-keys/using-owners/sign) to learn how to sign requests to Privy's API with your app's authorization key.

    Once you've learned and implemented how to sign requests, you can now follow the guides to send transactions on [Ethereum](/wallets/using-wallets/ethereum/send-a-transaction#rest-api) and [Solana](/wallets/using-wallets/solana/send-a-transaction#rest-api) with the NodeJS SDK.
  </Tab>
</Tabs>

<Tip>
  **Building a Telegram trading bot?** Check out the [Telegram trading bot
  recipe](/recipes/telegram-bot) to learn how to have your app initiate transactions on behalf of
  users with a trading bot.
</Tip>


# x402
Source: https://docs.privy.io/recipes/x402



# Using x402 payments with Privy

Enable your users to pay for APIs and content using x402, the new HTTP payment protocol. Privy's `useX402Fetch` hook makes it seamless to integrate automatic stablecoin payments with embedded wallets.

## What is x402?

[x402](https://x402.org) is an open payment protocol that enables instant, automatic payments for APIs and digital content over HTTP. When a resource requires payment, the server responds with `402 Payment Required`. The client constructs an `X-PAYMENT` header with a signed payment authorization and retries the request.

## Installation

```bash  theme={"system"}
npm install @privy-io/react-auth
```

The `useX402Fetch` hook is built into `@privy-io/react-auth` (v3.7.0+).

## Usage

### Basic example

```typescript  theme={"system"}
import {useX402Fetch, useWallets} from '@privy-io/react-auth';

function MyComponent() {
  const {wallets} = useWallets();
  const {wrapFetchWithPayment} = useX402Fetch();

  async function fetchPremiumContent() {
    // Wrap fetch with your wallet
    const fetchWithPayment = wrapFetchWithPayment({
      walletAddress: wallets[0]?.address,
      fetch,
    });

    // Use exactly like native fetch - automatically handles 402 payments
    const response = await fetchWithPayment('https://api.example.com/premium');
    const data = await response.json();

    return data;
  }

  return <button onClick={fetchPremiumContent}>Fetch Premium Content</button>;
}
```

### Using default connected wallet

```typescript  theme={"system"}
import {useX402Fetch} from '@privy-io/react-auth';

function MyComponent() {
  const {wrapFetchWithPayment} = useX402Fetch();

  async function fetchPremiumContent() {
    // Omit walletAddress to use first connected wallet
    const fetchWithPayment = wrapFetchWithPayment({fetch});

    const response = await fetchWithPayment('https://api.example.com/premium');
    const data = await response.json();

    return data;
  }

  return <button onClick={fetchPremiumContent}>Fetch Premium Content</button>;
}
```

### With maximum payment protection

```typescript  theme={"system"}
const fetchWithPayment = wrapFetchWithPayment({
  walletAddress: wallets[0].address,
  fetch,
  maxValue: BigInt(1000000) // Max 1 USDC (6 decimals)
});
```

## How it works

1. **User requests content**: Client calls `fetchWithPayment()`
2. **Server responds 402**: Returns payment requirements (USDC amount, recipient address, time window)
3. **Build typed data**: Hook constructs EIP-712 typed data for USDC's `transferWithAuthorization`
4. **Sign with Privy**: User signs the authorization using their embedded wallet (no gas required)
5. **Build X-PAYMENT**: Hook creates a base64-encoded JSON payload with `authorization` + `signature`
6. **Retry with payment**: Request repeats with `X-PAYMENT` header
7. **Server verifies**: Resource server calls facilitator to verify the payment
8. **Facilitator settles**: Facilitator submits the authorization onchain and confirms the transaction
9. **Server delivers**: Returns content with `200 OK`

## Key details

**Requirements:**

* Users need USDC in their Privy embedded wallet on the correct network (e.g. Base, Base Sepolia, or Solana)
* Use Privy's `useFundWallet` hook to help users add funds if needed
* The facilitator pays gas fees (users only need USDC, not ETH or SOL)

**Testing:**

* For testnet: Get free USDC from [Circle's faucet](https://faucet.circle.com/)

## x402 facilitators

Facilitators are services that verify payment authorizations and submit transactions onchain on behalf of users. They handle gas fees and transaction settlement, allowing users to pay only with USDC without needing native tokens like ETH or SOL. Several x402 facilitators are available, including:

* Pay AI: [facilitator](https://facilitator.payai.network/), [docs](https://docs.payai.network/x402/reference)
* Corbits: [facilitator](https://facilitator.corbits.dev/), [docs](https://docs.corbits.dev/)

## Learn more

* [x402 docs](https://x402.gitbook.io/x402)
* [Privy sign typed data](https://docs.privy.io/wallets/using-wallets/ethereum/sign-typed-data)
* [EIP-3009 standard](https://eips.ethereum.org/EIPS/eip-3009)


# User authorization keys
Source: https://docs.privy.io/security/authentication/authenticated-signers



[Authorization keys](/security/wallet-infrastructure/policy-and-controls) are the core primitive for control of Privy's [Wallet API](/security/wallet-infrastructure/architecture). Authorization key signatures prove that requests are authorized directly by the permitted user.

**Self-custodial** wallets are those owned directly by a user. Privy enables users to fully control their wallets by issuing time-bound authorization keys to users who authenticate via a verified JWT. Once users retrieve a time-bound authorization key, they can make requests with the key. This configuration results in cryptographically-enforced user custody of wallets.

<Tip>All Privy client-side SDKs enable **fully user self-custodial wallets by default**.</Tip>

### Authentication methods

Privy integrates directly with any OIDC or JWT-based authentication system and also offers [dozens of login methods natively](/security/authentication/user-authentication), including email, SMS, social login, passkeys, and more. If a user is logged in, they always have access to their wallet.

### Multi-factor authentication

Privy also enables multi-factor authentication for access to user authorization keys. Supported additional factors include:

* Authenticator apps (TOTP)
* Biometric verification (passkeys)
* SMS confirmation
* Hardware security keys

This means your app can require additional user verification for sensitive wallet operations. [Learn more](/authentication/user-authentication/mfa#mfa)

## Direct access via API

<Info>
  Directly managing user authorization keys via the API is an advanced setting. We recommend using
  Privy’s SDKs, which internally manage user authorization keys.
</Info>

Privy enables users to retrieve a **time-bound authorization key directly via a REST API**. This API can be called from either your app's frontend or backend.

Privy infrastructure issues authorization keys from within trusted execution environments (TEEs)—see [TEE architecture](/security/wallet-infrastructure/architecture) for more information. Privy integrates with any asymmetric JWT-based authentication system, such as Privy's native authentication system, Auth0, Firebase, or any OIDC or OAuth authentication provider.

The architecture works as follows:

1. Your app makes a request to the Privy API using the authentication token from your JWT-based authentication system.
2. The TEE issues a time-bound user authorization key in response.
3. Use the authorization key to authorize requests to the Wallet API.

The following diagram illustrates an server-side integration. Note that Privy client-side SDKs fully manage direct client-side integrations.

<Frame>
  <img src="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/api-signer.png?fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=401aafbbeab800590d4e4585500384ac" alt="Server-side user authorization keys" data-og-width="4161" width="4161" data-og-height="2634" height="2634" data-path="images/security/api-signer.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/api-signer.png?w=280&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=50bd2cd4b1657ac8f57f0fcf9ed98beb 280w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/api-signer.png?w=560&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=ea06644f0795c54be5c4b6a580d5b5ad 560w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/api-signer.png?w=840&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=21cd0497a84262d94c8db66d7840e5ae 840w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/api-signer.png?w=1100&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=de6011141e74462f764130040476f987 1100w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/api-signer.png?w=1650&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=d71df3f552278cb34045af0639cbdc73 1650w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/api-signer.png?w=2500&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=a978b793e55c5e72e37cd88e2e8b664b 2500w" />
</Frame>

When you use a Privy SDK to provision and transact with user wallets, the SDK fully manages user authorization keys internally.

### Encryption

The returned time-bound authorization key is encrypted from the TEE to the client using HPKE (Hybrid Public Key Encryption), using the same method used by the [wallet export API](/api-reference/wallets/export).


# User authentication
Source: https://docs.privy.io/security/authentication/user-authentication



**Privy's embedded wallets are fully compatible with any authentication provider that supports JWT-based, stateless authentication.** If you're looking to add embedded wallets to your app, you can either:

* use Privy as your authentication provider (easy to set up out-of-the-box)
* use a custom authentication provider (easy to integrate alongside your existing stack)

## Integrating with any OIDC/JWT-based authentication system

Privy integrates with any authentication system that relies on asymmetric JWT tokens. This includes popular authentication providers such as Auth0, AWS Cognito, Firebase, as well as **all** OIDC (OAuth) social providers such as Google, Apple, and Twitter.

See the [JWT-based authentication guide](/authentication/user-authentication/jwt-based-auth/overview) for more information.

## Integrating with Privy's native authentication methods

Privy's authentication system provides secure user verification out of the box while maintaining a seamless experience. Privy supports multiple verification methods to accommodate different user needs and security requirements:

* Email and phone verification using one-time passwords (OTPs) [Learn more](/authentication/user-authentication/login-methods/email) {/* spellchecker:disable-line */}
* Social authentication through OAuth2.0 with providers like Google, Apple, Twitter, Discord, Github, TikTok, LinkedIn, Spotify, and Instagram [Learn more](/authentication/user-authentication/login-methods/oauth)
* Sign In With Ethereum (SIWE) and Sign in with Solana (SIWS) for web3-native users [Learn more](/authentication/user-authentication/login-methods/wallet)
* Custom authentication methods to match your specific needs

We do not support regular password-based verification given [users' tendencies to use and reuse easy-to-guess passwords](https://blog.lastpass.com/2021/09/breaking-the-cycle-of-password-reuse/), and the [high incidence of password database breaches](https://haveibeenpwned.com/).

## Token architecture

Upon successful authentication, Privy issues two types of tokens that work together to maintain secure user sessions.

**Access token**

The access token is a [JWT (JSON Web Token)](https://jwt.io/introduction) signed by an asymmetric Privy Ed25519 key specific to your app. This signature cryptographically ensures that only Privy could have produced the token - it cannot be spoofed or tampered with. The token has a **one-hour lifetime**, limiting the impact of potential token exposure and enabling quick session revocation if needed.

Your backend can use this token to [validate authenticated requests](/authentication/user-authentication/access-tokens) from users, and the Privy SDK uses it to determine authentication status in your frontend.

**Refresh token**

To provide longer sessions without compromising security, the refresh token has a **30-day lifetime** but can only be used once. When used to obtain a new access token, it's automatically rotated. This ensures refresh tokens can only renew existing sessions, never create new ones.

<Warning>
  If the Privy SDK detects any token tampering, it immediately invalidates the session and requires
  re-authentication. This destroys the corresponding session in Privy's backend.
</Warning>

## Session security

Our authentication system includes several security enhancements to protect user sessions. When using a verified domain, tokens can be stored in **HttpOnly cookies** for enhanced protection against XSS attacks. All tokens are cryptographically signed and verified on both client and server.

The Privy SDK manages this complexity for you, handling token rotation, renewal, and invalidation automatically. Your backend can easily [validate authenticated requests](/authentication/user-authentication/access-tokens) using the provided access tokens.

<Tip>
  Learn more about configuring secure authentication for your application in our [security
  checklist](/security/implementation-guide/security-checklist).
</Tip>


# Guidance for Content Security Policies (CSPs)
Source: https://docs.privy.io/security/implementation-guide/content-security-policy



<Info>New to CSPs? [Skip to CSP Basics](#csp-basics) for an introduction.</Info>

If you are using Privy in a web client environment, we recommend setting a strict [Content Security Policy (CSP)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP) as a defense-in-depth strategy to mitigate XSS, clickjacking, and cross-site leak vulnerabilities.

## Quick start

<Tip>
  Remember to add your own domain to the relevant directives (e.g., add your domain to
  `connect-src`, `script-src`, etc.)
</Tip>

### Base CSP configuration

<Tabs>
  <Tab title="Raw CSP">
    ```
    Content-Security-Policy:
      default-src 'self';
      script-src 'self' https://challenges.cloudflare.com;
      style-src 'self' 'unsafe-inline';
      img-src 'self' data: blob:;
      font-src 'self';
      object-src 'none';
      base-uri 'self';
      form-action 'self';
      frame-ancestors 'none';
      child-src https://auth.privy.io https://verify.walletconnect.com https://verify.walletconnect.org;
      frame-src https://auth.privy.io https://verify.walletconnect.com https://verify.walletconnect.org https://challenges.cloudflare.com;
      connect-src 'self' https://auth.privy.io wss://relay.walletconnect.com wss://relay.walletconnect.org wss://www.walletlink.org https://*.rpc.privy.systems https://explorer-api.walletconnect.com;
      worker-src 'self';
      manifest-src 'self'
    ```
  </Tab>

  <Tab title="Next.js">
    ```js  theme={"system"}
    const nextConfig = {
      async headers() {
        return [
          {
            source: "/:path*",
            headers: [
              {
                key: "Content-Security-Policy",
                value: `
                  default-src 'self';
                  script-src 'self' https://challenges.cloudflare.com;
                  style-src 'self' 'unsafe-inline';
                  img-src 'self' data: blob:;
                  font-src 'self';
                  object-src 'none';
                  base-uri 'self';
                  form-action 'self';
                  frame-ancestors 'none';
                  child-src https://auth.privy.io https://verify.walletconnect.com https://verify.walletconnect.org;
                  frame-src https://auth.privy.io https://verify.walletconnect.com https://verify.walletconnect.org https://challenges.cloudflare.com;
                  connect-src 'self' https://auth.privy.io wss://relay.walletconnect.com wss://relay.walletconnect.org wss://www.walletlink.org https://*.rpc.privy.systems https://explorer-api.walletconnect.com;
                  worker-src 'self';
                  manifest-src 'self'
                `,
              },
            ],
          },
        ];
      },
    };
    ```
  </Tab>

  <Tab title="Express">
    ```js  theme={"system"}
    const helmet = require("helmet");

    app.use(
      helmet.contentSecurityPolicy({
        directives: {
          defaultSrc: ["'self'"],
          scriptSrc: ["'self'", "https://challenges.cloudflare.com"],
          styleSrc: ["'self'", "'unsafe-inline'"],
          imgSrc: ["'self'", "data:", "blob:"],
          fontSrc: ["'self'"],
          objectSrc: ["'none'"],
          baseUri: ["'self'"],
          formAction: ["'self'"],
          frameAncestors: ["'none'"],
          childSrc: [
            "https://auth.privy.io",
            "https://verify.walletconnect.com",
            "https://verify.walletconnect.org",
          ],
          frameSrc: [
            "https://auth.privy.io",
            "https://verify.walletconnect.com",
            "https://verify.walletconnect.org",
            "https://challenges.cloudflare.com",
          ],
          connectSrc: [
            "'self'",
            "https://auth.privy.io",
            "wss://relay.walletconnect.com",
            "wss://relay.walletconnect.org",
            "wss://www.walletlink.org",
            "https://*.rpc.privy.systems",
            "https://explorer-api.walletconnect.com",
          ],
          workerSrc: ["'self'"],
          manifestSrc: ["'self'"],
        },
      })
    );
    ```
  </Tab>

  <Tab title="Ruby on Rails">
    ```ruby  theme={"system"}
    Rails.application.config.content_security_policy do |policy|
      policy.default_src :self
      policy.script_src :self, "https://challenges.cloudflare.com"
      policy.style_src :self, :unsafe_inline
      policy.img_src :self, :data, :blob
      policy.font_src :self
      policy.object_src :none
      policy.base_uri :self
      policy.form_action :self
      policy.frame_ancestors :none
      policy.child_src "https://auth.privy.io",
                      "https://verify.walletconnect.com",
                      "https://verify.walletconnect.org"
      policy.frame_src "https://auth.privy.io",
                      "https://verify.walletconnect.com",
                      "https://verify.walletconnect.org",
                      "https://challenges.cloudflare.com"
      policy.connect_src :self,
                        "https://auth.privy.io",
                        "wss://relay.walletconnect.com",
                        "wss://relay.walletconnect.org",
                        "wss://www.walletlink.org",
                        "https://*.rpc.privy.systems",
                        "https://explorer-api.walletconnect.com"
      policy.worker_src :self
      policy.manifest_src :self
    end
    ```
  </Tab>
</Tabs>

## CSP recommendations

### CSP directives for @privy-io/react-auth

As part of enforcing a CSP, you will need to allow certain trusted resources that your site needs to load as part of normal operation:

<Info>
  If you have a base domain enabled, you must **also** add your domain-specific Privy instance, e.g.
  `https://privy.your-base-domain.com`.
</Info>

#### Required domains

* `child-src`
  * [https://auth.privy.io](https://auth.privy.io) (Privy iframe)
  * [https://verify.walletconnect.com](https://verify.walletconnect.com) (WalletConnect iframe)
  * [https://verify.walletconnect.org](https://verify.walletconnect.org) (WalletConnect fallback iframe)
* `frame-src`
  * [https://auth.privy.io](https://auth.privy.io) (Privy iframe)
  * [https://verify.walletconnect.com](https://verify.walletconnect.com) (WalletConnect iframe)
  * [https://verify.walletconnect.org](https://verify.walletconnect.org) (WalletConnect fallback iframe)
  * [https://challenges.cloudflare.com](https://challenges.cloudflare.com) (Cloudflare Turnstile CAPTCHA iframe)
* `connect-src`
  * [https://auth.privy.io](https://auth.privy.io) (Privy API)
  * wss\://relay.walletconnect.com (WalletConnect API)
  * wss\://relay.walletconnect.org (WalletConnect fallback API)
  * wss\://[www.walletlink.org](http://www.walletlink.org) (Coinbase Wallet API)
  * https\://\*.rpc.privy.systems (Privy RPC provider)
  * [https://explorer-api.walletconnect.com](https://explorer-api.walletconnect.com) (WalletConnect Explorer API)
* `script-src`
  * [https://challenges.cloudflare.com](https://challenges.cloudflare.com) (Cloudflare Turnstile CAPTCHA scripts)

#### Optional features

If your app uses Telegram login or linking, add:

* `frame-src`: [https://oauth.telegram.org](https://oauth.telegram.org) (Telegram OAuth domain)
* `script-src`: [https://telegram.org](https://telegram.org) (Telegram login domain)

If your app uses Privy's [funding kit](/wallets/funding/overview), add:

* `connect-src`:
  * [https://api.relay.link](https://api.relay.link) (Relay Bridging Provider)
  * [https://api.testnets.relay.link](https://api.testnets.relay.link) (Relay Bridging Provider for testnets)

If your app is on Solana, please add the [Solana cluster endpoints](https://solana.com/docs/core/clusters#on-a-high-level) if an override is not provided:

* `connect-src`:
  * [https://api.mainnet-beta.solana.com](https://api.mainnet-beta.solana.com)
  * [https://api.devnet.solana.com](https://api.devnet.solana.com)
  * [https://api.testnet.solana.com](https://api.testnet.solana.com)

## Best practices

1. **Start strict**: Begin with restrictive policies, and loosen only as needed. Document all exceptions.
2. **Test regularly**: Test your CSP after dependency updates and validate during deployments. Check compatibility across different browsers.
3. **Monitor**: Track violation reports and monitor performance impact. Watch for bypass attempts.
4. **Document changes and procedures**: Record all CSP changes and document allowed sources. Document testing procedures for your app.

## Testing and deployment

<Tip>
  We highly recommend testing your CSP thoroughly before deploying and enforcing in production.
</Tip>

### Test your CSP in a staging environment

Run through your standard user flows in a **staging** environment with CSP enforcement. This may mean connecting to browser extension wallets / mobile app wallets, transacting, logging out, etc.

It is possible that directives need to be updated after Privy SDK upgrades. **Whenever upgrading the Privy SDK, always test your CSP again before deploying the update to production.**

Other software you use, such as [MetaMask](https://docs.metamask.io/wallet/how-to/get-started-building/secure-dapp/), may document their own guidance on CSP usage.

### Using Report-Only mode

Most browsers support a [`Content-Security-Policy-Report-Only`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy-Report-Only) header, which sends violation reports without actually enforcing policies. This allows the developer to judge whether a modification to their CSP will impact their site's expected functionality.

If your policy is strict, you will see many reported violations due to extensions trying to inject scripts into the browser. This is completely normal. It's best to filter these out to avoid the noise.

### Deployment

We recommend that you first deploy your CSP in ` report-only` mode with the header `Content-Security-Policy-Report-Only`. Once it has been validated in production, you can migrate to `Content-Security-Policy`, which will enforce directive violations.

Going forward, you can deploy with both `Content-Security-Policy-Report-Only` and `Content-Security-Policy` headers set simultaneously. This will allow you to test on the report only header and A/B test against your existing policy.

### Monitoring

We recommend that you configure the `report-uri` to see violation/enforcement reports and set up a monitoring dashboard so you can review reports.

## CSP basics

A Content Security Policy (CSP) is a set of rules that tell the browser **what sources of content are valid.** CSPs help prevent the browser from executing malicious scripts. They can be used to increase the security of any website.

To enable a CSP, you need to configure your web server or backend application to return the `Content-Security-Policy` HTTP header. In that header, you specify a policy. A policy is described using a set of policy directives, each of which tells the browser what to do with respect to a given resource type.

### Example: `img-src` directive

For example, the `img-src` directive tells the browser sources of images are valid.
If you set this CSP header:

```
Content-Security-Policy: img-src https://my-website.com/
```

Then any `<img>` from other sites will be blocked:

```
<img src="https://bad-website.com/image.jpg"/>   {/* Error! This won't load! */}
```

### Important directives

Policy directives tell the browser what to do for a given resource type.

* Keep `script-src` as locked down as possible to prevent malicious code execution
* Set `frame-ancestors` to `none` unless you expect your website to be embedded
* Keep `connect-src` as locked down as possible to prevent unauthorized data exfiltration
* Use `child-src` and `frame-src` to control iframe loading and execution
* Consider `worker-src` if using web workers
* Implement `default-src` as a fallback for unlisted directives

### Read the following guides to learn more:

* [https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP)
* [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy)
* [https://cheatsheetseries.owasp.org/cheatsheets/Content\_Security\_Policy\_Cheat\_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html)


# Security checklist
Source: https://docs.privy.io/security/implementation-guide/security-checklist



Privy is a powerful library that enables you to provision powerful non-custodial embedded wallets in order to create delightful user experiences. Privy protects your users' accounts and wallets via secure account verification, session management, and key sharding cryptography. See the [architecture security documentation](/security/wallet-infrastructure/architecture) for more information.

Before deploying Privy in production, there are several important security configurations to consider. Beyond this, security is a comprehensive topic that touches every part of your stack.

## Secure your client environment

Because your application client provides the context in which users access their accounts, it is an essential environment to keep secure. Follow client-side security best practices, including limiting what is able to inject Javascript into your site. **You should make sure only the code you intend runs in your app.**

### Web integrations

If you use Privy in your web application, including mobile web, we recommend configuring the following security settings.

#### Restrict allowed domains

Configure your allowed domains to prevent unauthorized access to your Privy integration.

* Add your production domain in the [Configuration > App settings page](https://dashboard.privy.io/apps?setting=domains\&page=settings) of the Privy Dashboard. [Learn more](/recipes/dashboard/allowed-domains)
* Remove any test or development domains

<Info>
  Using domains not configured in your allowed domains list will cause your integration to fail.
  This is an important security measure that protects your users.
</Info>

#### Configure HttpOnly cookies

To enable HttpOnly cookies for enhanced security, you can verify your domain ownership through a simple setup process in the Privy dashboard. [Learn more](/recipes/dashboard/allowed-domains)

#### Security headers

Configure proper security headers:

* Implement a strict [Content Security Policy](/security/implementation-guide/content-security-policy)
* Configure appropriate CORS settings
* Set secure cookie attributes when using HttpOnly cookies

### Mobile integrations

If you use Privy in your native mobile application, we recommend configuring the following security settings.

#### Restrict allowed native app IDs

Set your mobile project's bundle identifier as the required native app identifier.

## Set up authentication

If you have integrated user authentication with Privy wallet infrastructure, we recommend the following authentication settings. **Authentication security starts with choosing appropriate methods for your application.** Consider your users' needs and security requirements when configuring these settings. Read more about our [authentication architecture](/security/authentication/user-authentication).

### **Login methods**

For high-value applications, we recommend that you:

* Disable SMS-based authentication to prevent SIM-swapping attacks
* Enable strong [MFA](/authentication/user-authentication/mfa#mfa) options like authenticator apps or passkeys
* Configure appropriate session duration. The default is 30 days. You can do this using [app clients](/basics/get-started/dashboard/app-clients)

<Info>
  These security settings can be configured in your Privy dashboard. The defaults are chosen to
  balance security and user experience, but you may want to adjust them based on your specific
  needs.
</Info>

### **OAuth configuration**

If using social login, ensure proper configuration:

* Set up [allowed OAuth redirect URLs](/recipes/react/allowed-oauth-redirects)
* Review OAuth scopes and permissions
* Enable only necessary social providers
* Monitor OAuth token security

## Protect your wallets

Wallet security requires careful consideration of your specific use case and threat model. Learn more about our [wallet security architecture](/security/wallet-infrastructure/architecture).

### Embedded wallets

For wallets that users interact with directly through your application, we recommend enabling increasingly strict security settings as account value increases.

#### **High-value assets**

When protecting significant value, implement multiple security layers:

* Require [MFA](/authentication/user-authentication/mfa#mfa) for all sensitive operations
* Enable user-managed [recovery](/wallets/advanced-topics/new-devices/provision-new-devices) through password or cloud backup
* Set up emergency contacts and procedures

#### **Standard use cases**

For typical wallet usage:

* Enable users to optionally configure [MFA](/authentication/user-authentication/mfa#mfa)
* Configure automatic recovery with appropriate login methods
* Implement user education about security best practices

### Secure server-controlled wallets

#### Authorization keys

Set an owner on the wallet to add an additional layer of security for transaction signing. This means your transaction requests must be authorized with two factors: 1) your Privy app secret and 2) a signature from an [authorization key](/controls/authorization-keys/overview), which is a cryptographic key that only your service has access to.
Once this is set up, implement key management controls:

* Use a hardware-backed KMS (key management system) such as AWS KMS to secure authorization keys. Hardware-backed KMS systems disallow any export of keys.
* We recommend rotating authorization keys regularly, by updating the owner on wallets to a new key on a regular basis (every 90-180 days).
* You can further segregate wallets by setting different keys as the owner on different wallets. This means a given authorization key may only transact on one or a subset of wallets.
* You can require additional authorization for transactions, by requiring a quorum of authorization keys to approve a transaction. For example, you may set a 2-of-2 key quorum as the owner of a wallet: one key held in a KMS, and one key held by your service.
* We strongly recommend backing up authorization keys for redundancy. Privy does not have access to authorization keys and cannot recover your authorization key if you lose it.

#### Least privilege access

**Recommended Security Practice**: A powerful security control your application can implement is to separate the keys used for transaction signing from the keys used for [policy management](/controls/policies/overview). This ensures that even if your backend is compromised and transaction signing keys are exposed, the attacker cannot modify or remove the policies that constrain the wallet's behavior.

To implement this separation:

1. Create two different signing keys: one for **managing wallets and policies** and one for **transaction signing**
   * The management key should be used rarely and only be accessed in a very restricted environment
   * The transaction signing key will be used frequently and will accessed by your core application

2. When creating a wallet or policy, set the management key as the `owner`, which will make its signature required for any updates

3. On your wallet, set your transaction signing key and the policy it is subject to as an [`additional_signer`](/api-reference/wallets/create#body-additional-signers)

This creates a robust security boundary where:

* Transaction signing keys can only operate within policy constraints
* Policy management keys are rarely used and can be stored with higher security
* A compromise of transaction signing infrastructure cannot escalate to policy modification

<Info>
  The keys above can be quorums (e.g., 2-of-3 keys), providing additional security through
  multi-party authorization requirements.
</Info>

Learn more about implementing policies in our [policy overview documentation](/controls/policies/overview).

#### Other security recommendations

In addition to securing your server-controlled wallets with authorization keys, we also recommend the following:

* Set a [policy](https://docs.privy.io/controls/policies/overview) on the wallet to limit the types of transactions that may be processed.
* Monitor API usage and implement rate limiting
* Set up alerts for unusual activity
* Use separate development and production credentials
* Implement proper logging and audit trails


# Security
Source: https://docs.privy.io/security/overview



**The security of your users' data and digital assets is our top priority at Privy.** We secure over 50 million users' wallets and have facilitated billions of dollars in transaction value through our secure, flexible infrastructure.

<Tip>
  Privy wallets are non-custodial and have a fully programmable control model. Privy's flexible
  configuration enables the full custody spectrum from user-custodial wallets to powerful
  service-controlled accounts.
</Tip>

## Our security approach

At Privy, we've built our security foundation on unwavering principles. Our systems are non-custodial by design, ensuring that only authorized users can access their keys through sophisticated key splitting and secure execution environments. We implement defense in depth, with multiple independent security boundaries protecting your users' assets—from cryptographic guarantees to hardware-level isolation.

<Info>
  We believe security requires constant vigilance. We maintain continuous validation through regular
  third-party audits, an active bug bounty program, and 24/7 security monitoring to ensure our
  systems remain secure as threats evolve.
</Info>

## Core architecture

The strength of Privy's security comes from our battle-tested approach to protecting sensitive operations and data:

**Trusted execution environments (secure enclaves)**

Sensitive wallet operations take place within Trusted Execution Environments (TEEs), also known as secure enclaves. TEEs are highly restricted compute environments that offer deep system isolation guaranteed by the processor itself. In particular, Privy uses [AWS Nitro Enclaves](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html).

**Key sharding and cryptography**

We use robust, scalable cryptographic techniques to shard private keys across separate security boundaries, ensuring they are never stored in complete form and can only be accessed by authorized parties.

<Tip>
  Privy's cryptosystem design ensures sensitive operations remain protected even if the surrounding
  system is compromised.
</Tip>

## Security validation

We regularly validate our security through comprehensive assessments:

* Multiple independent security audits from firms including Cure53, Zellic, and Doyensec
* SOC2 Type I and Type II certified
* Active bug bounty program on HackerOne
* 24/7 incident response with rapid response SLAs

<Info>
  Our commitment to security extends to transparency—our cryptographic implementations are
  open-source and have undergone dedicated third-party audits, available on our [GitHub
  repository](https://github.com/privy-io/shamir-secret-sharing).
</Info>

## Getting started

Our documentation will guide you through implementing Privy securely in your application. We recommend starting with our [security checklist](/security/implementation-guide/security-checklist) for a complete overview of security best practices, or diving into our [architecture details](/security/wallet-infrastructure/architecture) to learn more about our security model.

<Tip>
  Security researchers can learn more about our vulnerability disclosure program at
  [privy.io/vulnerability-disclosure](https://www.privy.io/vulnerability-disclosure) or reach out to
  [security@privy.io](mailto:security@privy.io).
</Tip>


# Threat models & security FAQ
Source: https://docs.privy.io/security/security-faqs



Threat models are an essential part of building secure systems. Establishing a threat model means understanding the robustness of a system against a given attacker and context. At Privy, we work to communicate these threat models clearly so developers and users can protect themselves and their assets effectively. We break down some threat models below. Please reach out to us at [security@privy.io](mailto:security@privy.io) if you have any questions.

As a reminder, Privy works to secure user assets and data in three main ways:

* **Proactive security**: Privy systems are engineered and built with security in mind. This means resource isolation and [cryptographic architecture](/security/overview) layered with a defense-in-depth approach, designed to protect your wallets. This also means doing cryptographic and infrastructure audits on a quarterly basis, as well as running a Vulnerability Disclosure Program and active Bug Bounty Program.
* **Active monitoring**: Privy systems are instrumented for active monitoring. This means automated alerts triggered by unexpected or abnormal activity and an on-call engineering team on standby 24/7. As our customers deploy apps, we work to monitor activity across the threat landscape online and collaborate with service providers to take down malicious threats.
* **Defensive measures**: Privy is built with failsafes to enable developers and their users to cut off access to key material in the event of an emergency. We work on pre-approved procedures for such instances with our enterprise customers and are always at the ready to protect user assets in the case of attack.

If you're a researcher interested in participating in our Bug Bounty or you believe you've detected a malicious threat relevant to Privy's work, please reach out to [security@privy.io](mailto:security@privy.io).

## Security philosophy

Security is continuous work, not a one-time achievement. We recognize that [wallets are not one size fits all](https://www.privy.io/blog/metrocards-and-bank-vaults), and we build highly configurable, flexible wallet infrastructure so you can configure the system appropriate for your use-case. Moreover, security needs evolve as asset value grows.

We give developers flexibility to build appropriate experiences while guiding them toward security best practices. We support the full spectrum from email-based embedded wallets to hardware-secured cold storage, recognizing the [inherent tradeoffs](https://www.privy.io/blog/embedded-wallet-architecture-breakdown) in any cryptosystem.

## Understanding threat models

The below summarizes some key questions but is not exhaustive. Please reach out for a deeper discussion on threat modeling or other attack strategies.

### Cross-application security

#### Q: Can unauthorized applications access the Privy iframe?

No. The iframe enforces that all frame ancestors must be an [allowed origin](/recipes/dashboard/allowed-domains) set by an application admin within the Privy dashboard. This is enforced by both frame ancestor CSP checks and in-code origin validation.

#### Q: Can unauthorized applications send messages to the Privy iframe?

No. The Privy iframe only accepts messages from its parent frame. The iframe message handler checks the origin of messages received and confirms they are from an approved parent origin. Additionally, the Privy iframe requires a valid access token to authenticate messages received from its parent frame.

#### Q: Can a Privy customer's application interfere with another customer's iframe?

No. Browser controls and authentication controls enforce isolation between applications. Iframe contexts run in separate processes and does not share memory.

### User security

#### Q: Can an unauthorized user access another user's wallet?

No. A valid access token is required to access a wallet. Specifically, the user's access token is required to retrieve the auth share needed to reconstruct the wallet. Access tokens are only granted to authenticated users and are stored as either localStorage or [HttpOnly cookies](/recipes/dashboard/allowed-domains#httponly-cookies) depending on configuration.

#### Q: How are users protected if their browser is compromised?

We implement multiple protections:

* Keys never are persisted in complete form
* MFA can be required for wallet operations
* Transaction approval requires the auth share which is not stored on device
* Emergency controls can immediately disable key reconstruction
* Recovery shares can be secured by user-managed methods

### Browser security

#### Q: Can bookmarklets and browser extensions inject malicious Javascript into the iframe?

In certain cases, yes. There is a CSP nonce on the embedded wallet iframe and the embedded wallet key export page. This means browsers are able to verify the iframe code via a server-set nonce, and additionally reject unauthorized code. We block extensions with CSPs that violate the unsafe eval directive.

However, it's important to understand that bookmarklets and extensions have elevated permissions and may have access to things such as browser requests and responses. According to the W3C CSP standard, browser implementations should allow user-agent features to override policies. Browsers enable bookmarklets and extensions to bypass CSP settings and inject Javascript code onto pages. We recommend educating users to not install untrusted bookmarkets and browser extensions. Furthermore, we recommend enabling wallet MFA which requires the user to MFA to approve transactions.

#### Q: What happens if browser security is compromised?

We maintain multiple layers of protection:

* Emergency kill switches for immediate response
* Access token revocation capabilities
* Geographic access restrictions
* Rapid incident response procedures
* Regular security updates

### Infrastructure security

#### Q: Can a compromised Privy team member access user keys?

No. Keys exist only as encrypted shares distributed across security boundaries. Wallet actions are only accessible within secure execution environments.

#### Q: Can a compromised engineer deploy unauthorized code?

No. Privy maintains a robust deployment security system with multiple independent controls. Code deployed to secure execution environments undergo extensive review and security controls, including strict multi-party approvals.

All code changes require review from multiple designated owners, must pass automated security testing, and go through staged deployments with additional approvals. The Privy CI/CD pipeline ensures build artifacts are deployed directly from protected source code, with branch protection rules and signing requirements. This process is regularly audited and monitored to prevent unauthorized modifications.

<Tip>
  For security questions not covered here or to report a security concern, contact us at
  [security@privy.io](mailto:security@privy.io). If you're a security researcher interested in our
  Bug Bounty Program, please reach out to the same address.
</Tip>


# On device execution environment
Source: https://docs.privy.io/security/wallet-infrastructure/advanced/user-device



Privy's security architecture leverages secure execution environments to protect your users' assets. Wallet private keys are only temporarily reconstructed within these strictly isolated, secure execution environments when needed for specific operations, under the wallet owner's control.

Privy provides two types of secure execution environments: 1) via TEEs and 2) on the user's device. Each environment ensures that private keys are never stored in complete form and are only temporarily reconstructed when needed.

<Tip>
  By default, Privy uses [trusted execution environments
  (TEEs)](/security/wallet-infrastructure/architecture), also known as secure enclaves, for secure
  wallet operations. As an advanced setting, Privy also enables wallets to be reassembled **directly
  on user devices**.
</Tip>

On-device execution is an advanced configuration. Please [reach out](https://privy.io/slack) to enable this setting.

* On-device execution enables the fastest-possible signing speed (5 ms), but involves a more limited feature set.
* If you have on-device execution enabled, you will see "On-device" as the Wallet environment in your app's Wallet > Advanced settings page. Otherwise, your app uses TEE execution.
* You can [migrate from on-device to TEE execution](/recipes/tee-wallet-migration-guide). Apps may only operate in one environment.

## Browser-isolated execution environments on user devices

With on-device execution, Privy secures wallets directly on user devices using browser-enforced isolation via iframes. This relies on the same browser security boundaries that have been battle-tested for decades, securing billions of dollars in daily financial transactions across the modern internet.

The Privy iframe runs in a separate process with its own isolated memory space, completely separated from your application. This isolation is enforced by:

* Hardware-level memory protection
* Browser process separation
* Strict origin and frame ancestor validation
* Content Security Policy controls that strictly lock down network access

<Info>
  Browser security boundaries have been battle-tested for decades, securing billions of dollars in
  daily financial transactions across the modern internet.
</Info>

## Key shares

Privy's security model is based on distributed key sharding. This means critical key entropy is split into encrypted shares, protected by separate security boundaries.

With on-device execution, there are three share types:

* **Device share**, which is persisted on the user's device. In a browser environment, this is stored in the browser's domain-partitioned local storage via the iframe.
* **Auth share**, which is encrypted and stored by Privy. This share is accessible only with valid user authentication.
* **Recovery share** is used to provision the wallet on new user devices. This share is encrypted and secured either through user-managed methods (password or cloud backup) or Privy's recovery key management system.

**Two shares** must be present to reconstruct the private key, which only happens temporarily within the iframe on the user's device.

Typical operation involves sets of **2-of-2 shares**, where a device-specific share and an auth share are provisioned for each device on which a wallet is used. Similarly, a recovery share and recovery-specific auth share are provisioned to enable recovery on new devices.

<Frame>
  <img src="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/on-device-shares.png?fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=889175c4a676e2af190b733ea6156fda" alt="Wallet key shares in on-device execution" data-og-width="3686" width="3686" data-og-height="2633" height="2633" data-path="images/security/on-device-shares.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/on-device-shares.png?w=280&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=907cd4306f6a4f93363f3e857cc8e982 280w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/on-device-shares.png?w=560&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=741ebf4f160d73a36c4c9b7f08c97deb 560w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/on-device-shares.png?w=840&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=9307f56f1ed1d721740f2c9f8a956e3e 840w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/on-device-shares.png?w=1100&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=3e7c2a2d154ea4434fe9a981516fc2c0 1100w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/on-device-shares.png?w=1650&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=b8c52ca738d4d185720a9f5877797854 1650w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/on-device-shares.png?w=2500&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=9012ceb1ad537822c91fead194cfe93d 2500w" />
</Frame>

### Securing the recovery share

Privy offers two approaches to securing the recovery share:

**Automatic recovery**

Privy's key management system secures the encrypted recovery share, allowing users to provision their wallet on new devices through normal authentication. Privy infrastructure ensures only the user can decrypt their recovery share on their device.

<Warning>
  When using automatic recovery, you are trusting Privy's infrastructure to secure the user's
  recovery share, and the user's authentication token as the sole root of trust for their wallet.
</Warning>

**User-managed recovery**

With user-managed recovery, the recovery share is encrypted via a recovery factor managed by the user. This takes two forms:

* **Passwords**: users can set a strong memorable password to secure the recovery share for their wallet. Privy has no knowledge of the user's password and cannot decrypt the recovery share.
* **Cloud-backup**: the recovery share is secured by a recovery decryption key that is backed up to the user's cloud storage account (e.g. Google Drive or iCloud). Privy cannot access this backup and cannot decrypt the recovery share.

## Key management operations

### Creating a wallet

When a user creates a wallet, the secure execution environment generates strong entropy (128 bits) from a cryptographically secure random number generator (CSPRNG). This is converted to a mnemonic using BIP-39, from which Privy derives the wallet's public key and private key. All Privy wallets are [hierarchical deterministic (HD) wallets](https://help.myetherwallet.com/en/articles/5867305-hd-wallets-and-derivation-paths).

Immediately after creation, the wallet entropy is sharded into key shares, and the key shares are encrypted and distributed across separate security boundaries. This ensures that wallets can never be accessed outside of the secure execution environment.

### Signing a transaction

Two shares must be present to reconstruct the private key. During regular operation, Privy reassembles the wallet using a **device share** and **auth share**. A device-specific share and an auth share are provisioned for each device on which a wallet is used.

In other words, when signing a transaction:

1. Your application passes the transaction data through the Privy SDK
2. The secure iframe validates authentication and retrieves necessary encrypted shares
3. Key reconstruction occurs only in the iframe's isolated memory
4. The key is used temporarily in-memory for cryptographic signing
5. Only the signature is returned to your application

Because Privy wallets are provisioned directly on user devices, cryptographic signing is extremely fast (5 ms).

<Frame>
  <img src="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/on-device-signing.png?fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=aedbe71a00750ec3c627149f2f98a1f9" alt="Signing a transaction" data-og-width="3686" width="3686" data-og-height="2633" height="2633" data-path="images/security/on-device-signing.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/on-device-signing.png?w=280&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=b7a67074a7fb7b10f756d84d64ea4b8e 280w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/on-device-signing.png?w=560&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=7d314f652efcbf7dc2069b8045f983a4 560w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/on-device-signing.png?w=840&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=a812fbcb07604833cd730d08e543f628 840w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/on-device-signing.png?w=1100&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=5a459b16abaa861cfe8fb7ef85cfd040 1100w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/on-device-signing.png?w=1650&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=3620e62f21d048196cd4c3357acbbe8f 1650w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/on-device-signing.png?w=2500&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=b942601020f3bdc82fd6fd457380041c 2500w" />
</Frame>

### Provision new devices

Users provision their wallet on a new device using the **recovery share** and **auth share**. This set of recovery shares is created on initialization of a new wallet.

When a user accesses your app on a new device, the iframe will retrieve the **auth share** for your user during the login process. Then, depending on how you've configured recovery, the iframe will decrypt the **recovery share** for your user by:

* requesting the recovery decryption key using the user's auth token, if using **automatic** recovery
* having the user decrypt the key using their recovery factor (password or cloud account), if using **user-managed** recovery

With the **auth share** and the **recovery share**, the iframe provisions a new **device share** for the new device. This device share allows your user to continue using the wallet on that device.

Learn how to provision new devices in our [docs](/wallets/advanced-topics/new-devices/overview).

<img src="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/recovery.png?fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=643b0669dfe159c6781a2cb80758dcfe" alt="Provision a new device" data-og-width="3686" width="3686" data-og-height="2633" height="2633" data-path="images/security/recovery.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/recovery.png?w=280&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=43398d9e2c157ceb58fa907bc4ab83d6 280w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/recovery.png?w=560&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=92f853e04663739cc0995b640035e8af 560w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/recovery.png?w=840&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=5bd254d997dd70564bc1ae968444b1ec 840w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/recovery.png?w=1100&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=090782e688da88cd2ba4fa790ecceed2 1100w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/recovery.png?w=1650&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=894ffc5f41ca19237dff34cf4f92f4c1 1650w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/recovery.png?w=2500&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=59d3e297a01b378e29dc81e5f7d9bbcb 2500w" />

## External key recovery

With Privy's architecture, a user is able to recover their private key even if they lose their device or if they lose access to your app.

* If the user loses access to their device and is unable to retrieve their **device share**, they can combine their **auth share** and decrypt their **recovery share** to reconstitute the full private key.
* If the user loses access to your app and is unable to retrieve their **auth share**, Privy enables an external recovery service so that **users are always able to export their wallet**.

In all of these cases, Privy rotates keys to ensure compromised devices or authentication methods cannot be combined to maliciously reconstitute the private key.


# Security architecture
Source: https://docs.privy.io/security/wallet-infrastructure/architecture



Privy's security architecture combines trusted execution environments (TEEs) with distributed key sharding to protect your users' assets. Simply put:

* Keys are only stored as **encrypted shares distributed across separate security boundaries.**
* Keys are only **temporarily reconstructed within trusted execution environments** when needed for specific operations, under the wallet owner's control.

## Concepts

### Trusted execution environments

Trusted execution environments (TEEs), also known as secure enclaves, are highly restricted, isolated compute environments that allow for secure code execution and cryptographic verification (attestation) of the code being executed. In particular, Privy uses [AWS Nitro Enclaves](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html).

Privy uses TEEs to support private key reconstruction for the following processor-level guarantees:

* Enclaves have no persistent storage, no interactive access, and no network connectivity, and so provide a secure, isolated compute environment for sensitive data. Private keys for wallets are only accessible within the enclave, and can only be used to produce signatures compliant with the policies attached to the wallet.
* Attestations are cryptographic verifications of the computation run on a TEE. They are signed hashes of code on an enclave that can be verified with the corresponding public key, and can be used to verify actions run within the TEE.

### Key shares

Privy's security model is based on distributed key sharding. This means critical key entropy is split into encrypted shares stored across separate security boundaries.

Key sharding enables future-proof flexibility, strict security isolation, and built-in redundancy. In particular, key sharding enables separate authentication and encryption of each distributed share, enforcing control by wallet owners.

Key sharding and assembly only ever occur within the trusted execution environment. Private keys are split into encrypted shares using a reliable, battle-tested, and fast cryptographic algorithm called [Shamir's secret sharing (SSS)](https://en.wikipedia.org/wiki/Shamir%27s_secret_sharing). No share in isolation provides any information or access to the wallet.

<Info>
  Privy's [`shamir-secret-sharing`](https://github.com/privy-io/shamir-secret-sharing) cryptography
  library is open-source, heavily audited, and used to secure millions of wallets. It is the most
  widely used open-source Typescript library for Shamir's secret sharing.
</Info>

When a wallet is created, it is split into two shares, protected by different security boundaries:

1. **Enclave share**, also referred to as the TEE share, which is secured directly by the trusted execution environment and encrypted with the TEE's cryptographic key. The enclave share can only be decrypted within the TEE.
2. **Auth share**, which is encrypted and stored by Privy. This share is accessible only with valid authentication credentials, e.g. a bearer token or secret, and is sent to the enclave whenever an action is requested from the wallet.

<Frame>
  <img src="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/tee-shares.png?fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=43055667284e4eec7a3bd04d45507280" alt="Trusted execution environment key shares" data-og-width="3686" width="3686" data-og-height="2633" height="2633" data-path="images/security/tee-shares.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/tee-shares.png?w=280&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=34ca61525ed5eca0696df230e35606ac 280w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/tee-shares.png?w=560&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=ca9ee03018481aa379e4ce4861e570a7 560w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/tee-shares.png?w=840&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=7a769e4bd9ade9386c8c7728c01cf8ff 840w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/tee-shares.png?w=1100&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=0ffb6acf152cd9081e852ffb354c4ed7 1100w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/tee-shares.png?w=1650&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=abf25a90870d2357a884b3f50e5bb49c 1650w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/tee-shares.png?w=2500&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=79aa2d9671518e63c90e1cc141218d64 2500w" />
</Frame>

This is a **2-of-2** share set, which means that *both* shares are required in order to generate signatures. Neither the auth share nor the enclave share in isolation provide any information or access to the wallet.

<Tip>
  Only the TEE can decrypt the enclave share and combine it with the auth share to temporarily
  reconstitute the wallet and execute actions.
</Tip>

## Key management operations

### Wallet creation

When a wallet is created, the trusted execution environment generates strong entropy (128 bits) from a cryptographically secure random number generator (CSPRNG). This is converted to a mnemonic using BIP-39, from which Privy derives the wallet's public key and private key. All Privy wallets are [hierarchical deterministic (HD) wallets](https://help.myetherwallet.com/en/articles/5867305-hd-wallets-and-derivation-paths).

Immediately after creation, the wallet entropy is sharded into key shares, and the key shares are encrypted and distributed across separate security boundaries. This ensures that wallets can never be accessed outside of the TEE.

<Info>
  Private keys only exist in complete form temporarily within the trusted execution environment
  during signing operations. At all other times, they remain split into encrypted shares stored
  across separate security boundaries.
</Info>

### Wallet transaction

When a wallet transaction is requested, the wallet private key is reconstituted temporarily in-memory within the trusted execution environment. Two shares must be present to reconstruct the private key, the **enclave share** and **auth share**. The private key does not persist beyond usage for the wallet operation.

This process ensures:

* Keys exist only as encrypted shares stored across separate security boundaries
* Shares are only combined temporarily within the secure environment for specific operations
* Network access is strictly controlled
* Every operation requires proper authentication

In more detail, when signing a transaction:

1. Your app or service makes a `POST` request to the Privy API with the appropriate API credential (bearer token or app secret) and an authorization key signature.
2. The Privy API authenticates the API credential. If the request is valid, the request is forwarded to the TEE, along with the auth share.
3. The TEE verifies authorization and policies. The authorization signature from the request is verified against the authorization public key.
4. The TEE decrypts the encrypted device share and combines it with the auth share to reconstruct the wallet's private key.
5. The key is used temporarily in-memory for cryptographic signing.
6. The transaction signature is returned to the caller.

Privy also supports broadcasting the signed transaction to the blockchain, directly from the API.

<Frame>
  <img src="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/enclave-flow.png?fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=219506b83f251a70b0e8a0e5dd1d5409" alt="Transaction flow" data-og-width="3686" width="3686" data-og-height="2633" height="2633" data-path="images/security/enclave-flow.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/enclave-flow.png?w=280&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=1b5dc0c16263cf1fba2b11f823ac7e0b 280w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/enclave-flow.png?w=560&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=7ed2189f3c6cfd4f0a1b690955564fbc 560w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/enclave-flow.png?w=840&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=e3bbdd42399349c3374117589b39ac8a 840w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/enclave-flow.png?w=1100&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=86ee1aa2d9a19144b595823e4f552dca 1100w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/enclave-flow.png?w=1650&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=bd32b6adf5f3d406c49cc8b9b6cfd9ae 1650w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/security/enclave-flow.png?w=2500&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=a1c6b2afb3147bebb01cc739b8f9f620 2500w" />
</Frame>

## Protecting code deployments to the trusted execution environment

Privy enforces strict controls of the code deployments within the trusted execution environment. Code deployed to the TEE undergoes extensive review and security controls, including strict multi-party approvals and hardware security key requirements.

All code changes require review from multiple designated owners, must pass automated security testing, and go through staged deployments with additional approvals. The Privy CI/CD pipeline ensures build artifacts are deployed directly from protected source code, with branch protection rules, security scanning, and signing requirements. This process is regularly audited and monitored to prevent unauthorized modifications.


# Wallet policies and controls
Source: https://docs.privy.io/security/wallet-infrastructure/policy-and-controls



Privy's wallet API is secured with tamper-proof cryptographic authorization and a powerful, intuitive policy engine. This means that the trusted execution environment (secure enclave) will only act on requests issued by authorized parties, and only specific permitted actions may be processed.

<Tip>
  Privy wallets are non-custodial and have a fully programmable control model. Privy's flexible
  configuration enables the full custody spectrum from user-custodial wallets to powerful
  service-controlled accounts.
</Tip>

## Authentication and authorization

### Authorization keys

Requests to Privy [wallet API](/security/wallet-infrastructure/architecture) endpoints are protected by **authorization keys**. This requires the secure enclave to verify a signature from the required authorization key before executing any requests. [Learn more](/controls/authorization-keys/overview)

Privy uses [P-256](https://neuromancer.sk/std/nist/P-256) (also known as secp256r1) asymmetric keys for authorization keys. When you register a key:

* The private key is generated on your device, and is only ever known to your app. **Neither Privy nor the enclave ever sees the P-256 private key, and cannot sign payloads with it.**
* The public key is registered with the enclave, and is used to verify signatures produced by your servers.

The authorization signature is a signature generated over the body and all critical parameters of each request. This authorization signature guarantees the enclave only processes verified requests. The enclave verifies the signature against the corresponding authorization public key registered for the wallet before executing any wallet actions.

### Powerful, flexible controls

Authorization keys enable a fully configurable control model for wallets. This includes the full spectrum from user-custodial wallets to powerful service-controlled accounts.

When you create a wallet, you specify its **owner**, which is the key (or key quorum) that controls the wallet. By default, this key is also required to authorize wallet actions, such as generating signatures or transacting funds.

This wallet ownership model is extremely flexible. It enables you to configure, e.g:

* **Fully user self-custodial wallets**, using an [authorization key tied to the user's authentication method](/security/authentication/authenticated-signers) as the authorization key
* **Fully user self-custodial wallets**, using the user's passkey as the authorization key
* **Service-controlled wallets**, using an authorization key that is held by your service
* **Multi-sig wallets**, using a quorum of authorization keys held by different parties

### Key quorums

Privy enables your app to require quorum approvals on wallet actions, so that signatures from m-of-n authorization keys are required in order to take action using the wallet. Key quorums are defined by a list of authorization public keys and a threshold required for approval. [Learn more](/controls/quorum-approvals/overview)

### Multi-factor authentication

Privy enables native multi-factor authentication for wallet actions. This means your app can require additional verification for sensitive wallet operations using:

* Authenticator apps (TOTP)
* Biometric verification (passkeys)
* SMS confirmation
* Hardware security keys

Multi-factor authentication is enforced via [authenticated signers](/security/authentication/authenticated-signers). Learn more about configuring multi-factor authentication for your app [here](/authentication/user-authentication/mfa).

## Policies

Privy's policy engine allow your application to **restrict the actions that can be taken with wallets**. This is important for features such as payment subscriptions, stop and limit orders, or scheduled transactions.

Policies allows you to configure transfer limits, allowlists and denylists of transfer recipients, allowlists and denylists of smart contracts and programs, and even constraints around calldata that can be passed to smart contracts.

By default, policies are enforced by the trusted execution environment as part of processing wallet actions, such as signature requests, transactions, and key export. Some policies are enforced at the API level. For example, limiting transfer sizes requires transaction simulation which runs outside the enclave today.

This ensures that wallets can only ever be used to take actions your application intends to take.

Learn more about configuring policies [here](/controls/policies/overview).

<img src="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/policy-splash.png?fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=989f6a61de268b5e232a8b8401d77737" alt="Managing policies in the Privy Dashboard" data-og-width="1192" width="1192" data-og-height="852" height="852" data-path="images/policy-splash.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/policy-splash.png?w=280&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=7bf0ceb9a0d4646bb7f0478f6788e68c 280w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/policy-splash.png?w=560&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=7de15091f47ede52324d91ffe9ae796e 560w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/policy-splash.png?w=840&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=771e517bf3b5814336a0b8917bdbe51d 840w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/policy-splash.png?w=1100&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=94d10f809f89f639e2258aec613aca7f 1100w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/policy-splash.png?w=1650&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=be5ff30c16cc8eed4860351d903e81d1 1650w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/policy-splash.png?w=2500&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=57d63fe2e9f470ca977ecb1a0634488b 2500w" />


# Chain support
Source: https://docs.privy.io/transaction-management/chain-support



Privy offers support for multiple blockchain ecosystems, organized into three distinct tiers that provide different levels of functionality. By default, Privy supports all blockchains based on Ed25519 and secp256k1 cryptographic curves, and more blockchains are added regularly.

## Supported chains

### Tier 3

<CardGroup cols={2}>
  <Card title="Ethereum" href="/wallets/using-wallets/ethereum/send-a-transaction">
    Includes all EVM-compatible networks
  </Card>

  <Card title="Solana" href="/wallets/using-wallets/solana/send-a-transaction">
    Includes all SVM-compatible networks
  </Card>
</CardGroup>

### Tier 2

<CardGroup cols={3}>
  <Card title="Bitcoin" href="/wallets/using-wallets/bitcoin/sign-transaction-inputs" />

  <Card title="Cosmos" href="/recipes/use-tier-2#cosmos" />

  <Card title="Stellar" href="/recipes/use-tier-2#stellar" />

  <Card title="Spark" href="/recipes/use-tier-2#spark" />

  <Card title="Sui" href="/recipes/use-tier-2#sui" />

  <Card title="Tron" href="/recipes/use-tier-2#tron" />

  <Card title="Near" href="/recipes/use-tier-2#near" />

  <Card title="Ton" href="/recipes/use-tier-2#ton" />

  <Card title="Starknet" href="/recipes/use-tier-2#starknet" />

  <Card title="Aptos" href="/recipes/use-tier-2#aptos" />

  <Card title="Movement" href="/recipes/use-tier-2#movement" />
</CardGroup>

### Tier 1

<CardGroup cols={2}>
  <Card title="Bitcoin L2s" />

  <Card title="All other Ed25519 and secp256k1 chains" />
</CardGroup>

## Support tier definitions

### Tier 3: Full functionality

Chains with Tier 3 support receive comprehensive capabilities, including:

* Complete client-level support end-to-end
* Full wallet functionality
* Transaction building and submission
* Native gas sponsorship
* Advanced features like webhooks and policies

### Tier 2: Wallet abstractions

Tier 2 support focuses on core wallet functionality:

* Curve-level cryptographic signatures that can be used for transaction signing
* Basic wallet functionality
* Integration with chain-specific libraries
* Chain address derivation
* 0-index HD wallet creation and key derivation
* Embedded wallets

### Tier 1: Cryptographic signing

Tier 1 provides fundamental cryptographic capabilities:

* Raw cryptographic signatures
* Basic key management

### Smart wallets, policies and more

Beyond this, Privy has advanced support for smart contract parsing as part of policies, native smart-contract wallet support and more.

Please reach out if you need this for the chain your product leverages.

<Info>
  Our roadmap prioritizes both expanding to new chains and enhancing support for existing chains by
  moving them to higher tiers.
</Info>

## Choosing the right integration

When building your application with Privy, consider the tier of support available for your target blockchain:

* **Tier 3 chains** offer the most seamless experience with full native functionality
* **Tier 2 chains** provide core transaction capabilities but may require chain-specific code
* **Tier 1 chains** support basic signing operations and require more custom implementation

For questions about specific chain support or to request prioritization of particular chains, please contact the Privy team.

<Warning>
  While all tiers allow for blockchain integration, lower tiers may require additional development
  effort to handle chain-specific operations.
</Warning>

<Tip>
  Learn more about configuring your application for different
  [EVM](/basics/react/advanced/configuring-evm-networks) and
  [Solana](/basics/react/advanced/configuring-evm-networks) networks
</Tip>


# Gas management
Source: https://docs.privy.io/transaction-management/gas-management



Privy's powerful **gas sponsorship** engine allows your app to manage gas and transaction fees across all of your wallets
without ever having to manage onchain funds and complex orchestrations.

Traditionally, wallets need a balance of the blockchain's native token to pay for transaction fees, also known as gas. For instance, a wallet on Ethereum or Solana traditionally must hold ETH or SOL even if their intent is to transact in USDC.

With Privy, you can configure gas fees to be automatically managed and payment included as part of your subscription plan.
This eliminates the need for your business to manage gas balances across all of your wallets, and substantially simplifies the
experience of executing transactions on the blockchain.

<Info>
  [Learn how to set up streamlined gas management across all of your
  wallets.](/wallets/gas-and-asset-management/gas/setup)
</Info>


# Permissions
Source: https://docs.privy.io/transaction-management/models/permissions



Privy wallets support **granular permissions** that allow you to:

* Enable custom ownership configurations, with single-party, multi-party, or quorum approvals
* Delegate permissions to third-parties or act on behalf of third-parties given their consent
* Enforce policies defining the actions a wallet can perform

and more. These capabilities are powered by Privy's abstraction of **owners** and **signers**.

## Owners

The [**owner**](/controls/authorization-keys/owners/overview) of a wallet has full control over the wallet, and has the ability to take actions with the wallet, enforce policies on the wallet, delegate permissions to third-parties (signers), and export the wallet's private key.

Owners can be set up as an authorization key (similar to an API secret) controlled by your server, a user ID in your authentication system, or a quorum of the two. Generally, your business should configure the owner of the wallet to be its primary controller.

## Signers

Owners of wallets can delegate certain transaction capabilities to third-parties known as [**signers**](/controls/authorization-keys/owners/overview), or **additional signers**.

Signers enable your business to set up wallets with custom configurations such as:

* **Scoping wallet policies to specific parties.** When setting signers on a wallet, you can set the specific policies that the signer should be subject to, allowing you to scope permissions to different signers.
* **Enabling third-parties to take action on behalf of your business or your business to take action on behalf of third-parties.** For instance, your business may need to execute recurring transactions on behalf of a customer on a recurring basis, and can be granted the capability of a **signer** while the wallet is owned by the third-party.

## Permissions

Owners and signers have different permissions over wallets, as outlined below.

|                                 | Owners | Signers |
| ------------------------------- | ------ | ------- |
| Sign messages                   | ✅      | ✅       |
| Send transactions               | ✅      | ✅       |
| Update policies                 | ✅      | ❌       |
| Update owners                   | ✅      | ❌       |
| Update signers                  | ✅      | ❌       |
| Export wallet                   | ✅      | ❌       |
| Can be configured with policies | ✅      | ✅       |

## Common setups

Learn more about common setups for structuring permissions.

<CardGroup cols={2}>
  <Card title="Owners & signers" icon="lock" href="/controls/authorization-keys/owners/overview">
    Learn more about the details of owners and signers and how to leverage them for your business.
  </Card>

  <Card title="Common setups" icon="layer-group" href="/transaction-management/setups/delegation">
    Create granular permission models for your wallets with owners and signers.
  </Card>
</CardGroup>


# Policies
Source: https://docs.privy.io/transaction-management/models/policies



Privy's **policy engine** allows your application to restrict the actions that can be taken with wallets.

Policies enable you to configure:

* Transfer limits
* Time-bound signers
* Allowlists and denylists of transfer recipients
* Allowlists and denylists of smart contracts and programs
* Allowlists and denylists of networks
* Allowed time window for key export
* Granular constraints around calldata and parameters that can be passed to smart contracts
* Restrictions around signatures needed for transactions, such as EVM typed data (EIP712)

This ensures that wallets can only ever be used to take actions your application intends to take.

<img src="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/policy-splash.png?fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=989f6a61de268b5e232a8b8401d77737" alt="Managing policies in the Privy Dashboard" data-og-width="1192" width="1192" data-og-height="852" height="852" data-path="images/policy-splash.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/policy-splash.png?w=280&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=7bf0ceb9a0d4646bb7f0478f6788e68c 280w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/policy-splash.png?w=560&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=7de15091f47ede52324d91ffe9ae796e 560w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/policy-splash.png?w=840&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=771e517bf3b5814336a0b8917bdbe51d 840w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/policy-splash.png?w=1100&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=94d10f809f89f639e2258aec613aca7f 1100w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/policy-splash.png?w=1650&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=be5ff30c16cc8eed4860351d903e81d1 1650w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/policy-splash.png?w=2500&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=57d63fe2e9f470ca977ecb1a0634488b 2500w" />

Learn more about policies and how to configure them for your wallets.

<CardGroup cols={2}>
  <Card title="Concepts" href="/controls/policies/overview#concepts" icon="file-contract">
    Learn about policies, rules, and conditions.
  </Card>

  <Card title="Usage" href="/controls/policies/create-a-policy" icon="shield-halved">
    Learn how to create policies and assign them to wallets.
  </Card>
</CardGroup>


# Transaction management
Source: https://docs.privy.io/transaction-management/overview



Privy provides your business with powerful **transaction management** capabilities, including:

* Treasury management for businesses holding digital assets
* TEE-secured cryptographic signing infrastructure
* Facilitating payments and subscriptions
* Moving and managing assets between fiat and crypto rails
* Receiving notifications on deposits and withdrawals on the blockchain and taking actions accordingly

and more. Learn more about Privy's transaction management capabilities below.

## Control model

Privy wallets come with a highly-configurable [**control model**](/transaction-management/models/permissions) that enables you to set up your wallets based on your business's regulatory needs and custody stance. You can configure wallets to be controlled by a single party, multiple parties, or a quorum (m-of-n) of multiple parties.

In addition, [owners](/controls/authorization-keys/owners/overview) of a wallet can delegate specific permissions to other parties to take actions on the wallet's behalf. This enables your product to automate preconfigured actions on behalf of a user (like limit orders, portfolio rebalancing, etc), delegation of assets to agents, and more. The scope of these permissioned actions can be restricted via policies.

## Policies

You can attach [policies](/transaction-management/models/policies) to wallets to enhance the security of your assets and restrict the scope of transactions that can be made with a wallet. For instance, your business might enforce a policy that a given wallet can only transact with a certain asset like USDC or that it can only send assets to a specific set of allowlisted addresses.

Privy's policy engine is highly expressive and enables your application to restrict transactions based on raw transaction parameters (recipient, chain, gas fees, etc.), smart contract parameters, calldata strings, and more.

## Chain support

Privy powers wallets on any blockchain using the Ed25519 or sec256k1 signature curves. This includes:

* all EVM chains, including Ethereum, Base, Arbitrum, HyperEVM, and custom rollups
* all SVM chains, including Solana and Eclipse
* Bitcoin L2s, including Spark and Lightning
* Stellar
* Tron
* Cosmos
* Bitcoin
* Spark
* Sui
* NEAR
* TON

Learn more about [chain support](/transaction-management/chain-support).

## Gas management

Privy's powerful **gas sponsorship** engine allows you to manage transaction fees across all of your wallets through a single payment flow. Privy facilitates gas payments across all of your wallets on your behalf, and streamlines payment into a single monthly bill for your business.

You can also use Privy's **policy engine** to restrict how different wallets can use your business's shared gas balance, ensuring that funds allocated for gas payments specifically are secured to only be used in specific interactions.

## Webhooks

Privy offers **webhooks for transaction statuses, deposits, and withdrawals** as well as **REST APIs for querying transaction status, balances, and more**. In addition, you can use **idempotency keys** to ensure that certain actions are idempotent to prevent against the double-spend of funds.

This streamlines the experience of keeping your business's financial ledgering in sync with the blockchain. Your business can focus on its core value proposition; Privy manages synchronizing with the blockchain, facilitating transactions, and indexing deposits and withdrawals for you.


# Delegating permissions
Source: https://docs.privy.io/transaction-management/setups/delegation



Privy wallets' powerful [**owners and signers**](/transaction-management/models/permissions) abstraction allow your application to configure granular permissions around the actions that various parties can take on wallets. Namely, **owners** have full control over wallets and can delegate permissions to **signers** to execute transactions from the wallet within the scope of a specific [**policy**](/transaction-management/models/policies).

<img src="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/owner-setups/delegating-permissions.png?fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=0988be2d2e851395f0acd27e6d4c2d7b" alt="delegate" data-og-width="5529" width="5529" data-og-height="3949" height="3949" data-path="images/owner-setups/delegating-permissions.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/owner-setups/delegating-permissions.png?w=280&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=449fbf348b133af7629d0efddf737cf9 280w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/owner-setups/delegating-permissions.png?w=560&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=ef493489d5c0893d3e0358b841861d00 560w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/owner-setups/delegating-permissions.png?w=840&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=d8ca3e6a65dad6783306addf88248b3e 840w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/owner-setups/delegating-permissions.png?w=1100&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=c80e3244ffdc98100421fe9bd338652b 1100w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/owner-setups/delegating-permissions.png?w=1650&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=736f309e98bb6cf697c357acef46674a 1650w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/owner-setups/delegating-permissions.png?w=2500&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=a1a472517a474e5409d00d88be294aca 2500w" />

A good rule of thumb is:

* If you need **third-parties to take actions on behalf of your business**, configure your business as the wallet's owner and each of the third-parties as a signer.
* If you need **your business to take actions on behalf of a third-party or a user**, configure the third-party as the wallet's owner and your business as a signer.

Owners and signers can be configured flexibly, including support for unilateral or quorum approvals.

Learn more about delegating permissions with signers below.

<Card title="Owners & signers" href="/controls/authorization-keys/owners/overview" icon="lock">
  Use owners and signers to enforce granular permissions and control models in your application.
</Card>


# Quorum approvals
Source: https://docs.privy.io/transaction-management/setups/quorum-approval



If your business needs multiple parties to be able to approve updates to or actions taken by wallets, the most common setup is to set up a [key quorum](/controls/key-quorum/overview) consisting of a set of multiple [authorization keys](/controls/authorization-keys/keys/create/key) or [users](/controls/authorization-keys/keys/create/user/overview) in your authentication system.

<img src="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/owner-setups/quorum.png?fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=a65b82a9df67965ebc6219a84979ad37" alt="quorum approval" data-og-width="5529" width="5529" data-og-height="3949" height="3949" data-path="images/owner-setups/quorum.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/owner-setups/quorum.png?w=280&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=29fb8d11469bdea77f6ab33a04e15401 280w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/owner-setups/quorum.png?w=560&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=e4f6faedb48d53702a49926f5d85afc1 560w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/owner-setups/quorum.png?w=840&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=1c9407844b34cfa16030f8ba94798764 840w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/owner-setups/quorum.png?w=1100&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=11e9302738bde727a4021422bc1e6ee9 1100w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/owner-setups/quorum.png?w=1650&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=82a4a1dfcf568aacef2b1cbfd927bab3 1650w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/owner-setups/quorum.png?w=2500&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=1f91df9fa159b0549c47985b18e29f93 2500w" />

You can define the quorum such that a certain number of members of the quorum must approve actions to wallets. This is known as the quorum's **authorization threshold**. Privy's TEE infrastructure enforces that at least that many members of the quorum must sign the request to take an action with a wallet. To allow multiple parties to unilaterally approve wallet actions, you can set this threshold to 1.

Quorum approvals allow your business to create setups where multiple parties must sign-off on actions taken by wallets, enhancing security and ensuring your wallet setup complies with your business's custody and regulatory stance.

Learn more about configuring quorum approvals below.

<Card title="Key quorums" href="/controls/key-quorum/overview" icon="diagram-project">
  Use key quorums to configure quorum approvals on wallet actions.
</Card>


# Single-party approvals
Source: https://docs.privy.io/transaction-management/setups/single-party-approval



If your business needs a single party to be able to unilaterally approve actions applied to or taken by wallets, the most common setup is to assign an [authorization key](/controls/authorization-keys/keys/create/key) or a [user](/controls/authorization-keys/keys/create/user/overview) in your authentication system as the [owner](/controls/authorization-keys/owners/overview) of the wallet.

<img src="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/owner-setups/single-party.png?fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=133864e53664a3e7bb126c69ee8dc72c" alt="single party approval" data-og-width="5529" width="5529" data-og-height="3949" height="3949" data-path="images/owner-setups/single-party.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/owner-setups/single-party.png?w=280&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=d0c835e04093cd7b3cbd928ca90b3ea2 280w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/owner-setups/single-party.png?w=560&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=407355bcc4e9af12d60b6f0d797a26a9 560w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/owner-setups/single-party.png?w=840&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=bf7fe7a0d10ed42d5486397670f9bada 840w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/owner-setups/single-party.png?w=1100&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=7a5194e50702f279aed07c453aaa3469 1100w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/owner-setups/single-party.png?w=1650&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=cdd47eaad3493c4bec84946052d76158 1650w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/owner-setups/single-party.png?w=2500&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=cabb5ab02cdb8f199846bc41c6cc8f38 2500w" />

Privy's TEE infrastructure enforces that all requests to update a wallet (e.g. assign policies or delegate permissions to signers) or take actions with the wallet (e.g. sign messages or send transactions) must be **signed** by the authorization key or a time-bound key associated with your user. If no valid signature is provided on requests, Privy will not execute the action.


# Webhooks
Source: https://docs.privy.io/transaction-management/webhooks



Privy offers powerful **webhooks** that allow your app to easily monitor and consume **transaction status updates**, **deposits**, and **withdrawals**. Privy handles the logic of keeping your service in sync with the blockchain, and your business can handle its core function.

## Blockchain monitoring

Webhooks provide your application with the following blockchain monitoring capabilities.

### Transaction status API

Fetch transaction details and status, like confirmations, failures, and delays, via API to keep your application in sync.

### Transaction status webhooks

Receive notifications when transactions are broadcasted, confirmed, failed, and more.

### Deposit webhooks

Get notified when your wallets receive registered assets on a variety of chains.

### Withdrawal webhooks

Get notified when your wallets spend registered assets on a variety of chains.

## Usage

Learn more about using webhooks below.

<CardGroup cols={3}>
  <Card icon="money-bill-transfer" href="/wallets/gas-and-asset-management/assets/balance-event-webhooks">
    Webhook notifications on deposits and withdrawals.
  </Card>

  <Card icon="network-wired" href="/wallets/gas-and-asset-management/assets/transaction-event-webhooks">
    Webhook notifications on transaction status updates.
  </Card>

  <Card icon="server" href="/wallets/gas-and-asset-management/assets/fetch-a-transaction">
    Fetch transaction status with the REST API.
  </Card>
</CardGroup>

## Webhook details

<Tip>
  Learn more about the registering and using webhooks
  [here](/wallets/gas-and-asset-management/assets/overview).
</Tip>

To use webhooks, simply register a webhook endpoint in the Privy Dashboard. Privy will fire webhooks on your selected events with a signed payload to your server, which you can verify and capture in your own state management.

### Retries

Webhooks are retried if your server returns something other than a 2xx response, at increasingly long intervals up to 5 days. Webhooks also include an idempotency key to help ensure that your server does not consume the same webhook twice.

### Static IPs

Webhoooks are delivered by a static set of IPs that your server can allowlist for incoming network requests.


# Create or import a batch of users
Source: https://docs.privy.io/user-management/migrating-users-to-privy/create-or-import-a-batch-of-users



To import existing users, Privy allows you to create users with their linked accounts (wallet, email, etc.) in batches via REST API to simplify the migration process. To create users, pass in an array of user objects which each represent a new user. You can also create wallets with wallet pregeneration.

Once a user has been created, all of their accounts (wallet, email, etc.) will be included in their user object when they log in. If the user has an embedded wallet, that wallet will be available to the user upon sign in.

<Tabs>
  <Tab title="REST API">
    Make a `POST` request to:

    ```sh  theme={"system"}
    https://auth.privy.io/api/v1/users/import
    ```

    In the body of the request, include a `users` field with an array of up to 20 user objects.

    Below is a **sample cURL command** for creating multiple new users:

    ```bash  theme={"system"}
    $ curl --request POST https://auth.privy.io/api/v1/users/import \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H "Content-Type: application/json" \
    -d '{
       "users": [
           {
               "linked_accounts": [
                   {
                       "type": "email",
                       "address": "joker@gmail.com"
                   }
               ]
           },
           {
               "linked_accounts": [
                   {
                       "type": "wallet",
                       "chain_type": "ethereum",
                       "address": "0xd8da6bf26964af9d7eed9e03e53415d37aa96045"
                   }
               ]
           },
           {
               "linked_accounts": [
                   {
                       "type": "email",
                       "address": "robin@gmail.com"
                   }
               ]
           }
       ]
    }'
    ```

    ### Parameters

    <ParamField body="linked_accounts" type="LinkedAccount[]" required>
      An array including all of the user's linked accounts. These objects are in the same shape as the
      linked accounts returned by [`getUser`](/user-management/users/managing-users/querying-users). For
      each linked account, you must specify the `type` and must not include a `verifiedAt` timestamp.

      <Accordion title="LinkedAccount types">
        <Accordion title="AppleAccount">
          | Field     | Type            | Description                                             |
          | --------- | --------------- | ------------------------------------------------------- |
          | `type`    | `'apple_oauth'` | N/A                                                     |
          | `email`   | `string`        | Email address associated with the user's Apple account. |
          | `subject` | `number`        | ID of user from Apple's user API.                       |
        </Accordion>

        <Accordion title="CustomJwtAccount">
          | Field                                            | Type            | Description                           |
          | ------------------------------------------------ | --------------- | ------------------------------------- |
          | `type`                                           | `'custom_auth'` | N/A                                   |
          | API: `custom_user_id` <br /> SDK: `customUserId` | `string`        | ID of user from custom auth provider. |
        </Accordion>

        <Accordion title="DiscordAccount">
          | Field      | Type              | Description                                                                                         |
          | ---------- | ----------------- | --------------------------------------------------------------------------------------------------- |
          | `type`     | `'discord_oauth'` | N/A                                                                                                 |
          | `subject`  | `string`          | ID of user from Discord user API response.                                                          |
          | `email`    | `string`          | Email of user from Discord user API response                                                        |
          | `username` | `string`          | Username of user from Discord user API response. Include the 4-digit discriminator prefixed by '#'. |

          (See [Discord docs](https://discord.com/developers/docs/resources/user))
        </Accordion>

        <Accordion title="EmailAccount">
          | Field     | Type      | Description                    |
          | --------- | --------- | ------------------------------ |
          | `type`    | `'email'` | N/A                            |
          | `address` | `string`  | Email address of user account. |
        </Accordion>

        <Accordion title="FarcasterAccount">
          | Field                                                      | Type          | Description                                                                                                                                             |
          | ---------------------------------------------------------- | ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
          | `type`                                                     | `'farcaster'` | N/A                                                                                                                                                     |
          | `fid`                                                      | `number`      | FID of the user from Farcaster user API response.                                                                                                       |
          | API: `owner_address` <br /> SDK: `ownerAddress`            | `string`      | Wallet address of the user from Farcaster user API response. Note that this is the Farcaster wallet address, and not the Privy embedded wallet address. |
          | `username`                                                 | `string`      | (Optional) Username of user from Farcaster user API response. Do not include the '@'.                                                                   |
          | API: `display_name` <br /> SDK: `displayName`              | `string`      | (Optional) Display name of user from Farcaster user API response.                                                                                       |
          | `bio`                                                      | `string`      | (Optional) Bio of user from Farcaster user API response.                                                                                                |
          | API: `profile_picture_url` <br /> SDK: `profilePictureUrl` | `string`      | (Optional) Profile picture URL of the user from Farcaster user API response. Must be a valid image URL.                                                 |
          | API: `homepage_url` <br /> SDK: `homepageUrl`              | `string`      | (Optional) Profile URL of the user from Farcaster user API response.                                                                                    |

          (See [Farcaster docs](https://docs.farcaster.xyz/reference/hubble/httpapi/userdata#userdata-api). Note that the Privy import interface differs slightly from the Farcaster public interface in order to maintain consistency with other Privy **`LinkedAccount`** types.)
        </Accordion>

        <Accordion title="GithubAccount">
          | Field      | Type             | Description                                    |
          | ---------- | ---------------- | ---------------------------------------------- |
          | `type`     | `'github_oauth'` | N/A                                            |
          | `subject`  | `string`         | ID of user from GitHub user API response.      |
          | `email`    | `string`         | Email of user from GitHub user API response    |
          | `name`     | `string`         | Name of user from GitHub user API response     |
          | `username` | `string`         | Username of user from GitHub user API response |

          (See [GitHub docs](https://docs.github.com/en/rest/users/users?apiVersion=2022-11-28#get-the-authenticated-user))
        </Accordion>

        <Accordion title="GoogleAccount">
          | Field     | Type             | Description                                                |
          | --------- | ---------------- | ---------------------------------------------------------- |
          | `type`    | `'google_oauth'` | N/A                                                        |
          | `subject` | `string`         | `sub` pulled from Google-provided JWT with "openid" scope. |
          | `email`   | `string`         | `email` from Google-provided JWT with "email" scope.       |
          | `name`    | `string`         | `name` from Google-provided JWT with "profile" scope.      |
        </Accordion>

        <Accordion title="InstagramAccount">
          | Field      | Type                | Description                                                                 |
          | ---------- | ------------------- | --------------------------------------------------------------------------- |
          | `type`     | `'instagram_oauth'` | N/A                                                                         |
          | `subject`  | `string`            | ID of user from Instagram user API response.                                |
          | `username` | `string`            | The name displayed on a user's profile from Instagram's `/me` API response. |

          (See [Instagram docs](https://developers.facebook.com/docs/instagram-basic-display-api/reference/me/))
        </Accordion>

        <Accordion title="LinkedinAccount">
          | Field     | Type               | Description                                                           |
          | --------- | ------------------ | --------------------------------------------------------------------- |
          | `type`    | `'linkedin_oauth'` | N/A                                                                   |
          | `subject` | `string`           | ID of user from LinkedIn user API response.                           |
          | `email`   | `string`           | Email of user from LinkedIn user API response                         |
          | `name`    | `string`           | Name of user from LinkedIn user API response. Do not include the '@'. |

          (See [Linkedin docs](https://learn.microsoft.com/en-us/linkedin/consumer/integrations/self-serve/sign-in-with-linkedin-v2#api-request-to-retreive-member-details))
        </Accordion>

        <Accordion title="PhoneAccount">
          | Field    | Type      | Description                                                             |
          | -------- | --------- | ----------------------------------------------------------------------- |
          | `type`   | `'phone'` | N/A                                                                     |
          | `number` | `string`  | Phone number of user account (non-international numbers default to US). |

          While `number` is accepted as input, `phoneNumber` is returned in the response.
        </Accordion>

        <Accordion title="SpotifyAccount">
          | Field     | Type              | Description                                                                     |
          | --------- | ----------------- | ------------------------------------------------------------------------------- |
          | `type`    | `'spotify_oauth'` | N/A                                                                             |
          | `subject` | `string`          | ID of user from Spotify user API response.                                      |
          | `email`   | `string`          | Email of user from Spotify user API.                                            |
          | `name`    | `string`          | The name displayed on a user's profile from Spotify display\_name API response. |

          (See [Spotify docs](https://developer.spotify.com/documentation/web-api/reference/get-current-users-profile))
        </Accordion>

        <Accordion title="TelegramAccount">
          | Field            | Type         | Description                                                      |
          | ---------------- | ------------ | ---------------------------------------------------------------- |
          | `type`           | `'telegram'` | N/A                                                              |
          | `telegramUserId` | `string`     | ID of a user's telegram account.                                 |
          | `firstName`      | `string`     | The first name displayed on a user's telegram account.           |
          | `lastName`       | `string`     | (Optional) The last name displayed on a user's telegram account. |
          | `username`       | `string`     | (Optional) The username displayed on a user's telegram account.  |
          | `photo_url`      | `string`     | (Optional) The url of a user's telegram account profile picture. |

          (See [Telegram docs](https://core.telegram.org/widgets/login#checking-authorization))
        </Accordion>

        <Accordion title="TwitterAccount">
          | Field                                                   | Type              | Description                                                                                           |
          | ------------------------------------------------------- | ----------------- | ----------------------------------------------------------------------------------------------------- |
          | `type`                                                  | `'twitter_oauth'` | N/A                                                                                                   |
          | `subject`                                               | `string`          | ID of user from Twitter user API response.                                                            |
          | `name`                                                  | `string`          | Name of user from Twitter user API response                                                           |
          | `username`                                              | `string`          | Username of user from Twitter user API response. Do not include the '@'.                              |
          | API: profile\_picture\_url`<br/>`SDK: profilePictureUrl | `string`          | (Optional) Profile picture URL of the user from Twitter user API response. Must be a valid image URL. |

          (See [Twitter docs](https://developer.twitter.com/en/docs/twitter-api/users/lookup/api-reference/get-users-me#tab0))
        </Accordion>

        <Accordion title="SmartWalletAccount">
          | Field               | Type              | Description                                                                                             |
          | ------------------- | ----------------- | ------------------------------------------------------------------------------------------------------- |
          | `type`              | `'smart_wallet'`  | N/A                                                                                                     |
          | `address`           | `string`          | Checksummed smart wallet address.                                                                       |
          | `smart_wallet_type` | `SmartWalletType` | One of `'kernel'`, `'safe'`, `'biconomy'`, `'thirdweb'`, `'light_account'` or `'coinbase_smart_wallet'` |
        </Accordion>

        <Accordion title="WalletAccount">
          | Field                                    | Type                     | Description                                                                                              |
          | ---------------------------------------- | ------------------------ | -------------------------------------------------------------------------------------------------------- |
          | `type`                                   | `'wallet'`               | N/A                                                                                                      |
          | API:`chain_type` <br /> SDK: `chainType` | `'ethereum' \| 'solana'` | Type of chain for the wallet. EVM chains (`'ethereum'`) and Solana (`'solana'`) are currently supported. |
          | `address`                                | `string`                 | Checksummed wallet address.                                                                              |
        </Accordion>
      </Accordion>
    </ParamField>

    <ParamField path="wallets" type="WalletCreateRequestType[]">
      (Optional) An array of wallets to create for the user.

      <Expandable defaultOpen="true">
        <ParamField path="chain_type" type="'ethereum' | 'solana' | 'stellar' | 'cosmos' | 'sui' | 'tron' | 'bitcoin-segwit' | 'near' | 'ton' | 'starknet' | 'movement' | 'aptos'" required>
          The chain type of the wallet to create.
        </ParamField>

        <ParamField path="additional_signers" type="object[]">
          <Expandable defaultOpen="true">
            <ParamField path="signer_id" type="string">
              The ID of the signer.
            </ParamField>

            <ParamField path="policy_ids" type="string[]">
              List of policy IDs for policies that should be enforced on the wallet. Currently, only one
              policy is supported per wallet.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField path="create_smart_wallet" type="boolean">
          Set to `true` to create a smart wallet with the user's wallet as the signer. Can only be set
          on wallets where `chain_type` is `ethereum`.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Response Format

    A successful response will include a list of results along with details about which succeeded and which failed:

    ```json  theme={"system"}
    {
      "results": [
        {
          "action": "create",
          "index": 0,
          "success": true,
          "id": "did:privy:clfn2wysq01ijykc8gyq2j2t1"
        },
        {
          "action": "create",
          "index": 1,
          "success": false,
          "code": 101,
          "error": "Account conflict caused by an existing user. Multiple users cannot share the same account.",
          "cause": "did:privy:clfmxole300rmykc89nojp3v2"
        },
        {
          "action": "create",
          "index": 2,
          "success": true,
          "id": "did:privy:clfn2wysq01ijykc8gyq2j2t3"
        }
      ]
    }
    ```

    Each result in the response includes:

    <ResponseField name="action" type="string">
      The action taken ("create").
    </ResponseField>

    <ResponseField name="index" type="number">
      The index of the user in the request array.
    </ResponseField>

    <ResponseField name="success" type="boolean">
      Whether the user creation succeeded.
    </ResponseField>

    <ResponseField name="id" type="string">
      The Privy DID of the user (if successful).
    </ResponseField>

    <ResponseField name="code" type="number">
      Error code (if unsuccessful).
    </ResponseField>

    <ResponseField name="error" type="string">
      Error message (if unsuccessful).
    </ResponseField>

    <ResponseField name="cause" type="string">
      The conflicting DID (if there was an account conflict).
    </ResponseField>
  </Tab>
</Tabs>

<Info>
  User creation endpoints have a rate limit of 240 users per minute. If you are being rate limited,
  responses will have status code 429. We suggest you set up exponential back-offs starting at 1
  second to seamlessly recover.
</Info>


# Create or import a user
Source: https://docs.privy.io/user-management/migrating-users-to-privy/create-or-import-a-user



To import an existing user, Privy allows you to create a user with their linked accounts (wallet, email, etc.) as part of the user creation request. You can also generate a wallet when you create a user.

When the user logs in, all of their linked accounts will be included in the user object. If the user has a pregenerated embedded wallet, that wallet will be available to the user upon sign in.

<Tabs>
  <Tab title="NodeJS">
    You can create a user by calling the `.users().create()` method on the `PrivyClient`.

    ```ts  theme={"system"}
    import {PrivyClient} from '@privy-io/node';

    const privy = new PrivyClient({
      appId: 'insert-your-app-id',
      appSecret: 'insert-your-app-secret'
    });

    try {
      const user = await privy.users().create({
        linked_accounts: [{type: 'email', address: 'batman@privy.io'}],
        wallets: [{chain_type: 'ethereum'}],
        custom_metadata: {key: 'value'}
      });
    } catch (error) {
      console.error(error);
    }
    ```

    Refer to the [API reference](/api-reference/users/create) for more details on the available
    parameters and returns.
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    Use the **`PrivyClient`**'s **`importUser`** method to create or import a single user into your Privy app.

    ```tsx  theme={"system"}
    const user = await privy.importUser({
      linkedAccounts: [
        {
          type: 'email',
          address: 'batman@privy.io'
        }
      ],
      wallets: [{chainType: "ethereum"}]
      customMetadata: {
        key: 'value'
      }
    });
    ```

    ### Parameters

    <ParamField body="linkedAccounts" type="LinkedAccount[]" required>
      An array including all of the user's linked accounts. These objects are in the same shape as the
      linked accounts returned by [`getUser`](/user-management/users/managing-users/querying-users). For
      each linked account, you must specify the `type` and must not include a `verifiedAt` timestamp.

      <Accordion title="LinkedAccount types">
        <Accordion title="AppleAccount">
          | Field     | Type            | Description                                             |
          | --------- | --------------- | ------------------------------------------------------- |
          | `type`    | `'apple_oauth'` | N/A                                                     |
          | `email`   | `string`        | Email address associated with the user's Apple account. |
          | `subject` | `number`        | ID of user from Apple's user API.                       |
        </Accordion>

        <Accordion title="CustomJwtAccount">
          | Field                                            | Type            | Description                           |
          | ------------------------------------------------ | --------------- | ------------------------------------- |
          | `type`                                           | `'custom_auth'` | N/A                                   |
          | API: `custom_user_id` <br /> SDK: `customUserId` | `string`        | ID of user from custom auth provider. |
        </Accordion>

        <Accordion title="DiscordAccount">
          | Field      | Type              | Description                                                                                         |
          | ---------- | ----------------- | --------------------------------------------------------------------------------------------------- |
          | `type`     | `'discord_oauth'` | N/A                                                                                                 |
          | `subject`  | `string`          | ID of user from Discord user API response.                                                          |
          | `email`    | `string`          | Email of user from Discord user API response                                                        |
          | `username` | `string`          | Username of user from Discord user API response. Include the 4-digit discriminator prefixed by '#'. |

          (See [Discord docs](https://discord.com/developers/docs/resources/user))
        </Accordion>

        <Accordion title="EmailAccount">
          | Field     | Type      | Description                    |
          | --------- | --------- | ------------------------------ |
          | `type`    | `'email'` | N/A                            |
          | `address` | `string`  | Email address of user account. |
        </Accordion>

        <Accordion title="FarcasterAccount">
          | Field                                                      | Type          | Description                                                                                                                                             |
          | ---------------------------------------------------------- | ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
          | `type`                                                     | `'farcaster'` | N/A                                                                                                                                                     |
          | `fid`                                                      | `number`      | FID of the user from Farcaster user API response.                                                                                                       |
          | API: `owner_address` <br /> SDK: `ownerAddress`            | `string`      | Wallet address of the user from Farcaster user API response. Note that this is the Farcaster wallet address, and not the Privy embedded wallet address. |
          | `username`                                                 | `string`      | (Optional) Username of user from Farcaster user API response. Do not include the '@'.                                                                   |
          | API: `display_name` <br /> SDK: `displayName`              | `string`      | (Optional) Display name of user from Farcaster user API response.                                                                                       |
          | `bio`                                                      | `string`      | (Optional) Bio of user from Farcaster user API response.                                                                                                |
          | API: `profile_picture_url` <br /> SDK: `profilePictureUrl` | `string`      | (Optional) Profile picture URL of the user from Farcaster user API response. Must be a valid image URL.                                                 |
          | API: `homepage_url` <br /> SDK: `homepageUrl`              | `string`      | (Optional) Profile URL of the user from Farcaster user API response.                                                                                    |

          (See [Farcaster docs](https://docs.farcaster.xyz/reference/hubble/httpapi/userdata#userdata-api). Note that the Privy import interface differs slightly from the Farcaster public interface in order to maintain consistency with other Privy **`LinkedAccount`** types.)
        </Accordion>

        <Accordion title="GithubAccount">
          | Field      | Type             | Description                                    |
          | ---------- | ---------------- | ---------------------------------------------- |
          | `type`     | `'github_oauth'` | N/A                                            |
          | `subject`  | `string`         | ID of user from GitHub user API response.      |
          | `email`    | `string`         | Email of user from GitHub user API response    |
          | `name`     | `string`         | Name of user from GitHub user API response     |
          | `username` | `string`         | Username of user from GitHub user API response |

          (See [GitHub docs](https://docs.github.com/en/rest/users/users?apiVersion=2022-11-28#get-the-authenticated-user))
        </Accordion>

        <Accordion title="GoogleAccount">
          | Field     | Type             | Description                                                |
          | --------- | ---------------- | ---------------------------------------------------------- |
          | `type`    | `'google_oauth'` | N/A                                                        |
          | `subject` | `string`         | `sub` pulled from Google-provided JWT with "openid" scope. |
          | `email`   | `string`         | `email` from Google-provided JWT with "email" scope.       |
          | `name`    | `string`         | `name` from Google-provided JWT with "profile" scope.      |
        </Accordion>

        <Accordion title="InstagramAccount">
          | Field      | Type                | Description                                                                 |
          | ---------- | ------------------- | --------------------------------------------------------------------------- |
          | `type`     | `'instagram_oauth'` | N/A                                                                         |
          | `subject`  | `string`            | ID of user from Instagram user API response.                                |
          | `username` | `string`            | The name displayed on a user's profile from Instagram's `/me` API response. |

          (See [Instagram docs](https://developers.facebook.com/docs/instagram-basic-display-api/reference/me/))
        </Accordion>

        <Accordion title="LinkedinAccount">
          | Field     | Type               | Description                                                           |
          | --------- | ------------------ | --------------------------------------------------------------------- |
          | `type`    | `'linkedin_oauth'` | N/A                                                                   |
          | `subject` | `string`           | ID of user from LinkedIn user API response.                           |
          | `email`   | `string`           | Email of user from LinkedIn user API response                         |
          | `name`    | `string`           | Name of user from LinkedIn user API response. Do not include the '@'. |

          (See [Linkedin docs](https://learn.microsoft.com/en-us/linkedin/consumer/integrations/self-serve/sign-in-with-linkedin-v2#api-request-to-retreive-member-details))
        </Accordion>

        <Accordion title="PhoneAccount">
          | Field    | Type      | Description                                                             |
          | -------- | --------- | ----------------------------------------------------------------------- |
          | `type`   | `'phone'` | N/A                                                                     |
          | `number` | `string`  | Phone number of user account (non-international numbers default to US). |

          While `number` is accepted as input, `phoneNumber` is returned in the response.
        </Accordion>

        <Accordion title="SpotifyAccount">
          | Field     | Type              | Description                                                                     |
          | --------- | ----------------- | ------------------------------------------------------------------------------- |
          | `type`    | `'spotify_oauth'` | N/A                                                                             |
          | `subject` | `string`          | ID of user from Spotify user API response.                                      |
          | `email`   | `string`          | Email of user from Spotify user API.                                            |
          | `name`    | `string`          | The name displayed on a user's profile from Spotify display\_name API response. |

          (See [Spotify docs](https://developer.spotify.com/documentation/web-api/reference/get-current-users-profile))
        </Accordion>

        <Accordion title="TelegramAccount">
          | Field            | Type         | Description                                                      |
          | ---------------- | ------------ | ---------------------------------------------------------------- |
          | `type`           | `'telegram'` | N/A                                                              |
          | `telegramUserId` | `string`     | ID of a user's telegram account.                                 |
          | `firstName`      | `string`     | The first name displayed on a user's telegram account.           |
          | `lastName`       | `string`     | (Optional) The last name displayed on a user's telegram account. |
          | `username`       | `string`     | (Optional) The username displayed on a user's telegram account.  |
          | `photo_url`      | `string`     | (Optional) The url of a user's telegram account profile picture. |

          (See [Telegram docs](https://core.telegram.org/widgets/login#checking-authorization))
        </Accordion>

        <Accordion title="TwitterAccount">
          | Field                                                   | Type              | Description                                                                                           |
          | ------------------------------------------------------- | ----------------- | ----------------------------------------------------------------------------------------------------- |
          | `type`                                                  | `'twitter_oauth'` | N/A                                                                                                   |
          | `subject`                                               | `string`          | ID of user from Twitter user API response.                                                            |
          | `name`                                                  | `string`          | Name of user from Twitter user API response                                                           |
          | `username`                                              | `string`          | Username of user from Twitter user API response. Do not include the '@'.                              |
          | API: profile\_picture\_url`<br/>`SDK: profilePictureUrl | `string`          | (Optional) Profile picture URL of the user from Twitter user API response. Must be a valid image URL. |

          (See [Twitter docs](https://developer.twitter.com/en/docs/twitter-api/users/lookup/api-reference/get-users-me#tab0))
        </Accordion>

        <Accordion title="SmartWalletAccount">
          | Field               | Type              | Description                                                                                             |
          | ------------------- | ----------------- | ------------------------------------------------------------------------------------------------------- |
          | `type`              | `'smart_wallet'`  | N/A                                                                                                     |
          | `address`           | `string`          | Checksummed smart wallet address.                                                                       |
          | `smart_wallet_type` | `SmartWalletType` | One of `'kernel'`, `'safe'`, `'biconomy'`, `'thirdweb'`, `'light_account'` or `'coinbase_smart_wallet'` |
        </Accordion>

        <Accordion title="WalletAccount">
          | Field                                    | Type                     | Description                                                                                              |
          | ---------------------------------------- | ------------------------ | -------------------------------------------------------------------------------------------------------- |
          | `type`                                   | `'wallet'`               | N/A                                                                                                      |
          | API:`chain_type` <br /> SDK: `chainType` | `'ethereum' \| 'solana'` | Type of chain for the wallet. EVM chains (`'ethereum'`) and Solana (`'solana'`) are currently supported. |
          | `address`                                | `string`                 | Checksummed wallet address.                                                                              |
        </Accordion>
      </Accordion>
    </ParamField>

    <ParamField body="customMetadata" type="object">
      An object containing any custom metadata you want to associate with the user. This metadata will
      be returned in the user object when the user logs in.
    </ParamField>

    <ParamField path="wallets" type="WalletCreateRequestType[]">
      (Optional) An array of wallets to create for the user.

      <Expandable defaultOpen="true">
        <ParamField path="chainType" type="'ethereum' | 'solana' | 'stellar' | 'cosmos' | 'sui' | 'tron' | 'bitcoin-segwit' | 'near' | 'ton' | 'starknet' | 'aptos'" required>
          The chain type of the wallet to create.
        </ParamField>

        <ParamField path="additionalSigners" type="object[]">
          <Expandable defaultOpen="true">
            <ParamField path="signerId" type="string">
              The ID of the signer.
            </ParamField>

            <ParamField path="policyIds" type="string[]">
              List of policy IDs for policies that should be enforced on the wallet. Currently, only one
              policy is supported per wallet.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField path="createSmartWallet" type="boolean">
          Set to `true` to create a smart wallet with the user's wallet as the signer. Can only be set
          on wallets where `chainType` is `ethereum`.
        </ParamField>
      </Expandable>
    </ParamField>
  </Tab>

  <Tab title="Java">
    You can create a user by calling the `.users().create()` method on the `PrivyClient`.

    ```java  theme={"system"}
    try {
        List<LinkedAccountInput> createUserLinkedAccounts = List.of(
            LinkedAccountInput.email("batman@privy.io")
        );
        Map<String, CustomMetadata> customMetadata = Map.of("username", CustomMetadata.of("name"));

        // Pregenerate an Ethereum wallet for the user
        List<UserWalletRequest> wallets = List.of(
            UserWalletRequest.builder()
                .chainType(WalletChainType.ETHEREUM)
                .build()
        );

        UserCreateRequestBody requestBody = UserCreateRequestBody.builder()
            .linkedAccounts(createUserLinkedAccounts)
            .customMetadata(customMetadata)
            .wallets(wallets)
            .build();

        UserCreateResponse response = privyClient
            .users()
            .create(requestBody);

        if (response.user().isPresent()) {
            User user = response.user().get();
        }
    } catch (APIException e) {
        String errorBody = e.bodyAsString();
        System.err.println(errorBody);
    } catch (Exception e) {
        System.err.println(e.getMessage());
    }
    ```

    ### Parameters

    You can specify the following values on the `UserCreateRequestBody` builder:

    <ParamField path="linkedAccounts" type="List<LinkedAccountInput>" required>
      A list of linked accounts to create for the user.
    </ParamField>

    <ParamField path="customMetadata" type="Map<String, CustomMetadata>">
      An object containing any custom metadata you want to associate with the user. This metadata will
      be returned in the user object when the user logs in.
    </ParamField>

    <ParamField path="wallets" type="List<UserWalletRequest>">
      A list of wallets to create for the user.
    </ParamField>

    ### Returns

    The `UserCreateResponse` object contains an optional `user()` field, present if the user was created successfully.

    <ResponseField name="user()" type="Optional<User>">
      The created `User` object. See the [user object](/user-management/users/the-user-object) for more
      details.
    </ResponseField>
  </Tab>

  <Tab title="Rust">
    You can create a user by calling the `.users().create()` method on the `PrivyClient`.

    ```rust  theme={"system"}
    use privy_rs::{PrivyClient, generated::types::*};
    use std::collections::HashMap;

    let client = PrivyClient::new(app_id, app_secret)?;

    // Create custom metadata with proper typing
    let mut metadata_map = HashMap::new();
    metadata_map.insert("key".to_string(), CustomMetadataValue::String("value".to_string()));
    let custom_metadata = CustomMetadata::from(metadata_map);

    let user = client
        .users()
        .create(&CreateUserBody {
            linked_accounts: vec![
                LinkedAccountInput::EmailInput(LinkedAccountEmailInput {
                    address: "batman@privy.io".to_string(),
                    type_: LinkedAccountEmailInputType::Email,
                }),
            ],
            wallets: vec![
                CreateWalletBody {
                    chain_type: WalletChainType::Ethereum,
                    additional_signers: None,
                    owner: None,
                    owner_id: None,
                    policy_ids: vec![],
                },
            ],
            custom_metadata: Some(custom_metadata),
        })
        .await?;

    println!("Created user: {}", user.id);
    ```

    ### Parameters and Returns

    See the Rust SDK documentation for detailed parameter and return types, including embedded examples:

    * [UsersClient::create](https://docs.rs/privy-rs/latest/privy_rs/subclients/struct.UsersClient.html#method.create)

    For REST API details, see the [API reference](/api-reference/users/create).
  </Tab>

  <Tab title="REST API">
    Make a `POST` request to:

    ```sh  theme={"system"}
    https://auth.privy.io/api/v1/users
    ```

    Below is a **sample cURL command** for creating a new user:

    ```bash  theme={"system"}
    $ curl --request POST https://auth.privy.io/api/v1/users \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H 'Content-Type: application/json' \
    -d '{
      "linked_accounts": [
        {
          "address": "batman@privy.io",
          "type": "email"
        }
      ]
    }'
    ```

    ### Parameters

    <ParamField body="linked_accounts" type="LinkedAccount[]" required>
      An array including all of the user's linked accounts. These objects are in the same shape as the
      linked accounts returned by [`getUser`](/user-management/users/managing-users/querying-users). For
      each linked account, you must specify the `type` and must not include a `verifiedAt` timestamp.
    </ParamField>

    <ParamField body="custom_metadata" type="object">
      An object containing any custom metadata you want to associate with the user. This metadata will
      be returned in the user object when the user logs in.
    </ParamField>

    <ParamField path="wallets" type="WalletCreateRequestType[]">
      (Optional) An array of wallets to create for the user.

      <Expandable defaultOpen="true">
        <ParamField path="chainType" type="'ethereum' | 'solana' | 'stellar' | 'cosmos' | 'sui' | 'tron' | 'bitcoin-segwit' | 'near' | 'ton' | 'starknet' | 'aptos'" required>
          The chain type of the wallet to create.
        </ParamField>

        <ParamField path="additional_signers" type="object[]">
          <Expandable defaultOpen="true">
            <ParamField path="signer_id" type="string">
              The ID of the signer.
            </ParamField>

            <ParamField path="override_policy_ids" type="string[]">
              The array of policy IDs that will be applied to wallet requests. If specified, this will
              override the base policy IDs set on the wallet. Currently, only one policy is supported
              per signer.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField path="policy_ids" type="string[]">
          List of policy IDs for policies that should be enforced on the wallet. Currently, only one
          policy is supported per wallet.
        </ParamField>

        <ParamField path="create_smart_wallet" type="boolean">
          Set to `true` to create a smart wallet with the user's wallet as the signer. Can only be set
          on wallets where `chainType` is `ethereum`.
        </ParamField>
      </Expandable>
    </ParamField>

    A successful response will include the new user object along with their DID:

    ```json  theme={"system"}
    {
      "id": "did:privy:clddy332f002tyqpq3b3lv327",
      "created_at": 1674788927,
      "linked_accounts": [
        {
          "address": "batman@privy.io",
          "type": "email",
          "verified_at": 1674788927
        }
      ]
    }
    ```
  </Tab>
</Tabs>

<Info>
  User creation endpoints have a rate limit of 240 users in total per minute. If you are being rate
  limited, responses will have status code 429. We suggest you set up exponential back-offs starting
  at 1 second to seamlessly recover.
</Info>


# Migrating existing users to Privy
Source: https://docs.privy.io/user-management/migrating-users-to-privy/overview



Privy makes it easy for you to import existing user accounts from your existing auth setup by creating new users with Privy.

At a high-level, your migration workflow involves two key components: **creating user accounts** and **ensuring users have continuous ownership over any assets stored in their wallets, including embedded wallets.** From these two pieces, you can easily switch over from a custom provider or add Privy to your existing auth flow.

## Importing user data

**You can easily create users and their accounts with Privy and can even pre-generate Privy embedded wallets for them.**

Privy supports both:

* [just-in-time migration](#just-in-time-migration) so you can map your existing users to new Privy users as they log in
* [proactive migration](#proactive-migration) to import user data into Privy all at once

### Just-in-time migration

The simplest option is to "lazily" transfer your existing users to Privy. When an existing user logs in to your app via Privy for the first time, add their Privy DID to your internal users database to create a mapping between your existing user entry and [their Privy user object](/user-management/users/the-user-object).

Namely, we suggest:

1. In your internal users database, add a `PrivyDID` column.
2. In the [**`onComplete`**](/authentication/user-authentication/ui-component) callback from Privy's `useLogin` hook, if the **`isNewUser`** flag is `true`, make a request to your backend with the user's Privy DID (`user.id`) and any account data you need to identify that user from your existing DB.

For example, the request to your backend for a new user might include a body like:

```json  theme={"system"}
{
  "address": user.wallet?.address,
  "email": user.email?.address,
  "privyDID": user.id
}
```

3. When your backend receives the request from step (2), find the corresponding entry in your internal user database, matching on their wallet address, email address, or any other relevant account data.

<Steps>
  <Step>
    If entry does not have a `PrivyDID`, add the Privy DID from your request to the `PrivyDID`
    column in your database.
  </Step>

  <Step>
    If the entry already has a "Privy DID" in your database, it should match the Privy DID included
    in your request. There is nothing more to do.
  </Step>

  <Step>
    If there is no user matching the account information in the request, you can assume it is a new
    user in your internal database, and create an entry for them with their `PrivyDID`.
  </Step>
</Steps>

In this way, you can maintain a mapping between your existing user data and the corresponding Privy user object.

Your user data will be updated as your users login to your app using Privy.

### Proactive migration

If your existing users database associates multiple linked accounts (e.g. email, wallet, Discord, etc.) to a single user, we recommend that you proactively migrate them to Privy using the [**create a batch of users**](/user-management/migrating-users-to-privy/create-or-import-a-batch-of-users) endpoint. This ensures you can migrate your users and preserve the links between their different accounts in Privy.

Please see the instructions [here](/user-management/migrating-users-to-privy/create-or-import-a-batch-of-users) for more.

## Ensuring continuous asset ownership

Once you've migrated your user data to Privy, you should next migrate user assets if necessary to ensure the transition is seamless for your users. This can be done by transferring over user addresses to Privy (migrating the wallet) or having them transfer assets to their new accounts (migrating the assets).

The best path depends on your current setup and whether you need users to keep their existing wallets. We generally recommend transferring assets if you can.

<Tip>
  In most cases, migrating assets and/or wallets is only necessary if you are coming from another
  **embedded wallet** provider. If your users currently use external wallets to store their assets,
  you can simply import their address to Privy.
</Tip>

### If you are able to transfer assets

<AccordionGroup>
  <Accordion title="Migrating from a custodial system">
    If you are able to submit transactions on behalf of your users, you can set up batch
    transactions on your backend, sponsoring gas on behalf of your users to transfer their assets
    into pregenerated Privy wallets.
  </Accordion>

  <Accordion title="Migrating from a non-custodial system">
    When they next log in, prompt your users to run a one-time transfer to migrate their assets over
    to their new account.
  </Accordion>
</AccordionGroup>

### If you need to transfer wallets instead of transferring assets

<AccordionGroup>
  <Accordion title="Migrating from a custodial system (where you have access to user keys)">
    You can import user keys to Privy easily if you have access to them. This enables you to
    smoothly move your users' keys so they are managed by Privy's non-custodial system.
  </Accordion>

  <Accordion title="Migrating from a non-custodial system">
    We recommend you prompt your user to export their keys so they can use them with an external
    wallet (like MetaMask).
  </Accordion>
</AccordionGroup>

<Tip>
  Privy's system is non-custodial. This means neither you nor Privy will have any access to your
  user's private keys after the migration.
</Tip>


# null
Source: https://docs.privy.io/user-management/overview



Understanding your user lifecycle is essential to crafting incredible products. Privy enables user management to help you serve your user throughout their journey.

Privy allows your application to easily manage users from the server and the Privy dashboard. This means letting users connect multiple accounts (e.g. sms, email, social) and wallets (embedded or external) to their account to let you manage onchain and offchain state easily.

## Managing user state

### Webhooks

Privy comes with built in webhooks that will alert your servers whenever a user takes a specified action. Simply configure the events to be notified on, ie when a user is created or logged in, and a destination URL. Privy will send updates every time a user takes that action on your application.

### Dashboard

The Privy Dashboard is the hub to manage your apps, retrieve your API keys, and manage the administrators for your account. From the dashboard, administrators can create new apps, easily configure Privy features, and view key metrics and data about users.

### REST API

Privy supports myriad API endpoints to manage your application from your server. Your application can take actions like search, create, and delete users in a single line API call.


# null
Source: https://docs.privy.io/user-management/users/custom-metadata



Privy allows you to set custom metadata on the `user` object to store any app-specific metadata. This field is a generic JSON object up to 1KB in size. The JSON can contain arbitrary key-value pairs where the key is a `string` and value is a `string`, `integer`, or `boolean` (ie `{username: 'name', isVerified: true, age: 23}`).

<Tabs>
  <Tab title="NodeJS">
    Use the **`PrivyClient`**'s **`setCustomMetadata`** method from the `users()` interface to set the custom metadata field for a user by their ID. As parameters, pass the user's ID as a `string` and the JSON object that you wish to set as custom metadata:

    ```ts  theme={"system"}
    import {PrivyClient} from '@privy-io/node';

    const privy = new PrivyClient({
      appId: process.env.PRIVY_APP_ID!,
      appSecret: process.env.PRIVY_APP_SECRET!
    });

    try {
      const user = await privy.users().setCustomMetadata('insert-user-id', {
        custom_metadata: {
          username: 'name'
        }
      });
    } catch (error) {
      console.error(error);
    }
    ```

    If a matching user is found for the ID and the custom metadata object is valid, the method will return the corresponding **`User`** object with updated custom metadata. If no matching user is found, or the custom metadata input is malformed or too large (>1KB), the method will throw an error.
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    Use the **`PrivyClient`**'s **`setCustomMetadata`** method to set the custom metadata field for a user by their DID. As parameters, pass the user's DID as a `string` and the JSON object that you wish to set as custom metadata:

    ```typescript  theme={"system"}
    import {PrivyClient} from '@privy-io/server-auth';

    const privy = new PrivyClient(process.env.PRIVY_APP_ID!, process.env.PRIVY_APP_SECRET!);

    const user = await privy.setCustomMetadata('did:privy:XXXXXX', {username: 'name'});
    ```

    If a matching user is found for the DID and the custom metadata object is valid, the method will return the corresponding **`User`** object with updated custom metadata. If no matching user is found, or the custom metadata input is malformed or too large (>1KB), the method will throw an error.

    <Tip>
      When using the **`setCustomMetadata`** function in TypeScript, you can specify a type generic in order to enable type inference on the method like so:

      ```tsx  theme={"system"}
      // TypeScript will throw a type error if customMetadata is not of type {key1: string}
      const user = await privy.setCustomMetadata<{key1: string}>('did:privy:XXXXXX', customMetadata);
      ```
    </Tip>
  </Tab>

  <Tab title="Java">
    You can set or update the custom metadata for a user by their ID using the `users().setCustomMetadata()` method.

    ```java  theme={"system"}
    try {
        UserCustomMetadataSetRequestBody customMetadataRequestBody = UserCustomMetadataSetRequestBody.builder()
    		    .customMetadata(Map.of("username", CustomMetadata.of("name")))
    	      .build();

        UserCustomMetadataSetResponse customMetadataResponse = privyClient
            .users()
            .setCustomMetadata()
            .userId("did:privy:XXXXXX")
            .requestBody(customMetadataRequestBody)
            .call();

        if (customMetadataResponse.user().isPresent()) {
            User updatedUser = customMetadataResponse.user().get();
        }
    } catch (APIException e) {
        String errorBody = e.bodyAsString();
        System.err.println(errorBody);
    } catch (Exception e) {
        System.err.println(e.getMessage());
    }
    ```

    ### Parameters

    When setting the custom metadata for a user, you may specify the following values on the `UserCustomMetadataSetRequestBody` builder:

    <ParamField path="customMetadata" type="Map<String, CustomMetadata>">
      A map of custom metadata key-value pairs. The key is a `String` and value is `CustomMetadata`
      object, which can be a `String`, `double`, or `boolean`.
    </ParamField>

    ### Returns

    The `UserCustomMetadataSetResponse` object contains an optional `user()` field that contains the
    updated user object if the custom metadata was set successfully.

    <ResponseField name="user()" type="Optional<User>">
      The updated user object. See the [user object](/user-management/users/the-user-object) for more
      details.
    </ResponseField>
  </Tab>

  <Tab title="Rust">
    Use the **`PrivyClient`**'s **`set_custom_metadata`** method from the `users()` interface to set the custom metadata field for a user by their ID. As parameters, pass the user's ID as a `string` and the metadata object:

    ```rust  theme={"system"}
    use privy_rs::{PrivyClient, generated::types::*};
    use std::collections::HashMap;

    let client = PrivyClient::new(app_id, app_secret)?;

    // Create custom metadata using the typed enum values
    let mut metadata_map = HashMap::new();
    metadata_map.insert("username".to_string(), CustomMetadataValue::String("name".to_string()));
    metadata_map.insert("isVerified".to_string(), CustomMetadataValue::Boolean(true));
    metadata_map.insert("age".to_string(), CustomMetadataValue::Number(23.0));

    let custom_metadata = CustomMetadata::from(metadata_map);

    let user = client
        .users()
        .set_custom_metadata("insert-user-id", &UserCustomMetadataSetRequestBody {
            custom_metadata,
        })
        .await?;

    println!("Updated user: {}", user.id);
    ```

    If a matching user is found for the ID and the custom metadata object is valid, the method will return the corresponding **`User`** object with updated custom metadata. If no matching user is found, or the custom metadata input is malformed or too large (>1KB), the method will return an error.

    ### Type Safety

    The Rust SDK provides type-safe custom metadata through the `CustomMetadataValue` enum:

    * `CustomMetadataValue::String(String)` for string values
    * `CustomMetadataValue::Number(f64)` for numeric values
    * `CustomMetadataValue::Boolean(bool)` for boolean values
  </Tab>

  <Tab title="REST API">
    To set the custom data for a user with a given DID, make a `POST` request to:

    ```bash  theme={"system"}
    https://auth.privy.io/api/v1/users/<did>/custom_metadata
    ```

    Replace `<did>` with your desired Privy DID. It should have the format `did:privy:XXXXXX`.

    Below is a sample cURL command for this request:

    ```bash  theme={"system"}
    curl --request POST https://auth.privy.io/api/v1/users/<user-did>/custom_metadata \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>"
    -d '{
      "custom_metadata": {username: "name", isVerified: true, age: 23}
    }'
    ```

    A successful response will include the user object associated with the DID, with updated custom\_metadata, like below:

    ```json  theme={"system"}
    {
      "id": "did:privy:cfbsvtqo2c22202mo08847jdux2z",
      "created_at": 1667165891,
      "custom_metadata": {"username": "name"},
      "linked_accounts": [
        {
          "type": "email",
          "address": "user@gmail.com",
          "verified_at": 1667350653
        }
      ]
    }
    ```

    If there is no user associated with the provided DID, or the custom metadata input is malformed or too large (>1KB), the API will return an error.
  </Tab>
</Tabs>


# Identity tokens
Source: https://docs.privy.io/user-management/users/identity-tokens

Access user data securely with Privy identity tokens

Identity tokens provide a secure and efficient way to access user data, especially on the server side. These tokens are JSON Web Tokens (JWTs) whose claims contain information about the currently authenticated user, including their linked accounts, metadata, and more.

Privy strongly recommends using identity tokens when you need user-level data on your server. They allow you to easily pass a signed representation of the current user's linked accounts from your frontend to your backend directly, letting you verifiably determine which accounts (wallet address, email address, Farcaster profile, etc.) are associated with the current request.

<Tip>
  Enable identity tokens in the [Privy
  Dashboard](https://dashboard.privy.io/apps?page=login-methods\&logins=advanced) before implementing
  this feature.
</Tip>

## Enabling identity tokens

To enable identity tokens for your application:

1. Navigate to your application dashboard's [User management > Authentication > Advanced](https://dashboard.privy.io/apps?logins=advanced\&page=login-methods) section
2. Toggle on **Return user data in an identity token**
3. Make sure you're using the latest version of the Privy SDK

## Token format

Privy identity tokens are [JSON Web Tokens (JWT)](https://jwt.io/introduction), signed with the ES256 algorithm. These JWTs include the following claims:

<Expandable title="claims" defaultOpen="true">
  <ParamField query="linked_accounts" type="string">
    A stringified array containing a lightweight version of the current user's `linkedAccounts`
  </ParamField>

  <ParamField query="custom_metadata" type="string">
    A stringified version of the current user's `customMetadata`
  </ParamField>

  <ParamField query="sub" type="string">
    The user's Privy DID
  </ParamField>

  <ParamField query="iss" type="string">
    The token issuer, which should always be `privy.io`
  </ParamField>

  <ParamField query="aud" type="string">
    Your Privy app ID
  </ParamField>

  <ParamField query="iat" type="number">
    The timestamp of when the JWT was issued
  </ParamField>

  <ParamField query="exp" type="number">
    The timestamp of when the JWT will expire (generally 1 hour after issuance)
  </ParamField>
</Expandable>

## Retrieving identity tokens

<Tabs>
  <Tab title="React">
    Once you've enabled identity tokens, Privy will **automatically** include the identity token as a cookie on every request from your frontend to your server.

    For setups where you cannot use cookies, you can retrieve the identity token using the `useIdentityToken` hook or the `getIdentityToken` method:

    ```tsx  theme={"system"}
    import { useIdentityToken, getIdentityToken } from '@privy-io/react-auth';

    function MyComponent() {
      const { identityToken } = useIdentityToken();

      // Use the token in your API requests
      const callApi = async () => {
        const response = await fetch('/api/your-endpoint', {
          headers: {
            'privy-id-token': identityToken // or await getIdentityToken() if you need to get the token outside of the useIdentityToken hook
          }
        });
      };

      return (
        <button onClick={callApi}>Call API</button>
      );
    }
    ```

    <Tip>
      We strongly recommend setting a base domain for your application, so that Privy can set the identity token as a more secure **HttpOnly** cookie.
    </Tip>
  </Tab>

  <Tab title="React Native">
    In React Native applications, you can get the current user's Privy token using the `getIdentityToken` method from the `useIdentityToken` hook:

    ```tsx  theme={"system"}
    import { useIdentityToken } from '@privy-io/expo';

    function MyComponent() {
      const { getIdentityToken } = useIdentityToken();

      const callApi = async () => {
        const idToken = await getIdentityToken();

        // For authenticated users, idToken will be a valid token
        // For unauthenticated users, idToken will be null

        if (idToken) {
          const response = await fetch('https://your-api.com/endpoint', {
            method: 'POST',
            headers: {
              'privy-id-token': idToken,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ /* your data */ })
          });
        }
      };

      return (
        <Button onPress={callApi} title="Call API" />
      );
    }
    ```
  </Tab>

  <Tab title="Swift">
    In Swift applications, the identity token can be accessed directly on the PrivyUser object. It will default to nil if it has not been configured. You can grab it with `privy.user.identityToken`:

    ```swift  theme={"system"}
    // Check if user is authenticated
    guard let user = privy.user else {
      // If user is nil, user is not authenticated
      return
    }

    // Access the identity token
    if let identityToken = user.identityToken {
      print("Identity token: \(identityToken)")
    } else {
      // Identity token has not been configured, defaults to nil
    }
    ```
  </Tab>

  <Tab title="Android">
    In Android applications, the identity token can be accessed directly on the PrivyUser object. It will default to null if it has not been configured. You can grab it with `privy.user.identityToken`:

    ```kotlin  theme={"system"}
    // Check if user is authenticated
    val user = privy.user
    if (user != null) {
      // Access the identity token
      val identityToken = user.identityToken
      if (identityToken != null) {
        println("Identity token: $identityToken")
      } else {
        // Identity token has not been configured, defaults to null
      }
    }
    ```
  </Tab>

  <Tab title="Flutter">
    In Flutter applications, the identity token can be accessed directly on the PrivyUser object. It will default to null if it has not been configured. You can grab it with `privy.user.identityToken`:

    ```dart  theme={"system"}
    // Check if user is authenticated
    final user = privy.user;
    if (user != null) {
      // Access the identity token
      final identityToken = user.identityToken;
      if (identityToken != null) {
        print("Identity token: $identityToken");
      } else {
        // Identity token has not been configured, defaults to null
      }
    }
    ```
  </Tab>
</Tabs>

## Reading identity tokens on your server

On your server, you can retrieve the identity token from incoming requests and use it to identify the user.

<Tabs>
  <Tab title="Next.js (Pages Router)">
    ```tsx  theme={"system"}
    // pages/api/example.ts
    import type { NextApiRequest, NextApiResponse } from 'next';
    import { PrivyClient } from '@privy-io/node';

    export default async function handler(req: NextApiRequest, res: NextApiResponse) {
      try {
        // Get identity token from cookie
        const idToken = req.cookies['privy-id-token'];

        // Or from header if sent that way
        // const idToken = req.headers['privy-id-token'];

        if (!idToken) {
          return res.status(401).json({ message: 'Unauthorized' });
        }

        // Parse and verify the token
        const user = await privy.users().get({ id_token: idToken });

        // Now you can use the user data
        return res.status(200).json({
          userId: user.id,
          // Other user data...
        });
      } catch (error) {
        console.error('Error verifying identity token:', error);
        return res.status(401).json({ message: 'Invalid token' });
      }
    }
    ```
  </Tab>

  <Tab title="Next.js (App Router)">
    ```tsx  theme={"system"}
    // app/api/example/route.ts
    import { cookies, headers } from 'next/headers';
    import { PrivyClient } from '@privy-io/node';
    import { NextResponse } from 'next/server';

    export async function GET() {
      try {
        // Get identity token from cookie
        const cookieStore = cookies();
        const idToken = cookieStore.get('privy-id-token')?.value;

        // Or from header if sent that way
        // const headersList = headers();
        // const idToken = headersList.get('privy-id-token');

        if (!idToken) {
          return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
        }

        // Parse and verify the token
        const user = await privy.users().get({ id_token: idToken });

        // Now you can use the user data
        return NextResponse.json({
          userId: user.id,
          // Other user data...
        });
      } catch (error) {
        console.error('Error verifying identity token:', error);
        return NextResponse.json({ message: 'Invalid token' }, { status: 401 });
      }
    }
    ```
  </Tab>

  <Tab title="Express">
    ```typescript  theme={"system"}
    import express from 'express';
    import cookieParser from 'cookie-parser';
    import { PrivyClient } from '@privy-io/node';

    const app = express();
    app.use(cookieParser());

    app.get('/api/protected', async (req, res) => {
      try {
        // Get identity token from cookie
        const idToken = req.cookies['privy-id-token'];

        // Or from header if sent that way
        // const idToken = req.headers['privy-id-token'];

        if (!idToken) {
          return res.status(401).json({ message: 'Unauthorized' });
        }

        // Parse and verify the token
        const user = await privy.users().get({ id_token: idToken });

        // Now you can use the user data
        return res.status(200).json({
          userId: user.id,
          // Other user data...
        });
      } catch (error) {
        console.error('Error verifying identity token:', error);
        return res.status(401).json({ message: 'Invalid token' });
      }
    });

    app.listen(3000, () => {
      console.log('Server running on port 3000');
    });
    ```
  </Tab>

  <Tab title="Next.js (Pages Router, server-auth)">
    ```tsx  theme={"system"}
    // pages/api/example.ts
    import type { NextApiRequest, NextApiResponse } from 'next';
    import { getUser } from '@privy-io/server-auth';

    export default async function handler(req: NextApiRequest, res: NextApiResponse) {
      try {
        // Get identity token from cookie
        const idToken = req.cookies['privy-id-token'];

        // Or from header if sent that way
        // const idToken = req.headers['privy-id-token'];

        if (!idToken) {
          return res.status(401).json({ message: 'Unauthorized' });
        }

        // Parse and verify the token
        const user = await getUser({ idToken });

        // Now you can use the user data
        return res.status(200).json({
          userId: user.id,
          // Other user data...
        });
      } catch (error) {
        console.error('Error verifying identity token:', error);
        return res.status(401).json({ message: 'Invalid token' });
      }
    }
    ```
  </Tab>

  <Tab title="Next.js (App Router, server-auth)">
    ```tsx  theme={"system"}
    // app/api/example/route.ts
    import { cookies, headers } from 'next/headers';
    import { getUser } from '@privy-io/server-auth';
    import { NextResponse } from 'next/server';

    export async function GET() {
      try {
        // Get identity token from cookie
        const cookieStore = cookies();
        const idToken = cookieStore.get('privy-id-token')?.value;

        // Or from header if sent that way
        // const headersList = headers();
        // const idToken = headersList.get('privy-id-token');

        if (!idToken) {
          return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
        }

        // Parse and verify the token
        const user = await getUser({ idToken });

        // Now you can use the user data
        return NextResponse.json({
          userId: user.id,
          // Other user data...
        });
      } catch (error) {
        console.error('Error verifying identity token:', error);
        return NextResponse.json({ message: 'Invalid token' }, { status: 401 });
      }
    }
    ```
  </Tab>

  <Tab title="Express (server-auth)">
    ```typescript  theme={"system"}
    import express from 'express';
    import cookieParser from 'cookie-parser';
    import { getUser } from '@privy-io/server-auth';

    const app = express();
    app.use(cookieParser());

    app.get('/api/protected', async (req, res) => {
      try {
        // Get identity token from cookie
        const idToken = req.cookies['privy-id-token'];

        // Or from header if sent that way
        // const idToken = req.headers['privy-id-token'];

        if (!idToken) {
          return res.status(401).json({ message: 'Unauthorized' });
        }

        // Parse and verify the token
        const user = await getUser({ idToken });

        // Now you can use the user data
        return res.status(200).json({
          userId: user.id,
          // Other user data...
        });
      } catch (error) {
        console.error('Error verifying identity token:', error);
        return res.status(401).json({ message: 'Invalid token' });
      }
    });

    app.listen(3000, () => {
      console.log('Server running on port 3000');
    });
    ```
  </Tab>

  <Tab title="Python">
    ```python  theme={"system"}
    from privy import PrivyAPI

    client = PrivyAPI(app_id="your-privy-app-id", app_secret="your-privy-api-key")

    user = client.users.get_by_id_token(id_token)

    print(user)
    ```
  </Tab>
</Tabs>

## Accessing custom metadata

Privy allows you to set [custom metadata](/user-management/users/custom-metadata) for a user via backend API requests. This metadata is available in the `custom_metadata` claim of the identity token.

Here's how to parse and access it:

<CodeGroup>
  ```typescript @privy-io/node theme={"system"}
  import {PrivyClient} from '@privy-io/node';
  import * as jose from 'jose';

  const client = new PrivyClient({appId: '$PRIVY_APP_ID', appSecret: '$PRIVY_APP_SECRET'});

  // Method 1: Using get (recommended)
  async function getUserWithMetadata(idToken: string) {
    const user = await client.users().get({id_token: idToken});
    // Custom metadata is already parsed and available
    return user.custom_metadata;
  }

  // Method 2: Manual parsing
  async function parseCustomMetadata(idToken: string) {
    const verificationKey = await jose.importJWK({}); /* your verification key */

    try {
      const {payload} = await jose.jwtVerify(idToken, verificationKey, {
        issuer: 'privy.io',
        audience: 'your-privy-app-id'
      });

      if (payload && payload.custom_metadata) {
        return JSON.parse(payload.custom_metadata as string);
      }

      return {};
    } catch (error) {
      console.error('Error parsing identity token:', error);
      throw error;
    }
  }
  ```

  ```typescript @privy-io/server-auth theme={"system"}
  import {PrivyClient} from '@privy-io/server-auth';
  import * as jose from 'jose';

  const client = new PrivyClient('$PRIVY_APP_ID', '$PRIVY_APP_SECRET');

  // Method 1: Using getUser (recommended)
  async function getUserWithMetadata(idToken: string) {
    const user = await client.getUser({idToken});
    // Custom metadata is already parsed and available
    return user.customMetadata;
  }

  // Method 2: Manual parsing
  async function parseCustomMetadata(idToken: string) {
    const verificationKey = await jose.importJWK({}); /* your verification key */

    try {
      const {payload} = await jose.jwtVerify(idToken, verificationKey, {
        issuer: 'privy.io',
        audience: 'your-privy-app-id'
      });

      if (payload && payload.custom_metadata) {
        return JSON.parse(payload.custom_metadata as string);
      }

      return {};
    } catch (error) {
      console.error('Error parsing identity token:', error);
      throw error;
    }
  }
  ```
</CodeGroup>

## Refreshing the identity token

A new identity token is automatically issued when a user:

* Authenticates into the application
* Links or unlinks an account
* Refreshes their application page
* Calls `getAccessToken` when the access token is expired

<Tabs>
  <Tab title="React">
    To programmatically refresh the identity token, call `refreshUser` from the `useUser` hook:

    ```tsx  theme={"system"}
    import {useUser} from '@privy-io/react-auth';

    function RefreshButton() {
      const {refreshUser} = useUser();

      return <button onClick={refreshUser}>Refresh User Data</button>;
    }
    ```
  </Tab>

  <Tab title="React Native">
    To programmatically refresh the identity token, call `client.user.get()` from the `usePrivyClient` hook:

    ```tsx  theme={"system"}
    import {usePrivyClient} from '@privy-io/expo';
    import {Button, View} from 'react-native';

    function RefreshButton() {
      const client = usePrivyClient();

      const refreshUser = async () => {
        // Refresh and get the updated user data
        const user = await client.user.get();
      };

      return (
        <View>
          <Button title="Refresh User Data" onPress={refreshUser} />
        </View>
      );
    }
    ```
  </Tab>
</Tabs>

## Verifying the identity token

When your server receives a request with an identity token, you should verify the token's signature to authenticate the user. The preferred way is to use the `getUser` method from `@privy-io/server-auth`, which handles verification and parsing:

<CodeGroup>
  ```typescript @privy-io/node theme={"system"}
  import {PrivyClient} from '@privy-io/node';

  const client = new PrivyClient({appId: '$PRIVY_APP_ID', appSecret: '$PRIVY_APP_SECRET'});

  async function verifyAndGetUser(idToken) {
    try {
      // This verifies the token signature and parses the payload
      const user = await client.users().get({id_token: idToken});
      return user;
    } catch (error) {
      console.error('Invalid identity token:', error);
      throw new Error('Authentication failed');
    }
  }
  ```

  ```typescript @privy-io/server-auth theme={"system"}
  import {PrivyClient} from '@privy-io/server-auth';

  const client = new PrivyClient('$PRIVY_APP_ID', '$PRIVY_APP_SECRET');

  async function verifyAndGetUser(idToken) {
    try {
      // This verifies the token signature and parses the payload
      const user = await client.getUser({idToken});
      return user;
    } catch (error) {
      console.error('Invalid identity token:', error);
      throw new Error('Authentication failed');
    }
  }
  ```
</CodeGroup>

<Info>
  The `verifyAuthToken` method will not work on identity tokens, as it is only used to verify Privy
  access tokens. Always use `get({id_token})` when working with identity tokens.
</Info>

For manual verification without using `get`, you can use JWT libraries like `jose`:

```typescript  theme={"system"}
import * as jose from 'jose';

async function verifyIdentityToken(idToken) {
  // Import the public key
  const publicKey = await jose.importJWK({
    // Your public key in JWK format
  });

  try {
    // Verify the token
    const {payload} = await jose.jwtVerify(idToken, publicKey, {
      issuer: 'privy.io',
      audience: 'your-privy-app-id'
    });

    return payload;
  } catch (error) {
    console.error('Token verification failed:', error);
    throw new Error('Authentication failed');
  }
}
```

## Security considerations

For optimal security when working with identity tokens:

1. **Always verify the token signature** before trusting any claims
2. **Check the expiration time** (`exp` claim) to ensure the token is still valid
3. **Set a base domain** for your application to enable HttpOnly cookies for the identity token
4. **Use HTTPS** for all communication between your frontend and backend
5. **Do not store sensitive information** in custom metadata, as it will be included in the identity token

<Info>Read more about Privy's tokens and their security in our [security guide](/security).</Info>


# Linking accounts to users
Source: https://docs.privy.io/user-management/users/linking-accounts



Developers can use Privy to prompt users to link additional accounts (such as a wallet or Discord profile) at *any point* in their user journey, not just during login.

This is key to Privy's **progressive onboarding**: improving conversion and UX by requiring users to complete onboarding steps (e.g. connecting an account) only when necessary.

<Tabs>
  <Tab title="React">
    The React SDK supports linking all supported account types via our modal-guided link methods.
    **To prompt a user to link an account, use the respective method from the **`useLinkAccount`** hook:**

    | Method          | Description             | User Experience  |
    | --------------- | ----------------------- | ---------------- |
    | `linkEmail`     | Links email address     | Opens modal      |
    | `linkPhone`     | Links phone number      | Opens modal      |
    | `linkWallet`    | Links external wallet   | Opens modal      |
    | `linkGoogle`    | Links Google account    | Direct redirect  |
    | `linkApple`     | Links Apple account     | Direct redirect  |
    | `linkTwitter`   | Links Twitter account   | Direct redirect  |
    | `linkDiscord`   | Links Discord account   | Direct redirect  |
    | `linkGithub`    | Links Github account    | Direct redirect  |
    | `linkLinkedIn`  | Links LinkedIn account  | Direct redirect  |
    | `linkTikTok`    | Links TikTok account    | Direct redirect  |
    | `linkSpotify`   | Links Spotify account   | Direct redirect  |
    | `linkInstagram` | Links Instagram account | Direct redirect  |
    | `linkTelegram`  | Links Telegram account  | Direct redirect  |
    | `linkFarcaster` | Links Farcaster account | Displays QR code |
    | `linkPasskey`   | Links passkey           | Opens modal      |

    <Info>
      Users are only permitted to link **a single account** for a given account type, except for wallets and passkeys. Concretely, a user may link at most one email address, but can link as many wallets and passkeys as they'd like.
    </Info>

        <img src="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/link-email.png?fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=7faa4c7332a637d835b9c04d48f92030" alt="Sample prompt to link a user's email after they have logged in" data-og-width="447" width="447" data-og-height="446" height="446" data-path="images/link-email.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/link-email.png?w=280&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=eaf9ecd4b6284741e0212279d2c52717 280w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/link-email.png?w=560&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=30a3a1d152a247673e5c50eb2c1d46cb 560w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/link-email.png?w=840&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=b041ba683c853ab47f47de7ff8f4933a 840w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/link-email.png?w=1100&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=a1f091071e19ebc5c81214a2e1b751bb 1100w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/link-email.png?w=1650&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=8df8eef7bf75d549500c376161869fb0 1650w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/link-email.png?w=2500&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=25b40342ae1b369a14b82e683f6c4c45 2500w" />

    Below is an example button for prompting a user to link an email to their account:

    ```tsx  theme={"system"}
    import {useLinkAccount} from '@privy-io/react-auth';

    function LinkOptions() {
        const {linkEmail, linkGoogle, linkWallet} = useLinkAccount();

        return (
            <div className="link-options">
                <button onClick={linkEmail}>Link Email to user</button>
                <button onClick={linkGoogle}>Link Google account to user</button>
                <button onClick={linkWallet}>Link Wallet to user</button>
            </div>
        );
    }
    ```

    ### Callbacks

    You can optionally register an `onSuccess` or `onError` callback on the `useLinkAccount` hook.

    ```tsx  theme={"system"}
    const {linkGoogle} = useLinkAccount({
        onSuccess: ({user, linkMethod, linkedAccount}) => {
            console.log('Linked account to user ', linkedAccount);
        },
        onError: (error) => {
            console.error('Failed to link account with error ', error)
        }
    })
    ```

    <ParamField path="onSuccess" type="({user: User, linkMethod: string, linkedAccount: linkedAccount}) => void">
      Optional callback to run after a user successfully links an account.
    </ParamField>

    <ParamField path="onError" type="(error: string) => void">
      Optional callback to run after there is an error during account linkage.
    </ParamField>

    <Info>
      **Looking for whitelabel `link` methods?** Our [`useLoginWith<AccountType>`](/authentication/user-authentication/login-methods/email) hooks allow will link an account to a user, provided that the user is already logged in whenever the authentication flow is completed. For headless wallet linking with `useLinkWithSiwe` or `useLinkWithSiws`, see the [whitelabel user management documentation](/user-management/users/whitelabel#react).
    </Info>
  </Tab>

  <Tab title="React Native">
    **To prompt a user to link an account, use the respective hooks:**

    | Account type | Description             | Hook to invoke                                 |
    | ------------ | ----------------------- | ---------------------------------------------- |
    | `Email`      | Links email address     | `useLinkEmail`                                 |
    | `Phone`      | Links phone number      | `useLinkSms`                                   |
    | `Wallet`     | Links external wallet   | `useLinkWithSiwe`, `useLinkWithSiws`           |
    | `Google`     | Links Google account    | `useLinkWithOAuth`                             |
    | `Apple`      | Links Apple account     | `useLinkWithOAuth`                             |
    | `Twitter`    | Links Twitter account   | `useLinkWithOAuth`                             |
    | `Discord`    | Links Discord account   | `useLinkWithOAuth`                             |
    | `Github`     | Links Github account    | `useLinkWithOAuth`                             |
    | `LinkedIn`   | Links LinkedIn account  | `useLinkWithOAuth`                             |
    | `TikTok`     | Links TikTok account    | `useLinkWithOAuth`                             |
    | `Spotify`    | Links Spotify account   | `useLinkWithOAuth`                             |
    | `Instagram`  | Links Instagram account | `useLinkWithOAuth`                             |
    | `Farcaster`  | Links Farcaster account | `useLinkWithFarcaster`                         |
    | `Passkey`    | Links passkey           | `useLinkPasskey` from `@privy-io/expo/passkey` |

    The steps to implementing the link flows are analogous to the [login hooks `useLoginWith<AccountType`](/authentication/user-authentication/login-methods/email).

    <Info>
      Users are only permitted to link **a single account** for a given account type, except for wallets and passkeys. Concretely, a user may link at most one email address, but can link as many wallets and passkeys as they'd like.
    </Info>
  </Tab>

  <Tab title="Android">
    **To prompt a user to link an account, use the respective methods:**

    | Account type   | Description         | Method         |
    | -------------- | ------------------- | -------------- |
    | `EmailAccount` | Links email address | `linkWithCode` |
    | `PhoneAccount` | Links phone number  | `linkWithCode` |

    The steps to implementing the `linkWithCode` flow are analogous to the [`loginWithCode` flow](/authentication/user-authentication/login-methods/email). The same thing applies for the `PhoneAccount` type, using `privy.sms.linkWithCode` similar to how [`privy.sms.loginWithCode`](/authentication/user-authentication/login-methods/sms) works.

    First, prompt the user for their email address and use the Privy client's `privy.email.sendCode` method to send them a one-time passcode:

    ```kotlin  theme={"system"}
    sendCode(email: String): Result<Unit>
    ```

    ### Link With Code

    Then, prompt the user for the code they received and use the `linkWithCode` method:

    ```kotlin  theme={"system"}
    linkWithCode(code: String, email: String? = null): Result<Unit>
    ```

    <ParamField path="code" type="String" required={true}>
      The one-time passcode sent to the user’s email address.
    </ParamField>

    <ParamField path="email" type="String" required={false}>
      (Optional)  The user’s email address. Though this parameter is optional, it is highly recommended that you pass the user’s email address explicitly. If email is omitted, the email from `sendCode` will be used.
    </ParamField>

    ### Returns

    <ResponseField name="Result<Unit>" type="Result<Unit>">
      A Result object that indicates whether the operation was successful. Returns `Result.success` if the email account was linked successfully, or `Result.failure` if there was an error.
    </ResponseField>

    ## Usage

    ```kotlin  theme={"system"}
    // Send code to user's email
    val sendResult: Result<Unit> = privy.email.sendCode(email = "user_email@gmail.com")

    sendResult.fold(
        onSuccess = {
            // OTP was successfully sent, now prompt user for code
        },
        onFailure = {
            println("Error sending OTP: ${it.message}")
        }
    )

    // Link the email using the code
    val linkResult: Result<Unit> = privy.email.linkWithCode(code = "123456", email = "user_email@gmail.com")

    linkResult.fold(
        onSuccess = {
            println("Email successfully linked!")
            // User linked email
        },
        onFailure = {
            println("Error linking email: ${it.message}")
        }
    )
    ```
  </Tab>

  <Tab title="Swift">
    **To prompt a user to link an account, use the respective methods:**

    | Account type         | Description         | Method         |
    | -------------------- | ------------------- | -------------- |
    | `EmailAccount`       | Links email address | `linkWithCode` |
    | `PhoneNumberAccount` | Links phone number  | `linkWithCode` |

    The steps to implementing the `linkWithCode` flow are analogous to the [`loginWithCode` flow](/authentication/user-authentication/login-methods/email).
    The same thing applies for the `PhoneNumberAccount` type, using `privy.sms.linkWithCode` similar to how [`privy.sms.loginWithCode`](/authentication/user-authentication/login-methods/sms) works.

    First, prompt the user for their email address and use the Privy client's `privy.email.sendCode` method to send them a one-time passcode:

    ```swift  theme={"system"}
    sendCode(to email: String) async throws
    ```

    ### Link With Code

    Then, prompt the user for the code they received and use the `linkWithCode` method:

    ```swift  theme={"system"}
    linkWithCode(_ code: String, sentTo email: String) async throws
    ```

    <ParamField path="code" type="String" required={true}>
      The one-time passcode sent to the user’s email address.
    </ParamField>

    <ParamField path="sentTo" type="String" required={true}>
      The user’s email address.
    </ParamField>

    ### Returns

    Nothing, indicating success.

    ### Throws

    An error if linking the account is unsuccessful.

    ## Usage

    ```swift  theme={"system"}
    // Send code to user's email
    do {
        try await privy.email.sendCode(to: "myuser@privy.io")
        // successfully sent code to users email
    } catch {
        print("error sending code to \(email): \(error)")
    }

    // Link the email using the code
    do {
        try await privy.email.linkWithCode("123456", sentTo: "myuser@privy.io")
        print("Email successfully linked!")
        // user has linked their email!
    } catch {
        print("error linking email: \(error)")
    }
    ```
  </Tab>
</Tabs>


# Allowlist
Source: https://docs.privy.io/user-management/users/managing-users/allowlist



**With Privy, you can enable an allowlist for your application to gate access to specific email addresses, phone numbers, and/or wallet addresses.** You can use the allowlist feature to coordinate a beta launch of your product for early-access users, manage an ongoing waitlist, and more!

When you enable an allowlist for your app:

* All existing users will still be permitted to login to your app
* New users must be added to the allowlist by their email address, phone number, or wallet address to be permitted to login
* New users who have not been added to your allowlist will **not** be permitted to login.

<Note>
  Allowlists apply to email, SMS, wallet, and OAuth methods with verified emails only. Login methods
  like Telegram and Farcaster are not supported.
</Note>

## Enabling the allowlist for your app

You can enable an allowlist directly from the [Privy developer dashboard](https://dashboard.privy.io). To do so, just navigate to the **Users** page > [Access Control](https://dashboard.privy.io/apps/cm7z7tdvm00oxpsqt25bha0tv/users?tab=access-control) tab of the dashboard and toggle allowlists on.

<img src="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Allow.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=3b4ffdce0f7ee57faa679c25ec982af2" alt="images/Allow.png" data-og-width="1843" width="1843" data-og-height="1317" height="1317" data-path="images/Allow.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Allow.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=f81a785712652173e5455fa5de8d715e 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Allow.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=38e0fe821f3c3ec414afd08c56a47a6b 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Allow.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=3153fda8e9bc7f058a630b8c6ae295f9 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Allow.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=a73b89babde69a9b0c0a4759e3d6c1ff 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Allow.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=e10f60fa46de61d6f954b6bdb8b9b182 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Allow.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=a9e1d2ceb3b8272476306f4043611c75 2500w" />

## Managing the allowlist

There are two main ways to manage the allowlist for your app:

* Using the API, you can easily [add users](/user-management/users/managing-users/allowlist#adding-to-the-allow-list), [remove users](/user-management/users/managing-users/allowlist#removing-from-the-allow-list), and [get your current allowlist](/user-management/users/managing-users/allowlist#getting-the-allow-list).
* Using the developer dashboard, you can easily [add and remove users](/user-management/users/managing-users/allowlist#adding-to-the-allow-list) from your app's invite list page.

<Tip>
  It's easy to use the Privy API to manage your waitlist with a third party-tool. For instance, if you are using [Airtable](https://www.airtable.com/) to manage your waitlist, you can easily integrate it with Privy.

  Check out [this guide](/recipes/dashboard/airtable) for more!
</Tip>

## Adding to the allowlist

Privy allows you to easily add a user's email address, phone number, or wallet address to the allowlist for your app.

<Tabs>
  <Tab title="NodeJS (server-auth)">
    Use the `inviteToAllowlist` method to add a user to your allowlist.

    ```tsx  theme={"system"}
    const allowlistEntry = await privy.inviteToAllowlist({
      type: 'email',
      value: 'batman@privy.io'
    });
    ```

    As a parameter to the method, pass an  object with the following fields:

    <ParamField path="type" type="'email' | 'phone' | 'wallet'" required>
      The type of account to add to the allowlist.
    </ParamField>

    <ParamField path="value" type="string" required>
      The identifier of the account to add to the allowlist. Should be the corresponding email address,
      phone number, or wallet address.
    </ParamField>

    If the invitation is successful, the method will return an . If the invitation fails, the method will throw an error.
  </Tab>

  <Tab title="REST API">
    ## Using the REST API

    Make a `POST` request to:

    ```sh  theme={"system"}
    https://auth.privy.io/api/v1/apps/<your-privy-app-id>/allowlist
    ```

    In the body of the request, include the following fields:

    <ParamField path="type" type="'email' | 'phone' | 'wallet'" required>
      The type of account to add to the allowlist.
    </ParamField>

    <ParamField path="value" type="string" required>
      The identifier of the account to add to the allowlist. Should be the corresponding email address,
      phone number, or wallet address.
    </ParamField>

    Below is a sample cURL command for adding an email to the allowlist:

    ```bash  theme={"system"}
    curl --request POST 'https://auth.privy.io/api/v1/apps/<your-privy-app-id>/allowlist' \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H 'Content-Type: application/json' \
    --data-raw '{
        "type": "email",
        "value": "user@email.com"
    }'
    ```

    A successful response will include the new allowlist entry, like below

    ```json  theme={"system"}
    {
      "id": "allowlist-entry-ID",
      "type": "wallet",
      "value": "0xab5801a7d398351b8be11c439e05c5b3259aec9b",
      "appId": "your-privy-app-ID"
    }
    ```
  </Tab>
</Tabs>

## Removing from the allowlist

Privy allows you to easily remove a user's email address, phone number, or wallet address to the allowlist for your app.

<Tabs>
  <Tab title="NodeJS (server-auth)">
    Use the 's  method to remove a user from your allowlist.

    ```tsx  theme={"system"}
    const removedAllowlistEntry = await privy.removeFromAllowlist({
      type: 'email',
      value: 'batman@privy.io'
    });
    ```

    As a parameter to the method, pass an  object with the following fields:

    <ParamField path="type" type="'email' | 'phone' | 'wallet'" required>
      The type of account to remove from the allowlist.
    </ParamField>

    <ParamField path="value" type="string" required>
      The identifier of the account to remove from the allowlist. Should be the corresponding email
      address, phone number, or wallet address.
    </ParamField>

    If the invitation is successful, the method will return an  that represents the now-deleted allowlist entry. If the invitation fails, the method will throw an error.
  </Tab>

  <Tab title="REST API">
    Make a `DELETE` request to:

    ```sh  theme={"system"}
    https://auth.privy.io/api/v1/apps/<your-privy-app-id>/allowlist
    ```

    In the body of the request, include the following fields:

    <ParamField path="type" type="'email' | 'phone' | 'wallet'" required>
      The type of account to remove from the allowlist.
    </ParamField>

    <ParamField path="value" type="string" required>
      The identifier of the account to remove from the allowlist. Should be the corresponding email
      address, phone number, or wallet address.
    </ParamField>

    Below is a sample cURL command for deleting an email from the allowlist:

    ```bash  theme={"system"}
    curl --request DELETE 'https://auth.privy.io/api/v1/apps/<your-privy-app-id>/allowlist' \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H 'Content-Type: application/json' \
    --data-raw '{
      "type": "email",
      "value": "user@email.com"
    }'
    ```

    A successful response will include a message, such as:

    ```json  theme={"system"}
    {
      "message": "Successfully deleted from allowlist"
    }
    ```

    If there is no corresponding allowlist entry for the invited account you attempted to delete, the response will include an error.
  </Tab>
</Tabs>

<Info>
  If a user has successfully logged into your application (e.g. after having been added to the allow
  list), you must [delete their user object](/user-management/users/managing-users/deleting-users),
  rather than deleting their allowlist entry—to revoke their access.
</Info>

***

# Getting the allowlist

Privy allows you to easily get the current allowlist for your app.

<Tabs>
  <Tab title="NodeJS (server-auth)">
    Use the 's  method to get your app's current allowlist. Pass no parameters to this method.

    ```tsx  theme={"system"}
    const allowlistEntry = await privy.getAllowlist();
    ```

    If the request is successful, the method will return an array of  objects. These include a `type` describing the type of entry (`'email'`, `'phone'`, or `'wallet'`) and a `value` with the corresponding account identifier (e.g. the email address).
  </Tab>

  <Tab title="REST API">
    Make a `GET` request to:

    ```
    https://auth.privy.io/api/v1/apps/<your-privy-app-id>/allowlist
    ```

    Below is a sample cURL command for getting your current allowlist:

    ```bash  theme={"system"}
    curl --request GET 'https://auth.privy.io/api/v1/apps/<your-privy-app-id>/allowlist' \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>"
    ```

    A successful response will include an array of your current allowlist entries, like below:

    ```json  theme={"system"}
    [
      {
        "id": "allowlist-entry-ID",
        "type": "wallet",
        "value": "0xab5801a7d398351b8be11c439e05c5b3259aec9b",
        "appId": "your-privy-app-ID"
      },
      {
        "id": "allowlist-entry-ID",
        "type": "email",
        "value": "user@email.com",
        "appId": "your-privy-app-ID"
      }
      // ...
    ]
    ```
  </Tab>
</Tabs>

***

# Customizing allowlist rejection

If your app has an allowlist enabled, new users who attempt to login with an account not in your allowlist will not be permitted to login to your app.

**You can customize the screen shown to the user when they are denied permission to login, to help contextualize the allowlist within your app.**

To customize this screen, make a `POST` request to

```
https://auth.privy.io/api/v1/apps/<your-privy-app-id>
```

In the body of the request, include an field that contains a JSON with the following fields. All fields in this object are optional.

<ParamField path="error_title" type="string">
  The primary text for the error message you'd like to show your user. Defaults to "You don't have
  access to this app".
</ParamField>

<ParamField path="error_detail" type="string">
  The secondary text for the error message you'd like to show your user. Defaults to "Have you been
  invited?"
</ParamField>

<ParamField path="cta_text" type="string">
  The text to show on the error confirmation button. Defaults to "Try another account"
</ParamField>

<ParamField path="cta_link" type="string">
  The URL to navigate the user to, when they click the error CTA. Defaults to just closing the
  screen on click, instead of navigating the user to another URL.
</ParamField>

Below is a sample cURL command for updating the allowlist config:

```bash  theme={"system"}
curl --request POST 'https://auth.privy.io/api/v1/apps/<your-privy-app-id>' \
-u "<your-privy-app-id>:<your-privy-app-secret>" \
-H "privy-app-id: <your-privy-app-id>" \
-H 'Content-Type: application/json' \
--data-raw '{
  "allowlist_config": {
    "error_title": "Insert your error title",
    "error_detail": "Insert your error detail",
    "cta_text": "Insert your error CTA",
    "cta_link": "Insert a URL to navigate the user to when clicking the CTA"
  }
}'
```


# Deleting users
Source: https://docs.privy.io/user-management/users/managing-users/deleting-users



Privy allows you to delete users via their Privy user ID. This is a destructive action: if the user logs into your app again, they will have a new user ID, will create a new embedded wallet address, and will have to relink any formerly linked accounts.

<Warning>
  **Please take extreme care when deleting users.** For security of user assets, Privy does not
  delete the embedded wallet, and instead "soft deletes" it by disassociating it from the deleted
  user and archiving the data. If the user still has access to their login method, their wallet can
  be recovered after deletion. Reprovisioning a deleted wallet involves a support process, so please
  take care to only delete users that you intend to delete.
</Warning>

<Tabs>
  <Tab title="NodeJS">
    Use the **`PrivyClient`**'s **`delete`** method from the `users()` interface to delete a user. As a parameter, pass the user's Privy ID as a `string`:

    ```ts  theme={"system"}
    await privy.users().delete('insert-user-id');
    ```

    ### Complete Example

    ```ts  theme={"system"}
    import { PrivyClient } from '@privy-io/node';

    const privy = new PrivyClient({
      appId: process.env.PRIVY_APP_ID,
      appSecret: process.env.PRIVY_APP_SECRET
    });

    async function deletePrivyUser(id: string) {
      try {
        await privy.users().delete(id);
        console.log(`User ${id} successfully deleted`);
        return true;
      } catch (error) {
        console.error(`Failed to delete user: ${error.message}`);
        return false;
      }
    }
    ```

    This method will throw an error if the deletion operation failed (e.g. due to an invalid Privy ID).
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    Use the **`PrivyClient`**'s **`deleteUser`** method to delete a user. As a parameter, pass the user's Privy DID as a `string`:

    ```ts  theme={"system"}
    await privy.deleteUser('did:privy:XXXXXX');
    ```

    ### Complete Example

    ```ts  theme={"system"}
    import { PrivyClient } from '@privy-io/server-auth';

    const privy = new PrivyClient(
      process.env.PRIVY_APP_ID,
      process.env.PRIVY_APP_SECRET
    );

    async function deletePrivyUser(did: string) {
      try {
        await privy.deleteUser(did);
        console.log(`User ${did} successfully deleted`);
        return true;
      } catch (error) {
        console.error(`Failed to delete user: ${error.message}`);
        return false;
      }
    }
    ```

    This method will throw an error if the deletion operation failed (e.g. due to an invalid Privy DID).
  </Tab>

  <Tab title="REST API">
    Make a `DELETE` request to:

    ```sh  theme={"system"}
    https://auth.privy.io/api/v1/users/<did>
    ```

    Replace `<did>` with your user's Privy DID. It should have the format `did:privy:XXXXXX`.

    ### Request

    <ParamField path="Authentication" type="Basic Auth">
      Use your Privy app ID as the username and your Privy app secret as the password.
    </ParamField>

    <ParamField path="Headers" type="Object">
      <ParamField path="privy-app-id" type="string" required>
        Your Privy app ID.
      </ParamField>
    </ParamField>

    ### Example

    Below is a sample cURL command for deleting the user object associated with a Privy DID:

    ```bash  theme={"system"}
    curl --request DELETE https://auth.privy.io/api/v1/users/<user-did> \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>"
    ```

    ### Response

    <ResponseField name="Status Code" type="number">
      <ResponseField name="204 No Content">
        The user was successfully deleted.
      </ResponseField>

      <ResponseField name="404 Not Found">
        There is no user associated with the provided Privy DID.
      </ResponseField>
    </ResponseField>
  </Tab>

  <Tab title="Rust">
    Use the **`PrivyClient`**'s **`delete`** method from the `users()` interface to delete a user. As a parameter, pass the user's Privy ID as a `string`:

    ```rust  theme={"system"}
    use privy_rs::PrivyClient;

    let client = PrivyClient::new(app_id, app_secret)?;
    client.users().delete("insert-user-id").await?;
    ```

    ### Complete Example

    ```rust  theme={"system"}
    use privy_rs::PrivyClient;

    async fn delete_privy_user(
        client: &PrivyClient,
        user_id: &str,
    ) -> Result<(), Box<dyn std::error::Error>> {
        match client.users().delete(user_id).await {
            Ok(_) => {
                println!("User {} successfully deleted", user_id);
                Ok(())
            }
            Err(error) => {
                eprintln!("Failed to delete user: {}", error);
                Err(error.into())
            }
        }
    }

    // Usage
    let client = PrivyClient::new(app_id, app_secret)?;
    delete_privy_user(&client, "cmf56qacr01qpl90brxql83lx").await?;
    ```

    This method will return an error if the deletion operation failed (e.g. due to an invalid Privy ID).
  </Tab>

  <Tab title="Dashboard">
    The Privy Dashboard provides a simple interface to delete users when necessary.

    ## Steps to delete a user

    1. Log in to the [Privy Dashboard](https://dashboard.privy.io/)
    2. Navigate to the **Users** page for your app
    3. Search for the user you wish to delete
    4. Click on the user to open the user drawer
    5. Scroll to the bottom of the user drawer
    6. Click the **Delete User** button
    7. Confirm the deletion in the confirmation dialog

    <Warning>
      This action cannot be undone. Once a user is deleted:

      * If they log in again, they will get a new DID
      * They will need to relink any accounts
      * They will get a new embedded wallet address
      * Any data associated with their previous DID will be inaccessible
    </Warning>
  </Tab>
</Tabs>


# Denylist
Source: https://docs.privy.io/user-management/users/managing-users/denylist



Privy allows your app to enable a **denylist** to block specific users from logging in to your app and creating accounts. You can use the denylist to block users who have previously been malicious in your application or who violate your terms of service.

Currently, Privy denylists support blocking users based on their **email address, phone number, EVM wallet address or Solana wallet address**. You can choose to either block a specific email address (e.g. `bruce@wayneenterprises.com`) or an email domain (e.g. `@wayneenterprises.com`).

<Note>
  Denylists apply to email, SMS, wallet, and OAuth methods with verified emails only. Login methods
  like Telegram and Farcaster are not supported.
</Note>

## Enabling the denylist for your app

You can enable an denylist directly from the [Privy developer dashboard](https://dashboard.privy.io). To do so, just navigate to the **Users** page > [Access Control](https://dashboard.privy.io/apps/cm7z7tdvm00oxpsqt25bha0tv/users?tab=access-control) tab of the dashboard and toggle denylists on.

<img src="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Deny.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=d21b5e4f18503ad4454191ea867034ed" alt="images/Deny.png" data-og-width="1843" width="1843" data-og-height="1317" height="1317" data-path="images/Deny.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Deny.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=058513f409e374c02de352b468e9cc24 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Deny.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=b86e4959273288c5e38393eaf0c686d2 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Deny.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=033ba0e019cad3a6478f11dacbd9029b 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Deny.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=3de9eb1b417847f77a288f41429ac186 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Deny.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=d7c9f2e49870af146853ddbfd51c8108 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Deny.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=ede2e46dd70ea7cf23a2487425984e75 2500w" />

## Managing the denylist

There are two main ways to manage the denylist for your app:

* Using the API, you can easily [add entries](/user-management/users/managing-users/denylist#adding-to-the-deny-list), [remove entries](/user-management/users/managing-users/denylist#removing-from-the-deny-list), and [get your current denylist](/user-management/users/managing-users/denylist#getting-the-deny-list).
* Using the developer dashboard, you can easily [add and remove entries](/user-management/users/managing-users/denylist#adding-to-the-deny-list) from your app's denylist.

## Adding to the denylist

<Info>If you do not have a denylist enabled for your app, this request will fail.</Info>

Privy allows you to easily add an individual email address, phone number, EVM wallet address or Solana wallet address to your denylist.

To add an entry to the denylist, make a `POST` request to:

```sh  theme={"system"}
https://auth.privy.io/api/v1/apps/<your-privy-app-id>/denylist
```

In the body of the request, include the following fields:

<ParamField path="type" type="'email' | 'emailDomain' | 'phoneNumber' | 'ethereumAddress' | 'solanaAddress'" required>
  Specifies that the request adds an email address, email domain, phone number, EVM wallet address
  or Solana wallet address to the denylist.
</ParamField>

<ParamField path="value" type="string" required>
  The email address, email domain, phone number, EVM wallet address or Solana wallet address to add
  to the denylist.
</ParamField>

Below is a sample cURL command for adding an email to the denylist:

```bash  theme={"system"}
curl --request POST 'https://auth.privy.io/api/v1/apps/<your-privy-app-id>/denylist' \
-u "<your-privy-app-id>:<your-privy-app-secret>" \
-H "privy-app-id: <your-privy-app-id>" \
-H "Content-Type: application/json" \
--data-raw '{
  "type": "email",
  "value": "user@email.com"
}'
```

A successful response will include the new denylist entry, like below

```json  theme={"system"}
{
  "id": "denylist-entry-ID",
  "rule_type": "email",
  "value": "user@email.com"
}
```

***

# Removing from the denylist

<Info>If you do not have a denylist enabled for your app, this request will fail.</Info>

To delete an entry from the denylist, make a `DELETE` request to:

```sh  theme={"system"}
https://auth.privy.io/api/v1/apps/<your-privy-app-id>/denylist
```

In the body of the request, include the following fields:

<ParamField path="id" type="string" required>
  The ID of the denylist entry to be removed. You can obtain this ID by [getting your current deny
  list](/user-management/users/managing-users/denylist).
</ParamField>

Below is a sample cURL command for deleting an email from the denylist:

```bash  theme={"system"}
curl --request DELETE 'https://auth.privy.io/api/v1/apps/<your-privy-app-id>/denylist' \
-u "<your-privy-app-id>:<your-privy-app-secret>" \
-H "privy-app-id: <your-privy-app-id>" \
-H "Content-Type: application/json" \
--data-raw '{
  "id": "clpa828s4001hl90f6dxoksrg",
}'
```

A successful request will return response code `204`. If there is no corresponding denylist entry, the response will include an error.

***

# Getting the denylist

To get your current denylist, make a `GET` request to:

```sh  theme={"system"}
https://auth.privy.io/api/v1/apps/<your-privy-app-id>/denylist
```

This is a paginated query, and the API will return up to 1000 denylist entries for a single request.

## Parameters

In the **request query parameters**, specify the following fields:

<ParamField path="cursor" type="string">
  When you request a batch of denylist entries from Privy, the API will return a cursor for the *next* batch of denylist entries in the `next_cursor` field of the [response](#response). This will be a denylist ID, which is a `string`.

  If you are requesting the *first* batch of denylist entries for your app, do not include a `cursor` in your request parameters.

  If you have already requested a batch of denylist entries and want to request the next batch, set the `cursor` in your request parameters to be the `next_cursor` returned by the API in your previous query. If the provided `cursor` is not a valid denylist ID, the API will return an error.
</ParamField>

<ParamField path="limit" type="number">
  The number of users you would like the API to return. Defaults to 1000.
</ParamField>

As an example, to get the first 1000 denylist entries for your app, you should include *no* URL query parameters:

```sh  theme={"system"}
curl --request GET https://auth.privy.io/api/v1/apps/<your-privy-app-id>/denylist \
-u "<your-privy-app-id>:<your-privy-app-secret>" \
-H "privy-app-id: <your-privy-app-id>"
```

Then, to get the *next* 1000 denylist entries for your app, you should pass the `next_cursor` field of the last response as the `cursor` in your request query parameters:

```sh  theme={"system"}
# Replace <insert-cursor> below with the `next_cursor` returned by the last query
curl --request GET https://auth.privy.io/api/v1/apps/<your-privy-app-id>/denylist?cursor=<insert-cursor> \
-u "<your-privy-app-id>:<your-privy-app-secret>" \
-H "privy-app-id: <your-privy-app-id>"
```

## Response

A successful response will include:

<ResponseField type="array">The denylist entries as an array</ResponseField>

<ResponseField type="string">The cursor to be used in your next request to this API</ResponseField>

Below is an example:

<Expandable title="child attributes" defaultOpen="true">
  ```json  theme={"system"}
  {
    "data": [
      {
        "id": "denylist-entry-ID1",
        "rule_type": "email",
        "value": "user@email.com"
      },
      {
        "id": "denylist-entry-ID2",
        "rule_type": "emailDomain",
        "value": "email.com"
      }
      // ...
    ],
    "next_cursor": "denylist-entry-ID2"
  }
  ```
</Expandable>

If you need to [remove an entry](/user-management/users/managing-users/denylist#removing-from-the-deny-list) from your denylist, you will need the `id` field returned in this API response.


# null
Source: https://docs.privy.io/user-management/users/managing-users/querying-users



Privy supports multiple ways to fetch and manage users in your application.

<Tabs>
  <Tab title="NodeJS">
    ## Querying users by identity token

    <Tip>
      Using identity tokens is the recommended way to query user information about authenticated users
      in your backend. If you need user data about unauthenticated users, you can use the `_get`
      method by passing in a user's DID.
    </Tip>

    Use the `get` method to get a single user by their identity token passed from the client, to learn more about identity tokens, see [identity tokens](/user-management/users/identity-tokens).

    ```typescript  theme={"system"}
    const user = await privy.users().get({id_token: 'your-id_token'});
    ```

    ## Querying users by ID

    To get a user by their Privy ID, call the `.users()._get()` method on the `PrivyClient`.

    ```ts  theme={"system"}
    try {
      const user = privyClient.users()._get('insert-user-id');
    } catch (error) {
      console.error(error);
    }
    ```

    Check out the [API reference](/api-reference/users/get) for more details on the available parameters and returns.

    ## Querying for all users

    To get all users for your app, call the `.users().list()` method on the `PrivyClient`.

    <CodeGroup>
      ```ts Automatic pagination theme={"system"}
      try {
        for await (const user of privyClient.users().list()) {
          console.log(user.id);
        }
      } catch (error) {
        console.error(error);
      }
      ```

      ```ts Manual pagination theme={"system"}
      try {
        const usersPage = await privyClient.users().list({
          // Optional params
          // cursor: '<cursor>',
          // limit: 100,
        });

        const users = usersPage.data;

        if (usersPage.hasNextPage()) {
          const nextPage = await usersPage.getNextPage();
          const nextUsers = nextPage.data;
          expect(nextUsers.length).toBeGreaterThan(0);
        }
      } catch (error) {
          console.error(error);
      }
      ```
    </CodeGroup>

    Check out the [API reference](/api-reference/users/get-all) for more details on the available parameters and returns.

    ## Querying for users by account data

    <AccordionGroup>
      <Accordion title="By email address">
        ```ts  theme={"system"}
        try {
          const user = await privy.users().getByEmailAddress({ address: 'batman@privy.io' });
        } catch (error) {
          console.error(error);
        }
        ```
      </Accordion>

      <Accordion title="By phone number">
        ```ts  theme={"system"}
        try {
          const user = await privy.users().getByPhoneNumber({ number: '+1 555 555 5555' });
        } catch (error) {
          console.error(error);
        }
        ```
      </Accordion>

      <Accordion title="By wallet address">
        ```ts  theme={"system"}
        try {
          const user = await privy.users().getByWalletAddress({ address: '0x1234567890' });
        } catch (error) {
          console.error(error);
        }
        ```
      </Accordion>

      <Accordion title="By smart wallet address">
        ```ts  theme={"system"}
        try {
          const user = await privy.users().getBySmartWalletAddress({ address: '0x1234567890' });
        } catch (error) {
          console.error(error);
        }
        ```
      </Accordion>

      <Accordion title="By custom auth ID">
        ```ts  theme={"system"}
        try {
          const user = await privy.users().getByCustomAuthID({ custom_user_id: 'insert-custom-auth-id' });
        } catch (error) {
          console.error(error);
        }
        ```
      </Accordion>

      <Accordion title="By Farcaster ID">
        ```ts  theme={"system"}
        try {
          const user = await privy.users().getByFarcasterID({ fid: 1234 });
        } catch (error) {
          console.error(error);
        }
        ```
      </Accordion>

      <Accordion title="By Twitter subject">
        ```ts  theme={"system"}
        try {
          const user = await privy.users().getByTwitterSubject({ subject: 'insert-twitter-subject' });
        } catch (error) {
          console.error(error);
        }
        ```
      </Accordion>

      <Accordion title="By Twitter username">
        ```ts  theme={"system"}
        try {
          const user = await privy.users().getByTwitterUsername({ username: 'batman' });
        } catch (error) {
          console.error(error);
        }
        ```
      </Accordion>

      <Accordion title="By Discord username">
        ```ts  theme={"system"}
        try {
          const user = await privy.users().getByDiscordUsername({ username: 'batman' });
        } catch (error) {
          console.error(error);
        }
        ```
      </Accordion>

      <Accordion title="By Telegram User ID">
        ```ts  theme={"system"}
        try {
          const user = await privy.users().getByTelegramUserID({ telegram_user_id: 'insert-telegram-user-id' });
        } catch (error) {
          console.error(error);
        }
        ```
      </Accordion>

      <Accordion title="By Telegram username">
        ```ts  theme={"system"}
        try {
          const user = await privy.users().getByTelegramUsername({ username: 'batman' });
        } catch (error) {
          console.error(error);
        }
        ```
      </Accordion>

      <Accordion title="By GitHub username">
        ```ts  theme={"system"}
        try {
          const user = await privy.users().getByGitHubUsername({ username: 'batman' });
        } catch (error) {
          console.error(error);
        }
        ```
      </Accordion>
    </AccordionGroup>
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    ## Querying users by identity token

    <Tip>
      Using identity tokens is the recommended way to query user information about authenticated users in your backend. If you need user data about unauthenticated users, you can use the `getUsers` method by passing in a user's DID.
    </Tip>

    Use the `getUser` method to get a single user by their identity token passed from the client, to learn more about identity tokens, see [identity tokens](/user-management/users/identity-tokens).

    ```typescript  theme={"system"}
    const user = await privy.getUser({idToken: 'your-idToken'});
    ```

    ## Other ways to query users

    <Warning>
      Privy rate limits REST API endpoints that you may call from your server. If you're looking to get
      information about an authenticated user, consider using [identity
      tokens](/user-management/users/identity-tokens) as a more secure and efficient way to access user
      data.
    </Warning>

    ### Querying users by ID

    Use the `getUser` method to get a single user by their Privy DID:

    ```typescript  theme={"system"}
    const user = await privy.getUserById('did:privy:XXXXXX');
    ```

    ### Querying for all users

    Use the `getUsers` method to get a list of all your users:

    ```typescript  theme={"system"}
    const users = await privy.getUsers();
    ```

    <Note>
      The `getUsers` method automatically handles pagination and includes built-in exponential backoff to manage rate limits.
    </Note>

    ### Querying for users by account data

    <AccordionGroup>
      <Accordion title="By email address">
        Use the `getUserByEmail` method to get a user by their email address:

        ```typescript  theme={"system"}
        const user = await privy.getUserByEmail('user@gmail.com');
        ```
      </Accordion>

      <Accordion title="By phone number">
        Use the `getUserByPhoneNumber` method to get a user by their phone number:

        ```typescript  theme={"system"}
        const user = await privy.getUserByPhoneNumber('+1 555 555 5555');
        ```
      </Accordion>

      <Accordion title="By wallet address">
        Use the `getUserByWalletAddress` method to get a user by their wallet address:

        ```typescript  theme={"system"}
        const user = await privy.getUserByWalletAddress('0xABCDEFGHIJKL01234567895C5cAe8B9472c14328');
        ```
      </Accordion>

      <Accordion title="By smart wallet address">
        Use the `getUserBySmartWalletAddress` method to get a user by their smart wallet address:

        ```typescript  theme={"system"}
        const user = await privy.getUserBySmartWalletAddress('0xABCDEFGHIJKL01234567895C5cAe8B9472c14328');
        ```
      </Accordion>

      <Accordion title="By custom auth ID">
        Use the `getUserByCustomAuthId` method to get a user by their custom auth ID:

        ```typescript  theme={"system"}
        const user = await privy.getUserByCustomAuthId('123');
        ```
      </Accordion>

      <Accordion title="By Farcaster fid">
        Use the `getUserByFarcasterId` method to get a user by their Farcaster fid:

        ```typescript  theme={"system"}
        const user = await privy.getUserByFarcasterId(1402);
        ```
      </Accordion>

      <Accordion title="By Twitter subject">
        Use the `getUserByTwitterSubject` method to get a user by their Twitter subject:

        ```typescript  theme={"system"}
        const user = await privy.getUserByTwitterSubject('456');
        ```
      </Accordion>

      <Accordion title="By Twitter username">
        Use the `getUserByTwitterUsername` method to get a user by their Twitter username:

        ```typescript  theme={"system"}
        const user = await privy.getUserByTwitterUsername('batman');
        ```
      </Accordion>

      <Accordion title="By Discord username">
        Use the `getUserByDiscordUsername` method to get a user by their Discord username:

        ```typescript  theme={"system"}
        const user = await privy.getUserByDiscordUsername('batman');
        ```
      </Accordion>

      <Accordion title="By Telegram User ID">
        Use the `getUserByTelegramUserId` method to get a user by their Telegram User ID:

        ```typescript  theme={"system"}
        const user = await privy.getUserByTelegramUserId('456');
        ```
      </Accordion>

      <Accordion title="By Telegram username">
        Use the `getUserByTelegramUsername` method to get a user by their Telegram username:

        ```typescript  theme={"system"}
        const user = await privy.getUserByTelegramUsername('batman');
        ```
      </Accordion>
    </AccordionGroup>
  </Tab>

  <Tab title="Python">
    ## Querying users by identity token

    <Tip>
      Using identity tokens is the recommended way to query user information about authenticated users in your backend. If you need user data about unauthenticated users, you can use the `get` method by passing in a user's DID.
    </Tip>

    Use the `get_by_id_token` method to get a single user by their identity token passed from the client, to learn more about identity tokens, see [identity tokens](/user-management/users/identity-tokens).

    ```python  theme={"system"}
    user = privy.users.get_by_id_token(id_token="your-idToken")
    ```

    ## Other ways to query users

    <Warning>
      Privy rate limits REST API endpoints that you may call from your server. If you're looking to get
      information about an authenticated user, consider using [identity
      tokens](/user-management/users/identity-tokens) as a more secure and efficient way to access user
      data.
    </Warning>

    ### Querying users by ID

    Use the `get` method to get a single user by their Privy DID:

    ```python  theme={"system"}
    user = privy.users.get(user_id="did:privy:XXXXXX")
    ```

    ### Querying for all users

    Use the `list` method to get a list of all your users:

    ```python  theme={"system"}
    users = privy.users.list()
    ```

    <Note>
      The `list` method automatically handles pagination.
    </Note>

    ### Querying for users by account data

    <AccordionGroup>
      <Accordion title="By email address">
        Use the `get_by_email_address` method to get a user by their email address:

        ```python  theme={"system"}
        user = privy.users.get_by_email_address(address="user@gmail.com")
        ```
      </Accordion>

      <Accordion title="By wallet address">
        Use the `get_by_wallet_address` method to get a user by their wallet address:

        ```python  theme={"system"}
        user = privy.users.get_by_wallet_address(address="0xABCDEFGHIJKL01234567895C5cAe8B9472c14328")
        ```
      </Accordion>

      <Accordion title="By custom auth ID">
        Use the `get_by_jwt_subject_id` method to get a user by their custom auth ID:

        ```python  theme={"system"}
        user = privy.users.get_by_jwt_subject_id(custom_user_id="123")
        ```
      </Accordion>
    </AccordionGroup>
  </Tab>

  <Tab title="Java">
    ## Querying users by ID

    To get a user by their Privy DID, call the `.users().retrieve()` method on the `PrivyClient`.

    ```java  theme={"system"}
    try {
        UserRetrieveResponse response = privyClient.users().retrieve("<did>");
        if (response.user().isPresent()) {
            User user = response.user().get();
        }
    } catch (APIException e) {
        String errorBody = e.bodyAsString();
        System.err.println(errorBody);
    } catch (Exception e) {
        System.err.println(e.getMessage());
    }
    ```

    ### Parameters

    <ParamField path="userId" type="String" required>
      The user's Privy DID (i.e., `did:privy:XXXXXX`).
    </ParamField>

    ### Returns

    The `UserRetrieveResponse` object contains an optional `user()` field, present if the user was
    retrieved successfully.

    <ResponseField name="user()" type="Optional<User>">
      The retrieved `User` object. See the [user object](/user-management/users/the-user-object) for
      more details.
    </ResponseField>

    ## Querying for all users

    To get all users for your app, call the `.users().list()` method on the `PrivyClient`.

    ```java  theme={"system"}
    try {
        UserListRequestBody requestBody = UserListRequestBody.builder()

        UserListResponse response = privyClient
            .users()
            .list()
            // .cursor("<cursor>") // Optional
            // .limit(100) // Optional
            .call();

        if (response.object().isPresent()) {
            List<User> users = response.object().get().data();
        }
    } catch (APIException e) {
        String errorBody = e.bodyAsString();
        System.err.println(errorBody);
    } catch (Exception e) {
        System.err.println(e.getMessage());
    }
    ```

    ### Parameters

    <ParamField path=".cursor()" type="string">
      Cursor for pagination. Use the `next_cursor` from the previous response.
    </ParamField>

    <ParamField path=".limit()" type="number">
      Number of users to return per request. Defaults to 100.
    </ParamField>

    ### Returns

    The `UserListResponse` object contains an optional `object()` field, present if the users were
    retrieved successfully.

    <ResponseField name="object()" type="Optional<UserListResponseBody>">
      The retrieved `UserListResponseBody` object.

      <Expandable defaultOpen="true">
        <ResponseField name="data()" type="List<User>">
          The list of users.
        </ResponseField>

        <ResponseField name="nextCursor()" type="Optional<String>">
          Cursor to use for the next batch of users.
        </ResponseField>
      </Expandable>
    </ResponseField>

    ## Querying for users by account data

    <AccordionGroup>
      <Accordion title="By email address">
        To get a user by their email address, call the `.users().retrieveByEmailAddress()` method on the
        `PrivyClient`.

        ```java  theme={"system"}
        try {
            UserRetrieveByEmailAddressRequestBody request = UserRetrieveByEmailAddressRequestBody.builder()
                .address("user@gmail.com")
                .build();

            UserRetrieveByEmailAddressResponse response = privyClient
                .users()
                .retrieveByEmailAddress(request);

            if (response.user().isPresent()) {
                User user = response.user().get();
            }
        } catch (APIException e) {
            String errorBody = e.bodyAsString();
            System.err.println(errorBody);
        } catch (Exception e) {
            System.err.println(e.getMessage());
        }
        ```

        ### Parameters

        You can specify the following values on the `UserRetrieveByEmailAddressRequestBody` builder:

        <ParamField path=".address()" type="String" required>
          Email address of the user.
        </ParamField>

        ### Returns

        The `UserRetrieveByEmailAddressResponse` object contains an optional `user()` field, present if the user was retrieved successfully.

        <ResponseField name="user()" type="Optional<User>">
          The retrieved `User` object. See the [user object](/user-management/users/the-user-object) for
          more details.
        </ResponseField>
      </Accordion>

      <Accordion title="By custom auth ID">
        To get a user by their custom auth ID, call the `.users().retrieveByCustomAuthId()` method on the
        `PrivyClient`.

        ```java  theme={"system"}
        try {
            UserRetrieveByCustomAuthIdRequestBody request = UserRetrieveByCustomAuthIdRequestBody.builder()
                .customUserId("123")
                .build();

            UserRetrieveByCustomAuthIdResponse response = privyClient
                .users()
                .retrieveByCustomAuthId(request);

            if (response.user().isPresent()) {
                User user = response.user().get();
            }
        } catch (APIException e) {
            String errorBody = e.bodyAsString();
            System.err.println(errorBody);
        } catch (Exception e) {
            System.err.println(e.getMessage());
        }
        ```

        ### Parameters

        You can specify the following values on the `UserRetrieveByCustomAuthIdRequestBody` builder:

        <ParamField path=".customUserId()" type="String" required>
          Custom user ID provided by your authentication system.
        </ParamField>

        ### Returns

        The `UserRetrieveByCustomAuthIdResponse` object contains an optional `user()` field, present if the user was retrieved successfully.

        <ResponseField name="user()" type="Optional<User>">
          The retrieved `User` object. See the [user object](/user-management/users/the-user-object) for
          more details.
        </ResponseField>
      </Accordion>
    </AccordionGroup>
  </Tab>

  <Tab title="REST API">
    ## Querying users by ID

    To get a user by their Privy DID, make a `GET` request to:

    ```bash  theme={"system"}
    https://auth.privy.io/api/v1/users/<did>
    ```

    ### Parameters

    <ParamField query="did" type="string" required>
      The user's Privy DID (e.g., `did:privy:XXXXXX`).
    </ParamField>

    ### Sample request

    ```bash  theme={"system"}
    curl --request GET https://auth.privy.io/api/v1/users/<user-did> \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>"
    ```

    ## Querying for all users

    To get all users for your app, make a `GET` request to:

    ```bash  theme={"system"}
    https://auth.privy.io/api/v1/users
    ```

    ### Parameters

    <ParamField query="cursor" type="string">
      Cursor for pagination. Use the `next_cursor` from the previous response.
    </ParamField>

    <ParamField query="limit" type="number">
      Number of users to return per request. Defaults to 100.
    </ParamField>

    ### Response

    The response will include:

    * `data`: Array of user objects
    * `next_cursor`: Cursor to use for the next batch of users

    ### Sample request

    ```bash  theme={"system"}
    # First batch of users
    curl --request GET https://auth.privy.io/api/v1/users \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>"

    # Subsequent batches using cursor
    curl --request GET https://auth.privy.io/api/v1/users?cursor=<next_cursor> \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>"
    ```

    ## Querying for users by account data

    <AccordionGroup>
      <Accordion title="By email address">
        To get a user by their email address, make a `POST` request to:

        ```bash  theme={"system"}
        https://auth.privy.io/api/v1/users/email/address
        ```

        ### Body

        <ParamField body="address" type="string" required>
          Email address of the user.
        </ParamField>

        ### Sample request

        ```bash  theme={"system"}
        curl --request POST "https://auth.privy.io/api/v1/users/email/address" \
        -u "<your-privy-app-id>:<your-privy-app-secret>" \
        -H "privy-app-id: <your-privy-app-id>" \
        -H 'Content-Type: application/json' \
        -d '{
          "address": "user@gmail.com"
        }'
        ```
      </Accordion>

      <Accordion title="By phone number">
        To get a user by their phone number, make a `POST` request to:

        ```bash  theme={"system"}
        https://auth.privy.io/api/v1/users/phone/number
        ```

        ### Body

        <ParamField body="number" type="string" required>
          Phone number of the user.
        </ParamField>

        ### Sample request

        ```bash  theme={"system"}
        curl --request POST "https://auth.privy.io/api/v1/users/phone/number" \
        -u "<your-privy-app-id>:<your-privy-app-secret>" \
        -H "privy-app-id: <your-privy-app-id>" \
        -H 'Content-Type: application/json' \
        -d '{
          "number": "1234567890"
        }'
        ```
      </Accordion>

      <Accordion title="By wallet address">
        To get a user by their wallet address, make a `POST` request to:

        ```bash  theme={"system"}
        https://auth.privy.io/api/v1/users/wallet/address
        ```

        ### Body

        <ParamField body="address" type="string" required>
          Wallet address of the user.
        </ParamField>

        ### Sample request

        ```bash  theme={"system"}
        curl --request POST "https://auth.privy.io/api/v1/users/wallet/address" \
        -u "<your-privy-app-id>:<your-privy-app-secret>" \
        -H "privy-app-id: <your-privy-app-id>" \
        -H 'Content-Type: application/json' \
        -d '{
          "address": "0xABCDEFGHIJKL01234567895C5cAe8B9472c14328"
        }'
        ```
      </Accordion>

      <Accordion title="By smart wallet address">
        To get a user by their smart wallet address, make a `POST` request to:

        ```bash  theme={"system"}
        https://auth.privy.io/api/v1/users/smart_wallet/address
        ```

        ### Body

        <ParamField body="address" type="string" required>
          Smart wallet address of the user.
        </ParamField>

        ### Sample request

        ```bash  theme={"system"}
        curl --request POST "https://auth.privy.io/api/v1/users/smart_wallet/address" \
        -u "<your-privy-app-id>:<your-privy-app-secret>" \
        -H "privy-app-id: <your-privy-app-id>" \
        -H 'Content-Type: application/json' \
        -d '{
          "address": "0xABCDEFGHIJKL01234567895C5cAe8B9472c14328"
        }'
        ```
      </Accordion>

      <Accordion title="By custom auth ID">
        To get a user by their custom auth ID, make a `POST` request to:

        ```bash  theme={"system"}
        https://auth.privy.io/api/v1/users/custom_auth/id
        ```

        ### Body

        <ParamField body="custom_user_id" type="string" required>
          Custom user ID provided by your authentication system.
        </ParamField>

        ### Sample request

        ```bash  theme={"system"}
        curl --request POST "https://auth.privy.io/api/v1/users/custom_auth/id" \
        -u "<your-privy-app-id>:<your-privy-app-secret>" \
        -H "privy-app-id: <your-privy-app-id>" \
        -H 'Content-Type: application/json' \
        -d '{
          "custom_user_id": "123"
        }'
        ```
      </Accordion>

      <Accordion title="By Farcaster fid">
        To get a user by their Farcaster fid, make a `POST` request to:

        ```bash  theme={"system"}
        https://auth.privy.io/api/v1/users/farcaster/fid
        ```

        ### Body

        <ParamField body="fid" type="string" required>
          Farcaster ID of the user.
        </ParamField>

        ### Sample request

        ```bash  theme={"system"}
        curl --request POST "https://auth.privy.io/api/v1/users/farcaster/fid" \
        -u "<your-privy-app-id>:<your-privy-app-secret>" \
        -H "privy-app-id: <your-privy-app-id>" \
        -H 'Content-Type: application/json' \
        -d '{
          "fid": "789"
        }'
        ```
      </Accordion>

      <Accordion title="By Twitter subject">
        To get a user by their Twitter subject, make a `POST` request to:

        ```bash  theme={"system"}
        https://auth.privy.io/api/v1/users/twitter/subject
        ```

        ### Body

        <ParamField body="subject" type="string" required>
          Twitter subject identifier of the user.
        </ParamField>

        ### Sample request

        ```bash  theme={"system"}
        curl --request POST "https://auth.privy.io/api/v1/users/twitter/subject" \
        -u "<your-privy-app-id>:<your-privy-app-secret>" \
        -H "privy-app-id: <your-privy-app-id>" \
        -H 'Content-Type: application/json' \
        -d '{
          "subject": "12345"
        }'
        ```

        <Note>
          Use subject instead of username to get Twitter accounts with faster queries.
        </Note>
      </Accordion>

      <Accordion title="By Twitter username">
        To get a user by their Twitter username, make a `POST` request to:

        ```bash  theme={"system"}
        https://auth.privy.io/api/v1/users/twitter/username
        ```

        ### Body

        <ParamField body="username" type="string" required>
          Twitter username of the user.
        </ParamField>

        ### Sample request

        ```bash  theme={"system"}
        curl --request POST "https://auth.privy.io/api/v1/users/twitter/username" \
        -u "<your-privy-app-id>:<your-privy-app-secret>" \
        -H "privy-app-id: <your-privy-app-id>" \
        -H 'Content-Type: application/json' \
        -d '{
          "username": "batman"
        }'
        ```
      </Accordion>

      <Accordion title="By Discord username">
        To get a user by their Discord username, make a `POST` request to:

        ```bash  theme={"system"}
        https://auth.privy.io/api/v1/users/discord/username
        ```

        ### Body

        <ParamField body="username" type="string" required>
          Discord username of the user.
        </ParamField>

        ### Sample request

        ```bash  theme={"system"}
        curl --request POST "https://auth.privy.io/api/v1/users/discord/username" \
        -u "<your-privy-app-id>:<your-privy-app-secret>" \
        -H "privy-app-id: <your-privy-app-id>" \
        -H 'Content-Type: application/json' \
        -d '{
          "username": "batman"
        }'
        ```
      </Accordion>

      <Accordion title="By Telegram User ID">
        To get a user by their Telegram User ID, make a `POST` request to:

        ```bash  theme={"system"}
        https://auth.privy.io/api/v1/users/telegram/telegram_user_id
        ```

        ### Body

        <ParamField body="telegram_user_id" type="string" required>
          Telegram User ID of the user.
        </ParamField>

        ### Sample request

        ```bash  theme={"system"}
        curl --request POST "https://auth.privy.io/api/v1/users/telegram/telegram_user_id" \
        -u "<your-privy-app-id>:<your-privy-app-secret>" \
        -H "privy-app-id: <your-privy-app-id>" \
        -H 'Content-Type: application/json' \
        -d '{
          "telegram_user_id": "12345"
        }'
        ```

        <Note>
          Use ID instead of username to get Telegram accounts with faster queries.
        </Note>
      </Accordion>

      <Accordion title="By Telegram username">
        To get a user by their Telegram username, make a `POST` request to:

        ```bash  theme={"system"}
        https://auth.privy.io/api/v1/users/telegram/username
        ```

        ### Body

        <ParamField body="username" type="string" required>
          Telegram username of the user.
        </ParamField>

        ### Sample request

        ```bash  theme={"system"}
        curl --request POST "https://auth.privy.io/api/v1/users/telegram/username" \
        -u "<your-privy-app-id>:<your-privy-app-secret>" \
        -H "privy-app-id: <your-privy-app-id>" \
        -H 'Content-Type: application/json' \
        -d '{
          "username": "batman"
        }'
        ```
      </Accordion>
    </AccordionGroup>
  </Tab>

  <Tab title="Rust">
    ## Querying users by ID

    To get a user by their Privy ID, call the `.users().get()` method on the `PrivyClient`.

    ```rust  theme={"system"}
    use privy_rs::PrivyClient;

    let client = PrivyClient::new(app_id, app_secret)?;

    let user = client.users().get("insert-user-id").await?;
    println!("Found user: {}", user.id);
    ```

    Check out the [API reference](/api-reference/users/get) for more details on the available parameters and returns.

    ## Querying for all users

    To get all users for your app, call the `.users().list()` method on the `PrivyClient`.

    ```rust  theme={"system"}
    use privy_rs::{PrivyClient, generated::types::ListUsersQuery};

    let client = PrivyClient::new(app_id, app_secret)?;

    // Get users with optional pagination
    let users_response = client
        .users()
        .list(Some(&ListUsersQuery {
            cursor: None,
            limit: Some(100),
        }))
        .await?;

    for user in users_response.data {
        println!("User ID: {}", user.id);
    }

    // Handle pagination if needed
    if let Some(next_cursor) = users_response.next_cursor {
        let next_page = client
            .users()
            .list(Some(&ListUsersQuery {
                cursor: Some(next_cursor),
                limit: Some(100),
            }))
            .await?;
    }
    ```

    ## Querying users by specific criteria

    The Rust SDK provides several methods to query users by specific linked accounts:

    ```rust  theme={"system"}
    use privy_rs::generated::types::*;

    // Get user by email address
    let user = client
        .users()
        .get_by_email_address(&GetUsersByEmailAddressBody {
            email: "user@example.com".to_string(),
        })
        .await?;

    // Get user by wallet address
    let user = client
        .users()
        .get_by_wallet_address(&GetUsersByWalletAddressBody {
            address: "0x1234...".to_string(),
        })
        .await?;

    // Get user by phone number
    let user = client
        .users()
        .get_by_phone_number(&GetUsersByPhoneNumberBody {
            phone_number: "+1234567890".to_string(),
        })
        .await?;

    // Get user by custom auth ID
    let user = client
        .users()
        .get_by_custom_auth_id(&GetUsersByCustomAuthIdBody {
            custom_user_id: "custom-user-123".to_string(),
        })
        .await?;
    ```
  </Tab>
</Tabs>


# Overview
Source: https://docs.privy.io/user-management/users/overview



Privy provides a unified user management system that seamlessly combines traditional authentication methods with web3 capabilities. Each user in your application gets a unique Privy DID (Decentralized Identifier) and can link multiple authentication methods and wallets to their account.

<img src="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Users2.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=06adb4371b947fcf9158ba72f074219a" alt="images/Users2.png" data-og-width="1843" width="1843" data-og-height="1317" height="1317" data-path="images/Users2.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Users2.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=4a7b9d725f4915808965123838dc33df 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Users2.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=9fa7cf704310441541c4c48b878d4634 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Users2.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=b1f33306ff2e72802d59e0fcc32b5b53 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Users2.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=71a9a9ff982023f50d1e635c1510d38a 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Users2.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=e3767ab556e39718944c78853e762044 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Users2.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=f680ee09cf4b2bc66c7cbc4d428e6473 2500w" />

### The user object

At the core of Privy's user management is the user object, which provides a unified view of your user's identity across different authentication methods. Each user object contains:

* A unique Privy DID for consistent identification
* A collection of linked accounts (email, phone, wallets)
* Optional custom metadata for application-specific data
* Creation timestamp and other system metadata

### Linked accounts

Privy supports a comprehensive range of authentication methods that can be connected to a user's account. Users can authenticate using traditional methods like email, phone, and passkeys, or through popular social accounts including Google, Apple, and Discord. All of these methods are unified under a single user object, enabling seamless multi-method login while maintaining a consistent user identity.

### Account management

Managing user accounts with Privy is straightforward and flexible. You can dynamically link new authentication methods to existing accounts or remove them when needed. The platform provides powerful tools for:

* Adding custom metadata to enrich user profiles
* Controlling access through allowlists and denylists
* Managing user data and deletion requests
* Monitoring account activity and changes

### Identity verification

Privy's identity token system provides robust security and verification capabilities. These tokens securely represent user identity and can be verified on your backend. They include custom metadata and feature automatic refresh functionality to maintain session state without interruption.

### User events

Monitor user activity through Privy's webhook system, which notifies your backend when important events occur, such as:

* New account creation
* Authentication method changes
* Custom metadata updates
* Other significant account modifications

### UI components

Privy streamlines implementation by providing ready-to-use UI components for all essential user management tasks. These include authentication flows, account linking interfaces, profile management tools, and wallet connection experiences—all designed to work seamlessly with your application.

## Next steps

* Learn about [the user object](/user-management/users/the-user-object)
* Understand how to [link accounts](/user-management/users/linking-accounts)
* Implement [custom metadata](/user-management/users/custom-metadata)
* Set up [user webhooks](/user-management/users/webhooks)


# Handling the user object
Source: https://docs.privy.io/user-management/users/the-user-object



All of Privy's login methods result in a unified JSON representation of your user.

<Tabs>
  <Tab title="React">
    **To get the current user, inspect the [`user`](/user-management/users/the-user-object) object returned by the `usePrivy` hook:**

    ```tsx  theme={"system"}
    const { user } = usePrivy();
    ```

    ### Unauthenticated users

    For **unauthenticated** users, the [**`user`**](/user-management/users/the-user-object) object will be `null`.

    ### Authenticated users

    For **authenticated** users, you can use the following fields:

    <Expandable title="User" defaultOpen={true}>
      <ParamField body="id" type="string" required>
        The Privy-issued DID for the user. If you need to store additional information about a user, you
        can use this DID to reference them.
      </ParamField>

      <ParamField body="createdAt" type="string" required>
        The datetime of when the user was created, in ISO 8601 format.
      </ParamField>

      <ParamField body="linkedAccounts" type="array" required>
        The list of accounts associated with this user. Each account contains additional metadata that may
        be helpful for advanced use cases.

        <Expandable title="Properties">
          <Expandable title="Wallet">
            <ParamField body="type" type="'wallet'" required>
              Denotes that this is a wallet account
            </ParamField>

            <ParamField body="id" type="string | null" required>
              The wallet ID of the wallet. Null if the wallet is not delegated. Only applies to embedded
              wallets (walletClientType === 'privy')
            </ParamField>

            <ParamField body="address" type="string" required>
              The wallet address
            </ParamField>

            <ParamField body="chainType" type="'ethereum' | 'solana'" required>
              Chain type of the wallet address
            </ParamField>

            <ParamField body="walletClientType" type="string" required>
              The wallet client used for this wallet during the most recent verification. If the value is
              'privy', then this is a privy embedded wallet
            </ParamField>

            <ParamField body="connectorType" type="string" required>
              The connector type used for this wallet during the most recent verification
            </ParamField>

            <ParamField body="recoveryMethod" type="'privy' | UserRecoveryMethod" required>
              If this is a 'privy' embedded wallet, stores the recovery method
            </ParamField>

            <ParamField body="imported" type="boolean" required>
              Whether the wallet is imported. Only applies to embedded wallets (walletClientType === 'privy')
            </ParamField>

            <ParamField body="delegated" type="boolean" required>
              Whether the wallet is delegated. Only applies to embedded wallets (walletClientType === 'privy')
            </ParamField>

            <ParamField body="walletIndex" type="number | null" required>
              HD index for the wallet. Only applies to embedded wallets (walletClientType === 'privy')
            </ParamField>
          </Expandable>

          <Expandable title="SmartWallet">
            <ParamField body="type" type="'smart_wallet'" required>
              Denotes that this is a smart wallet account
            </ParamField>

            <ParamField body="address" type="string" required>
              The wallet address
            </ParamField>

            <ParamField body="smartWalletType" type="SmartWalletType" required>
              The provider of the smart wallet
            </ParamField>
          </Expandable>

          <Expandable title="Email">
            <ParamField body="type" type="'email'" required>
              Denotes that this is an email account
            </ParamField>

            <ParamField body="address" type="string" required>
              The email address
            </ParamField>
          </Expandable>

          <Expandable title="Phone">
            <ParamField body="type" type="'phone'" required>
              Denotes that this is a phone account
            </ParamField>

            <ParamField body="number" type="string" required>
              The phone number
            </ParamField>
          </Expandable>

          <Expandable title="Google">
            <ParamField body="type" type="'google_oauth'" required>
              Denotes that this is a Google account
            </ParamField>

            <ParamField body="subject" type="string" required>
              The 'sub' claim from the Google-issued JWT for this account
            </ParamField>

            <ParamField body="email" type="string" required>
              The email associated with the Google account
            </ParamField>

            <ParamField body="name" type="string | null" required>
              The name associated with the Google account
            </ParamField>
          </Expandable>

          <Expandable title="Twitter">
            <ParamField body="type" type="'twitter_oauth'" required>
              Denotes that this is a Twitter account
            </ParamField>

            <ParamField body="subject" type="string" required>
              The 'sub' claim from the Twitter-issued JWT for this account
            </ParamField>

            <ParamField body="username" type="string | null" required>
              The username associated with the Twitter account
            </ParamField>

            <ParamField body="name" type="string | null" required>
              The name associated with the Twitter account
            </ParamField>

            <ParamField body="profilePictureUrl" type="string | null" required>
              The profile picture URL associated with the Twitter account
            </ParamField>
          </Expandable>

          <Expandable title="Discord">
            <ParamField body="type" type="'discord_oauth'" required>
              Denotes that this is a Discord account
            </ParamField>

            <ParamField body="subject" type="string" required>
              The 'sub' claim from the Discord-issued JWT for this account
            </ParamField>

            <ParamField body="username" type="string | null" required>
              The username associated with the Discord account
            </ParamField>

            <ParamField body="email" type="string | null" required>
              The email associated with the Discord account
            </ParamField>
          </Expandable>

          <Expandable title="Github">
            <ParamField body="type" type="'github_oauth'" required>
              Denotes that this is a Github account
            </ParamField>

            <ParamField body="subject" type="string" required>
              The 'sub' claim from the Github-issued JWT for this account
            </ParamField>

            <ParamField body="username" type="string | null" required>
              The username associated with the Github account
            </ParamField>

            <ParamField body="name" type="string | null" required>
              The name associated with the Github account
            </ParamField>

            <ParamField body="email" type="string | null" required>
              The email associated with the Github account
            </ParamField>
          </Expandable>

          <Expandable title="Spotify">
            <ParamField body="type" type="'spotify_oauth'" required>
              Denotes that this is a Spotify account
            </ParamField>

            <ParamField body="subject" type="string" required>
              The user id associated with the Spotify account
            </ParamField>

            <ParamField body="email" type="string | null" required>
              The email associated with the Spotify account
            </ParamField>

            <ParamField body="name" type="string | null" required>
              The display name associated with the Spotify account
            </ParamField>
          </Expandable>

          <Expandable title="Instagram">
            <ParamField body="type" type="'instagram_oauth'" required>
              Denotes that this is an Instagram account
            </ParamField>

            <ParamField body="subject" type="string" required>
              The user id associated with the Instagram account
            </ParamField>

            <ParamField body="username" type="string | null" required>
              The username associated with the Instagram account
            </ParamField>
          </Expandable>

          <Expandable title="Tiktok">
            <ParamField body="type" type="'tiktok_oauth'" required>
              Denotes that this is a Tiktok account
            </ParamField>

            <ParamField body="subject" type="string" required>
              The 'sub' claim from the Tiktok-issued JWT for this account
            </ParamField>

            <ParamField body="username" type="string | null" required>
              The username associated with the Tiktok account
            </ParamField>

            <ParamField body="name" type="string | null" required>
              The display name associated with the Tiktok account
            </ParamField>
          </Expandable>

          <Expandable title="Line">
            <ParamField body="type" type="'line_oauth'" required>
              Denotes that this is a Line account
            </ParamField>

            <ParamField body="subject" type="string" required>
              The 'sub' claim from the Line-issued JWT for this account
            </ParamField>

            <ParamField body="name" type="string | null" required>
              The name associated with the Line account
            </ParamField>

            <ParamField body="email" type="string | null" required>
              The email associated with the Line account
            </ParamField>

            <ParamField body="profilePictureUrl" type="string | null" required>
              The profile image URL associated with the Line account
            </ParamField>
          </Expandable>

          <Expandable title="LinkedIn">
            <ParamField body="type" type="'linkedin_oauth'" required>
              Denotes that this is a LinkedIn account
            </ParamField>

            <ParamField body="subject" type="string" required>
              The 'sub' claim from the LinkedIn-issued JWT for this account
            </ParamField>

            <ParamField body="name" type="string | null" required>
              The name associated with the LinkedIn account
            </ParamField>

            <ParamField body="email" type="string | null" required>
              The email associated with the LinkedIn account
            </ParamField>

            <ParamField body="vanityName" type="string | null" required>
              The vanityName/profile URL associated with the LinkedIn account
            </ParamField>
          </Expandable>

          <Expandable title="Apple">
            <ParamField body="type" type="'apple_oauth'" required>
              Denotes that this is an Apple account
            </ParamField>

            <ParamField body="subject" type="string" required>
              The 'sub' claim from the Apple-issued JWT for this account
            </ParamField>

            <ParamField body="email" type="string" required>
              The email associated with the Apple account
            </ParamField>
          </Expandable>

          <Expandable title="CustomJwt">
            <ParamField body="type" type="'custom_auth'" required>
              Denotes that this is a custom account
            </ParamField>

            <ParamField body="customUserId" type="string" required>
              The user ID given by the custom auth provider
            </ParamField>
          </Expandable>

          <Expandable title="Farcaster">
            <ParamField body="type" type="'farcaster'" required>
              Denotes that this is a Farcaster account
            </ParamField>

            <ParamField body="fid" type="number | null" required>
              The Farcaster on-chain FID
            </ParamField>

            <ParamField body="ownerAddress" type="string" required>
              The Farcaster ethereum address that owns the FID
            </ParamField>

            <ParamField body="username" type="string | null" required>
              The Farcaster protocol username
            </ParamField>

            <ParamField body="displayName" type="string | null" required>
              The Farcaster protocol display name
            </ParamField>

            <ParamField body="bio" type="string | null" required>
              The Farcaster protocol bio
            </ParamField>

            <ParamField body="pfp" type="string | null" required>
              The Farcaster protocol profile picture
            </ParamField>

            <ParamField body="url" type="string | null" required>
              The Farcaster protocol profile url
            </ParamField>

            <ParamField body="signerPublicKey" type="string | null" required>
              The public key of the signer, if set. This is not guaranteed to be valid, as the user can revoke
              the key at any time
            </ParamField>
          </Expandable>

          <Expandable title="Passkey">
            <ParamField body="type" type="'passkey'" required>
              Denotes that this is a Passkey account
            </ParamField>

            <ParamField body="credentialId" type="string" required>
              The passkey credential ID
            </ParamField>

            <ParamField body="enrolledInMfa" type="boolean" required>
              Whether or not this passkey can be used for MFA
            </ParamField>

            <ParamField body="authenticatorName" type="string" required>
              The type of authenticator holding the passkey
            </ParamField>

            <ParamField body="createdWithDevice" type="string" required>
              Metadata about the device that registered the passkey
            </ParamField>

            <ParamField body="createdWithOs" type="string" required>
              Metadata about the OS that registered the passkey
            </ParamField>

            <ParamField body="createdWithBrowser" type="string" required>
              Metadata about the browser that registered the passkey
            </ParamField>
          </Expandable>

          <Expandable title="Telegram">
            <ParamField body="type" type="'telegram'" required>
              Denotes that this is a Telegram account
            </ParamField>

            <ParamField body="telegramUserId" type="string" required>
              The user ID that owns this Telegram account
            </ParamField>

            <ParamField body="firstName" type="string | null" required>
              The first name of the user
            </ParamField>

            <ParamField body="lastName" type="string | null" required>
              The last name of the user
            </ParamField>

            <ParamField body="username" type="string | null" required>
              The username associated with the Telegram account
            </ParamField>

            <ParamField body="photoUrl" type="string | null" required>
              The url of the user's profile picture
            </ParamField>
          </Expandable>

          <Expandable title="CrossApp">
            <ParamField body="type" type="'cross_app'" required>
              Denotes that this is a cross-app account
            </ParamField>

            <ParamField body="embeddedWallets" type="{ address: string }[]" required>
              The user's embedded wallet address(es) from the provider app
            </ParamField>

            <ParamField body="smartWallets" type="{ address: string }[]" required>
              The user's smart wallet address(es) from the provider app
            </ParamField>

            <ParamField body="providerApp" type="ProviderAppMetadata" required>
              Metadata about the provider app
            </ParamField>

            <ParamField body="subject" type="string" required>
              The subject identifier for this cross-app account
            </ParamField>
          </Expandable>

          {/*

            <Expandable title="AuthorizationKey">

            <ParamField body="type" type="'authorization_key'" required>
              Denotes that this is an authorization key
            </ParamField>
            <ParamField body="publicKey" type="string" required>
              The public key of the authorization key
            </ParamField>
            </Expandable> 
            */}

          <br />
        </Expandable>
      </ParamField>

      <ParamField body="mfaMethods" type="array" required>
        The list of MFA Methods associated with this user.
      </ParamField>

      <ParamField body="hasAcceptedTerms" type="boolean" required>
        Whether or not the user has explicitly accepted the Terms and Conditions and/or Privacy Policy
      </ParamField>

      <ParamField body="isGuest" type="boolean" required>
        Whether or not the user is a guest
      </ParamField>

      <Expandable title="Optional fields">
        <ParamField body="email" type="object">
          The user's email address, if they have linked one. It cannot be linked to another user.

          <Expandable title="Properties">
            <ParamField body="address" type="string">
              The email address.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField body="phone" type="object">
          The user's phone number, if they have linked one. It cannot be linked to another user.

          <Expandable title="Properties">
            <ParamField body="number" type="string">
              The phone number.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField body="wallet" type="object">
          The user's first verified wallet, if they have linked at least one wallet. It cannot be linked to
          another user.
        </ParamField>

        <ParamField body="smartWallet" type="object">
          The user's smart wallet, if they have set up through the Privy Smart Wallet SDK.

          <Expandable title="Properties">
            <ParamField body="address" type="string">
              The wallet address.
            </ParamField>

            <ParamField body="smartWalletType" type="string">
              The provider of the smart wallet.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField body="google" type="object">
          The user's Google account, if they have linked one. It cannot be linked to another user.

          <Expandable title="Properties">
            <ParamField body="subject" type="string">
              The `sub` claim from the Google-issued JWT for this account.
            </ParamField>

            <ParamField body="email" type="string">
              The email associated with the Google account.
            </ParamField>

            <ParamField body="name" type="string">
              The name associated with the Google account.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField body="twitter" type="object">
          The user's Twitter account, if they have linked one. It cannot be linked to another user.

          <Expandable title="Properties">
            <ParamField body="subject" type="string">
              The `sub` claim from the Twitter-issued JWT for this account.
            </ParamField>

            <ParamField body="username" type="string">
              The username associated with the Twitter account.
            </ParamField>

            <ParamField body="name" type="string">
              The name associated with the Twitter account.
            </ParamField>

            <ParamField body="profilePictureUrl" type="string">
              The profile picture URL associated with the Twitter account.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField body="discord" type="object">
          The user's Discord account, if they have linked one. It cannot be linked to another user.

          <Expandable title="Properties">
            <ParamField body="subject" type="string">
              The `sub` claim from the Discord-issued JWT for this account.
            </ParamField>

            <ParamField body="username" type="string">
              The username associated with the Discord account.
            </ParamField>

            <ParamField body="email" type="string">
              The email associated with the Discord account.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField body="github" type="object">
          The user's Github account, if they have linked one. It cannot be linked to another user.

          <Expandable title="Properties">
            <ParamField body="subject" type="string">
              The `sub` claim from the Github-issued JWT for this account.
            </ParamField>

            <ParamField body="username" type="string">
              The username associated with the Github account.
            </ParamField>

            <ParamField body="name" type="string">
              The name associated with the Github account.
            </ParamField>

            <ParamField body="email" type="string">
              The email associated with the Github account.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField body="spotify" type="object">
          The user's Spotify account, if they have linked one. It cannot be linked to another user.

          <Expandable title="Properties">
            <ParamField body="subject" type="string">
              The user id associated with the Spotify account.
            </ParamField>

            <ParamField body="email" type="string">
              The email associated with the Spotify account.
            </ParamField>

            <ParamField body="name" type="string">
              The display name associated with the Spotify account.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField body="instagram" type="object">
          The user's Instagram account, if they have linked one. It cannot be linked to another user.

          <Expandable title="Properties">
            <ParamField body="subject" type="string">
              The user id associated with the Instagram account.
            </ParamField>

            <ParamField body="username" type="string">
              The username associated with the Instagram account.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField body="tiktok" type="object">
          The user's Tiktok account, if they have linked one. It cannot be linked to another user.

          <Expandable title="Properties">
            <ParamField body="subject" type="string">
              The `sub` claim from the Tiktok-issued JWT for this account.
            </ParamField>

            <ParamField body="username" type="string">
              The username associated with the Tiktok account.
            </ParamField>

            <ParamField body="name" type="string">
              The display name associated with the Tiktok account.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField body="line" type="object">
          The user's Line account, if they have linked one. It cannot be linked to another user.

          <Expandable title="Properties">
            <ParamField body="subject" type="string">
              The `sub` claim from the Line-issued JWT for this account.
            </ParamField>

            <ParamField body="name" type="string">
              The name associated with the Line account.
            </ParamField>

            <ParamField body="email" type="string">
              The email associated with the Line account.
            </ParamField>

            <ParamField body="profilePictureUrl" type="string">
              The profile image URL associated with the Line account.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField body="linkedin" type="object">
          The user's LinkedIn account, if they have linked one. It cannot be linked to another user.

          <Expandable title="Properties">
            <ParamField body="subject" type="string">
              The `sub` claim from the LinkedIn-issued JWT for this account.
            </ParamField>

            <ParamField body="name" type="string">
              The name associated with the LinkedIn account.
            </ParamField>

            <ParamField body="email" type="string">
              The email associated with the LinkedIn account.
            </ParamField>

            <ParamField body="vanityName" type="string">
              The vanityName/profile URL associated with the LinkedIn account.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField body="apple" type="object">
          The user's Apple account, if they have linked one. It cannot be linked to another user.

          <Expandable title="Properties">
            <ParamField body="subject" type="string">
              The `sub` claim from the Apple-issued JWT for this account.
            </ParamField>

            <ParamField body="email" type="string">
              The email associated with the Apple account.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField body="farcaster" type="object">
          The user's Farcaster account, if they have linked one. It cannot be linked to another user.

          <Expandable title="Properties">
            <ParamField body="fid" type="number">
              The Farcaster on-chain FID
            </ParamField>

            <ParamField body="ownerAddress" type="string">
              The Farcaster ethereum address that owns the FID
            </ParamField>

            <ParamField body="username" type="string">
              The Farcaster protocol username
            </ParamField>

            <ParamField body="displayName" type="string">
              The Farcaster protocol display name
            </ParamField>

            <ParamField body="bio" type="string">
              The Farcaster protocol bio
            </ParamField>

            <ParamField body="pfp" type="string">
              The Farcaster protocol profile picture
            </ParamField>

            <ParamField body="url" type="string">
              The Farcaster protocol profile url
            </ParamField>

            <ParamField body="signerPublicKey" type="string">
              The public key of the signer, if set. This is not guaranteed to be valid, as the user can
              revoke the key at any time
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField body="telegram" type="object">
          The user's Telegram account, if they have linked one. It cannot be linked to another user.

          <Expandable title="Properties">
            <ParamField body="telegramUserId" type="string">
              The user ID that owns this Telegram account.
            </ParamField>

            <ParamField body="firstName" type="string">
              The first name of the user.
            </ParamField>

            <ParamField body="lastName" type="string">
              The last name of the user.
            </ParamField>

            <ParamField body="username" type="string">
              The username associated with the Telegram account.
            </ParamField>

            <ParamField body="photoUrl" type="string">
              The url of the user's profile picture.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField body="customMetadata" type="object">
          Custom metadata field for a given user account
        </ParamField>
      </Expandable>

      <br />
    </Expandable>

    <Tip>
      You can set custom metadata for a user via Privy's backend [server SDK and/or
      API endpoints](/user-management/users/custom-metadata).
    </Tip>

    If a user has not linked an account of a given type, the corresponding field on the [`user`](/user-management/users/the-user-object) object will be undefined.

    <Tip>
      Users can have multiple passkeys linked to their account. To find all linked
      passkeys, use the `linkedAccounts` list and filter by `passkey` account type.
    </Tip>

    Below is an example of how you might use the [**`user`**](/user-management/users/the-user-object) object in a minimal user profile:

    ```tsx Example User Profile theme={"system"}
    import { usePrivy } from "@privy-io/react-auth";

    function User() {
    const { ready, authenticated, user } = usePrivy();

    // Show nothing if user is not authenticated or data is still loading
    if (!(ready && authenticated) || !user) {
        return null;
    }

    return (
        <div>
        <p>User {user.id} has linked the following accounts:</p>
        <ul>
            <li>Apple: {user.apple ? user.apple.email : "None"}</li>
            <li>Discord: {user.discord ? user.discord.username : "None"}</li>
            <li>Email: {user.email ? user.email.address : "None"}</li>
            <li>Farcaster: {user.farcaster ? user.farcaster.username : "None"}</li>
            <li>GitHub: {user.github ? user.github.username : "None"}</li>
            <li>Google: {user.google ? user.google.email : "None"}</li>
            <li>Instagram: {user.instagram ? user.instagram.username : "None"}</li>
            <li>LinkedIn: {user.linkedin ? user.linkedin.email : "None"}</li>
            <li>Line: {user.line ? user.line.email : "None"}</li>
            <li>Phone: {user.phone ? user.phone.number : "None"}</li>
            <li>Spotify: {user.spotify ? user.spotify.email : "None"}</li>
            <li>Telegram: {user.telegram ? user.telegram.username : "None"}</li>
            <li>TikTok: {user.tiktok ? user.tiktok.username : "None"}</li>
            <li>Twitter: {user.twitter ? user.twitter.username : "None"}</li>
            <li>Wallet: {user.wallet ? user.wallet.address : "None"}</li>
        </ul>
        </div>
    );
    }
    ```

    ### Refreshing the `user` object

    In order to update a `user` object after any type of backend update, (i.e. [unlinking an account](/user-management/users/unlinking-accounts) or setting [custom metadata](/user-management/users/custom-metadata)) you can ensure the user object in the application is up-to-date by invoking the **`refreshUser`** method from the **`useUser`** hook:

    ```tsx Example refresh User theme={"system"}
    import { useUser } from "@privy-io/react-auth";

    const { user, refreshUser } = useUser();

    const updateMetadata = async (value: string) => {
    // Make API request to update custom metadata for a user from the backend
    const response = await updateUserMetadata({ value });
    await refreshUser();
    // `user` object should be updated
    console.log(user);
    };
    ```
  </Tab>

  <Tab title="React Native">
    **You can get information about the current user from the `user` object in the `usePrivy` hook:**

    ```tsx  theme={"system"}
    const {user} = usePrivy();
    ```

    **For unauthenticated users, the `user` object will be null. For authenticated users, you can use:**

    * **`user.id`** to get their Privy DID, which you may use to identify your user on your backend
    * **`user.created_at`** to get a UNIX timestamp of when the user was created.
    * **`user.linked_accounts`** to get an array of the user's linked accounts

    ## Parsing linked accounts

    Each entry in the `linked_accounts` array has different fields depending on the user data associated with that account type.

    See the dropdowns below to see the specific fields associated with each account type.

    ### Refreshing the `user` object

    In order to update a `user` object after any type of backend update, (i.e. [unlinking an account](/user-management/users/unlinking-accounts) or setting [custom metadata](/user-management/users/custom-metadata)) you can ensure the user object in the application is up-to-date by invoking the **`get`** method from the **`privyClient.user`** object:

    <Tabs>
      <Tab title="_layout.tsx">
        ```tsx  theme={"system"}
        import { createPrivyClient, PrivyProvider } from "@privy-io/expo";

        export const privyClient = createPrivyClient({
          appId: "your-app-id",
        })

        export default function RootLayout() {
          return (
            <PrivyProvider
              appId={Constants.expoConfig?.extra?.privyAppId}
              client={privyClient}
            >
              <Stack>
                <Stack.Screen name="index" />
              </Stack>
            </PrivyProvider>
          );
        }
        ```
      </Tab>

      <Tab title="index.tsx">
        ```tsx  theme={"system"}
        import {privyClient} from '@/_layout';

        const updateMetadata = async (value: string) => {
        // Make API request to update custom metadata for a user from the backend
        const response = await updateUserMetadata({ value });

        // Refresh the user object to ensure it reflects the latest backend updates
        await privyClient.user.get();
        // `user` object should be updated
        };
        ```
      </Tab>
    </Tabs>

    <Expandable title="Wallet">
      <ParamField body="type" type="'wallet'" required>
        Denotes that this is a wallet account
      </ParamField>

      <ParamField body="id" type="string | null" required>
        The wallet ID of the wallet. Null if the wallet is not delegated. Only applies to embedded
        wallets (walletClientType === 'privy')
      </ParamField>

      <ParamField body="address" type="string" required>
        The wallet address
      </ParamField>

      <ParamField body="chainType" type="'ethereum' | 'solana'" required>
        Chain type of the wallet address
      </ParamField>

      <ParamField body="walletClientType" type="string" required>
        The wallet client used for this wallet during the most recent verification. If the value is
        'privy', then this is a privy embedded wallet
      </ParamField>

      <ParamField body="connectorType" type="string" required>
        The connector type used for this wallet during the most recent verification
      </ParamField>

      <ParamField body="recoveryMethod" type="'privy' | UserRecoveryMethod" required>
        If this is a 'privy' embedded wallet, stores the recovery method
      </ParamField>

      <ParamField body="imported" type="boolean" required>
        Whether the wallet is imported. Only applies to embedded wallets (walletClientType === 'privy')
      </ParamField>

      <ParamField body="delegated" type="boolean" required>
        Whether the wallet is delegated. Only applies to embedded wallets (walletClientType === 'privy')
      </ParamField>

      <ParamField body="walletIndex" type="number | null" required>
        HD index for the wallet. Only applies to embedded wallets (walletClientType === 'privy')
      </ParamField>
    </Expandable>

    <Expandable title="SmartWallet">
      <ParamField body="type" type="'smart_wallet'" required>
        Denotes that this is a smart wallet account
      </ParamField>

      <ParamField body="address" type="string" required>
        The wallet address
      </ParamField>

      <ParamField body="smartWalletType" type="SmartWalletType" required>
        The provider of the smart wallet
      </ParamField>
    </Expandable>

    <Expandable title="Email">
      <ParamField body="type" type="'email'" required>
        Denotes that this is an email account
      </ParamField>

      <ParamField body="address" type="string" required>
        The email address
      </ParamField>
    </Expandable>

    <Expandable title="Phone">
      <ParamField body="type" type="'phone'" required>
        Denotes that this is a phone account
      </ParamField>

      <ParamField body="number" type="string" required>
        The phone number
      </ParamField>
    </Expandable>

    <Expandable title="Google">
      <ParamField body="type" type="'google_oauth'" required>
        Denotes that this is a Google account
      </ParamField>

      <ParamField body="subject" type="string" required>
        The 'sub' claim from the Google-issued JWT for this account
      </ParamField>

      <ParamField body="email" type="string" required>
        The email associated with the Google account
      </ParamField>

      <ParamField body="name" type="string | null" required>
        The name associated with the Google account
      </ParamField>
    </Expandable>

    <Expandable title="Twitter">
      <ParamField body="type" type="'twitter_oauth'" required>
        Denotes that this is a Twitter account
      </ParamField>

      <ParamField body="subject" type="string" required>
        The 'sub' claim from the Twitter-issued JWT for this account
      </ParamField>

      <ParamField body="username" type="string | null" required>
        The username associated with the Twitter account
      </ParamField>

      <ParamField body="name" type="string | null" required>
        The name associated with the Twitter account
      </ParamField>

      <ParamField body="profilePictureUrl" type="string | null" required>
        The profile picture URL associated with the Twitter account
      </ParamField>
    </Expandable>

    <Expandable title="Discord">
      <ParamField body="type" type="'discord_oauth'" required>
        Denotes that this is a Discord account
      </ParamField>

      <ParamField body="subject" type="string" required>
        The 'sub' claim from the Discord-issued JWT for this account
      </ParamField>

      <ParamField body="username" type="string | null" required>
        The username associated with the Discord account
      </ParamField>

      <ParamField body="email" type="string | null" required>
        The email associated with the Discord account
      </ParamField>
    </Expandable>

    <Expandable title="Github">
      <ParamField body="type" type="'github_oauth'" required>
        Denotes that this is a Github account
      </ParamField>

      <ParamField body="subject" type="string" required>
        The 'sub' claim from the Github-issued JWT for this account
      </ParamField>

      <ParamField body="username" type="string | null" required>
        The username associated with the Github account
      </ParamField>

      <ParamField body="name" type="string | null" required>
        The name associated with the Github account
      </ParamField>

      <ParamField body="email" type="string | null" required>
        The email associated with the Github account
      </ParamField>
    </Expandable>

    <Expandable title="Spotify">
      <ParamField body="type" type="'spotify_oauth'" required>
        Denotes that this is a Spotify account
      </ParamField>

      <ParamField body="subject" type="string" required>
        The user id associated with the Spotify account
      </ParamField>

      <ParamField body="email" type="string | null" required>
        The email associated with the Spotify account
      </ParamField>

      <ParamField body="name" type="string | null" required>
        The display name associated with the Spotify account
      </ParamField>
    </Expandable>

    <Expandable title="Instagram">
      <ParamField body="type" type="'instagram_oauth'" required>
        Denotes that this is an Instagram account
      </ParamField>

      <ParamField body="subject" type="string" required>
        The user id associated with the Instagram account
      </ParamField>

      <ParamField body="username" type="string | null" required>
        The username associated with the Instagram account
      </ParamField>
    </Expandable>

    <Expandable title="Tiktok">
      <ParamField body="type" type="'tiktok_oauth'" required>
        Denotes that this is a Tiktok account
      </ParamField>

      <ParamField body="subject" type="string" required>
        The 'sub' claim from the Tiktok-issued JWT for this account
      </ParamField>

      <ParamField body="username" type="string | null" required>
        The username associated with the Tiktok account
      </ParamField>

      <ParamField body="name" type="string | null" required>
        The display name associated with the Tiktok account
      </ParamField>
    </Expandable>

    <Expandable title="Line">
      <ParamField body="type" type="'line_oauth'" required>
        Denotes that this is a Line account
      </ParamField>

      <ParamField body="subject" type="string" required>
        The 'sub' claim from the Line-issued JWT for this account
      </ParamField>

      <ParamField body="name" type="string | null" required>
        The name associated with the Line account
      </ParamField>

      <ParamField body="email" type="string | null" required>
        The email associated with the Line account
      </ParamField>

      <ParamField body="profilePictureUrl" type="string | null" required>
        The profile image URL associated with the Line account
      </ParamField>
    </Expandable>

    <Expandable title="LinkedIn">
      <ParamField body="type" type="'linkedin_oauth'" required>
        Denotes that this is a LinkedIn account
      </ParamField>

      <ParamField body="subject" type="string" required>
        The 'sub' claim from the LinkedIn-issued JWT for this account
      </ParamField>

      <ParamField body="name" type="string | null" required>
        The name associated with the LinkedIn account
      </ParamField>

      <ParamField body="email" type="string | null" required>
        The email associated with the LinkedIn account
      </ParamField>

      <ParamField body="vanityName" type="string | null" required>
        The vanityName/profile URL associated with the LinkedIn account
      </ParamField>
    </Expandable>

    <Expandable title="Apple">
      <ParamField body="type" type="'apple_oauth'" required>
        Denotes that this is an Apple account
      </ParamField>

      <ParamField body="subject" type="string" required>
        The 'sub' claim from the Apple-issued JWT for this account
      </ParamField>

      <ParamField body="email" type="string" required>
        The email associated with the Apple account
      </ParamField>
    </Expandable>

    <Expandable title="CustomJwt">
      <ParamField body="type" type="'custom_auth'" required>
        Denotes that this is a custom account
      </ParamField>

      <ParamField body="customUserId" type="string" required>
        The user ID given by the custom auth provider
      </ParamField>
    </Expandable>

    <Expandable title="Farcaster">
      <ParamField body="type" type="'farcaster'" required>
        Denotes that this is a Farcaster account
      </ParamField>

      <ParamField body="fid" type="number | null" required>
        The Farcaster on-chain FID
      </ParamField>

      <ParamField body="ownerAddress" type="string" required>
        The Farcaster ethereum address that owns the FID
      </ParamField>

      <ParamField body="username" type="string | null" required>
        The Farcaster protocol username
      </ParamField>

      <ParamField body="displayName" type="string | null" required>
        The Farcaster protocol display name
      </ParamField>

      <ParamField body="bio" type="string | null" required>
        The Farcaster protocol bio
      </ParamField>

      <ParamField body="pfp" type="string | null" required>
        The Farcaster protocol profile picture
      </ParamField>

      <ParamField body="url" type="string | null" required>
        The Farcaster protocol profile url
      </ParamField>

      <ParamField body="signerPublicKey" type="string | null" required>
        The public key of the signer, if set. This is not guaranteed to be valid, as the user can revoke
        the key at any time
      </ParamField>
    </Expandable>

    <Expandable title="Passkey">
      <ParamField body="type" type="'passkey'" required>
        Denotes that this is a Passkey account
      </ParamField>

      <ParamField body="credentialId" type="string" required>
        The passkey credential ID
      </ParamField>

      <ParamField body="enrolledInMfa" type="boolean" required>
        Whether or not this passkey can be used for MFA
      </ParamField>

      <ParamField body="authenticatorName" type="string" required>
        The type of authenticator holding the passkey
      </ParamField>

      <ParamField body="createdWithDevice" type="string" required>
        Metadata about the device that registered the passkey
      </ParamField>

      <ParamField body="createdWithOs" type="string" required>
        Metadata about the OS that registered the passkey
      </ParamField>

      <ParamField body="createdWithBrowser" type="string" required>
        Metadata about the browser that registered the passkey
      </ParamField>
    </Expandable>

    <Expandable title="Telegram">
      <ParamField body="type" type="'telegram'" required>
        Denotes that this is a Telegram account
      </ParamField>

      <ParamField body="telegramUserId" type="string" required>
        The user ID that owns this Telegram account
      </ParamField>

      <ParamField body="firstName" type="string | null" required>
        The first name of the user
      </ParamField>

      <ParamField body="lastName" type="string | null" required>
        The last name of the user
      </ParamField>

      <ParamField body="username" type="string | null" required>
        The username associated with the Telegram account
      </ParamField>

      <ParamField body="photoUrl" type="string | null" required>
        The url of the user's profile picture
      </ParamField>
    </Expandable>

    <Expandable title="CrossApp">
      <ParamField body="type" type="'cross_app'" required>
        Denotes that this is a cross-app account
      </ParamField>

      <ParamField body="embeddedWallets" type="{ address: string }[]" required>
        The user's embedded wallet address(es) from the provider app
      </ParamField>

      <ParamField body="smartWallets" type="{ address: string }[]" required>
        The user's smart wallet address(es) from the provider app
      </ParamField>

      <ParamField body="providerApp" type="ProviderAppMetadata" required>
        Metadata about the provider app
      </ParamField>

      <ParamField body="subject" type="string" required>
        The subject identifier for this cross-app account
      </ParamField>
    </Expandable>

    {/*

      <Expandable title="AuthorizationKey">

      <ParamField body="type" type="'authorization_key'" required>
        Denotes that this is an authorization key
      </ParamField>
      <ParamField body="publicKey" type="string" required>
        The public key of the authorization key
      </ParamField>
      </Expandable> 
      */}

    <br />
  </Tab>

  <Tab title="Flutter">
    Once a user has authenticated with Privy, you will have access to the `PrivyUser` object. This will be the main entry point for all user actions.

    ```dart  theme={"system"}
    abstract class PrivyUser {
      /// Unique identifier for the user.
      String get id;

      /// List of linked accounts associated with the user.
      List<LinkedAccounts> get linkedAccounts;

      /// List of embedded Ethereum wallets associated with the user.
      List<EmbeddedEthereumWallet> get embeddedEthereumWallets;

      /// List of embedded Solana wallets associated with the user.
      List<EmbeddedSolanaWallet> get embeddedSolanaWallets;

      /// Creates an Ethereum embedded wallet for the user.
      Future<Result<EmbeddedEthereumWallet>> createEthereumWallet(
          {bool allowAdditional = false});

      /// Creates a Solana embedded wallet for the user.
      Future<Result<EmbeddedSolanaWallet>> createSolanaWallet();
    }
    ```

    ## Linked accounts

    A user contains a list of LinkedAccounts, which are all account types associated with the user.

    ```dart  theme={"system"}
    /// A sealed class representing different types of linked accounts.
    sealed class LinkedAccount {}

    /// Represents a phone number-based linked account.
    class PhoneAccount extends LinkedAccount {}

    /// Represents an email-based linked account.
    class EmailAccount extends LinkedAccount {}

    /// Represents a custom authentication-linked account.
    class CustomAuth extends LinkedAccount {}

    /// Represents an Ethereum embedded wallet linked account.
    class EmbeddedEthereumWalletAccount extends LinkedAccount {}

    /// Represents a Solana embedded wallet linked account.
    class EmbeddedSolanaWalletAccount extends LinkedAccount {}
    ```

    ## Refreshing the `user` object

    To ensure the `user` object reflects the latest backend updates, invoke the **`refresh`** method on the user instance to synchronize it with the current data:

    ```dart  theme={"system"}
    final refreshResult = await privy.user?.refresh();
    ```

    If the refresh operation is successful, `refresh()` will return `Result.success` with no additional data.
    If an error occurs during the refresh operation, `refresh()` will return `Result.failure` with an encapsulated `PrivyException`.

    ***
  </Tab>

  <Tab title="Android">
    Once a user has authenticated with Privy, you will have access to the `PrivyUser` object. This will be the main entry point for all user actions.

    ```kotlin  theme={"system"}
    public data class PrivyUser(
        // The user's Privy ID
        val id: String,

        // A list of all linked accounts - can be authentication methods or embedded wallets
        val linkedAccounts: List<LinkedAccount>,

        // A list of user's ethereum wallets
        val ethereumWallets: List<EmbeddedEthereumWallet>,

        // A list of the user's solana wallets
        val solanaWallets: List<EmbeddedSolanaWallet>

        // Refresh the user
        public suspend fun refresh(): Result<Unit>

        // Other user methods
    )

    public sealed interface LinkedAccount {
        public data class PhoneAccount(/* Account specific data */) : LinkedAccount

        public data class EmailAccount(/* Account specific data */) : LinkedAccount

        public data class CustomAuth(/* Account specific data */) : LinkedAccount

        public data class EmbeddedEthereumWalletAccount(/* Account specific data */) : LinkedAccount

        public data class EmbeddedSolanaWalletAccount(/* Account specific data */) : LinkedAccount

        // Other linked account types
    }
    ```
  </Tab>

  <Tab title="Swift">
    Once a user has authenticated with Privy, you will have access to the `PrivyUser` object. This will be the main entry point for all user actions.

    ```swift  theme={"system"}
    public protocol PrivyUser {
        /// The user's Privy ID
        var id: String { get }

        /// The user's ID token
        var identityToken: String? { get }

        /// The point in time at which the logged in user was created.
        /// Value will only be nil if there is no user currently logged in.
        var createdAt: Date? { get }

        // A list of all linked accounts - can be authentication methods or embedded wallets
        var linkedAccounts: [LinkedAccount] { get }

        // A list of user's ethereum wallets
        var embeddedEthereumWallets: [EmbeddedEthereumWallet] { get }

        // A list of the user's solana wallets
        var embeddedSolanaWallets: [EmbeddedSolanaWallet] { get }

        // Refresh the user
        func refresh() async throws

        // Returns the user's access token, but will first refresh the user session if needed.
        func getAccessToken() async throws -> String

        // Other user methods
    }

    public enum LinkedAccount {
        case phone(PhoneNumberAccount)
        case email(EmailAccount)
        case customAuth(CustomAuth)
        case embeddedEthereumWallet(EmbeddedEthereumWalletAccount)
        case embeddedSolanaWallet(EmbeddedSolanaWalletAccount)

    // Other linked account types
    }
    ```
  </Tab>

  <Tab title="Unity">
    Once your user has successfully authenticated, you can get a `PrivyUser` object containing their account data via:

    ```csharp  theme={"system"}
    // User will be null if no user is authenticated
    PrivyUser user = PrivyManager.Instance.User;
    ```

    The `PrivyUser` implements the interface below:

    ```csharp  theme={"system"}
    public interface IPrivyUser
    {
        // The user's ID
        string Id { get; }

        // List of the User's linked accounts
        PrivyLinkedAccount[] LinkedAccounts { get; }

        // A list of the user's embedded ethereum wallets
        IEmbeddedEthereumWallet[] EmbeddedWallets { get; }

        // A list of the user's embedded solana wallets
        IEmbeddedSolanaWallet[] EmbeddedSolanaWallets { get; }

        // Creates an embedded ethereum wallet for the user
        Task<IEmbeddedEthereumWallet> CreateWallet(bool allowAdditional = false);

        // Creates an embedded solana wallet for the user
        Task<IEmbeddedSolanaWallet> CreateSolanaWallet(bool allowAdditional = false);

        // Custom user metadata, stored as a set of key-value pairs.
        // This custom metadata is set server-side.
        Dictionary<string, string> CustomMetadata { get; }
    }
    ```

    <Warning>
      Make sure you subscribe to the [Authentication State Updates](/authentication/user-authentication/authentication-state) and avoid calling the `IPrivyUser` object without being Authenticated, as properties will return a default value otherwise.

      <Accordion title="See the default values for the PrivyUser when the user is not authenticated:">
        * `user.Id = ""`
        * `user.LinkedAccounts = []`
        * `user.EmbeddedWallets = []`
        * `user.CustomMetadata = new Dictionary()`
      </Accordion>
    </Warning>

    <Tip>
      You can set custom metadata for a user via Privy's backend [server SDK and/or API endpoints](/user-management/users/custom-metadata).
    </Tip>
  </Tab>
</Tabs>


# UI components
Source: https://docs.privy.io/user-management/users/ui-components



<Tabs>
  <Tab title="React">
    Privy provides a `UserPill` component to easily embed in your application. Users can login or connect their wallet from the user pill. Once authenticated, users can interact with the pill to quickly view their account information and use their wallets.

        <img src="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Userpill2.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=0e1baa60006191c882308f8d592c2f41" alt="images/Userpill2.png" data-og-width="1540" width="1540" data-og-height="1100" height="1100" data-path="images/Userpill2.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Userpill2.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=ed624633c59e60d68ac4fb4f897c77a4 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Userpill2.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=2c89efa86cc50b2e770f35535009c28a 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Userpill2.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=e765c4566d86d57146b3d41d71d9c405 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Userpill2.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=1b6130ec0ce11a7d6b7823e9bc971b98 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Userpill2.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=575d9ba1b43765166cdae286ed1bbefe 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Userpill2.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=203102d7adc3a09f18604e7f137ca1d9 2500w" />

    ## Usage

    To use the user pill component, import from the `@privy-io/react-auth` package:

    ```tsx  theme={"system"}
    import {UserPill} from '@privy-io/react-auth/ui';
    ```

    Then, embed the user pill within any component wrapped by your `PrivyProvider`:

    ```tsx {8} theme={"system"}
    import {UserPill} from '@privy-io/react-auth/ui';

    function Page() {
      return (
        <div>
          <h1>Dashboard</h1>
          ...
          <UserPill />
          ...
        </div>
      );
    }
    ```

    You can also customize the user pill by passing the props describing the desired action, label, and size for the component. See more on these props below.

    ```tsx {18-22} theme={"system"}
    import {UserPill} from '@privy-io/react-auth/ui';

    const logoImageElement = (
      <Image
        className="h-8 w-8 rounded-full"
        src="/images/logo.png"
        alt="logo placeholder"
        height={32}
        width={32}
      />
    );

    function Page() {
      return (
        <div>
          <h1>Dashboard</h1>
          ...
          <UserPill
            action={{type: 'login', options: {loginMethods: ['email']}}}
            label={logoImageElement}
            size={32}
          />
          ...
        </div>
      );
    }
    ```

    <Tip>
      The `UserPill` component relies on some base CSS styles to render properly. If you notice styling issues with the component, you can add these foundational styles to your application:

      ```css  theme={"system"}
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        border: 0 solid;
      }

      html {
        font-family: sans-serif;
        line-height: 1.15;
      }

      button {
        background-color: transparent;
      }
      ```
    </Tip>

    ## Customizing via props

    Privy allows you to easily customize the user pill within your app by passing `action`, `label`, and/or `size` props on the component.

    | Prop | Type      | Description                               |
    | ---- | --------- | ----------------------------------------- |
    |      | See below | The action users take from the user pill. |
    |      |           |                                           |
    |      |           | The size (in pixels) of the pill button.  |
    |      |           |                                           |

    ### Action prop

    The action prop describes the action the user can take from the `UserPill` component. This prop is an object with a `type` and `options` field.

    You can set the `type` to:

    * `'connectWallet'` to guide the user to connect their wallet. If `type: 'connectWallet'` is set, you may set `options: {description?: string}` to provide a description for the wallet connection prompt.
    * `'login'` to guide the user to login to your application with any of your configured login methods. If `type: 'login'` is set, you may set `options` to an object containing `loginMethods` and/or `prefill`. The `loginMethods` field contains an array of the login methods to use in the pill and the `prefill` field contains an email address or phone number to prefill into the Privy login modal.

    Concretely, this type looks like

    ```tsx  theme={"system"}
    type Action =
      | {
          type: 'login';
          // Prompt the user to login
          options?: {
            loginMethods?: [string];
            prefill?: {
              type: 'email' | 'phone';
              value: string;
            };
          };
        }
      | {
          type: 'connectWallet';
          // Prompt the user to connect their wallet
          options?: {description?: string};
        };
    ```
  </Tab>
</Tabs>


# Unlinking accounts from users
Source: https://docs.privy.io/user-management/users/unlinking-accounts



Developers can use Privy to prompt users to unlink their linked accounts (such as a wallet or Discord profile) at *any point* in their user journey. This might be useful whenever the user has either created a new external account (such as a new Twitter profile or email address) and want to remove the old linked account from their user.

<Tabs>
  <Tab title="React">
    The React SDK supports unlinking all supported account types via our modal-guided link methods.
    **To prompt a user to unlink an account, use the respective method from the **`usePrivy`** hook:**

    | Method            | Description               |
    | ----------------- | ------------------------- |
    | `unlinkEmail`     | unlinks email address     |
    | `unlinkPhone`     | unlinks phone number      |
    | `unlinkWallet`    | unlinks external wallet   |
    | `unlinkGoogle`    | unlinks Google account    |
    | `unlinkApple`     | unlinks Apple account     |
    | `unlinkTwitter`   | unlinks Twitter account   |
    | `unlinkDiscord`   | unlinks Discord account   |
    | `unlinkGithub`    | unlinks Github account    |
    | `unlinklinkedIn`  | unlinks LinkedIn account  |
    | `unlinkTikTok`    | unlinks TikTok account    |
    | `unlinkSpotify`   | unlinks Spotify account   |
    | `unlinkInstagram` | unlinks Instagram account |
    | `unlinkTelegram`  | unlinks Telegram account  |
    | `unlinkFarcaster` | unlinks Farcaster account |
    | `unlinkPasskey`   | unlinks passkey           |

    <Info>
      Users are only permitted to unlink **an account** so long as they have at least one more linked account.
    </Info>

    Below is an example button for prompting a user to unlink certain linked accounts:

    ```tsx  theme={"system"}
    import {usePrivy} from '@privy-io/react-auth';

    function LinkOptions() {
    const {unlinkEmail, unlinkGoogle, unlinkWallet} = usePrivy();

    return (
    <div className="unlink-options">
    <button onClick={unlinkEmail}>Unlink Email to user</button>
    <button onClick={unlinkGoogle}>Unlink Google account to user</button>
    <button onClick={unlinkWallet}>Unlink Wallet to user</button>
    </div>
    );
    }
    ```
  </Tab>

  <Tab title="React Native">
    **To prompt a user to unlink an account, use the respective functions and hooks:**

    | Account type | Description               | Hook to invoke       |
    | ------------ | ------------------------- | -------------------- |
    | `Email`      | Unlinks email address     | `useUnlinkEmail`     |
    | `Wallet`     | Unlinks external wallet   | `useUnlinkWallet`    |
    | `Google`     | Unlinks Google account    | `useUnlinkOAuth`     |
    | `Apple`      | Unlinks Apple account     | `useUnlinkOAuth`     |
    | `Twitter`    | Unlinks Twitter account   | `useUnlinkOAuth`     |
    | `Discord`    | Unlinks Discord account   | `useUnlinkOAuth`     |
    | `Github`     | Unlinks Github account    | `useUnlinkOAuth`     |
    | `LinkedIn`   | Unlinks LinkedIn account  | `useUnlinkOAuth`     |
    | `TikTok`     | Unlinks TikTok account    | `useUnlinkOAuth`     |
    | `Spotify`    | Unlinks Spotify account   | `useUnlinkOAuth`     |
    | `Instagram`  | Unlinks Instagram account | `useUnlinkOAuth`     |
    | `Farcaster`  | Unlinks Farcaster account | `useUnlinkFarcaster` |

    <Info>
      Users are only permitted to unlink **an account** so long as they have at least one more linked account.
    </Info>

    <Tabs>
      <Tab title="Email">
        ### Usage

        ```tsx  theme={"system"}
        import {useUnlinkEmail} from '@privy-io/expo';
        const {unlinkEmail} = useUnlinkEmail();
        await unlinkEmail({ email: 'user@example.com' });
        ```

        ### Parameters

        <ParamField path="email" type="string" required>
          The email address to unlink from the current user.
        </ParamField>

        ### Callbacks

        You can optionally register an `onSuccess` or `onError` callback on the `useUnlinkEmail` hook.

        ```tsx  theme={"system"}
        import {useUnlinkEmail} from '@privy-io/expo';
        const {unlinkEmail} = useUnlinkEmail({
          onSuccess: (user) => {
            console.log('Email unlinked', user);
          },
          onError: (err) => console.error(err),
        });
        ```

        <ParamField path="onSuccess" type="(user: User) => void">
          Optional callback to run after a user successfully unlinks an email address.
        </ParamField>

        <ParamField path="onError" type="(err: string) => void">
          Optional callback to run after there is an error during email unlinking.
        </ParamField>
      </Tab>

      <Tab title="Wallet">
        ### Usage

        ```tsx  theme={"system"}
        import {useUnlinkWallet} from '@privy-io/expo';
        const {unlinkWallet} = useUnlinkWallet();
        await unlinkWallet({ address: 'wallet_address' });
        ```

        ### Parameters

        <ParamField path="address" type="string" required>
          The wallet address to unlink from the current user.
        </ParamField>

        ### Callbacks

        You can optionally register an `onSuccess` or `onError` callback on the `useUnlinkWallet` hook.

        ```tsx  theme={"system"}
        import {useUnlinkWallet} from '@privy-io/expo';
        const {unlinkWallet} = useUnlinkWallet({
          onSuccess: (user, isNewUser) => {
            console.log('Wallet unlinked', user, isNewUser);
          },
          onError: (err) => console.error(err),
        });
        ```

        <ParamField path="onSuccess" type="(user: User, isNewUser: boolean) => void">
          Optional callback to run after a user successfully unlinks a wallet.
        </ParamField>

        <ParamField path="onError" type="(err: string) => void">
          Optional callback to run after there is an error during wallet unlinking.
        </ParamField>
      </Tab>

      <Tab title="OAuth">
        ### Usage

        ```tsx  theme={"system"}
        import {useUnlinkOAuth} from '@privy-io/expo';
        const {unlinkOAuth} = useUnlinkOAuth();
        await unlinkOAuth({ provider: 'google', subject: 'subject_identifier' });
        ```

        ### Parameters

        <ParamField path="provider" type="'google' | 'apple' | 'twitter' | 'discord' | 'github' | 'linkedin' | 'tiktok' | 'spotify' | 'instagram'" required>
          The OAuth provider for the account to unlink.
        </ParamField>

        <ParamField path="subject" type="string" required>
          The provider-specific subject ("sub" claim) that uniquely identifies the user for the selected OAuth provider.
        </ParamField>
      </Tab>

      <Tab title="Farcaster">
        ### Usage

        ```tsx  theme={"system"}
        import {useUnlinkFarcaster} from '@privy-io/expo';
        const {unlinkFarcaster} = useUnlinkFarcaster();
        await unlinkFarcaster({ fid: 123 });
        ```

        ### Parameters

        <ParamField path="fid" type="number" required>
          The Farcaster ID to unlink from the current user.
        </ParamField>

        ### Callbacks

        You can optionally register an `onSuccess` or `onError` callback on the `useUnlinkFarcaster` hook.

        ```tsx  theme={"system"}
        import {useUnlinkFarcaster} from '@privy-io/expo';
        const {unlinkFarcaster} = useUnlinkFarcaster({
          onSuccess: (user) => console.log('Farcaster unlinked', user),
          onError: (err) => console.error(err),
        });
        ```

        <ParamField path="onSuccess" type="(user: User) => void">
          Optional callback to run after a user successfully unlinks a Farcaster account.
        </ParamField>

        <ParamField path="onError" type="(err: string) => void">
          Optional callback to run after there is an error during Farcaster unlinking.
        </ParamField>
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="REST API">
    Make a `POST` request to:

    ```bash  theme={"system"}
    https://auth.privy.io/api/v1/apps/<privy-app-id>/users/unlink
    ```

    Replace `<privy-app-id>` with your Privy app ID and pass in the following parameters:

    | Parameter  | Type     | Description                                                                                 |
    | ---------- | -------- | ------------------------------------------------------------------------------------------- |
    | `user_id`  | `string` | Privy DID of the user                                                                       |
    | `type`     | `string` | Linked account type (see supported types below)                                             |
    | `handle`   | `string` | The identifier for the account (e.g., email address, wallet address)                        |
    | `provider` | `string` | (Only required for cross app unlinking) The cross app provider id, prefixed with `'privy:'` |

    ### Supported Account Types

    The following account types can be unlinked via the API:

    * `email` - Email accounts
    * `phone` - Phone number accounts
    * `wallet` - Externally connected wallets (Ethereum or Solana)
    * `smart_wallet` - Smart contract wallets
    * `farcaster` - Farcaster accounts
    * `telegram` - Telegram accounts
    * `cross_app` - Cross app accounts
    * OAuth providers:
      * `google_oauth`
      * `discord_oauth`
      * `twitter_oauth`
      * `github_oauth`
      * `linkedin_oauth`
      * `apple_oauth`
      * `spotify_oauth`
      * `instagram_oauth`
      * `tiktok_oauth`

    <Note>
      The API does not support unlinking `passkey`, `custom_auth`, `cross_app`, or `guest` account
      types.
    </Note>

    ### Example Requests

    <CodeGroup>
      ```bash Email account theme={"system"}
      curl --request POST "https://auth.privy.io/api/v1/apps/<privy-app-id>/users/unlink" \
      -u "<your-privy-app-id>:<your-privy-app-secret>" \
      -H "privy-app-id: <your-privy-app-id>" \
      -H 'Content-Type: application/json' \
      -d '{
        "user_id": "<user-did>",
        "type": "email",
        "handle": "test@privy.io"
      }'
      ```

      ```bash Wallet account theme={"system"}
      curl --request POST "https://auth.privy.io/api/v1/apps/<privy-app-id>/users/unlink" \
      -u "<your-privy-app-id>:<your-privy-app-secret>" \
      -H "privy-app-id: <your-privy-app-id>" \
      -H 'Content-Type: application/json' \
      -d '{
        "user_id": "<user-did>",
        "type": "wallet",
        "handle": "0x1234...5678"
      }'
      ```

      ```bash OAuth account theme={"system"}
      curl --request POST "https://auth.privy.io/api/v1/apps/<privy-app-id>/users/unlink" \
      -u "<your-privy-app-id>:<your-privy-app-secret>" \
      -H "privy-app-id: <your-privy-app-id>" \
      -H 'Content-Type: application/json' \
      -d '{
        "user_id": "<user-did>",
        "type": "google_oauth",
        "handle": "<subject-identifier>"
      }'
      ```

      ```bash Cross app account theme={"system"}
      curl --request POST "https://auth.privy.io/api/v1/apps/<privy-app-id>/users/unlink" \
      -u "<your-privy-app-id>:<your-privy-app-secret>" \
      -H "privy-app-id: <your-privy-app-id>" \
      -H 'Content-Type: application/json' \
      -d '{
        "user_id": "<user-did>",
        "type": "cross_app",
        "handle": "<subject-identifier>",
        "provider": "privy:<cross-app-provider-id>"
      }'
      ```
    </CodeGroup>

    ### Response

    If the unlinking is successful, the API will return a 200 status code.

    If there's no account associated with the Privy DID that matches the type and handle, the API will return a 400 status code.
  </Tab>

  <Tab title="Dashboard">
    To unlink via the dashboard:

    1. Navigate to the [Users page](https://dashboard.privy.io/?page=users\&tab=all-users)
    2. Select the user
    3. Click the button beside the account you want to unlink
    4. Click `Unlink account`

    <Note>
      The unlink option won't appear if unlinking is not available for the account.
    </Note>

        <img src="https://mintcdn.com/privy-c2af3412/Ih_Fo3QYM486gzWq/images/users-unlink.png?fit=max&auto=format&n=Ih_Fo3QYM486gzWq&q=85&s=3504f9666c84c559bb47b134172aa8d3" alt="Unlinking an account in the Privy Dashboard" data-og-width="1280" width="1280" data-og-height="894" height="894" data-path="images/users-unlink.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/Ih_Fo3QYM486gzWq/images/users-unlink.png?w=280&fit=max&auto=format&n=Ih_Fo3QYM486gzWq&q=85&s=ff626060473ffbca8dc280c4b35cec41 280w, https://mintcdn.com/privy-c2af3412/Ih_Fo3QYM486gzWq/images/users-unlink.png?w=560&fit=max&auto=format&n=Ih_Fo3QYM486gzWq&q=85&s=00ceedf421684973daafe8ca0c1ef51c 560w, https://mintcdn.com/privy-c2af3412/Ih_Fo3QYM486gzWq/images/users-unlink.png?w=840&fit=max&auto=format&n=Ih_Fo3QYM486gzWq&q=85&s=5ee11e8ad54d838107a227b22175d197 840w, https://mintcdn.com/privy-c2af3412/Ih_Fo3QYM486gzWq/images/users-unlink.png?w=1100&fit=max&auto=format&n=Ih_Fo3QYM486gzWq&q=85&s=76b234eaf96052773e244519d380d3a3 1100w, https://mintcdn.com/privy-c2af3412/Ih_Fo3QYM486gzWq/images/users-unlink.png?w=1650&fit=max&auto=format&n=Ih_Fo3QYM486gzWq&q=85&s=488e942fa3f994820e6cedce3ea5ce8d 1650w, https://mintcdn.com/privy-c2af3412/Ih_Fo3QYM486gzWq/images/users-unlink.png?w=2500&fit=max&auto=format&n=Ih_Fo3QYM486gzWq&q=85&s=9d248dfc2b1a1d6b43fd39b0986490d3 2500w" />
  </Tab>
</Tabs>


# Updating user accounts
Source: https://docs.privy.io/user-management/users/updating-accounts



<Tabs>
  <Tab title="React">
    <Tabs>
      <Tab title="Email">
        To prompt users to change their email, you can use the `updateEmail` method from the `usePrivy` hook:

        ```tsx  theme={"system"}
        updateEmail: () => void
        ```

        ### Usage

        ```tsx  theme={"system"}
        import {usePrivy} from '@privy-io/react-auth';
        const {updateEmail} = usePrivy();
        ```

        When invoked, the method will open the Privy modal and guide the user through updating their existing email to a new one. If a user does not already have an email account and attempts to update it, Privy will throw an error indicating such.

        ### Example

        ```tsx  theme={"system"}
        import {usePrivy} from '@privy-io/react-auth';

        function Page() {
          const {ready, authenticated, user, updateEmail} = usePrivy();

          return (
            <button onClick={updateEmail} disabled={!ready || !authenticated || !user.email}>
              Update your email
            </button>
          );
        }
        ```

        <Info>
          In the event that a user encounters an error through the flow, their existing account will be maintained.
        </Info>
      </Tab>

      <Tab title="Phone Number">
        To prompt users to change their phone number, you can use the `updatePhone` method from the `usePrivy` hook:

        ```tsx  theme={"system"}
        updatePhone: () => void
        ```

        ### Usage

        ```tsx  theme={"system"}
        import {usePrivy} from '@privy-io/react-auth';
        const {updatePhone} = usePrivy();
        ```

        When invoked, the method will open the Privy modal and guide the user through updating their existing phone number to a new one. If a user does not already have a phone account and attempts to update it, Privy will throw an error indicating such.

        ### Example

        ```tsx  theme={"system"}
        import {usePrivy} from '@privy-io/react-auth';

        function Page() {
          const {ready, authenticated, user, updatePhone} = usePrivy();

          return (
            <button onClick={updatePhone} disabled={!ready || !authenticated || !user.phone}>
              Update your phone number
            </button>
          );
        }
        ```

        <Info>
          In the event that a user encounters an error through the flow, their existing account will be maintained.
        </Info>
      </Tab>
    </Tabs>

    ### Callbacks

    To configure callbacks for Privy's `updateEmail` and `updatePhone` methods, use the `useUpdateAccount` hook:

    ```tsx  theme={"system"}
    useUpdateAccount: ({
      onSuccess?: ({user, updateMethod, updatedAccount}) => void,
      onError?: (error, details) => void
    }) => {updateEmail: () => void, updatePhone: () => void}
    ```

    ### Usage

    ```tsx  theme={"system"}
    import {useUpdateAccount} from '@privy-io/react-auth';

    const {updateEmail, updatePhone} = useUpdateAccount({
      onSuccess: ({user, updateMethod, updatedAccount}) => {
        console.log(user, updateMethod, updatedAccount);
        // Any logic you'd like to execute if the user successfully updates an account
      },
      onError: (error, details) => {
        console.log(error, details);
        // Any logic you'd like to execute after a user exits the updateAccount flow or there is an error
      }
    });

    // Then call one of the update methods in your code, which will invoke these callbacks on completion
    ```

    ### Parameters

    The `useUpdateAccount` hook accepts an options object with the following fields:

    <ParamField path="onSuccess" type="({user: User, updateMethod: string, updatedAccount: LinkedAccountType}) => void">
      Optional callback to run after a user successfully updates an account.
    </ParamField>

    <ParamField path="onError" type="(error: string, details: {updateMethod: string}) => void">
      Optional callback to run if there is an error during the update account flow, or if the user exits the flow prematurely.
    </ParamField>

    ### Callback Details

    #### onSuccess

    If set, the `onSuccess` callback will execute after a user has successfully updated either their phone or email on their Privy account.

    Within this callback, you can access:

    <ResponseField name="user" type="User">
      The user object with the user's DID, linked accounts, and more.
    </ResponseField>

    <ResponseField name="updateMethod" type="string">
      A string indicating the type of update flow just executed for the authenticated user.
      Possible values are `'email'` or `'sms'`.
    </ResponseField>

    <ResponseField name="updatedAccount" type="LinkedAccountType">
      An object representing the account that was just updated on the authenticated user.
    </ResponseField>

    <details>
      <summary><b>See an example of using the onSuccess callback for updating an account!</b></summary>

      As an example, you might configure an `onSuccess` callback to support the following behavior:

      * If the user updates an email to their account, add the new updated email to your own Users DB.

      Below is a template for implementing the above with `onSuccess`:

      ```tsx  theme={"system"}
      const {updateEmail, updatePhone} = useUpdateAccount({
        onSuccess: ({user, updatedAccount}) => {
          if (updatedAccount === 'email') {
            // show a toast, send analytics event, etc...
          } else if (updatedAccount === 'sms') {
            // show a toast, send analytics event, etc...
          }
        }
      });
      ```
    </details>

    #### onError

    If set, the `onError` callback will execute after a user initiates an update account attempt and there is an error, or if the user exits the update account flow prematurely.

    Within this callback, you can access:

    <ResponseField name="error" type="string">
      The error code with more information about the error.
    </ResponseField>

    <ResponseField name="details.updateMethod" type="string">
      A string indicating the type of update account flow just attempted for the authenticated user.
    </ResponseField>
  </Tab>

  <Tab title="React Native">
    <Tabs>
      <Tab title="Email">
        To update a user's email, use the `useUpdateEmail` hook:

        ```tsx  theme={"system"}
        const {sendCode, updateEmail} = useUpdateEmail();
        ```

        ### Send an OTP

        First, use the `sendCode` method to send an OTP verification code to the user's new email address:

        ```tsx  theme={"system"}
        sendCode: ({newEmailAddress: string}) => Promise<void>
        ```

        ### Usage

        ```tsx  theme={"system"}
        import {useUpdateEmail} from '@privy-io/expo';
        const {sendCode} = useUpdateEmail();
        ```

        ### Parameters

        <ParamField path="newEmailAddress" type="string">
          The new email address to be validated.
        </ParamField>

        This will send a one-time passcode to the new email address, which the user will need to enter to verify it and confirm the update.
        The method returns a `Promise` that resolves if the code was sent successfully, and rejects otherwise.

        ### Example

        ```tsx  theme={"system"}
        import {useUpdateEmail} from '@privy-io/expo';

        function UpdateEmailForm() {
          const {sendCode} = useUpdateEmail();

          const [newEmailAddress, setNewEmailAddress] = useState('');

          return (
            <View>
              <Input value={newEmailAddress} onChangeText={setNewEmailAddress} />
              <Button onPress={() => sendCode({newEmailAddress})}>Send code</Button>
            </View>
          );
        }
        ```

        ### Verify the OTP

        Prompt the user for the OTP they received and verify the OTP by passing it to the `updateEmail` method:

        ```tsx  theme={"system"}
        updateEmail: ({newEmailAddress: string, code: string}) => Promise<User>
        ```

        ### Usage

        ```tsx  theme={"system"}
        import {useUpdateEmail} from '@privy-io/expo';
        const {updateEmail} = useUpdateEmail();
        ```

        ### Parameters

        <ParamField path="newEmailAddress" type="string">
          The new email address to set.
        </ParamField>

        <ParamField path="code" type="string">
          The one time code received on the new email address.
        </ParamField>

        ### Returns

        <ResponseField name="user" type="Promise<User>">
          A `Promise` that resolves with the updated user object if the update was successful, and rejects otherwise.
        </ResponseField>

        ### Example

        ```tsx  theme={"system"}
        import {useUpdateEmail} from '@privy-io/expo';

        function ConfirmEmailUpdateForm() {
          const {updateEmail} = useUpdateEmail();

          const [code, setCode] = useState('');

          return (
            <View>
              <Input value={code} onChangeText={setCode} />
              <Button onPress={() => updateEmail({code, newEmailAddress})}>Confirm</Button>
            </View>
          );
        }
        ```
      </Tab>

      <Tab title="Phone Number">
        To update a user's phone number, use the `useUpdatePhone` hook:

        ```tsx  theme={"system"}
        const {sendCode, updatePhone} = useUpdatePhone();
        ```

        ### Send an OTP

        First, use the `sendCode` method to send an OTP verification code to the user's new phone number:

        ```tsx  theme={"system"}
        sendCode: ({newPhoneNumber: string}) => Promise<void>
        ```

        ### Usage

        ```tsx  theme={"system"}
        import {useUpdatePhone} from '@privy-io/expo';
        const {sendCode} = useUpdatePhone();
        ```

        ### Parameters

        <ParamField path="newPhoneNumber" type="string">
          The new phone number to be validated.
        </ParamField>

        This will send a one-time passcode to the new phone number, which the user will need to enter to verify it and confirm the update.
        The method returns a `Promise` that resolves if the code was sent successfully, and rejects otherwise.

        ### Example

        ```tsx  theme={"system"}
        import {useUpdatePhone} from '@privy-io/expo';

        function UpdatePhoneForm() {
          const {sendCode} = useUpdatePhone();

          const [newPhoneNumber, setNewPhoneNumber] = useState('');

          return (
            <View>
              <Input value={newPhoneNumber} onChangeText={setNewPhoneNumber} />
              <Button onPress={() => sendCode({newPhoneNumber})}>Send code</Button>
            </View>
          );
        }
        ```

        ### Verify the OTP

        Prompt the user for the OTP they received and verify the OTP by passing it to the `updatePhone` method:

        ```tsx  theme={"system"}
        updatePhone: ({newPhoneNumber: string, code: string}) => Promise<User>
        ```

        ### Usage

        ```tsx  theme={"system"}
        import {useUpdatePhone} from '@privy-io/expo';
        const {updatePhone} = useUpdatePhone();
        ```

        ### Parameters

        <ParamField path="newPhoneNumber" type="string">
          The new phone number to set.
        </ParamField>

        <ParamField path="code" type="string">
          The one time code received on the new phone number.
        </ParamField>

        ### Returns

        <ResponseField name="user" type="Promise<User>">
          A `Promise` that resolves with the updated user object if the update was successful, and rejects otherwise.
        </ResponseField>

        ### Example

        ```tsx  theme={"system"}
        import {useUpdatePhone} from '@privy-io/expo';

        function ConfirmPhoneUpdateForm() {
          const {updatePhone} = useUpdatePhone();

          const [code, setCode] = useState('');

          return (
            <View>
              <Input value={code} onChangeText={setCode} />
              <Button onPress={() => updatePhone({code, newPhoneNumber})}>Confirm</Button>
            </View>
          );
        }
        ```
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Swift">
    <Tabs>
      <Tab title="Email">
        To update a user's email, use the `privy.email.updateWithCode` method:

        ```swift  theme={"system"}
        updateWithCode(_ code: String, sentTo email: String) async throws
        ```

        ## Send an OTP

        First, use the `sendCode` method to send an OTP verification code to the user's new email address:

        ```swift  theme={"system"}
        sendCode(to email: String) async throws
        ```

        ### Usage

        ```swift  theme={"system"}
        try await privy.email.sendCode(to: "newemail@privy.io")
        // successfully sent code to user's new email
        ```

        ### Parameters

        <ParamField path="to email" type="string">
          The new email address to be validated.
        </ParamField>

        This will send a one-time passcode to the new email address,
        which the user will need to enter to verify it and confirm the
        update.

        ## Verify the OTP

        Prompt the user for the OTP they received and verify the OTP by
        passing it to the `updateWithCode` method:

        ```swift  theme={"system"}
        updateWithCode(_ code: String, sentTo email: String) async throws
        ```

        ### Usage

        ```swift  theme={"system"}
        try await privy.email.updateWithCode("123456", sentTo: "newemail@privy.io")
        ```

        ### Parameters

        <ParamField path="_ code" type="string">
          The one time code received on the new email address.
        </ParamField>

        <ParamField path="sentTo email" type="string">
          The new email address to set.
        </ParamField>
      </Tab>

      <Tab title="Phone Number">
        To update a user's phone number, use the `privy.sms.updateWithCode` method:

        ```swift  theme={"system"}
        updateWithCode(_ code: String, sentTo phoneNumber: String) async throws
        ```

        ## Send an OTP

        First, use the `sendCode` method to send an OTP verification code to the user's new phone number:

        ```swift  theme={"system"}
        sendCode(to phoneNumber: String) async throws
        ```

        ### Usage

        ```swift  theme={"system"}
        try await privy.sms.sendCode(to: "+1234567890")
        // successfully sent code to user's new phone number
        ```

        ### Parameters

        <ParamField path="to phoneNumber" type="string">
          The new phone number to be validated.
        </ParamField>

        This will send a one-time passcode to the new phone number,
        which the user will need to enter to verify it and confirm the
        update.

        ## Verify the OTP

        Prompt the user for the OTP they received and verify the OTP by
        passing it to the `updateWithCode` method:

        ```swift  theme={"system"}
        updateWithCode(_ code: String, sentTo phoneNumber: String) async throws
        ```

        ### Usage

        ```swift  theme={"system"}
        try await privy.sms.updateWithCode("123456", sentTo: "+1234567890")
        ```

        ### Parameters

        <ParamField path="_ code" type="string">
          The one time code received on the new phone number.
        </ParamField>

        <ParamField path="sentTo phoneNumber" type="string">
          The new phone number to set.
        </ParamField>
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Android">
    <Tabs>
      <Tab title="Email">
        To update a user's email, use the `privy.email.updateWithCode` method:

        ```kotlin  theme={"system"}
        suspend fun updateWithCode(code: String, email: String): Result<Unit>
        ```

        ## Send an OTP

        First, use the `sendCode` method to send an OTP verification code to the user's new email address:

        ```kotlin  theme={"system"}
        suspend fun sendCode(email: String): Result<Unit>
        ```

        ### Usage

        ```kotlin  theme={"system"}
        privy.email.sendCode(email = "newemail@privy.io").fold(
            onSuccess = {
                // Successfully sent code to user's new email address
            },
            onFailure = { error ->
                // Handle error
            }
        )
        ```

        ### Parameters

        <ParamField path="email" type="String">
          The new email address to be validated.
        </ParamField>

        This will send a one-time passcode to the new email address, which the user will need to enter to verify it and confirm the update.

        ## Verify the OTP

        Prompt the user for the OTP they received and verify the OTP by passing it to the `updateWithCode` method:

        ```kotlin  theme={"system"}
        suspend fun updateWithCode(code: String, email: String): Result<Unit>
        ```

        ### Usage

        ```kotlin  theme={"system"}
        privy.email.updateWithCode(code = "123456", email = "newemail@privy.io").fold(
            onSuccess = {
                // Email address successfully updated
            },
            onFailure = { error ->
                // Handle error
            }
        )
        ```

        ### Parameters

        <ParamField path="code" type="String">
          The one time code received on the new email address.
        </ParamField>

        <ParamField path="email" type="String">
          The new email address to set.
        </ParamField>
      </Tab>

      <Tab title="Phone Number">
        To update a user's phone number, use the `privy.sms.updateWithCode` method:

        ```kotlin  theme={"system"}
        suspend fun updateWithCode(code: String, phoneNumber: String): Result<Unit>
        ```

        ## Send an OTP

        First, use the `sendCode` method to send an OTP verification code to the user's new phone number:

        ```kotlin  theme={"system"}
        suspend fun sendCode(phoneNumber: String): Result<Unit>
        ```

        ### Usage

        ```kotlin  theme={"system"}
        privy.sms.sendCode(phoneNumber = "+15551234567").fold(
            onSuccess = {
                // Successfully sent code to user's new phone number
            },
            onFailure = { error ->
                // Handle error
            }
        )
        ```

        ### Parameters

        <ParamField path="phoneNumber" type="String">
          The new phone number to be validated.
        </ParamField>

        This will send a one-time passcode to the new phone number, which the user will need to enter to verify it and confirm the update.

        ## Verify the OTP

        Prompt the user for the OTP they received and verify the OTP by passing it to the `updateWithCode` method:

        ```kotlin  theme={"system"}
        suspend fun updateWithCode(code: String, phoneNumber: String): Result<Unit>
        ```

        ### Usage

        ```kotlin  theme={"system"}
        privy.sms.updateWithCode(code = "123456", phoneNumber = "+15551234567").fold(
            onSuccess = {
                // Phone number successfully updated
            },
            onFailure = { error ->
                // Handle error
            }
        )
        ```

        ### Parameters

        <ParamField path="code" type="String">
          The one time code received on the new phone number.
        </ParamField>

        <ParamField path="phoneNumber" type="String">
          The new phone number to set.
        </ParamField>
      </Tab>
    </Tabs>
  </Tab>
</Tabs>


# Handling events
Source: https://docs.privy.io/user-management/users/webhooks/handling-events



When a user takes an action in your application, Privy will emit a webhooks payload with the following fields:

## Webhook example payloads

Webhook payloads generally have two different formats. Both formats include a `user` object that is the same structure as what [the user REST API](/user-management/users/the-user-object) returns. For webhook events that involve an account change, we will include an `account` object that represents the changed account. For example, in a `user.unlinked_account` event, the `account` value will be the account that was just removed, so it will no longer exist on the `user`.

Example payload for different webhook events:

<CodeGroup>
  ```json user.created theme={"system"}
  {
    "type": "user.created",
    "user": {
      "created_at": 969628260,
      "has_accepted_terms": false,
      "id": "did:privy:cfbsvtqo2c22202mo08847jdux2z",
      "is_guest": false,
      "linked_accounts": [
        {
          "address": "bilbo@privy.io",
          "first_verified_at": 969628260,
          "latest_verified_at": 969628260,
          "type": "email",
          "verified_at": 969628260
        }
      ],
      "mfa_methods": []
    }
  }
  ```

  ```json user.authenticated theme={"system"}
  {
    "type": "user.authenticated",
    "account": {
      "address": "bilbo@privy.io",
      "first_verified_at": 969628260,
      "latest_verified_at": 969628260,
      "type": "email",
      "verified_at": 969628260
    },
    "user": {
      "created_at": 969628260,
      "has_accepted_terms": false,
      "id": "did:privy:cfbsvtqo2c22202mo08847jdux2z",
      "is_guest": false,
      "linked_accounts": [
        {
          "address": "bilbo@privy.io",
          "first_verified_at": 969628260,
          "latest_verified_at": 969628260,
          "type": "email",
          "verified_at": 969628260
        }
      ],
      "mfa_methods": []
    }
  }
  ```

  ```json user.linked_account theme={"system"}
  {
    "type": "user.linked_account",
    "account": {
      "address": "bilbo@privy.io",
      "first_verified_at": 969628260,
      "latest_verified_at": 969628260,
      "type": "email",
      "verified_at": 969628260
    },
    "user": {
      "created_at": 969628260,
      "has_accepted_terms": false,
      "id": "did:privy:cfbsvtqo2c22202mo08847jdux2z",
      "is_guest": false,
      "linked_accounts": [
        {
          "address": "bilbo@privy.io",
          "first_verified_at": 969628260,
          "latest_verified_at": 969628260,
          "type": "email",
          "verified_at": 969628260
        }
      ],
      "mfa_methods": []
    }
  }
  ```

  ```json user.wallet_created theme={"system"}
  {
    "type": "user.wallet_created"
    "user": {
      "created_at": 969628260,
      "has_accepted_terms": false,
      "id": "did:privy:cfbsvtqo2c22202mo08847jdux2z",
      "is_guest": false,
      "linked_accounts": [
        {
          "address": "bilbo@privy.io",
          "first_verified_at": 969628260,
          "latest_verified_at": 969628260,
          "type": "email",
          "verified_at": 969628260
        }
      ],
      "mfa_methods": []
    },
    "wallet": {
      "type": "wallet",
      "address": "0x123...",
      "chain_type": "ethereum"
    }
  }
  ```

  ```json user.unlinked_account theme={"system"}
  {
    "type": "user.unlinked_account",
    "account": {
      "address": "bilbo@privy.io",
      "first_verified_at": 969628260,
      "latest_verified_at": 969628260,
      "type": "email",
      "verified_at": 969628260
    },
    "user": {
      "created_at": 969628260,
      "has_accepted_terms": false,
      "id": "did:privy:cfbsvtqo2c22202mo08847jdux2z",
      "is_guest": false,
      "linked_accounts": [
        {
          "address": "bilbo@privy.io",
          "first_verified_at": 969628260,
          "latest_verified_at": 969628260,
          "type": "email",
          "verified_at": 969628260
        }
      ],
      "mfa_methods": []
    }
  }
  ```

  ```json user.updated_account theme={"system"}
  {
    "type": "user.updated_account",
    "account": {
      "address": "bilbo@privy.io",
      "first_verified_at": 969628260,
      "latest_verified_at": 969628260,
      "type": "email",
      "verified_at": 969628260
    },
    "user": {
      "created_at": 969628260,
      "has_accepted_terms": false,
      "id": "did:privy:cfbsvtqo2c22202mo08847jdux2z",
      "is_guest": false,
      "linked_accounts": [
        {
          "address": "bilbo@privy.io",
          "first_verified_at": 969628260,
          "latest_verified_at": 969628260,
          "type": "email",
          "verified_at": 969628260
        }
      ],
      "mfa_methods": []
    }
  }
  ```

  ```json user.transferred_account theme={"system"}
  {
    "type": "user.transferred_account",
    "fromUser": {
      "id": "did:privy:clu2wsin402h9h9kt6ae7dfuh"
    },
    "toUser": {
      "created_at": 969628260,
      "has_accepted_terms": false,
      "id": "did:privy:cfbsvtqo2c22202mo08847jdux2z",
      "is_guest": false,
      "linked_accounts": [
        {
          "address": "bilbo@privy.io",
          "first_verified_at": 969628260,
          "latest_verified_at": 969628260,
          "type": "email",
          "verified_at": 969628260
        },
        {
          "address": "+1234567890",
          "first_verified_at": 969628260,
          "latest_verified_at": 969628260,
          "type": "phone",
          "verified_at": 969628260
        }
      ]
    },
    "account": {
      "address": "+1234567890",
      "first_verified_at": 969628260,
      "latest_verified_at": 969628260,
      "type": "phone",
      "verified_at": 969628260
    },
    "deletedUser": true
  }
  ```

  ```json mfa.enabled theme={"system"}
  {
    "type": "mfa.enabled",
    "user_id": "user_123",
    "method": "sms"
  }
  ```

  ```json mfa.disabled theme={"system"}
  {
    "type": "mfa.disabled",
    "user_id": "user_123",
    "method": "sms"
  }
  ```

  ```json wallet.private_key_export theme={"system"}
  {
    "type": "wallet.private_key_export",
    "user_id": "user_123",
    "wallet_id": "wallet_123",
    "wallet_address": "0x123..."
  }
  ```

  ```json wallet.recovery_setup theme={"system"}
  {
    "type": "wallet.recovery_setup",
    "user_id": "user_123",
    "wallet_id": "wallet_123",
    "wallet_address": "0x123...",
    "method": "passkey"
  }
  ```

  ```json wallet.recovered theme={"system"}
  {
    "type": "wallet.recovered",
    "user_id": "user_123",
    "wallet_id": "wallet_123",
    "wallet_address": "0x123..."
  }
  ```

  ```json privy.test theme={"system"}
  {
    "type": "privy.test",
    "message": "Hello, World!"
  }
  ```
</CodeGroup>

You can find information about transaction and balance webhooks under [Gas and asset management](/wallets/gas-and-asset-management/assets/transaction-event-webhooks)

## Webhook signing key

The webhook signing key is necessary to verify that the payloads sent to your endpoint are from Privy. Follow the steps below in order to set up webhook verification in your backend.

<Accordion title="Verifying a webhook payload">
  Webhook payloads must be verified before they are trusted and used on your server. This is done by verifying a signature sent with your webhook. Privy uses [`svix`](https://www.svix.com/) for webhooks infrastructure.

  <Tip>
    Your endpoint must return a 2xx (status code 200-299) response for the webhook to be marked as
    delivered. Any other statuses (including 3xx) are considered failed deliveries. Your endpoint will
    be automatically disabled after 5 consecutive days of delivery failures
  </Tip>

  ## Using `@privy-io/server-auth`

  Use the **`PrivyClient`**'s **`verifyWebhook`** method to verify an incoming webhook. Pass in the request body, headers, and signing key (from the Privy Dashboard). As an example, for a NextJS API request, you can verify a webhook using the code below:

  ```tsx  theme={"system"}
  // req is an input of type `NextApiRequest`

  const privy = new PrivyClient(
    process.env.PRIVY_APP_ID as string,
    process.env.PRIVY_APP_SECRET as string
  );

  // Get the request's `id`, `timestamp`, and `signature`
  // These are sent in the `'svix-id'`, `'svix-timestamp'`, and `'svix-signature'` headers respectively
  const id = req.headers['svix-id'] ?? '';
  const timestamp = req.headers['svix-timestamp'] ?? '';
  const signature = req.headers['svix-signature'] ?? '';

  const verifiedPayload = await privy.verifyWebhook(
    req.body,
    {id, timestamp, signature},
    'insert-your-webhook-signing-key-from-the-dashboard'
  );
  ```

  If the webhook payload is valid, the method will return the payload back. If the webhook payload is invalid, the method will throw an error.

  ## Manual verification

  In order to verify an incoming webhook, please refer to svix's [manual verification guide](https://docs.svix.com/receiving/verifying-payloads/how-manual) or [library verification guide](https://docs.svix.com/receiving/verifying-payloads/how).
</Accordion>


# null
Source: https://docs.privy.io/user-management/users/webhooks/overview



Webhooks allow you to specify a backend endpoint that Privy will call with a signed payload whenever a user makes an action in your application, such as logging in, or linking a new account. As soon as you register an endpoint, Privy will start sending subscribed events in near real-time.

<Info>
  Webhooks is currently a scale feature. To use webhooks, please upgrade your account in the Privy
  Dashboard.
</Info>

<img src="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Webhooks.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=991c4fac21a2532704a32d492dfaeb50" alt="images/Webhooks.png" data-og-width="1843" width="1843" data-og-height="1317" height="1317" data-path="images/Webhooks.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Webhooks.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=b211378d887cbb2629f0881b3cf36ba2 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Webhooks.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=1233d21cb5732d45b49ec736f2391640 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Webhooks.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=7e8544c1d8d268f2b0091bbda8c74924 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Webhooks.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=bfcc33d9d5c2f53b11e9a9c235cd12bb 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Webhooks.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=ef68597557e926207350de261ac69945 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Webhooks.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=b5706c5af1c6c8071a26714e40ef4bae 2500w" />

## Registering an endpoint

1. In your backend, create a new endpoint that will accept **POST** requests from Privy

   <Tip>
     When creating your endpoint to receive webhook events, always verify the payload signature by
     following our [webhook signing key
     documentation](/user-management/users/webhooks/handling-events#webhook-signing-key`).
   </Tip>

2. In the dashboard, go to the **Configuration > Webhooks** page

3. Add your new endpoint as the destination URL and select any event types you'd like to be notified for

You can specify which user events your webhook endpoint will be notified about. The options are as follows:

| Event Name               | Type                      | Action                                                                         |
| ------------------------ | ------------------------- | ------------------------------------------------------------------------------ |
| User created             | user.created              | A user was created in the application.                                         |
| User authenticated       | user.authenticated        | A user successfully logged into the application.                               |
| User linked account      | user.linked\_account      | A user successfully linked a new login method.                                 |
| User unlinked account    | user.unlinked\_account    | A user successfully unlinked an existing login method.                         |
| User updated account     | user.updated\_account     | A user successfully updates the email or phone number linked to their account. |
| User transferred account | user.transferred\_account | A user successfully transferred their account to a new account.                |
| Wallet created for user  | user.wallet\_created      | A wallet (embedded or smart wallet) was successfully created for a user.       |
| MFA enabled              | mfa.enabled               | A user has enabled MFA for their account.                                      |
| MFA disabled             | mfa.disabled              | A user has disabled MFA for their account.                                     |
| Private key exported     | private\_key.exported     | A user has exported their private key from an embedded wallet.                 |
| Wallet recovery setup    | wallet.recovery\_setup    | A user has set up wallet recovery for their embedded wallet.                   |
| Wallet recovered         | wallet.recovered          | A user has successfully recovered their embedded wallet.                       |

**That's it! You've successfully configured webhooks for your app.** 🎉

## Testing the webhook setup

<Accordion title="Quick testing guide">
  During development and testing, you can quickly verify your webhook endpoint is working correctly. Here's a simple step-by-step guide:

  #### Step 1: Expose your local endpoint

  If you're testing locally, you'll need to expose your local server to the internet. Use a tool like [ngrok](https://ngrok.com/) or [Cloudflare Tunnel](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/):

  ```bash  theme={"system"}
  # Using ngrok (after installing: https://ngrok.com/download)
  ngrok http 3000

  # Or using Cloudflare Tunnel (after installing: https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/installation/)
  cloudflared tunnel --url http://localhost:3000
  ```

  Copy the public URL (e.g., `https://abc123.ngrok.io` or `https://abc123.trycloudflare.com`).

  #### Step 2: Create your webhook endpoint

  Create a simple endpoint in your backend that accepts POST requests:

  ```tsx  theme={"system"}
  import {NextRequest, NextResponse} from 'next/server';

  export async function POST(req: NextRequest) {
    const body = await req.json();

    // Log the webhook payload
    console.log('Webhook received:', body);

    // Return 200 to acknowledge receipt
    return NextResponse.json({received: true}, {status: 200});
  }
  ```

  #### Step 3: Register your endpoint in the dashboard

  1. Go to **Configuration > Webhooks** in the Privy Dashboard
  2. Add your public URL (from Step 1) as the webhook endpoint
  3. Select the event types you want to test

  #### Step 4: Test your endpoint

  Click the **"Test webhook"** button in the dashboard. This will send a test webhook (`privy.test`) to your endpoint with the following payload:

  ```json  theme={"system"}
  {
    "type": "privy.test",
    "message": "Hello, World!"
  }
  ```

  #### Step 5: Verify receipt

  Check your server logs to confirm you received the webhook. You should see:

  * The webhook payload in your console/logs
  * A successful 200 response returned to Privy

  <Tip>
    For quick testing, you can also use services like [webhook.site](https://webhook.site/) or
    [RequestBin](https://requestbin.com/) to get a temporary endpoint URL without setting up your own
    server.
  </Tip>
</Accordion>

## Retry behavior

Your endpoint must return a 2xx response for the webhook delivery to be considered successful. Anything else is considered an error response, and will be retried based on the following schedule, where each period is started following the failure of the preceding attempt:

* Immediately
* 5 seconds
* 5 minutes
* 30 minutes
* 2 hours
* 5 hours
* 10 hours
* 10 hours (in addition to the previous)

After the final attempt, the message will be marked as a failure, and must be manually retried from the dashboard. If all attempts to your endpoint fail for 5 consecutive days, your endpoint will be automatically disabled.

## Static IPs

Webhooks will be delivered from the following list of IP addresses:

```
44.228.126.217
50.112.21.217
52.24.126.164
54.148.139.208
2600:1f24:64:8000::/52
```


# Whitelabel
Source: https://docs.privy.io/user-management/users/whitelabel



Privy enables complete control over user management flows, so you can match every user action to your app’s brand and experience. Build your own UI for linking and unlinking accounts, managing user profiles, and more, while Privy handles the backend logic securely.

<Tabs>
  <Tab title="React">
    Privy supports whitelabeling user management for linking and unlinking accounts.

    <Accordion title="Linking a social account">
      To whitelabel linking social accounts, use the `useLinkAccount` hook and call `link<Provider>`.

      ```tsx  theme={"system"}
      import {useLinkAccount} from '@privy-io/react-auth';
      ```

      ```tsx  theme={"system"}
      const {linkGoogle, linkTwitter} = useLinkAccount();
      linkGoogle();
      linkTwitter();
      ```
    </Accordion>

    <Accordion title="Linking a wallet">
      To whitelabel linking wallets, use the `useLinkWithSiwe` hook for Ethereum wallets or `useLinkWithSiws` hook for Solana wallets. These hooks allow you to generate messages, request signatures, and link wallets without using Privy's modal UI.

      <Tabs>
        <Tab title="Ethereum (SIWE)">
          To link an Ethereum wallet to a user via [SIWE](https://eips.ethereum.org/EIPS/eip-4361), use the React SDK's `useLinkWithSiwe` hook.

          ### Generate SIWE message

          ```tsx  theme={"system"}
          generateSiweMessage({ address: string, chainId: string }) => Promise<string>
          ```

          <Expandable title="Parameters">
            <ParamField path="address" type="string" required>
              EIP-55 checksum-encoded wallet address performing the signing.
            </ParamField>

            <ParamField path="chainId" type="string" required>
              The chain ID to which the session is bound, in [CAIP-2 format](https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-2.md), e.g. `'eip155:1'`.
            </ParamField>
          </Expandable>

          ### Sign the SIWE message

          Request an EIP-191 `personal_sign` signature for the `message` returned by `generateSiweMessage` from the wallet.

          ```tsx  theme={"system"}
          import {useWallets} from '@privy-io/react-auth';

          const {wallets} = useWallets();
          const signature = await wallets[0].sign(message);
          ```

          Alternatively, you can request a signature from any external wallet or smart account:

          ```tsx  theme={"system"}
          const signature = await wallet.signMessage({message});
          ```

          ### Link with SIWE

          ```tsx  theme={"system"}
          linkWithSiwe({
            signature: string,
            message: string,
            chainId: string,
            walletClientType?: string,
            connectorType?: string
          }) => Promise<void>
          ```

          <Expandable title="Parameters">
            <ParamField path="signature" type="string" required>
              The EIP-191 signature corresponding to the message.
            </ParamField>

            <ParamField path="message" type="string" required>
              The EIP-4361 message returned by `generateSiweMessage`.
            </ParamField>

            <ParamField path="chainId" type="string" required>
              The same [CAIP-2 formatted](https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-2.md)
              chain ID you passed to `generateSiweMessage`, e.g. `'eip155:1'`.
            </ParamField>

            <ParamField path="walletClientType" type="string">
              Optional. The wallet client of the external wallet (e.g., `'metamask'`, `'coinbase_wallet'`).
              Defaults to `null` if not specified.
            </ParamField>

            <ParamField path="connectorType" type="string">
              Optional. The method used to connect the wallet to the application (e.g., `'injected'`, `'wallet_connect_v2'`). Defaults to `null` if not specified.
            </ParamField>
          </Expandable>

          ### Usage

          ```tsx  theme={"system"}
          import {useLinkWithSiwe, useWallets} from '@privy-io/react-auth';

          export function LinkWalletButton() {
            const {generateSiweMessage, linkWithSiwe} = useLinkWithSiwe();
            const {wallets} = useWallets();

            const handleLink = async () => {
              if (!wallets?.length) return;
              const activeWallet = wallets[0];

              const message = await generateSiweMessage({
                address: activeWallet.address,
                chainId: 'eip155:1'
              });

              const signature = await activeWallet.sign(message);
              await linkWithSiwe({
                message,
                chainId: 'eip155:1',
                signature
              });
            };

            return <button onClick={handleLink}>Link wallet</button>;
          }
          ```

          ### Callbacks

          You can optionally pass callbacks into `useLinkWithSiwe`:

          ```tsx  theme={"system"}
          const {generateSiweMessage, linkWithSiwe} = useLinkWithSiwe({
            onSuccess: ({user, linkMethod, linkedAccount}) => {
              console.log('Wallet linked successfully', linkedAccount);
            },
            onError: (error) => {
              console.error('Failed to link wallet', error);
            }
          });
          ```
        </Tab>

        <Tab title="Solana (SIWS)">
          To link a Solana wallet to a user via [SIWS](https://github.com/phantom/sign-in-with-solana), use the React SDK's `useLinkWithSiws` hook.

          ### Generate SIWS message

          ```tsx  theme={"system"}
          generateSiwsMessage({ address: string }) => Promise<string>
          ```

          <Expandable title="Parameters">
            <ParamField path="address" type="string" required>
              The Solana wallet address performing the signing.
            </ParamField>
          </Expandable>

          ### Sign the SIWS message

          Request a signature for the `message` returned by `generateSiwsMessage` from the Solana wallet. The message needs to be encoded as Uint8Array for signing.

          ```tsx  theme={"system"}
          import {useWallets} from '@privy-io/react-auth/solana';

          const {wallets} = useWallets();
          const encodedMessage = new TextEncoder().encode(message);
          const results = await wallets[0].signMessage({message: encodedMessage});
          ```

          ### Link with SIWS

          ```tsx  theme={"system"}
          linkWithSiws({
            message: string,
            signature: string,
            walletClientType?: string,
            connectorType?: string
          }) => Promise<{ user: User; linkedAccount: LinkedAccountWithMetadata | null }>
          ```

          <Expandable title="Parameters">
            <ParamField path="message" type="string" required>
              The SIWS message returned from `generateSiwsMessage`.
            </ParamField>

            <ParamField path="signature" type="string" required>
              The signature corresponding to the message. Convert the signature bytes from the wallet's
              `signMessage` method to a base64-encoded string using
              `Buffer.from(results.signature).toString('base64')`.
            </ParamField>

            <ParamField path="walletClientType" type="string">
              Optional. A string indicating the wallet client you'd like to associate with the wallet. Defaults
              to `'privy'`.
            </ParamField>

            <ParamField path="connectorType" type="string">
              Optional. A string indicating the connector type you'd like to associate with the wallet. Defaults to `'privy'`.
            </ParamField>
          </Expandable>

          ### Usage

          ```tsx  theme={"system"}
          import {useLinkWithSiws} from '@privy-io/react-auth';
          import {useWallets} from '@privy-io/react-auth/solana';

          export function LinkSolanaWalletButton() {
            const {generateSiwsMessage, linkWithSiws} = useLinkWithSiws();
            const {wallets} = useWallets();

            const handleLink = async () => {
              if (!wallets?.length) return;
              const activeWallet = wallets[0];

              const message = await generateSiwsMessage({
                address: activeWallet.address
              });

              const encodedMessage = new TextEncoder().encode(message);
              const results = await activeWallet.signMessage({message: encodedMessage});

              // Convert signature bytes to string (base64)
              const signatureBase64 = Buffer.from(results.signature).toString('base64');

              await linkWithSiws({
                message,
                signature: signatureBase64
              });
            };

            return <button onClick={handleLink}>Link Solana wallet</button>;
          }
          ```

          ### Callbacks

          You can optionally pass callbacks into `useLinkWithSiws`:

          ```tsx  theme={"system"}
          const {generateSiwsMessage, linkWithSiws} = useLinkWithSiws({
            onSuccess: ({user, linkMethod, linkedAccount}) => {
              console.log('Solana wallet linked successfully', linkedAccount);
            },
            onError: (error) => {
              console.error('Failed to link Solana wallet', error);
            }
          });
          ```
        </Tab>
      </Tabs>
    </Accordion>

    <Accordion title="Unlinking an account">
      To whitelabel unlinking an account, use the `usePrivy` hook and call `unlink<Provider>`.

      ```tsx  theme={"system"}
      import {usePrivy} from '@privy-io/react-auth';
      ```

      ```tsx  theme={"system"}
      const {unlinkEmail, unlinkGoogle, unlinkWallet} = usePrivy();
      unlinkEmail();
      unlinkGoogle();
      unlinkWallet();
      ```
    </Accordion>
  </Tab>

  <Tab title="React Native">
    Privy’s React Native SDK is whitelabel by default allowing your app to build your own user
    management UI and flows using the SDK’s functions. Get started with linking a social account
    [here](/user-management/users/linking-accounts#react-native).
  </Tab>

  <Tab title="Android">
    Privy’s Android SDK is whitelabel by default, enabling apps to implement custom user management
    UI and flows using the SDK’s functions. Get started with linking a social account
    [here](/user-management/users/linking-accounts#android).
  </Tab>

  <Tab title="Swift">
    Privy’s Swift SDK is whitelabel by default, enabling apps to implement custom user management UI
    and flows using the SDK’s functions. Get started with linking a social account
    [here](/user-management/users/linking-accounts#swift).
  </Tab>
</Tabs>


# Integrating with ethers
Source: https://docs.privy.io/wallets/connectors/ethereum/integrations/ethers



## Ethers

Privy is fully compatible with ethers.js. To get an ethers provider for a user's connected wallet, first [find your desired wallet](/wallets/wallets/get-a-wallet/get-connected-wallet) from the **`wallets`** array and switch it to your desired network, using the wallet's **`switchChain`** method:

### Ethers v5

```tsx  theme={"system"}
const privyProvider = await wallet.getEthereumProvider();
const provider = new ethers.providers.Web3Provider(privyProvider);
```

### Ethers v6

```tsx  theme={"system"}
const provider = await wallet.getEthereumProvider();
const ethersProvider = new ethers.BrowserProvider(provider);
const signer = ethersProvider.getSigner();
```


# Integrating with viem
Source: https://docs.privy.io/wallets/connectors/ethereum/integrations/viem



Viem represents connected wallets as a [**wallet client**](https://viem.sh/docs/clients/wallet.html) object, which you can use to get information about the current wallet or the request signatures and transactions.

To get a viem wallet client for a user's connected wallet, first import your desired network from the **`viem/chains`** package and import the **`createWalletClient`** method and **`custom`** transport from **`viem`**:

```tsx  theme={"system"}
import {createWalletClient, custom} from 'viem';
// Replace `sepolia` with your desired network
import {sepolia} from 'viem/chains';
```

Then, find your desired wallet from the **`wallets`** array and switch its network to the chain you imported, using the wallet's **`switchChain`** method:

```tsx  theme={"system"}
const {wallets} = useWallets();
const wallet = wallets[0]; // Replace this with your desired wallet
await wallet.switchChain(sepolia.id);
```

Lastly, get the wallet's EIP1193 provider using the wallet's **`getEthereumProvider`** method and pass it to viem's **`createWalletClient`** method like so:

```tsx  theme={"system"}
const provider = await wallet.getEthereumProvider();
const walletClient = createWalletClient({
    account: wallet.address as Hex,
    chain: sepolia,
    transport: custom(provider),
});
```

You can then use the [**wallet client**](https://viem.sh/docs/clients/wallet) to get information about the wallet or request signatures and transactions.


# Integrating with wagmi
Source: https://docs.privy.io/wallets/connectors/ethereum/integrations/wagmi



[Wagmi](https://wagmi.sh/) is a set of React hooks for interfacing with Ethereum wallets, allowing you read wallet state, request signatures or transactions, and take read and write actions on the blockchain.

**Privy is fully compatible with [wagmi](https://wagmi.sh/), and you can use [wagmi](https://wagmi.sh/)'s React hooks to interface with external and embedded wallets from Privy.** Just follow the steps below!

## Integration steps

This guide assumes you have already integrated Privy into your app. If not, please begin with the Privy [Quickstart](/basics/react/quickstart).

### 1. Install dependencies

Install the latest versions of [**`wagmi`**](https://www.npmjs.com/package/wagmi), [**`@tanstack/react-query`**](https://www.npmjs.com/package/@tanstack/react-query), [**`@privy-io/react-auth`**](https://www.npmjs.com/package/@privy-io/react-auth), and [**`@privy-io/wagmi`**](https://www.npmjs.com/package/@privy-io/wagmi):

```sh  theme={"system"}
npm i wagmi @privy-io/react-auth @privy-io/wagmi @tanstack/react-query
```

### 2. Setup TanStack Query

To start, set up your app with the [TanStack Query's React Provider](https://tanstack.com/query/v5/docs/framework/react/overview). Wagmi uses TanStack Query under the hood to power its data fetching and caching of wallet and blockchain data.

To set up your app with TanStack Query, in the component where you render your **`PrivyProvider`**, import the [**`QueryClient`**](https://tanstack.com/query/v4/docs/reference/QueryClient) class and the [**`QueryClientProvider`**](https://tanstack.com/query/latest/docs/framework/react/reference/QueryClientProvider) component from [**`@tanstack/react-query`**](https://www.npmjs.com/package/@tanstack/react-query):

```tsx  theme={"system"}
import {QueryClient, QueryClientProvider} from '@tanstack/react-query';
```

Next, create a new instance of the [**`QueryClient`**](https://tanstack.com/query/v4/docs/reference/QueryClient):

```tsx  theme={"system"}
const queryClient = new QueryClient();
```

Then, like the **`PrivyProvider`**, wrap your app's components with the [**`QueryClientProvider`**](https://tanstack.com/query/latest/docs/framework/react/reference/QueryClientProvider). This must be rendered *inside* the **`PrivyProvider`** component.

```tsx providers.tsx theme={"system"}
<PrivyProvider appId="your-privy-app-id" config={insertYourPrivyConfig}>
  <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
</PrivyProvider>
```

For the [**`client`**](https://tanstack.com/query/latest/docs/framework/react/reference/QueryClientProvider) property of the [**`QueryClientProvider`**](https://tanstack.com/query/latest/docs/framework/react/reference/QueryClientProvider), pass the [**`queryClient`**](https://tanstack.com/query/v4/docs/reference/QueryClient) instance you created.

### 3. Setup wagmi

Next, setup wagmi. This involves creating your wagmi **`config`** and wrapping your app with the **`WagmiProvider`**.

<Warning>
  While completing the wagmi setup, make sure to import `createConfig` and `WagmiProvider` from
  `@privy-io/wagmi`. Do not import these from `wagmi` directly.
</Warning>

#### Build your wagmi config

To build your [**`wagmi`**](https://wagmi.sh) config, import the `createConfig` method from [**`@privy-io/wagmi`**](https://www.npmjs.com/package/@privy-io/wagmi):

```tsx wagmiConfig.ts theme={"system"}
import {createConfig} from '@privy-io/wagmi';
```

This is a drop-in replacement for [wagmi's native **`createConfig`**](https://wagmi.sh/react/getting-started#create-config), but ensures that the appropriate configuration options are set for the Privy integration. Specifically, it allows Privy to drive wagmi's connectors state, enabling the two libraries to stay in sync.

Next, import your app's required chains from [**`viem/chains`**](https://viem.sh/docs/chains/introduction.html) and the [**`http`**](https://wagmi.sh/core/api/transports/http#http) transport from [**`wagmi`**](https://www.npmjs.com/package/wagmi). Your app's required chains should match whatever you configure as [**`supportedChains`**](/basics/react/advanced/configuring-evm-networks#supported-chains) for Privy.

```tsx  theme={"system"}
import {mainnet, sepolia} from 'viem/chains';
import {http} from 'wagmi';

// Replace this with your app's required chains
```

Lastly, call `createConfig` with your imported chains and the [**`http`**](https://wagmi.sh/core/api/transports/http#http) transport like so:

```tsx wagmiConfig.ts theme={"system"}
// Make sure to import `createConfig` from `@privy-io/wagmi`, not `wagmi`
import {createConfig} from '@privy-io/wagmi';
...
export const config = createConfig({
  chains: [mainnet, sepolia], // Pass your required chains as an array
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
    // For each of your required chains, add an entry to `transports` with
    // a key of the chain's `id` and a value of `http()`
  },
});
```

#### Wrap your app with the `WagmiProvider`

Once you've built your wagmi `config`, in the same component where you render your **`PrivyProvider`**, import the `WagmiProvider` component from [**`@privy-io/wagmi`**](https://www.npmjs.com/package/@privy-io/wagmi).

```tsx  theme={"system"}
import {WagmiProvider} from '@privy-io/wagmi';
```

This is a drop-in replacement for [wagmi's native **`WagmiProvider`**](https://wagmi.sh/react/api/WagmiProvider#wagmiprovider), but ensures the necessary configuration properties for Privy are set. Specifically, it ensures that the [**`reconnectOnMount`**](https://wagmi.sh/react/api/WagmiProvider#reconnectonmount) prop is set to false, which is required for handling the embedded wallet. Wallets will still be automatically reconnected on mount.

Then, like the **`PrivyProvider`**, wrap your app's components with the `WagmiProvider`. This must be rendered *inside* both the **`PrivyProvider`** and [**`QueryClientProvider`**](https://tanstack.com/query/latest/docs/framework/react/reference/QueryClientProvider) components.

```tsx providers.tsx theme={"system"}
import {PrivyProvider} from '@privy-io/react-auth';
// Make sure to import `WagmiProvider` from `@privy-io/wagmi`, not `wagmi`
import {WagmiProvider} from '@privy-io/wagmi';
import {QueryClientProvider} from '@tanstack/react-query';
...
<PrivyProvider appId='insert-your-privy-app-id' config={insertYourPrivyConfig}>
  <QueryClientProvider client={queryClient}>
    <WagmiProvider config={config}>
      {children}
    </WagmiProvider>
  </QueryClientProvider>
</PrivyProvider>
```

For the `config` property of the `WagmiProvider`, pass the `config` you created earlier.

#### Complete example

Altogether, this should look like:

<Tabs>
  <Tab title="providers.tsx">
    ```tsx  theme={"system"}
    import {QueryClient, QueryClientProvider} from '@tanstack/react-query';

    import {PrivyProvider} from '@privy-io/react-auth';
    // Make sure to import these from `@privy-io/wagmi`, not `wagmi`
    import {WagmiProvider, createConfig} from '@privy-io/wagmi';

    import {privyConfig} from './privyConfig';
    import {wagmiConfig} from './wagmiConfig';

    const queryClient = new QueryClient();

    export default function Providers({children}: {children: React.ReactNode}) {
      return (
        <PrivyProvider appId="insert-your-privy-app-id" config={privyConfig}>
          <QueryClientProvider client={queryClient}>
            <WagmiProvider config={wagmiConfig}>{children}</WagmiProvider>
          </QueryClientProvider>
        </PrivyProvider>
      );
    }
    ```
  </Tab>

  <Tab title="wagmiConfig.ts">
    ```tsx  theme={"system"}
    import {mainnet, sepolia} from 'viem/chains';
    import {http} from 'wagmi';

    import {createConfig} from '@privy-io/wagmi';

    // Replace these with your app's chains

    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    });
    ```
  </Tab>

  <Tab title="privyConfig.ts">
    ```tsx  theme={"system"}
    import type {PrivyClientConfig} from '@privy-io/react-auth';

    // Replace this with your Privy config
    export const privyConfig: PrivyClientConfig = {
      embeddedWallets: {
        createOnLogin: 'users-without-wallets',
        requireUserPasswordOnCreate: true,
        showWalletUIs: true
      },
      loginMethods: ['wallet', 'email', 'sms'],
      appearance: {
        showWalletLoginFirst: true
      }
    };
    ```
  </Tab>
</Tabs>

**That's it! You've successfully integrated Privy alongside [`wagmi`](https://wagmi.sh) in your app! 🎉**

### 4. Use `wagmi` throughout your app

Once you've completed the setup above, you can use [**`wagmi`**](https://wagmi.sh)'s React hooks throughout your app to interface with wallets and take read and write actions on the blockchain.

#### Using `wagmi` hooks

To use [**`wagmi`**](https://wagmi.sh) hooks, like [**`useAccount`**](https://wagmi.sh/react/api/hooks/useAccount#useaccount), in your components, import the hook directly from [**`wagmi`**](https://wagmi.sh) and call it as usual:

```tsx  theme={"system"}
import {useAccount} from 'wagmi';

export default const WalletAddress = () => {
  const {address} = useAccount();
  return <p>Wallet address: {address}</p>;
}
```

<Info>
  Injected wallets, like the MetaMask browser extension, cannot be programmatically disconnected from your site; they can only be manually disconnected. In kind, Privy does not currently support programmatically disconnecting a wallet via wagmi's [`useDisconnect`](https://wagmi.sh/react/api/hooks/useDisconnect) hook. This hook "shims" a disconnection, which can create discrepancies between what wallets are connected to an app vs. wagmi.

  Instead of disconnecting a given wallet, you can always prompt a user to connect a different wallet via the [`connectWallet`](/wallets/connectors/usage/connecting-external-wallets) method.
</Info>

#### When to use Privy vs. `wagmi`

Both Privy's out-of-the-box interfaces and wagmi's React hooks enable you to interface with wallets and to request signatures and transactions.

If your app integrates Privy alongside wagmi, you should:

* use Privy to connect external wallets and create embedded wallets
* use [**`wagmi`**](https://wagmi.sh) to take read or write actions from a connected wallet

#### Updating the active wallet

With Privy, users may have multiple wallets connected to your app, but [**`wagmi`**](https://wagmi.sh)'s React hooks return information for only *one* connected wallet at a time. This is referred to as the **active wallet**.

To update [**`wagmi`**](https://wagmi.sh) to return information for a *different* connected wallet, first import the **`useWallets`** hook from [**`@privy-io/react-auth`**](https://www.npmjs.com/package/@privy-io/react-auth) and the `useSetActiveWallet` hook from [**`@privy-io/wagmi`**](https://www.npmjs.com/package/@privy-io/wagmi):

```tsx  theme={"system"}
import {useWallets} from '@privy-io/react-auth';
import {useSetActiveWallet} from '@privy-io/wagmi';
```

Then, find your desired active wallet from the **`wallets`** array returned by **`useWallets`**

```tsx  theme={"system"}
const {wallets} = useWallets();
// Replace this logic to find your desired wallet
const newActiveWallet = wallets.find((wallet) => wallet.address === 'insert-your-desired-address');
```

Lastly, pass your desired active wallet to the `setActiveWallet` method returned by the `useSetActiveWallet` hook:

```tsx  theme={"system"}
await setActiveWallet(newActiveWallet);
```

## Demo app

Check out our [wagmi demo app](https://wagmi-app.vercel.app) to see the hooks listed above in action.

Feel free to take a look at the [app's source code](https://github.com/privy-io/examples/tree/main/examples/privy-next-wagmi) to see an end-to-end implementation of Privy with wagmi.


# Overview
Source: https://docs.privy.io/wallets/connectors/overview



Privy can be integrated with all popular wallet connectors so your application can easily interface with your users wallets. Privy is built to connect with all external wallets, including those on browser and mobile devices, so that users can bring their existing wallets and assets into your app.

You can integrate Wagmi, Viem, Ethers, @solana/web3.js, and web3swift to manage embedded or external wallets on your app. This compatibility allows your application to interface with all of your user's wallets in your existing web3 stack.

<img src="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Connectors3.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=c0e26042d5ea73c83d057b041e53b964" alt="Connectors3" data-og-width="1843" width="1843" data-og-height="1317" height="1317" data-path="images/Connectors3.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Connectors3.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=c01bb57b215512cf6215c732a8bc0e70 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Connectors3.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=0a8cab89c7f40abac283dfd178a73d41 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Connectors3.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=e6faed8e973533f80ec3af7419e93a98 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Connectors3.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=15a812a4d1171b05393c199cc565c987 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Connectors3.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=dfa64308f693cca92494ab55214230b9 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Connectors3.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=8dc00c7cc3da5510421c032b2bca69d7 2500w" />


# Configure external connector chains
Source: https://docs.privy.io/wallets/connectors/setup/configuring-external-connector-chains



Privy supports connecting wallets on both EVM networks and Solana to your application. To configure your app for the wallet types you need, follow the steps below.

## Configuring EVM/Solana external connectors

<Tabs>
  <Tab title="EVM and Solana">
    <Tip>
      If you are connecting to Solana wallets, you must also initialize Solana connectors using Privy's `toSolanaWalletConnectors` method and pass them to the `config.externalWallets.solana.connectors` field.
    </Tip>

    In your `PrivyProvider`, set the `config.appearance.walletChainType` to `'ethereum-and-solana'`.

    ```tsx  theme={"system"}
    import {PrivyProvider} from '@privy-io/react-auth';
    import {toSolanaWalletConnectors} from "@privy-io/react-auth/solana";

    <PrivyProvider
      config={{
        appearance: {walletChainType: 'ethereum-and-solana'},
        externalWallets: {solana: {connectors: toSolanaWalletConnectors()}}
      }}
    >
      {children}
    </PrivyProvider>
    ```
  </Tab>

  <Tab title="EVM">
    In your `PrivyProvider`, set the `config.appearance.walletChainType` to `'ethereum-only'`.

    ```tsx  theme={"system"}
    import {PrivyProvider} from '@privy-io/react-auth';

    <PrivyProvider
      config={{
        appearance: {walletChainType: 'ethereum-only'}
      }}
    >
      {children}
    </PrivyProvider>
    ```
  </Tab>

  <Tab title="Solana">
    <Tip>
      If you are connecting to Solana wallets, you must also initialize Solana connectors using Privy's `toSolanaWalletConnectors` method and pass them to the `config.externalWallets.solana.connectors` field.
    </Tip>

    In your `PrivyProvider`, set the `config.appearance.walletChainType` to `'solana-only'`.

    ```tsx  theme={"system"}
    import {PrivyProvider} from '@privy-io/react-auth';
    import {toSolanaWalletConnectors} from "@privy-io/react-auth/solana";

    <PrivyProvider
      config={{
        appearance: {walletChainType: 'solana-only'},
        externalWallets: {
          solana: {connectors: toSolanaWalletConnectors()}
        }
      }}
    >
      {children}
    </PrivyProvider>
    ```
  </Tab>
</Tabs>


# Configure wallet options
Source: https://docs.privy.io/wallets/connectors/setup/configuring-external-connector-wallets



To customize the external wallet options for your app, pass in a **`WalletListEntry`** array to the **`config.appearance.walletList`** property. When users login with, connect, or link an external wallet in your app, the possible options (e.g. MetaMask, Rainbow, WalletConnect) will be presented to users in the order you configure them in this array.

```tsx  theme={"system"}
<PrivyProvider
  appId="your-privy-app-id"
  config={{
    appearance: {
      // Defaults ['detected_wallets', 'metamask', 'coinbase_wallet', 'rainbow', 'wallet_connect']
      walletList: ['metamask', 'rainbow', 'wallet_connect'],
      ...insertTheRestOfYourAppearanceConfig
    },
    ...insertTheRestOfYourPrivyProviderConfig
  }}
>
  {children}
</PrivyProvider>
```

<Info>
  When your React web app is accessed through the in-app browser of a mobile wallet (e.g., Rainbow,
  Phantom, etc.) and that wallet is selected as a login option, the Privy SDK will automatically
  detect the wallet object and prompt the user to connect in app. However, if your app is accessed
  via a standard browser (e.g., Chrome, Safari, etc.), Privy will default to using WalletConnect for
  mobile wallet connection.
</Info>

You can also configure which wallet options to show at runtime, by passing in `walletList` to the `connectWallet` method:

```tsx  theme={"system"}
import {usePrivy} from '@privy-io/react-auth';

const {connectWallet} = usePrivy();

<button onClick={() => connectWallet({walletList: ['rainbow', 'coinbase_wallet']})}>
  Login with email and sms only
</button>;
```

The possible wallets to include in the array are:

* `detected_ethereum_wallets`
* `detected_solana_wallets`
* `metamask`
* `coinbase_wallet`
* `rainbow`
* `phantom`
* `zerion`
* `cryptocom`
* `uniswap`
* `okx_wallet`
* `universal_profile`
* `rabby_wallet`
* `bybit_wallet`
* `ronin_wallet`
* `haha_wallet`
* `safe`
* `solflare`
* `backpack`
* `binance`
* `bitkeep` (BitGet)
* `wallet_connect` (include this to capture the long-tail of wallets that support WalletConnect in your app)
* `wallet_connect_qr` (include this to just show a QR code to connect any wallet via the WalletConnect protocol)

The `detected_*_wallets` option includes all wallets that Privy detects which are not explicitly included elsewhere in the walletList array. As an example, if your user has the Zerion browser extension installed, it will appear under `detected_*_wallets` – unless you include `zerion` elsewhere in the `walletList` array, in which case it will appear in the placement of `zerion`.

<Info>
  Privy detects wallets via [EIP6963 injection](https://eips.ethereum.org/EIPS/eip-6963),
  `window.ethereum` injection, or a mobile wallet's in-app browser.
</Info>

<Accordion title="Using the Base Account (formerly Coinbase Smart Wallet)">
  Coinbase Smart Wallet is now [Base Account](https://www.base.org/build/base-account). If you support Coinbase Smart Wallet, you should add the `base_account` option to your walletList while keeping `coinbase_wallet` in the if you'd like to maintain support for existing Coinbase Smart Wallet users.

  For more details, see the [Base Account migration guide](https://docs.base.org/base-account/guides/migration-guide).
</Accordion>


# Integrating with @solana/kit
Source: https://docs.privy.io/wallets/connectors/solana/kit-integrations



<Tabs>
  <Tab title="React">
    Privy's **ConnectedStandardSolanaWallet** object is fully compatible with popular web3 libraries for interfacing wallets and signing transactions and messages, such as [`@solana/kit`](https://www.solanakit.com/).

    Read below to learn how to best integrate Privy alongside `@solana/kit`.

    First find your desired wallet from the **`wallets`** array:

    ```tsx  theme={"system"}
    import {useWallets} from '@privy-io/react-auth/solana';

    const {wallets} = useWallets();
    const wallet = wallets[0]; // Replace this with your desired wallet
    ```

    ## Signing Transactions

    Transactions generated by `@solana/kit` can be signed using the `signTransaction` method from the `useStandardSignTransaction` hook.

    ```tsx  theme={"system"}
    import {
      pipe,
      createTransactionMessage,
      setTransactionMessageFeePayer,
      setTransactionMessageLifetimeUsingBlockhash,
      appendTransactionMessageInstructions,
      compileTransaction,
      createNoopSigner,
      createSolanaRpc,
      getTransactionEncoder
    } from '@solana/kit';
    import {getTransferSolInstruction} from '@solana-program/system';
    import {useStandardSignTransaction} from '@privy-io/react-auth/solana';

    const {signTransaction} = useStandardSignTransaction();

    const LAMPORTS_PER_SOL = 1_000_000_000;

    const transferInstruction = getTransferSolInstruction({
      amount: LAMPORTS_PER_SOL * 1,
      destination: address(to),
      source: createNoopSigner(address(wallet.address))
    });

    const {getLatestBlockhash} = createSolanaRpc('YOUR_SOLANA_RPC_URL');
    const {value: latestBlockhash} = await getLatestBlockhash().send();

    // Create transaction
    const transaction = pipe(
      createTransactionMessage({version: 0}),
      (tx) => setTransactionMessageFeePayer(address(wallet.address), tx),
      (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
      (tx) => appendTransactionMessageInstructions([transferInstruction], tx),
      (tx) => compileTransaction(tx)
    );
    const encodedTransaction = getTransactionEncoder().encode(transaction);

    // Sign the transaction
    const signedTransaction = await signTransaction({
      transaction: new Uint8Array(encodedTransaction),
      wallet: wallet
    });
    ```

    ## Sending Transactions

    Transactions signed using the `signTransaction` method can be sent using the `signAndSendTransaction` method from the `useStandardSignAndSendTransaction` hook.

    ```tsx  theme={"system"}
    import {useStandardSignAndSendTransaction} from '@privy-io/react-auth/solana';

    const {signAndSendTransaction} = useStandardSignAndSendTransaction();

    const signature = await signAndSendTransaction({
      transaction: new Uint8Array(transaction), // The transaction to send, from the previous example
      wallet: wallet
    }).signature;
    ```
  </Tab>
</Tabs>


# Integrating with @solana/web3.js
Source: https://docs.privy.io/wallets/connectors/solana/web3-integrations



<Tabs>
  <Tab title="React">
    Privy's **`ConnectedStandardSolanaWallet`** object is fully compatible with popular web3 libraries for interfacing wallets, such as [`@solana/web3js`](https://solana-foundation.github.io/solana-web3.js/).

    Read below to learn how to best integrate Privy alongside @solana/web3.js.

    First find your desired wallet from the **`wallets`** array:

    ```tsx  theme={"system"}
    import {PublicKey, Transaction, Connection, SystemProgram} from '@solana/web3.js';

    const {wallets} = useWallets();
    const wallet = wallets[0]; // Replace this with your desired wallet
    ```

    Then, use this wallet to then send Transactions using the @solana/web3.js Transaction and Connection classes:

    ```tsx  theme={"system"}
    // Build out the transaction object for your desired program
    // https://solana-foundation.github.io/solana-web3.js/classes/Transaction.html
    let transaction = new Transaction();

    // Send transaction
    console.log(
      await wallet.signAndSendTransaction!({
        chain: 'solana:devnet',
        transaction: new Uint8Array(
          transaction.serialize({
            requireAllSignatures: false,
            verifySignatures: false
          })
        )
      })
    );
    ```
  </Tab>
</Tabs>


# Authenticate a connected wallet
Source: https://docs.privy.io/wallets/connectors/usage/authenticate



<Tabs>
  <Tab title="React">
    Once a user has connected their wallet to your app, and the wallet is available in either of the **`useWallets`** arrays, you can also prompt them to **login** with that wallet or **link** that wallet to their existing account, instead of prompting the entire **`login`** or **`linkWallet`** flow.

    To do so, find the **`ConnectedWallet`** or **`ConnectedStandardSolanaWallet`** object from Privy, and call the object's **`loginOrLink`** method for EVM wallets and use the **`useLoginWithSiws`** or **`useLinkWithSiws`** hooks for the Solana wallets:

    <Tabs>
      <Tab title="EVM">
        ```tsx  theme={"system"}
        import {useWallets} from '@privy-io/react-auth';
        ...
        const {wallets} = useWallets();
        ...
        wallets[0].loginOrLink();
        ```
      </Tab>

      <Tab title="Solana">
        ```tsx  theme={"system"}
        import {useLoginWithSiws} from '@privy-io/react-auth';
        import {useWallets} from '@privy-io/react-auth/solana';

        const {wallets} = useWallets();
        const {generateSiwsMessage, loginWithSiws} = useLoginWithSiws();

        const message = await generateSiwsMessage({address: wallets[0].address});
        const encodedMessage = new TextEncoder().encode(message);
        const results = await wallets[0].signMessage({message: encodedMessage});
        await loginWithSiws({message: encodedMessage, signature: results.signature});
        ```
      </Tab>
    </Tabs>

    When called, **`loginOrLink`** will directly request a [SIWE](https://docs.login.xyz/general-information/siwe-overview/eip-4361) signature from the user's connected wallet to authenticate the wallet.

    If the user was not **`authenticated`** when the method was called, the user will become **`authenticated`** after signing the message.

    If the user was already **`authenticated`** when the method was called, the user will remain **`authenticated`** after signing the message, and the connected wallet will become one of the user's **`linkedAccounts`** in their **`user`** object.

    You might use the methods above to "split up" the connect and sign steps of external wallet login, like so:

    <Tabs>
      <Tab title="EVM">
        ```tsx  theme={"system"}
        import {useConnectWallet, useWallets} from '@privy-io/react-auth';

        export default function WalletButton() {
        const {connectWallet} = useConnectWallet();
        const {wallets} = useWallets();

        // Prompt user to connect a wallet with Privy modal
        return (
            {/* Button to connect wallet */}
            <button
                onClick={connectWallet}>
                Connect wallet
            </button>
            {/* Button to login with or link the most recently connected wallet */}
            <button
                disabled={!wallets[0]}
                onClick={() => { wallets[0].loginOrLink() }}>
                Login with wallet
            </button>
        );
        }
        ```
      </Tab>

      <Tab title="Solana">
        ```tsx  theme={"system"}
        import {useConnectWallet, useLoginWithSiws} from '@privy-io/react-auth';
        import {useWallets} from '@privy-io/react-auth/solana';

        export default function WalletButton() {
          const {connectWallet} = useConnectWallet();
          const {wallets} = useWallets();
          const {generateSiwsMessage, loginWithSiws} = useLoginWithSiws()

          // Prompt user to connect a wallet with Privy modal
          return (
            {/* Button to connect wallet */}
            <button
                onClick={connectWallet}>
                Connect wallet
            </button>
            {/* Button to login with the most recently connected wallet */}
            <button
                disabled={!wallets[0]}
                onClick={async () => {
                  const message = await generateSiwsMessage({address: wallets[0].address})
                  const encodedMessage = new TextEncoder().encode(message)
                  const results = await wallets[0].signMessage({message: encodedMessage})
                  await loginWithSiws({message: encodedMessage, signature: results.signature})
                }}
            >
                Login with wallet
            </button>
          );
        }
        ```
      </Tab>
    </Tabs>

    ### Sign in with Ledger on Solana

    Currently, Ledger Solana hardware wallets only support transaction signatures, not the message signatures required
    for Sign-In With Solana (SIWS) authentication. In order to authenticate with a Solana Ledger wallet,
    you must mount the `useSolanaLedgerPlugin` hook **inside** your `PrivyProvider`.

    <Warning>
      **Critical:** The `useSolanaLedgerPlugin` hook **must be placed inside** a component that is
      wrapped by `PrivyProvider`. If the hook is placed alongside or outside the `PrivyProvider`, it
      will not function correctly.
    </Warning>

    ```tsx  theme={"system"}
    import {PrivyProvider} from '@privy-io/react-auth';
    import {useSolanaLedgerPlugin} from '@privy-io/react-auth/solana';

    function SolanaLedgerSetup() {
      // This hook MUST be called inside a component wrapped by PrivyProvider
      useSolanaLedgerPlugin();
      return null;
    }

    export default function App() {
      return (
        <PrivyProvider appId="your-app-id" config={{...}}>
          <SolanaLedgerSetup />
          {/* Your app components */}
        </PrivyProvider>
      );
    }
    ```

    Then, when you attempt to login with a Phantom Solana wallet, you will be prompted to indicate whether you are signing with a Ledger wallet,
    which will initiate a separate SIWS flow wherein which a no-op transaction will be signed and used for verification.
  </Tab>
</Tabs>


# Connect or create a wallet
Source: https://docs.privy.io/wallets/connectors/usage/connect-or-create



<Tabs>
  <Tab title="React">
    You can also use Privy to connect a user's external wallet if they have one, or to create an embedded wallet for them if they do not. This ensures users always have a connected wallet they can use with your application, and allows them to choose to use their external wallet if preferred.

    To do so, use the **`connectOrCreateWallet`** method of the **`usePrivy`** hook:

    ```tsx  theme={"system"}
    const {connectOrCreateWallet} = usePrivy();
    ```

    This method will prompt the user to connect an external wallet, or log in with email, SMS, or socials, depending on your configured `loginMethods`, to create an embedded wallet.

    <Info>
      Privy's `connectOrCreate` interface currently only supports external and embedded wallets on EVM
      networks.
    </Info>

    For example, you might have a "Connect" button in your app that prompts users to connect their wallet, like so:

    ```tsx  theme={"system"}
    import {useConnectOrCreateWallet} from '@privy-io/react-auth';

    export default function ConnectWalletButton() {
      const {connectOrCreateWallet} = useConnectOrCreateWallet();
      // Prompt user to connect a wallet with Privy modal
      return <button onClick={connectOrCreateWallet}>Connect wallet</button>;
    }
    ```

    <Tip>
      This method functions exactly the same as Privy's `login` method, except when users connect their
      external wallet, they will not automatically be prompted to authenticate that wallet by signing a
      message
    </Tip>

    ### Callbacks

    You can optionally pass callbacks to the `useConnectOrCreateWallet` hook to run custom logic after connecting a wallet or to handle errors.

    #### `onSuccess`

    ```tsx  theme={"system"}
    onSuccess: (args: {wallet: ConnectedWallet}) => Promise<void>;
    ```

    ##### Parameters

    <ParamField path="wallet" type="ConnectedWallet">
      The most recently connected wallet.
    </ParamField>

    #### `onError`

    ```tsx  theme={"system"}
    onError: (error: Error) => Promise<void>;
    ```

    ##### Parameters

    <ParamField path="error" type="Error">
      The error that occurred during the this flow.
    </ParamField>
  </Tab>
</Tabs>


# Connect an external wallet
Source: https://docs.privy.io/wallets/connectors/usage/connecting-external-wallets



<Tabs>
  <Tab title="React">
    <Tip>
      To determine if Privy has fully processed all external and embedded wallet connections, use the **`ready`** boolean returned by the **`useWallets`** hooks.
    </Tip>

    To prompt a user to connect an external wallet (on EVM networks or Solana) to your app, use the `connectWallet` method from the `useConnectWallet` hook.

    ```tsx  theme={"system"}
    connectWallet: async ({ description?: string, walletList?: WalletListEntry[], walletChainType?: 'ethereum' | 'solana' }) => void
    ```

    ### Usage

    <Info>
      To connect external wallets on Solana, your application must first explicitly configure Solana connectors for Privy. [Learn more](/recipes/react/configuring-external-connectors#connecting-external-wallets-on-solana)
    </Info>

    ```tsx  theme={"system"}
    import {useConnectWallet} from '@privy-io/react-auth';
    const {connectWallet} = useConnectWallet();

    connectWallet();
    ```

    ### Parameters

    <ParamField path="description" type="string">
      A description for the wallet connection prompt, which will be displayed in
      Privy's UI.
    </ParamField>

    <ParamField path="walletList" type="WalletListEntry[]">
      {/* TODO add walletList link */}A list of \[wallet option] that you would like
      Privy to display in the connection prompt.

      {/* TODO: Add list of wallets that can be supported here, as an expandable */}
    </ParamField>

    <ParamField path="walletChainType" type="'solana-only' | 'ethereum-only' | 'ethereum-and-solana'">
      Filter the login wallet options to only show wallets that support the specified
      chain type.
    </ParamField>

    ### Callbacks

    You can optionally register an onSuccess or onError callback on the useConnectWallet hook.

    ```tsx  theme={"system"}
    const {connectWallet} = useConnectWallet({
        onSuccess: ({wallet}) => {
            console.log(wallet);
        },
        onError: (error) => {
            console.log(error);
        },
    });
    ```

    <ParamField path="onSuccess" type="({wallet: Wallet}) => void">
      An optional callback function that is called when a user successfully connects their wallet.
    </ParamField>

    <ParamField path="onError" type="({error: string}) => void">
      An optional callback function that is called when a user exits the connection flow or there is an error.
    </ParamField>
  </Tab>
</Tabs>


# Configuring funding methods
Source: https://docs.privy.io/wallets/funding/configuration



To enable various funding flows for your users, visit the and select your app from the **App Dropdown** in the sidebar. Then, navigate to the [Account Funding](https://dashboard.privy.io/apps?page=funding) page for your selected app.

<img src="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/funding/config-funding.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=05f3b82931eb42e2f75df17f1e7c3eb6" alt="Fundingupdate PNG" data-og-width="1843" width="1843" data-og-height="1317" height="1317" data-path="images/funding/config-funding.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/funding/config-funding.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=737f2440881b2f0a60b4cf2dfb62cca2 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/funding/config-funding.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=fd4ecc46ce52e27aa5c427642fe0f1cf 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/funding/config-funding.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=c58720c8c97d4372cf166ad74d9b6642 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/funding/config-funding.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=755f499baa5c783e2045d0338d449615 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/funding/config-funding.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=20b7e0ddafaf0dcbe0bade9b2bb1ea9b 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/funding/config-funding.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=f2ec010e91b359103bb2f91d1ec1925d 2500w" />

## Enable funding methods

<Tip>
  Set up Privy UIs in your app with [this guide](/authentication/user-authentication/ui-component),
  as they are required to be integrated in your app for Privy's funding flows.
</Tip>

To enable funding in your app, select which funding methods you would like to allow by selecting the corresponding option in the Dashboard.

Privy will present the options you enable here for your users to select from during a funding flow.

<Info>
  We are actively working on bringing **Transfer from external wallet** to React Native, but this is
  currently **not** yet supported. Enabling this method on your dashboard will not provide this
  option to users.
</Info>

## Set a default chain and amount

Once you have selected your funding methods, you can select the chain your users will use. When EVM is selected you'll need to select a **default network**. Both for EVM or Solana you'll need an **amount** that users should fund their wallets with. Users can update the amount manually if they choose, before confirming.

During funding flows, Privy will prompt users to fund their wallets with the **native currency of your default chain** (e.g. ETH on Ethereum Mainnet, POL on Polygon, SOL on Solana) with the funding amount you specify here.

<Tip>
  You can also prompt users to fund their wallets with USDC or other ERC20 tokens by setting a
  funding asset [in code](/wallets/funding/prompting-users-to-fund/evm).
</Tip>

You can always change these values in the Dashboard later or even override them in your app's code.

## \[For bank transfer method] Set provider API keys

If using the bank transfer funding method, you will be prompted to set your onramp provider API keys in the Dashboard. For Bridge, you can request API access through [Bridge's website](https://bridge.xyz/).

<img src="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/funding/bridge.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=7c9bc691f29634777c9872ef445f4171" alt="Bridge keys PNG" data-og-width="1843" width="1843" data-og-height="1317" height="1317" data-path="images/funding/bridge.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/funding/bridge.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=5b27b846917b54e8d9a7a6b613569254 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/funding/bridge.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=b8a2422a32657b4c4d8916a505c4d185 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/funding/bridge.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=8b66c0759e37e2f07c53b9aaba0fd8a8 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/funding/bridge.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=9e6aaceddf39709593c9ebdc31ae089e 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/funding/bridge.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=c6e1a4d515b6b42c225ae4180faa48fb 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/funding/bridge.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=ae4da1651e414b3442ffc62de529306f 2500w" />


# Funding via bank account
Source: https://docs.privy.io/wallets/funding/methods/bank-account



<Info>Funding via bank account is currently available server-side in your app.</Info>

The **withdraw from bank account** funding option enables users to convert fiat funds from their bank account into crypto. To facilitate, the user would make a bank transfer (ACH, wire, SEPA) to the onramp provider, who then converts the funds into crypto and deposits it into the user's Privy wallet.

### Process overview

1. The user withdrawing from their bank account **submits KYC information** to the onramp provider, via Privy.
2. The user **initiates an onramp transaction**, which prompts the user to **make a bank transfer** to the onramp provider.
3. Once the fiat funds are received from the user's bank, the provider **converts the funds into crypto and deposits** it into the user's Privy wallet.

### Providers

Below are the providers that currently support bank transfer funding via Privy, with links to a respective step-by-step integration guide and the regions supported. More support and providers coming soon!

* **Bridge** [(integration guide)](/recipes/bridge-onramp): supports ACH, wire, and SEPA funding in the US and Europe.


# Funding via card, Apple Pay, and Google Pay
Source: https://docs.privy.io/wallets/funding/methods/card



export const CardOnrampMainnetOnly = () => <Warning>
    Card and fiat on-ramp purchases are supported on mainnets only. On testnets (e.g. Polygon Amoy,
    Sepolia), on-ramps cannot purchase testnet tokens, so this flow will not be shown or will fail.
  </Warning>;

<Note>
  Users must be authenticated through Privy to make use of card funding methods. In other words a
  valid access token is required for the user to proceed with card funding.
</Note>

The **pay with card** funding option enables users to purchase assets with a debit card, including with browser payment rails like **Apple Pay** and **Google Pay**. This is particularly useful for users that may not hold crypto outside of your application and are purchasing crypto for the first time.

Privy facilitates card purchases through onramp providers like MoonPay or [Coinbase Onramp](https://www.coinbase.com/developer-platform/products/onramp) embedded within your app. Privy will default to the best provider for your user's payment method, location, and asset; if purchases fail with one provider, users will be given the option to select another.

Please note that these purchases are not immediate, and depending on the payment method selected by your users, it may take a few days for funds to arrive in your user's wallet. Generally, **paying with debit card over credit card has the highest approval rates** for cryptocurrency purchases. Debit cards can be used with Apple and Google Pay.

<CardOnrampMainnetOnly />

<Info>
  With MoonPay and Coinbase Onramp, users can purchase a variety of assets across different EVM
  networks and Solana. Please view
  [MoonPay's](https://support.moonpay.com/customers/docs/list-of-supported-cryptocurrencies) and
  [Coinbase's](https://docs.cdp.coinbase.com/onramp/docs/api-configurations#fiat-currencies-and-crypto-assets-supported)
  list of supported assets for more information.
</Info>

Please refer to our [recipe](/recipes/card-based-funding) for a step-by-step guide on how to enable card funding in your app.

<Info>
  Due to known issues with Coinbase's native on-ramp configuration, Apple Pay may not always be
  surfaced after selecting "Confirm and Purchase" through the Coinbase on-ramp for Pay with Card.
  Please contact Coinbase for further assistance.
</Info>


# Funding via exchange
Source: https://docs.privy.io/wallets/funding/methods/exchange



The **transfer from exchange** funding option enables users to purchase or transfer assets from an existing Coinbase exchange account, via [Coinbase Onramp](https://www.coinbase.com/developer-platform/products/onramp) embedded within your app. If users have already completed KYC and identity verification with Coinbase for their Coinbase account, they will not need to do so again, streamlining their asset purchase/transfer experience.

If a user chooses to fund via Coinbase Onramp, Privy will prompt the user to fund with the [amount](/wallets/funding/configuration#set-a-default-chain-and-amount) you configure in Dashboard by opening Coinbase in a pop-up window. Once the purchase is complete, this window will automatically close and users can continue in your application.

Please note that these purchases are not immediate and it may take a few minutes for funds to arrive in your user's wallet.

<Warning>
  Transfers and purchases via exchange on-ramps (e.g. Coinbase Onramp) are only supported on
  mainnets. On testnets (e.g. Polygon Amoy, Sepolia), on-ramps cannot purchase testnet tokens, so
  this flow will not be shown or will fail.
</Warning>

<Info>
  When transferring from an exchange, users can fund their accounts with a network's native currency (e.g. ETH, SOL) or USDC on Coinbase Onramp's [supported networks](https://docs.cdp.coinbase.com/get-started/supported-networks).

  Note that not all payment methods are available in all regions due to local regulations. See [this guide](https://docs.cdp.coinbase.com/onramp/docs/payment-methods/) for more information on which payment methods are supported in which regions.
</Info>


# Funding via wallet
Source: https://docs.privy.io/wallets/funding/methods/wallet



The **transfer from wallets** funding option enables users to transfer or bridge funds from an external wallet (e.g. MetaMask, Phantom) to their embedded wallet within your app.

If a user chooses to fund via external wallet, Privy will prompt the user to connect their external wallet to your app and will query their balance on the [chain](/wallets/funding/configuration) you've configured in the Dashboard.

<Info>
  With external wallets, users can fund their accounts on EVM networks with the network's native
  asset (e.g. ETH, POL), USDC, or ERC20 tokens, and accounts on Solana with SOL.
</Info>

<Expandable title="how to enable funding with Solana Wallets">
  To enable funding from Solana wallets, ensure your `PrivyProvider` is configured with:

  ```tsx  theme={"system"}
  <PrivyProvider
    appId="your-app-id"
    config={{
      appearance: {
        walletChainType: "ethereum-and-solana"
      },
      externalWallets: {
        solana: {
          connectors: toSolanaWalletConnectors()
        }
      },
      solana: {
        rpcs: {
          'solana:mainnet': {
            rpc: createSolanaRpc('https://api.mainnet-beta.solana.com'),
            rpcSubscriptions: createSolanaRpcSubscriptions('wss://api.mainnet-beta.solana.com')
          },
        }
      }
    }}
    ...
  >
    {/* your app */}
  </PrivyProvider>
  ```
</Expandable>

#### Transferring funds on the configured chain

If the external wallet has sufficient funds on the configured chain, Privy will prompt the user to directly **transfer** funds on the configured chain.

If users don't want to connect an external wallet, Privy will also give the users to copy their embedded wallet address or scan it with a QR code, and manually transfer funds from their external wallet to their embedded wallet.

#### Bridging funds to the configured chain

If the external wallet does not have sufficient funds on the configured chain, but has funds on other networks, Privy will prompt the user to instead **bridge** funds to your configured chain. Privy will query balances on the networks listed [here](/basics/react/advanced/configuring-evm-networks#default-configuration) and any additional [`supportedChains`](/basics/react/advanced/configuring-evm-networks#supported-chains) you configure to determine possible source chains for bridging.

If the user only has enough funds on one chain, Privy will automatically prompt the user to bridge from that chain. If the user has enough funds on multiple source chains, Privy will allow the user to select from where to bridge funds.

Users can also bridge funds from Solana to EVM networks and vice versa.

Privy uses [Reservoir Relay](https://relay.link/) to power instant bridging, and supports bridging funds to the networks listed [here](https://docs.relay.link/references/api/api_resources/supported-chains#supported-chains).


# null
Source: https://docs.privy.io/wallets/funding/overview



**Privy makes it easy for your users to fund their wallets with a variety of assets**, including a network's native currency (e.g. ETH, SOL), USDC, and other tokens.

This makes it seamless to take onchain actions within your apps such as purchasing goods, swapping tokens, minting NFTs, and more.

<img src="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Funding.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=de9937f1a2a8cbad56f66b54ed7c8227" alt="images/Funding.png" data-og-width="1843" width="1843" data-og-height="1317" height="1317" data-path="images/Funding.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Funding.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=b4a3b80bd015b0049435600eb305afa3 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Funding.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=5bf155f27fe6d394382a2412823bdb64 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Funding.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=b1e4b099d3f7c2d6d40910ba2a4294f7 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Funding.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=d4c1c48e83d2a96ef3cab0318ecd0c98 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Funding.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=6306db312dd6e8626b6672b564a7e226 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Funding.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=f520e0ff1262769a76b9b305eac355cf 2500w" />

Privy enables users to fund their wallets by:

* purchasing via [**debit/credit card, Apple Pay, and Google Pay**](/wallets/funding/methods/card)
* transferring or bridging assets from an [**external wallet**](/wallets/funding/methods/wallet) (e.g. MetaMask, Phantom)
* transferring assets from a cryptocurrency [**exchange**](/wallets/funding/methods/exchange), such as Coinbase
* withdrawing funds [from their bank account](/wallets/funding/methods/bank-account) via ACH, wire, or SEPA

Continue to the subpages linked above to learn more about the different methods.

To head straight to integration, see [Configuring funding methods](/wallets/funding/configuration). If you are integrating on the frontend, see our guide on how to prompt users to fund their wallets [here](/wallets/funding/prompting-users-to-fund).


# EVM
Source: https://docs.privy.io/wallets/funding/prompting-users-to-fund/evm



<Note>
  This page walks through a client-side funding integration for EVM wallets. If you are looking to
  integrate server-side for funding via bank transfer, see the [Funding via bank
  transfer](../methods/bank-account) page.
</Note>

# Prompting users to fund wallets

With funding methods enabled for your app, Privy will prompt users to fund their wallets at two points in their experience:

1. Manually, when you call Privy's `fundWallet` method documented below
2. Automatically, when the user attempts to send a transaction but has insufficient funds

You can also configure the chain, asset, and amount that users should fund their wallets with directly in code.

## Manually invoking funding

Once you've enabled a set of funding methods for your app, to invoke the funding flow, use the **`useFundWallet`** hook from the Privy SDK as follows:

<Tabs>
  <Tab title="React">
    Prompt the user to fund their wallets by calling `fundWallet`.

    ```tsx  theme={"system"}
    import {useFundWallet} from '@privy-io/react-auth';
    ...
    const {fundWallet} = useFundWallet();
    await fundWallet({address: 'your-wallet-address-here'});
    ```

    If you are using Privy's cross-chain bridging feature to fund an EVM wallet using assets on Solana,
    you will additionally need to mount the **`useSolanaFundingPlugin()`** hook in your app like so:

    ```tsx  theme={"system"}
    import {useSolanaFundingPlugin} from '@privy-io/react-auth/solana';
    ...
    // Ensure this is mounted throughout the entire funding flow
    useSolanaFundingPlugin();
    ```

    Once invoked, the **`fundWallet`** method will open a modal that contains a list of funding options the user can take. If only one funding method was enabled for your app, Privy will navigate the user directly to that specific flow.

    You can pass additional configurations to the funding flow in the `options` parameter to **`fundWallet`**.

    <Warning>
      Purchases with third-party providers are not always instantaneous, and there may be some time
      before the user completes their purchase and the funds are available in their wallet.
    </Warning>

    ## Automatically invoking funding

    With funding methods enabled for your app, if a user attempts to send a transaction but does not have sufficient funds to do so, Privy will show them an "Add funds" button in the transaction modal that enables them to invoke funding flows.

    ## Setting a funding amount in code

    Optionally, you can pass in a **chain, funding amount, and funding asset** to `fundWallet` to override your Dashboard configuration.

    To do so, in the `options` parameter to `fundWallet`, pass an object with the following fields:

    | Parameter                       | Type                                                | Description                                                                                                                                                                                                                                                                                  |
    | ------------------------------- | --------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | `chain`                         | [`Chain`](https://viem.sh/docs/chains/introduction) | Optional. A [`viem/chains`](https://viem.sh/docs/chains/introduction) object for the network on which users should fund their accounts. Defaults to the network you configured in the Privy Dashboard.                                                                                       |
    | `asset`                         | `'native-currency' \| 'USDC' \| {erc20: string}`    | Optional. The asset you'd like the user to fund their accounts with. Set `'native-currency'` to fund with the `chain`'s native currency (e.g. ETH), `'USDC'` to fund with USDC, or a token address in the `erc20` field to fund with an arbitrary ERC20. Defaults to `'native-currency'`.    |
    | `amount`                        | `string`                                            | Required if `asset` is set, optional otherwise. The amount of the asset to fund as a decimal string. Defaults to the amount you configured in the Privy Dashboard.                                                                                                                           |
    | `defaultFundingMethod`          | `'card' \| 'exchange' \| 'wallet' \| 'manual'`      | Optional. Specifying the default funding method will send the user directly to the card / exchange provider, directly open the wallet transfer, or directly open the manual QR wallet transfer screen. Additional configured payment options will be shown after the default funding method. |
    | `card.preferredProvider`        | `'coinbase' \| 'moonpay'`                           | Optional. The preferred card provider to use for funding. If not specified, users will be directed to one of these providers initially and given an option to navigate to a different later.                                                                                                 |
    | `uiConfig.receiveFundsTitle`    | `string`                                            | Optional. Configure the title of the "Receive funds" screen.                                                                                                                                                                                                                                 |
    | `uiConfig.receiveFundsSubtitle` | `string`                                            | Optional. Configure the subtitle of the "Receive funds" screen.                                                                                                                                                                                                                              |

    <Note>Testnets are not supported for the `chain` parameter.</Note>

    As examples, you can configure the chain, asset, amount, default funding method, and provider to fund like below:

    #### Fund with ETH

    ```tsx  theme={"system"}
    // Replace this with your desired network
    import {base} from 'viem/chains'
    ...
    // `fundWallet` from the useFundWallet() hook
    fundWallet({
      address: 'your-wallet-address-here',
      options: {
        chain: base,
        amount: '0.01' // Since no `asset` is set, defaults to 'native-currency' (ETH)
      }
    })
    ```

    #### Fund with USDC

    ```tsx  theme={"system"}
    // Replace this with your desired network
    import {base} from 'viem/chains'
    ...
    // `fundWallet` from the useFundWallet() hook
    fundWallet({
      address: 'your-wallet-address-here',
      options: {
        chain: base,
        amount: '15',
        asset: 'USDC'
      }
    })
    ```

    #### Fund with arbitrary ERC20

    ```tsx  theme={"system"}
    // Replace this with your desired network
    import {base} from 'viem/chains'
    ...
    // `fundWallet` from the useFundWallet() hook
    fundWallet({
      address: 'your-wallet-address-here',
      options: {
        chain: base,
        amount: '30',
        asset: {erc20: '0x0578d8A44db98B23BF096A382e016e29a5Ce0ffe'}
      }
    })
    ```

    #### Fund with Moonpay

    ```tsx  theme={"system"}
    // Replace this with your desired network
    import {base} from 'viem/chains'
    ...
    // `fundWallet` from the useFundWallet() hook
    fundWallet({
      address: 'your-wallet-address-here',
      options: {
        amount: '0.01',
        chain: base,
        card: {
          preferredProvider: 'moonpay',
        },
      }
    });
    ```

    #### Fund with Coinbase exchange immediately

    ```tsx  theme={"system"}
    // Replace this with your desired network
    import {base} from 'viem/chains'
    ...
    // `fundWallet` from the useFundWallet() hook
    fundWallet({
      address: 'your-wallet-address-here',
      options: {
        amount: '0.01',
        chain: base,
        card: {
          preferredProvider: 'coinbase',
        },
        defaultFundingMethod: 'exchange'
      }
    });
    ```

    ## Callbacks

    To understand when users have gone through a funding flow, you can use the `onUserExited` callback that can be provided to the **`useFundWallet`** hook. The `address`, `chain`, `fundingMethod`, and `balance` (value of the wallet being funded) are available via the callback, which fires when users exit the funding flow.

    For example, if you want to prompt a user to fund their wallet upon logging in for the first time as a part of your onboarding flow:

    ```tsx  theme={"system"}
    const {fundWallet} = useFundWallet({
      onUserExited({balance}) {
        if (balance < 1000n) {
          router.push('/insufficient-funds');
        } else {
          router.push('/dashboard');
        }
      }
    });

    const {login} = useLogin({
      onComplete(user, isNewUser) {
        if (isNewUser && user.wallet?.walletClientType === 'privy') {
          fundWallet({address: user.wallet.address});
        } else {
          router.push('/dashboard');
        }
      }
    });
    ```

    ## Customizing the "Receive funds" screen

    Privy allows you to customize the "Receive funds" screen by providing `uiConfig` options in the `fundWallet` method. You can set the `receiveFundsTitle` and `receiveFundsSubtitle` to customize the title and subtitle of the screen.

    You can then call `fundWallet` like so to customize the UI:

    ```tsx  theme={"system"}
    import {useFundWallet} from '@privy-io/react-auth';

    // ...
    const {fundWallet} = useFundWallet();
    fundWallet({
      address: 'your-wallet-address-here',
      options: {
        uiConfig: {
          receiveFundsTitle: 'Receive 0.05 ETH',
          receiveFundsSubtitle: 'Scan this code or copy your wallet address to receive funds on Base.'
        }
      }
    });
    ```

    This will change the default "Receive funds" screen to:

        <img src="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/customized-receive-funds.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=51fc89c9ae88852681dea0c47e9eb2ed" alt="Customized Receive funds screen" data-og-width="1158" width="1158" data-og-height="1842" height="1842" data-path="images/customized-receive-funds.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/customized-receive-funds.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=66607be32c4ced5028dbfb6c24f92e2b 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/customized-receive-funds.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=ff54e3575844f6a3bf628c2717a2337e 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/customized-receive-funds.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=ffa3f989756f1e88a06340997cb0f3c5 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/customized-receive-funds.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=7e1281c7b83d90b9687ccccc586d3496 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/customized-receive-funds.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=34143718a1847754646bc5aaefc970d2 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/customized-receive-funds.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=e728682a4ae26c48a38728a6b340d8c4 2500w" />
  </Tab>

  <Tab title="React Native">
    <Tip>
      Make sure `<PrivyElements />` is mounted first, by following [this
      guide](/authentication/user-authentication/ui-component).
    </Tip>

    Prompt the user to fund their wallets by calling `fundWallet`.

    ```tsx  theme={"system"}
    import { useFundWallet } from "@privy-io/expo/ui";
    ...
    const {fundWallet} = useFundWallet();
    await fundWallet({address: 'your-wallet-address-here'});
    ```

    Once invoked, the **`fundWallet`** method will open a modal that contains a list of funding options the user can take.

    You can pass additional configurations to the funding flow in the second, optional parameter to **`fundWallet`**.

    <Warning>
      Purchases with third-party providers are not always instantaneous, and there may be some time
      before the user completes their purchase and the funds are available in their wallet.
    </Warning>

    ## Setting a funding amount in code

    Optionally, you can pass in a **chain, funding amount, and funding asset** to `fundWallet` to override your Dashboard configuration.

    To do so, as the second, optional parameter to `fundWallet`, pass an object with the following fields:

    | Parameter                | Type                                                    | Description                                                                                                                                                                                                                                                   |
    | ------------------------ | ------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | `address`                | `string`                                                | The destination address to fund.                                                                                                                                                                                                                              |
    | `chain`                  | [`Chain`](https://viem.sh/docs/chains/introduction)     | Optional. A [`viem/chains`](https://viem.sh/docs/chains/introduction) object for the network on which users should fund their accounts. Defaults to the network you configured in the Privy Dashboard.                                                        |
    | `asset`                  | `'native-currency' \| 'USDC' \| {tokenAddress: string}` | Optional. The asset you'd like the user to fund their accounts with. Set `'native-currency'` to fund with the `chain`'s native currency (e.g. ETH), `'USDC'` to fund with USDC, or pass the token address to `tokenAddress`. Defaults to `'native-currency'`. |
    | `amount`                 | `string`                                                | Required if `asset` is set, optional otherwise. The amount of the asset to fund as a decimal string. Defaults to the amount you configured in the Privy Dashboard.                                                                                            |
    | `defaultPaymentMethod`   | `'card' \| 'exchange'`                                  | Optional. If provided, skip the payment method selection screen and immediately trigger the funding flow with the provider.                                                                                                                                   |
    | `card.preferredProvider` | `'coinbase' \| 'moonpay'`                               | Optional. Configure the 3rd-party provider for card based funding flows.                                                                                                                                                                                      |

    <Note>Testnets are not supported for the `chain` parameter.</Note>

    ```tsx  theme={"system"}
    import {useFundWallet} from '@privy-io/expo/ui';
    // Replace this with your desired network
    import {base} from 'viem/chains';
    // ...
    const {fundWallet} = useFundWallet();
    fundWallet({
      address: '0x2F3eb40872143b77D54a6f6e7Cc120464C764c09',
      asset: 'USDC',
      chain: base,
      amount: '1',
      defaultPaymentMethod: 'card',
      card: {
        preferredProvider: 'coinbase'
      }
    });
    ```

    <Tip>
      To skip directly to the provider's on-ramp experience you can use the `defaultPaymentMethod`
      option.
    </Tip>
  </Tab>
</Tabs>


# Solana
Source: https://docs.privy.io/wallets/funding/prompting-users-to-fund/solana



<Note>
  This page walks through a client-side funding integration for Solana wallets. If you are looking
  to integrate server-side for funding via bank transfer, see the [Funding via bank
  transfer](../methods/bank-account) page.
</Note>

# Prompting users to fund wallets

With funding methods enabled for your app, Privy will prompt users to fund their wallets at two points in their experience:

1. Manually, when you call Privy's `fundWallet` method documented below
2. Automatically, when the user attempts to send a transaction but has insufficient funds

You can also configure the chain, asset, and amount that users should fund their wallets with directly in code.

## Manually invoking funding

Once you've enabled a set of funding methods for your app, to invoke the funding flow, use the **`useFundWallet`** hook from the Privy SDK as follows:

<Tabs>
  <Tab title="React">
    Prompt the user to fund their wallets by calling `fundWallet`.

    ```tsx  theme={"system"}
    import {useFundWallet} from '@privy-io/react-auth/solana';
    ...
    const {fundWallet} = useFundWallet();
    await fundWallet({address: 'your-wallet-address-here'});
    ```

    Once invoked, the **`fundWallet`** method will open a modal that contains a list of funding options the user can take. If only one funding method was enabled for your app, Privy will navigate the user directly to that specific flow.

    You can pass additional configurations to the funding flow in the `options` parameter to **`fundWallet`**.

    <Warning>
      Purchases with third-party providers are not always instantaneous, and there may be some time
      before the user completes their purchase and the funds are available in their wallet.
    </Warning>

    ## Automatically invoking funding

    With funding methods enabled for your app, if a user attempts to send a transaction but does not have sufficient funds to do so, Privy will show them an "Add funds" button in the transaction modal that enables them to invoke funding flows.

    ## Setting a funding amount in code

    Optionally, you can pass in a **chain, funding amount, and funding asset** to `fundWallet` to override your Dashboard configuration.

    To do so, in the `options` parameter to `fundWallet`, pass an object with the following fields:

    | Parameter                       | Type                                           | Description                                                                                                                                                                                                                                                                                  |
    | ------------------------------- | ---------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | `cluster`                       | `{name: Cluster}`                              | Optional. An object for the [Cluster](https://solana-foundation.github.io/solana-web3.js/types/Cluster.html) on which users should fund their accounts. Defaults to `mainnet-beta`.                                                                                                          |
    | `amount`                        | `string`                                       | Required if `asset` is set, optional otherwise. The amount of the asset to fund as a decimal string. Defaults to the amount you configured in the Privy Dashboard.                                                                                                                           |
    | `defaultFundingMethod`          | `'card' \| 'exchange' \| 'wallet' \| 'manual'` | Optional. Specifying the default funding method will send the user directly to the card / exchange provider, directly open the wallet transfer, or directly open the manual QR wallet transfer screen. Additional configured payment options will be shown after the default funding method. |
    | `card.preferredProvider`        | `'coinbase' \| 'moonpay'`                      | Optional. The preferred card provider to use for funding. If not specified, users will be directed to one of these providers initially and given an option to navigate to a different later.                                                                                                 |
    | `uiConfig.receiveFundsTitle`    | `string`                                       | Optional. Configure the title of the "Receive funds" screen.                                                                                                                                                                                                                                 |
    | `uiConfig.receiveFundsSubtitle` | `string`                                       | Optional. Configure the subtitle of the "Receive funds" screen.                                                                                                                                                                                                                              |

    As examples, you can configure the cluster, amount, and provider to fund like below:

    #### Fund with SOL

    ```tsx  theme={"system"}
    // `fundWallet` from the useFundWallet() hook
    fundWallet({
      address: 'your-wallet-address-here',
      options: {
        cluster: {name: 'devnet'},
        amount: '0.01' // SOL
      }
    });
    ```

    #### Fund with Moonpay

    ```tsx  theme={"system"}
    fundWallet({
      address: 'your-wallet-address-here',
      options: {
        amount: '0.01', // SOL
        card: {
          preferredProvider: 'moonpay'
        }
      }
    });
    ```

    #### Fund with Coinbase exchange immediately

    ```tsx  theme={"system"}
    // `fundWallet` from the useFundWallet() hook
    fundWallet({
      address: 'your-wallet-address-here',
      options: {
        amount: '0.01',
        card: {
          preferredProvider: 'coinbase'
        },
        defaultFundingMethod: 'exchange'
      }
    });
    ```

    ## Callbacks

    To understand when users have gone through a funding flow, you can use the `onUserExited` callback that can be provided to the **`useFundWallet`** hook. The `address`, `chain`, `fundingMethod`, and `balance` (value of the wallet being funded) are available via the callback, which fires when users exit the funding flow.

    For example, if you want to prompt a user to fund their wallet upon logging in for the first time as a part of your onboarding flow:

    ```tsx  theme={"system"}
    const {fundWallet} = useFundWallet({
      onUserExited({balance}) {
        if (balance < 1000n) {
          router.push('/insufficient-funds');
        } else {
          router.push('/dashboard');
        }
      }
    });

    const {login} = useLogin({
      onComplete(user, isNewUser) {
        if (isNewUser && user.wallet?.walletClientType === 'privy') {
          fundWallet({address: user.wallet.address});
        } else {
          router.push('/dashboard');
        }
      }
    });
    ```

    ## Customizing the "Receive funds" screen

    Privy allows to customize the "Receive funds" screen by providing `uiConfig` options in the `fundWallet` method. You can set the `receiveFundsTitle` and `receiveFundsSubtitle` to customize the title and subtitle of the screen.

    You can then call `fundWallet` like so to customize the UI:

    ```tsx  theme={"system"}
    import {useFundWallet} from '@privy-io/react-auth';

    // ...
    const {fundWallet} = useFundWallet();
    fundWallet({
      address: 'your-wallet-address-here',
      options: {
        uiConfig: {
          receiveFundsTitle: 'Receive 0.05 SOL',
          receiveFundsSubtitle: 'Scan this code or copy your wallet address to receive funds on Solana.'
        }
      }
    });
    ```

    This will change the default "Receive funds" screen to:

        <img src="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/customized-receive-funds.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=51fc89c9ae88852681dea0c47e9eb2ed" alt="Receive funds screen" data-og-width="1158" width="1158" data-og-height="1842" height="1842" data-path="images/customized-receive-funds.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/customized-receive-funds.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=66607be32c4ced5028dbfb6c24f92e2b 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/customized-receive-funds.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=ff54e3575844f6a3bf628c2717a2337e 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/customized-receive-funds.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=ffa3f989756f1e88a06340997cb0f3c5 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/customized-receive-funds.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=7e1281c7b83d90b9687ccccc586d3496 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/customized-receive-funds.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=34143718a1847754646bc5aaefc970d2 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/customized-receive-funds.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=e728682a4ae26c48a38728a6b340d8c4 2500w" />
  </Tab>

  <Tab title="React Native">
    <Tip>
      Make sure `<PrivyElements />` is mounted first, by following [this
      guide](/authentication/user-authentication/ui-component).
    </Tip>

    Prompt the user to fund their wallets by calling `fundSolanaWallet`.

    ```tsx  theme={"system"}
    import { useFundSolanaWallet } from "@privy-io/expo/ui";
    ...
    const {fundWallet} = useFundSolanaWallet();
    await fundWallet({address: 'your-wallet-address-here'});
    ```

    Once invoked, the **`fundWallet`** method will open a modal that contains a list of funding options the user can take.

    You can pass additional configurations to the funding flow in the second, optional parameter to **`fundWallet`**.

    <Warning>
      Purchases with third-party providers are not always instantaneous, and there may be some time
      before the user completes their purchase and the funds are available in their wallet.
    </Warning>

    ## Setting a funding amount in code

    Optionally, you can pass in a **chain, funding amount, and funding asset** to `fundWallet` to override your Dashboard configuration.

    To do so, as the second, optional parameter to `fundWallet`, pass an object with the following fields:

    | Parameter                | Type                          | Description                                                                                                                                                                                    |
    | ------------------------ | ----------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | `address`                | `string`                      | The destination address to fund.                                                                                                                                                               |
    | `cluster`                | `SolanaCluster`               | Optional. An object for the cluster on which users should fund their accounts. Defaults to `mainnet-beta`.                                                                                     |
    | `asset`                  | `'native-currency' \| 'USDC'` | Optional. The asset you'd like the user to fund their accounts with. Set `'native-currency'` to use the app's configured asset or `'USDC'` to fund with USDC. Defaults to `'native-currency'`. |
    | `amount`                 | `string`                      | Required if `asset` is set, optional otherwise. The amount of the asset to fund as a decimal string. Defaults to the amount you configured in the Privy Dashboard.                             |
    | `defaultPaymentMethod`   | `'card' \| 'exchange'`        | Optional. If provided, skip the payment method selection screen and immediately trigger the funding flow with the provider.                                                                    |
    | `card.preferredProvider` | `'coinbase' \| 'moonpay'`     | Optional. Configure the 3rd-party provider for card based funding flows.                                                                                                                       |

    As an example, you can configure the cluster and amount to fund like so:

    ```tsx  theme={"system"}
    import {useFundSolanaWallet} from '@privy-io/expo/ui';
    // ...
    const {fundWallet} = useFundSolanaWallet();
    fundWallet({
      address: 'your-wallet-address-here',
      amount: '0.01', // SOL
      defaultPaymentMethod: 'card',
      card: {
        preferredProvider: 'coinbase'
      }
    });
    ```

    <Tip>
      To skip directly to the provider's on-ramp experience you can use the `defaultPaymentMethod`
      option.
    </Tip>
  </Tab>
</Tabs>


# Fetch balance via webhook
Source: https://docs.privy.io/wallets/gas-and-asset-management/assets/balance-event-webhooks



**Privy emits webhooks whenever a wallet sends or receives a registered asset.** This helps your application stay in sync with the assets in your wallets, and easily track deposits and withdrawals.

To set up deposit and/or withdrawal webhooks, follow the guide below.

<Info>
  Webhooks is currently a scale feature. To use webhooks, please upgrade your account in the Privy
  Dashboard.
</Info>

<Tip>
  Deposit webhooks are available for select chains on Tier 3 and Tier 2. To see which exact chains
  are supported, go to the [Dashboard Webhooks page.](https://dashboard.privy.io/apps?page=webhooks)
</Tip>

## Setup a webhooks URL

To start, go to the [**Webhooks**](https://dashboard.privy.io/apps?page=webhooks) page for your app in the [Privy Dashboard](https://dashboard.privy.io) and provide a destination URL for receiving webhooks.

Then, enable the `'wallet.funds_deposited'` and/or `'wallet.funds_withdrawn'` events. You can next configure which assets Privy should emit `'wallet.funds_deposited'` and/or `'wallet.funds_withdrawn'` events for.

Privy will emit a signed webhook to this URL whenever your wallets sends/receives a transaction for a registered asset, and will retry delivery if the endpoint does not successfully respond to the original webhook.
Privy's webhook system operates on a `at least once` delivery basis, and redundant requests can be identified via the `idempotency_key` field.

## Configure assets to track

Once you've enabled the `'wallet.funds_deposited'` and/or `'wallet.funds_withdrawn'` events, you can then configure which assets you'd like to track via the Privy Dashboard.

Privy supports webhooks for **native tokens** (e.g. ETH, SOL) on EVM and Solana, **ERC20 tokens** on EVM, and **SPL tokens** on Solana.

#### Native tokens

To configure webhooks for native token transactions, simply select the **Native token** asset type and provide the CAIP-2 chain ID for the network on which to track the native token.

#### ERC20 tokens

To configure webhooks for ERC20 token transfers, simply select the **ERC20 token** asset type and provide:

* the contract address for the ERC20 token
* the CAIP-2 chain ID for the network on which to track the ERC20 token

#### SPL tokens

To configure webhooks for SPL token transfers, simply select the **SPL token** asset type and provide:

* the mint address for the SPL token
* the CAIP-2 chain ID for the network on which to track the SPL token

## Payload

When a wallet receives a transaction for a registered asset, Privy will emit a webhooks payload with the following fields:

<Expandable title="child attributes" defaultOpen="true">
  <ResponseField name="type" type="'wallet.funds_deposited' | 'wallet.funds_withdrawn'">
    Event name for the webhook.
  </ResponseField>

  <ResponseField name="wallet_id" type="string">
    ID of the wallet that received the deposit.
  </ResponseField>

  <ResponseField name="asset" type="Object">
    Asset for the transaction.

    <Expandable title="child attributes" defaultOpen="true" defaultOpen="true">
      <ResponseField name="type" type="'native-token' | 'erc20' | 'spl'">
        Type of the asset for the transaction.
      </ResponseField>

      <ResponseField name="address" type="string">
        Contract address for an ERC20 asset, or mint address for an SPL asset. This field will only be included for the 'erc20' and 'spl' asset.types.
      </ResponseField>
    </Expandable>
  </ResponseField>

  <ResponseField name="amount" type="string">
    Absolute amount of the transaction. Denominated based on the asset (e.g. wei for EVM, or lamports
    for SOL). Stringified to maintain precision from BigInt.
  </ResponseField>

  <ResponseField name="transaction_hash" type="string">
    Hash for the transaction.
  </ResponseField>

  <ResponseField name="sender" type="string">
    Sender of the transaction.
  </ResponseField>

  <ResponseField name="recipient" type="string">
    Recipient of the transaction.
  </ResponseField>

  <ResponseField name="caip2" type="string">
    CAIP-2 chain ID of the network where the transaction happened.
  </ResponseField>

  <ResponseField name="block" type="Object">
    Information about the block for the transaction.

    <Expandable title="child attributes" defaultOpen="true" defaultOpen="true">
      <ResponseField name="number" type="number">
        Number of the block for the transaction.
      </ResponseField>
    </Expandable>
  </ResponseField>

  <ResponseField name="idempotency_key" type="string">
    An idempotent ID that uniquely identifies the deposit or withdrawal. In cases where the webhooks
    trigger more than once, the idempotency\_key will match.
  </ResponseField>
</Expandable>


# Fetch transaction via API
Source: https://docs.privy.io/wallets/gas-and-asset-management/assets/fetch-a-transaction



<Warning>
  The following functionality exists for [wallets reconstituted
  server-side](/wallets/wallets/create/create-a-wallet). More on [Privy architecture
  here](/security/wallet-infrastructure/architecture)
</Warning>

<Note>
  In August 2025 we migrated transactions to a new data store. As part of this migration, we changed
  the format of transaction IDs from CUID2 to UUIDv4. You may continue using the CUID2 for your
  existing transactions, but we encourage migration to the new UUID, as it will avoid a very slight
  latency increase due to an extra lookup for mapping from the legacy ID to the new ID.
</Note>

<Tabs>
  <Tab title="NodeJS">
    To get a transaction's details using the NodeJS SDK, use the `get` method on the `transactions()` interface of the Privy client:

    ### Usage

    ```typescript  theme={"system"}
    import {PrivyClient} from '@privy-io/node';

    const privy = new PrivyClient({
      appId: 'insert-your-app-id',
      appSecret: 'insert-your-app-secret'
    });

    const transaction = await privy.transactions().get('insert-transaction-id');
    console.log(transaction);
    ```

    ### Parameters and Returns

    Check out the [API reference](/api-reference/transactions/get) for more details.
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    To get a transaction's details using the NodeJS SDK, use the `getTransaction` method from the Privy client:

    ```typescript {skip-check} theme={"system"}
    getTransaction: (input: {id: string}) => Promise<WalletApiTransactionResponseType>;
    ```

    ### Usage

    ```typescript  theme={"system"}
    import {PrivyClient} from '@privy-io/server-auth';

    const privy = new PrivyClient('insert-your-app-id', 'insert-your-app-secret');

    const transaction = await privy.walletApi.getTransaction({
      id: 'insert-transaction-id'
    });
    console.log(transaction);
    ```

    ### Parameters

    <ParamField path="id" type="string" required>
      ID of the transaction to fetch details for.
    </ParamField>

    ### Returns

    <ResponseField name="transaction" type="WalletApiTransactionResponseType">
      <Expandable title="WalletApiTransactionResponseType" defaultOpen="true">
        <ResponseField name="id" type="string">
          ID for the transaction.
        </ResponseField>

        <ResponseField name="walletId" type="string">
          ID for the wallet that sent the transaction.
        </ResponseField>

        <ResponseField name="caip2" type="string">
          CAIP-2 chain ID for the network the transaction was broadcasted on.
        </ResponseField>

        <ResponseField name="transactionHash" type="string">
          Hash for the transaction.
        </ResponseField>

        <ResponseField name="status" type="'broadcasted' | 'confirmed' | 'execution_reverted' | 'failed' | 'replaced' | 'pending' | 'provider_error'">
          Current status of the transaction. - `'broadcasted'` refers to when a transaction has been
          submitted to the network but has not yet been included in a block - `'confirmed'` refers to when a
          transaction has been included in a block that has been confirmed on the network. -
          `'execution_reverted'` refers to when a transaction has reverted in execution. - `'failed'` refers
          to when a transaction has been pending for too long, signaling that it will not be included
          on-chain. This can happen when the gas fee is too low given the current activity on the blockchain
          and is only triggered for chains that have a defined pending time limit (e.g. Base, Solana,
          Flow.). - `'replaced'` refers to when a transaction has been replaced by another transaction with
          the same nonce. This is only applicable to EVM chains. - `'pending'` irefers to when a custodial
          wallet transaction has been initiated with the custodian and is undergoing processing. -
          `'provider_error'` refers to when a custodial wallet transaction request has been rejected by the
          custodian or encountered an error. This can happen when you attempt to spend funds that haven't
          been fully screened by the custodian yet, or when a transaction does not meet the custodian's
          compliance requirements.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="Java">
    To get a transaction by ID, use the `getTransaction` method.

    ```java  theme={"system"}
    try {
        TransactionRetrieveResponse response = privyClient
            .transactions()
            .retrieve('insert-transaction-id');

        if (response.transaction().isPresent()) {
            Transaction transaction = response.transaction().get();
        }
    } catch (APIException e) {
        String errorBody = e.bodyAsString();
        System.err.println(errorBody);
    } catch (Exception e) {
        System.err.println(e.getMessage());
    }
    ```

    ### Parameters

    <ParamField body="transactionId" type="String" required>
      The ID of the transaction to retrieve
    </ParamField>

    ### Returns

    The `TransactionRetrieveResponse` object contains an optional `transaction()` field, present if the
    transaction was retrieved successfully.

    <ResponseField name="transaction()" type="Optional<Transaction>">
      The retrieved `Transaction` object.

      <Expandable defaultOpen="true">
        <ResponseField type="String" name="id">
          Unique ID of the transaction.
        </ResponseField>

        <ResponseField type="String" name="walletId">
          ID for the wallet that sent the transaction.
        </ResponseField>

        <ResponseField type="String" name="caip2">
          CAIP-2 chain ID for the network the transaction was broadcasted on.
        </ResponseField>

        <ResponseField type="String" name="transactionHash">
          Hash for the transaction.
        </ResponseField>

        <ResponseField type="Status" name="status">
          Current status of the transaction.
        </ResponseField>

        <ResponseField type="double" name="createdAt">
          The creation date of the wallet, in milliseconds since midnight, January 1, 1970 UTC.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="REST API">
    Privy supports fetching transaction status by the transaction ID.

    To do so, make a `GET` request to

    ```bash  theme={"system"}
    https://api.privy.io/v1/transactions/<transaction_id>
    ```

    replacing `<transaction_id>` with the ID of your desired transaction.

    ## Response

    <ResponseField name="id" type="string">
      ID for the transaction.
    </ResponseField>

    <ResponseField name="wallet_id" type="string">
      ID for the wallet that sent the transaction.
    </ResponseField>

    <ResponseField name="status" type="'broadcasted' | 'confirmed' | 'execution_reverted' | 'failed' | 'replaced' | 'pending' | 'provider_error'">
      Current status of the transaction. - `'broadcasted'` refers to when a transaction has been
      submitted to the network but has not yet been included in a block - `'confirmed'` refers to when a
      transaction has been included in a block that has been confirmed on the network. -
      `'execution_reverted'` refers to when a transaction has reverted in execution. - `'failed'` refers
      to when a transaction has been pending for too long, signaling that it will not be included
      on-chain. This can happen when the gas fee is too low given the current activity on the blockchain
      and is only triggered for chains that have a defined pending time limit (e.g. Base, Solana,
      Flow.). - `'replaced'` refers to when a transaction has been replaced by another transaction with
      the same nonce. This is only applicable to EVM chains. - `'pending'` irefers to when a custodial
      wallet transaction has been initiated with the custodian and is undergoing processing. -
      `'provider_error'` refers to when a custodial wallet transaction request has been rejected by the
      custodian or encountered an error. This can happen when you attempt to spend funds that haven't
      been fully screened by the custodian yet, or when a transaction does not meet the custodian's
      compliance requirements.
    </ResponseField>

    <ResponseField name="transaction_hash" type="string">
      Hash for the transaction.
    </ResponseField>

    <ResponseField name="caip2" type="string">
      CAIP-2 chain ID for the network the transaction was broadcasted on.
    </ResponseField>

    ## Example

    For example, you might fetch a transactions status using transaction ID using the `cURL` request below.

    ```bash  theme={"system"}
    $ curl --request GET https://api.privy.io/v1/transactions/<transaction_id> \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H 'Content-Type: application/json' \
    ```

    The response might look like

    ```json  theme={"system"}
    {
      "id": "<transaction_id>",
      "wallet_id": "fmfdj6yqly31huorjqzq38zc",
      "status": "confirmed",
      "transaction_hash": "0x2446f1fd773fbb9f080e674b60c6a033c7ed7427b8b9413cf28a2a4a6da9b56c",
      "caip2": "eip155:8453"
    }
    ```
  </Tab>

  <Tab title="Rust">
    To get a transaction's details using the Rust SDK, use the `get` method on the `transactions()` interface of the Privy client:

    ### Usage

    ```rust  theme={"system"}
    use privy_rs::PrivyClient;

    let client = PrivyClient::new(app_id, app_secret)?;

    let transaction = client.transactions().get("insert-transaction-id").await?;
    println!("Transaction: {:?}", transaction);
    ```

    ### Parameters and Returns

    See the Rust SDK documentation for detailed parameter and return types, including embedded examples:

    * [TransactionsClient::get](https://docs.rs/privy-rs/latest/privy_rs/subclients/struct.TransactionsClient.html#method.get)
    * [Transaction](https://docs.rs/privy-rs/latest/privy_rs/generated/types/struct.Transaction.html)

    For REST API details, see the [API reference](/api-reference/transactions/get).
  </Tab>
</Tabs>


# Fetch balance via API
Source: https://docs.privy.io/wallets/gas-and-asset-management/assets/fetch-balance



<Warning>
  The following functionality exists for [wallets reconstituted
  server-side](/wallets/wallets/create/create-a-wallet). More on [Privy architecture
  here](/security/wallet-infrastructure/architecture)
</Warning>

<Tabs>
  <Tab title="REST API">
    Privy supports fetching wallet balances by the wallet ID.

    To do so, make a `GET` request to

    ```bash  theme={"system"}
    https://api.privy.io/v1/wallets/<wallet_id>/balance
    ```

    replacing `<wallet_id>` with the ID of your desired wallet.

    ## Response

    <ResponseField name="balance" type="string">
      The wallet's native token balance in the smallest denomination (e.g., wei for Ethereum). Returned
      as a string to maintain precision.
    </ResponseField>

    <ResponseField name="chain_type" type="string">
      The blockchain type (e.g., "ethereum", "solana").
    </ResponseField>

    <ResponseField name="address" type="string">
      The wallet's public address.
    </ResponseField>

    ## Example

    For example, your app might fetch a wallet's balance using the `cURL` request below.

    ```bash  theme={"system"}
    $ curl --request GET https://api.privy.io/v1/wallets/<wallet_id>/balance \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H 'Content-Type: application/json'
    ```

    The response might look like

    ```json  theme={"system"}
    {
      "balances": [
        {
          "chain": "base",
          "asset": "eth",
          "raw_value": "1000000000000000000",
          "raw_value_decimals": 18,
          "display_values": {
            "eth": "0.001",
            "usd": "2.56"
          }
        }
      ]
    }
    ```

    ### Parameters and Returns

    Check out the [API reference](/api-reference/wallets/get-balance) for more details.
  </Tab>

  <Tab title="NodeJS">
    To get a wallet's balance using the NodeJS SDK, use the `getBalance` method on the `wallets()` interface of the Privy client:

    ### Usage

    ```typescript  theme={"system"}
    import {PrivyClient} from '@privy-io/node';

    const privy = new PrivyClient({
      appId: 'insert-your-app-id',
      appSecret: 'insert-your-app-secret'
    });

    const balance = await privy.wallets().balance.get('insert-wallet-id', {
      asset: 'usdc',
      chain: 'ethereum'
    });
    console.log(balance);
    ```

    ### Parameters and Returns

    Check out the [API reference](/api-reference/wallets/get-balance) for more details.
  </Tab>

  <Tab title="Java">
    To get a wallet's balance by ID, use the `getBalance` method.

    ```java  theme={"system"}
    try {
        WalletBalanceResponse response = privyClient
            .wallets()
            .balance()
            .walletId("insert-wallet-id")
            .call();

        if (response.object().isPresent()) {
            WalletBalanceResponseBody balanceBody = response.object().get();

            // The response contains a list of balances (one per chain/asset combination)
            for (Balance balance : balanceBody.balances()) {
                String rawValue = balance.rawValue();
                double rawValueDecimals = balance.rawValueDecimals();
                System.out.println("Balance: " + rawValue);
                System.out.println("Balance (decimals): " + rawValueDecimals);
                System.out.println("Chain: " + balance.chain());
                System.out.println("Asset: " + balance.asset());
            }
        }
    } catch (APIException e) {
        String errorBody = e.bodyAsString();
        System.err.println(errorBody);
    } catch (Exception e) {
        System.err.println(e.getMessage());
    }
    ```

    ### Parameters

    <ParamField body="walletId" type="String" required>
      The ID of the wallet to retrieve balance for
    </ParamField>

    ### Returns

    The `WalletBalanceResponse` object contains balance information for the wallet.

    <ResponseField name="balances()" type="List<Balance>">
      List of balance objects for different chain/asset combinations.

      <Expandable defaultOpen="true">
        <ResponseField name="rawValue()" type="String">
          Balance value as a string in the smallest denomination to maintain precision.
        </ResponseField>

        <ResponseField name="rawValueDecimals()" type="double">
          Balance value as a decimal number.
        </ResponseField>

        <ResponseField name="chain()" type="BalanceChainType">
          The blockchain type (e.g., ETHEREUM, SOLANA, BASE, POLYGON).
        </ResponseField>

        <ResponseField name="asset()" type="Asset">
          The asset type (e.g., NATIVE, USDC, USDT).
        </ResponseField>

        <ResponseField name="displayValues()" type="Map<String, String>">
          Formatted display values for the balance in different currencies/formats.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="Rust">
    To get a wallet's balance using the Rust SDK, use the `get_balance` method on the `wallets()` interface of the Privy client:

    ### Usage

    ```rust  theme={"system"}
    use privy_rs::PrivyClient;

    let client = PrivyClient::new(app_id, app_secret)?;

    // For a Solana wallet
    let balance = client
        .wallets()
        .balance()
        .get(
            "insert-wallet-id",
            &GetWalletBalanceAsset::String(GetWalletBalanceAssetString::Sol),
            &GetWalletBalanceChain::String(GetWalletBalanceChainString::Solana),
            None, // optional: currency conversion (e.g., Some(GetWalletBalanceIncludeCurrency::Usd))
        )
        .await?;
    ```

    ### Parameters and Returns

    See the Rust SDK documentation for detailed parameter and return types, including embedded examples:

    * [WalletsBalanceClient::get](https://docs.rs/privy-rs/latest/privy_rs/subclients/struct.WalletsBalanceClient.html)
    * [GetWalletBalanceResponse](https://docs.rs/privy-rs/latest/privy_rs/generated/types/struct.GetWalletBalanceResponse.html)

    For REST API details, see the [API reference](/api-reference/wallets/get-balance).
  </Tab>
</Tabs>


# Wallet webhooks
Source: https://docs.privy.io/wallets/gas-and-asset-management/assets/overview



Privy offers powerful **webhooks** that notify your application of updates to:

* [transaction statuses](/wallets/gas-and-asset-management/assets/transaction-event-webhooks)
* [incoming deposits](/wallets/gas-and-asset-management/assets/balance-event-webhooks)
* [outgoing withdrawals](/wallets/gas-and-asset-management/assets/balance-event-webhooks)

In addition, you can use Privy's [REST API](/wallets/gas-and-asset-management/assets/fetch-a-transaction) to query the transaction status and wallet balances.

Follow the guide below to set up webhooks for your app.

## Registering an endpoint

1. In your backend, create a new endpoint that will accept **POST** requests from Privy

   <Tip>
     When creating your endpoint to receive webhook events, always verify the payload signature by
     following our [webhook signing key
     documentation](/user-management/users/webhooks/handling-events#webhook-signing-key`).
   </Tip>

2. In the dashboard, go to the **Configuration > Webhooks** page

3. Add your new endpoint as the destination URL and select any event types you'd like to be notified for

You can specify which user events your webhook endpoint will be notified about. The options are as follows:

| Event Name               | Type                      | Action                                                                         |
| ------------------------ | ------------------------- | ------------------------------------------------------------------------------ |
| User created             | user.created              | A user was created in the application.                                         |
| User authenticated       | user.authenticated        | A user successfully logged into the application.                               |
| User linked account      | user.linked\_account      | A user successfully linked a new login method.                                 |
| User unlinked account    | user.unlinked\_account    | A user successfully unlinked an existing login method.                         |
| User updated account     | user.updated\_account     | A user successfully updates the email or phone number linked to their account. |
| User transferred account | user.transferred\_account | A user successfully transferred their account to a new account.                |
| Wallet created for user  | user.wallet\_created      | A wallet (embedded or smart wallet) was successfully created for a user.       |
| MFA enabled              | mfa.enabled               | A user has enabled MFA for their account.                                      |
| MFA disabled             | mfa.disabled              | A user has disabled MFA for their account.                                     |
| Private key exported     | private\_key.exported     | A user has exported their private key from an embedded wallet.                 |
| Wallet recovery setup    | wallet.recovery\_setup    | A user has set up wallet recovery for their embedded wallet.                   |
| Wallet recovered         | wallet.recovered          | A user has successfully recovered their embedded wallet.                       |

**That's it! You've successfully configured webhooks for your app.** 🎉

## Testing the webhook setup

<Accordion title="Quick testing guide">
  During development and testing, you can quickly verify your webhook endpoint is working correctly. Here's a simple step-by-step guide:

  #### Step 1: Expose your local endpoint

  If you're testing locally, you'll need to expose your local server to the internet. Use a tool like [ngrok](https://ngrok.com/) or [Cloudflare Tunnel](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/):

  ```bash  theme={"system"}
  # Using ngrok (after installing: https://ngrok.com/download)
  ngrok http 3000

  # Or using Cloudflare Tunnel (after installing: https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/installation/)
  cloudflared tunnel --url http://localhost:3000
  ```

  Copy the public URL (e.g., `https://abc123.ngrok.io` or `https://abc123.trycloudflare.com`).

  #### Step 2: Create your webhook endpoint

  Create a simple endpoint in your backend that accepts POST requests:

  ```tsx  theme={"system"}
  import {NextRequest, NextResponse} from 'next/server';

  export async function POST(req: NextRequest) {
    const body = await req.json();

    // Log the webhook payload
    console.log('Webhook received:', body);

    // Return 200 to acknowledge receipt
    return NextResponse.json({received: true}, {status: 200});
  }
  ```

  #### Step 3: Register your endpoint in the dashboard

  1. Go to **Configuration > Webhooks** in the Privy Dashboard
  2. Add your public URL (from Step 1) as the webhook endpoint
  3. Select the event types you want to test

  #### Step 4: Test your endpoint

  Click the **"Test webhook"** button in the dashboard. This will send a test webhook (`privy.test`) to your endpoint with the following payload:

  ```json  theme={"system"}
  {
    "type": "privy.test",
    "message": "Hello, World!"
  }
  ```

  #### Step 5: Verify receipt

  Check your server logs to confirm you received the webhook. You should see:

  * The webhook payload in your console/logs
  * A successful 200 response returned to Privy

  <Tip>
    For quick testing, you can also use services like [webhook.site](https://webhook.site/) or
    [RequestBin](https://requestbin.com/) to get a temporary endpoint URL without setting up your own
    server.
  </Tip>
</Accordion>

## Retry behavior

Your endpoint must return a 2xx response for the webhook delivery to be considered successful. Anything else is considered an error response, and will be retried based on the following schedule, where each period is started following the failure of the preceding attempt:

* Immediately
* 5 seconds
* 5 minutes
* 30 minutes
* 2 hours
* 5 hours
* 10 hours
* 10 hours (in addition to the previous)

After the final attempt, the message will be marked as a failure, and must be manually retried from the dashboard. If all attempts to your endpoint fail for 5 consecutive days, your endpoint will be automatically disabled.

## Static IPs

Webhooks will be delivered from the following list of IP addresses:

```
44.228.126.217
50.112.21.217
52.24.126.164
54.148.139.208
2600:1f24:64:8000::/52
```


# Fetch transaction via webhook
Source: https://docs.privy.io/wallets/gas-and-asset-management/assets/transaction-event-webhooks



<Warning>
  The following functionality exists for [wallets reconstituted
  server-side](/wallets/wallets/create/create-a-wallet). More on [Privy architecture
  here](/security/wallet-infrastructure/architecture)
</Warning>

**Privy emits webhooks whenever the status of a transaction sent by a wallet changes.** This helps your application track the status of the transaction after it has been broadcasted to the network, and be notified when the transaction is confirmed or reverts.

<Info>
  Webhooks is currently a scale feature. To use webhooks, please upgrade your account in the Privy
  Dashboard.
</Info>

To set up transaction webhooks, follow the guide below.

## Events

Privy allows you to subscribe to webhooks on the following transaction events:

* `'broadcasted'` refers to when a transaction has been submitted to the network but has not yet been included in a block
* `'still_pending'` refers to when a transaction has been submitted to the network but is taking longer than expected to be confirmed. To ensure that the transaction gets included, we recommend listening to this webhook to trigger [transaction speed-ups](/recipes/speeding-up-transactions).
* `'confirmed'` refers to when a transaction has been included in at least one block that has been confirmed on the network.
* `'execution_reverted'` refers to when a transaction has reverted in execution.
* `'replaced'` refers to when a transaction has been replaced by another transaction with the same nonce. This is only applicable to EVM chains.
* `'failed'` refers to when a transaction has been pending for too long, signaling that it will not be included on-chain. This can happen when the gas fee is too low given the current activity on the blockchain and is only triggered for chains that have a defined pending time limit (e.g. Base, Solana, Flow.).
* `'provider_error'` refers to when a custodial wallet transaction request has been rejected by the custodian or encountered an error. This can happen when you attempt to spend funds that haven't been fully screened by the custodian yet, or when a transaction does not meet the custodian's compliance requirements.

<Info>
  Failures are uncommon overall, but more likely to occur on Base and Polygon than other chains
  (\<1% of transactions). To ensure transactions get confirmed, follow our guide on [transaction
  replacement](/recipes/speeding-up-transactions) to speed up stalled transactions.
</Info>

## Setup

To start, go to the **Webhooks** page for your app in the [Privy Dashboard](https://dashboard.privy.io) and provide a destination URL for receiving webhooks.

Then, enable the `'transaction.broadcasted'`, `transaction.still_pending`, `'transaction.confirmed'`, `'transaction.execution_reverted'`, `'transaction.replaced'`, and/or `'transaction.failed'` events depending on the transaction events you'd like to be notified of.

Privy will emit a signed webhook to this URL whenever transaction status updates, and will retry delivery if the endpoint does not successfully respond to the original webhook.

## Payload

When the status of a transaction updates, Privy will emit a webhooks payload with the following fields:

<ResponseField name="type" type="'transaction.{broadcasted, still_pending, confirmed, execution_reverted, replaced, failed, provider_error}'">
  Event for the transaction.
</ResponseField>

<ResponseField name="transaction_id" type="string">
  ID for the transaction.
</ResponseField>

<ResponseField name="wallet_id" type="string">
  ID of the wallet that sent the transaction.
</ResponseField>

<ResponseField name="transaction_hash" type="string">
  Hash for the transaction.
</ResponseField>

<ResponseField name="caip2" type="string">
  CAIP-2 chain ID of the network that the transaction was broadcasted on.
</ResponseField>


# Webhook events reference
Source: https://docs.privy.io/wallets/gas-and-asset-management/assets/webhook-events-reference

Comprehensive reference for all webhook event types with example payloads

This reference provides detailed documentation for all webhook event types available in Privy, including example payloads for each event.

<Info>
  Webhooks is currently a scale feature. To use webhooks, please upgrade your account in the Privy
  Dashboard.
</Info>

## Webhook delivery

Privy sends webhooks to your configured endpoint via Svix. The webhook system operates on an **at least once** delivery basis with automatic retries if the endpoint does not successfully respond.

<Info>
  Redundant webhook deliveries can be identified using the `idempotency_key` field where available,
  ensuring your application can safely handle duplicate events.
</Info>

To set up webhooks, go to the [webhooks page](https://dashboard.privy.io/apps?page=webhooks) in the Privy Dashboard.

## Event structure

All webhook events follow a consistent structure with the event type included as a `type` field:

```json  theme={"system"}
{
  "type": "event.type"
  // Event-specific data
}
```

## User and authentication events

### `user.created`

Triggered when a new user is created in your app.

<Expandable title="Example payload">
  ```json  theme={"system"}
  {
    "type": "user.created",
    "user": {
      "id": "did:privy:cfbsvtqo2c22202mo08847jdux2z",
      "created_at": 1716153600,
      "linked_accounts": [],
      "mfa_methods": [],
      "has_accepted_terms": true,
      "is_guest": false
    }
  }
  ```
</Expandable>

### `user.authenticated`

Triggered when a user successfully authenticates with your app.

<Expandable title="Example payload (email authentication)">
  ```json  theme={"system"}
  {
    "type": "user.authenticated",
    "user": {
      "id": "did:privy:cfbsvtqo2c22202mo08847jdux2z",
      "created_at": 1716153600,
      "linked_accounts": [
        {
          "type": "email",
          "address": "user@example.com",
          "verified_at": 1716153600,
          "first_verified_at": 1716153600,
          "latest_verified_at": 1716153600
        }
      ],
      "mfa_methods": [
        {
          "type": "totp",
          "verified_at": 1716153600
        }
      ],
      "has_accepted_terms": true,
      "is_guest": false
    },
    "account": {
      "type": "email",
      "address": "user@example.com",
      "verified_at": 1716153600,
      "first_verified_at": 1716153600,
      "latest_verified_at": 1716153600
    }
  }
  ```
</Expandable>

### `user.linked_account`

Triggered when a user links a new account (email, wallet, social, etc.) to their Privy account.

<Tabs>
  <Tab title="Email account">
    ```json  theme={"system"}
    {
      "type": "user.linked_account",
      "user": {
        "id": "did:privy:cfbsvtqo2c22202mo08847jdux2z",
        "created_at": 1716153600,
        "linked_accounts": [],
        "mfa_methods": [],
        "has_accepted_terms": true,
        "is_guest": false
      },
      "account": {
        "type": "email",
        "address": "user@example.com",
        "verified_at": 1716153600,
        "first_verified_at": 1716153600,
        "latest_verified_at": 1716153600
      }
    }
    ```
  </Tab>

  <Tab title="Ethereum wallet">
    ```json  theme={"system"}
    {
      "type": "user.linked_account",
      "user": {
        "id": "did:privy:cfbsvtqo2c22202mo08847jdux2z",
        "created_at": 1716153600,
        "linked_accounts": [],
        "mfa_methods": [],
        "has_accepted_terms": true,
        "is_guest": false
      },
      "account": {
        "type": "wallet",
        "address": "0x1234567890123456789012345678901234567890",
        "chain_type": "ethereum",
        "verified_at": 1716153600,
        "first_verified_at": 1716153600,
        "latest_verified_at": 1716153600,
        "wallet_client": "unknown",
        "wallet_client_type": "unknown",
        "connector_type": "unknown"
      }
    }
    ```
  </Tab>

  <Tab title="Google OAuth">
    ```json  theme={"system"}
    {
      "type": "user.linked_account",
      "user": {
        "id": "did:privy:cfbsvtqo2c22202mo08847jdux2z",
        "created_at": 1716153600,
        "linked_accounts": [],
        "mfa_methods": [],
        "has_accepted_terms": true,
        "is_guest": false
      },
      "account": {
        "type": "google_oauth",
        "subject": "google-123",
        "email": "test@gmail.com",
        "name": "Test User",
        "verified_at": 1716153600,
        "first_verified_at": 1716153600,
        "latest_verified_at": 1716153600
      }
    }
    ```
  </Tab>
</Tabs>

### `user.unlinked_account`

Triggered when a user unlinks an account from their Privy account.

<Expandable title="Example payload">
  ```json  theme={"system"}
  {
    "type": "user.unlinked_account",
    "user": {
      "id": "did:privy:cfbsvtqo2c22202mo08847jdux2z",
      "created_at": 1716153600,
      "linked_accounts": [],
      "mfa_methods": [],
      "has_accepted_terms": true,
      "is_guest": false
    },
    "account": {
      "type": "email",
      "address": "user@example.com",
      "verified_at": 1716153600,
      "first_verified_at": 1716153600,
      "latest_verified_at": 1716153600
    }
  }
  ```
</Expandable>

### `user.updated_account`

Triggered when a user updates an existing linked account.

<Expandable title="Example payload">
  ```json  theme={"system"}
  {
    "type": "user.updated_account",
    "user": {
      "id": "did:privy:cfbsvtqo2c22202mo08847jdux2z",
      "created_at": 1716153600,
      "linked_accounts": [],
      "mfa_methods": [],
      "has_accepted_terms": true,
      "is_guest": false
    },
    "account": {
      "type": "email",
      "address": "user@example.com",
      "verified_at": 1716153600,
      "first_verified_at": 1716153600,
      "latest_verified_at": 1716153600
    }
  }
  ```
</Expandable>

### `user.transferred_account`

Triggered when an account is transferred from one user to another (typically during user merging).

<Expandable title="Example payload">
  ```json  theme={"system"}
  {
    "type": "user.transferred_account",
    "fromUser": {
      "id": "did:privy:clu2wsin402h9h9kt6ae7dfuh"
    },
    "toUser": {
      "id": "did:privy:cfbsvtqo2c22202mo08847jdux2z",
      "created_at": 1716153600,
      "linked_accounts": [],
      "mfa_methods": [],
      "has_accepted_terms": true,
      "is_guest": false
    },
    "account": {
      "type": "email",
      "address": "user@example.com",
      "verified_at": 1716153600,
      "first_verified_at": 1716153600,
      "latest_verified_at": 1716153600
    },
    "deletedUser": true
  }
  ```
</Expandable>

### `user.wallet_created`

Triggered when a user creates a new embedded wallet.

<Expandable title="Example payload">
  ```json  theme={"system"}
  {
    "type": "user.wallet_created",
    "user": {
      "id": "did:privy:cfbsvtqo2c22202mo08847jdux2z",
      "created_at": 1716153600,
      "linked_accounts": [],
      "mfa_methods": [],
      "has_accepted_terms": true,
      "is_guest": false
    },
    "wallet": {
      "type": "wallet",
      "address": "0x123",
      "chain_type": "ethereum"
    }
  }
  ```
</Expandable>

## Transaction events

### `transaction.broadcasted`

Triggered when a transaction has been submitted to the network but has not yet been included in a block.

<Expandable title="Example payload">
  ```json  theme={"system"}
  {
    "type": "transaction.broadcasted",
    "wallet_id": "wallet-123",
    "transaction_id": "tx-123",
    "caip2": "eip155:1",
    "transaction_hash": "0x123"
  }
  ```
</Expandable>

### `transaction.confirmed`

Triggered when a transaction has been included in at least one block that has been confirmed on the network.

<Expandable title="Example payload">
  ```json  theme={"system"}
  {
    "type": "transaction.confirmed",
    "wallet_id": "wallet-123",
    "transaction_id": "tx-123",
    "caip2": "eip155:1",
    "transaction_hash": "0x123"
  }
  ```
</Expandable>

### `transaction.execution_reverted`

Triggered when a transaction's execution reverted (typically due to a smart contract error).

<Expandable title="Example payload">
  ```json  theme={"system"}
  {
    "type": "transaction.execution_reverted",
    "wallet_id": "r3mbxxfmzsuxxw3guxxha2xx",
    "transaction_id": "537e327d-7382-4e61-93e5-0241c72d0793",
    "caip2": "eip155:1",
    "transaction_hash": "0x123"
  }
  ```
</Expandable>

### `transaction.still_pending`

Triggered when a transaction is still pending after the expected confirmation time. Listen to this webhook to trigger [transaction speed-ups](/recipes/speeding-up-transactions).

<Expandable title="Example payload">
  ```json  theme={"system"}
  {
    "type": "transaction.still_pending",
    "wallet_id": "wallet-123",
    "transaction_id": "tx-123",
    "caip2": "eip155:1",
    "transaction_hash": "0x123",
    "transaction_request": {
      "from": "0x123",
      "to": "0x456",
      "value": "0x0",
      "data": "0x",
      "gas": "0x5208",
      "gasPrice": "0x4a817c800"
    }
  }
  ```
</Expandable>

<Info>
  Failures are uncommon overall, but more likely to occur on Base and Polygon than other chains
  (\<1% of transactions). To ensure transactions get confirmed, follow the guide on [transaction
  replacement](/recipes/speeding-up-transactions) to speed up stalled transactions.
</Info>

### `transaction.failed`

Triggered when a transaction has been pending for too long, signaling that it will not be included on-chain. This can happen when the gas fee is too low given the current activity on the blockchain.

<Expandable title="Example payload">
  ```json  theme={"system"}
  {
    "type": "transaction.failed",
    "wallet_id": "wallet-123",
    "transaction_id": "tx-123",
    "caip2": "eip155:1",
    "transaction_hash": "0x123"
  }
  ```
</Expandable>

### `transaction.replaced`

Triggered when a transaction was replaced (e.g., speed-up or cancel operation). This is only applicable to EVM chains.

<Expandable title="Example payload">
  ```json  theme={"system"}
  {
    "type": "transaction.replaced",
    "wallet_id": "wallet-123",
    "transaction_id": "tx-123",
    "caip2": "eip155:1",
    "transaction_hash": "0x123"
  }
  ```
</Expandable>

### `transaction.provider_error`

Triggered when a custodial wallet transaction request has been rejected by the custodian or encountered an error. This can happen when attempting to spend funds that haven't been fully screened by the custodian yet, or when a transaction does not meet the custodian's compliance requirements.

<Expandable title="Example payload">
  ```json  theme={"system"}
  {
    "type": "transaction.provider_error",
    "wallet_id": "wallet-123",
    "transaction_id": "tx-123",
    "caip2": "eip155:1",
    "transaction_hash": "0x123"
  }
  ```
</Expandable>

## Wallet and funds events

### `wallet.funds_deposited`

Triggered when funds are deposited into a wallet.

<Tip>
  Deposit webhooks are available for select chains on Tier 3 and Tier 2. To see which exact chains
  are supported, go to the [Dashboard webhooks page](https://dashboard.privy.io/apps?page=webhooks).
</Tip>

<Tabs>
  <Tab title="Native token">
    ```json  theme={"system"}
    {
      "type": "wallet.funds_deposited",
      "wallet_id": "wallet-123",
      "idempotency_key": "124",
      "caip2": "eip155:1",
      "asset": {
        "type": "native-token",
        "address": null
      },
      "amount": "1000000000000000000",
      "transaction_hash": "0x456",
      "sender": "0x789",
      "recipient": "0xabc",
      "block": {
        "number": 12346
      }
    }
    ```
  </Tab>

  <Tab title="ERC-20 token">
    ```json  theme={"system"}
    {
      "type": "wallet.funds_deposited",
      "wallet_id": "wallet-123",
      "idempotency_key": "123",
      "caip2": "eip155:1",
      "asset": {
        "type": "erc20",
        "address": "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
      },
      "amount": "10000000",
      "transaction_hash": "0x123",
      "sender": "0x456",
      "recipient": "0x789",
      "block": {
        "number": 12345
      }
    }
    ```
  </Tab>

  <Tab title="SPL token">
    ```json  theme={"system"}
    {
      "type": "wallet.funds_deposited",
      "wallet_id": "wallet-456",
      "idempotency_key": "125",
      "caip2": "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
      "asset": {
        "type": "spl",
        "mint": "So11111111111111111111111111111111111111112"
      },
      "amount": "1000000000",
      "transaction_hash": "transaction-hash",
      "sender": "sender-address",
      "recipient": "recipient-address",
      "block": {
        "number": 123456789
      }
    }
    ```
  </Tab>
</Tabs>

<ResponseField name="idempotency_key" type="string">
  An idempotent ID that uniquely identifies the deposit. In cases where the webhook triggers more
  than once, the idempotency\_key will match.
</ResponseField>

<ResponseField name="amount" type="string">
  Absolute amount of the transaction. Denominated based on the asset (e.g. wei for EVM, or lamports
  for SOL). Stringified to maintain precision from BigInt.
</ResponseField>

### `wallet.funds_withdrawn`

Triggered when funds are withdrawn from a wallet.

<Tabs>
  <Tab title="Native token">
    ```json  theme={"system"}
    {
      "type": "wallet.funds_withdrawn",
      "wallet_id": "wallet-123",
      "idempotency_key": "124",
      "caip2": "eip155:1",
      "asset": {
        "type": "native-token",
        "address": null
      },
      "amount": "1000000000000000000",
      "transaction_hash": "0x456",
      "sender": "0x789",
      "recipient": "0xabc",
      "block": {
        "number": 12346
      }
    }
    ```
  </Tab>

  <Tab title="ERC-20 token">
    ```json  theme={"system"}
    {
      "type": "wallet.funds_withdrawn",
      "wallet_id": "wallet-123",
      "idempotency_key": "123",
      "caip2": "eip155:1",
      "asset": {
        "type": "erc20",
        "address": "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
      },
      "amount": "10000000",
      "transaction_hash": "0x123",
      "sender": "0x456",
      "recipient": "0x789",
      "block": {
        "number": 12345
      }
    }
    ```
  </Tab>

  <Tab title="SPL token">
    ```json  theme={"system"}
    {
      "type": "wallet.funds_withdrawn",
      "wallet_id": "wallet-456",
      "idempotency_key": "125",
      "caip2": "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
      "asset": {
        "type": "spl",
        "mint": "So11111111111111111111111111111111111111112"
      },
      "amount": "1000000000",
      "transaction_hash": "transaction-hash",
      "sender": "sender-address",
      "recipient": "recipient-address",
      "block": {
        "number": 123456789
      }
    }
    ```
  </Tab>
</Tabs>

## Security events

### `wallet.private_key_export`

Triggered when a user exports their private key from an embedded wallet.

<Expandable title="Example payload">
  ```json  theme={"system"}
  {
    "type": "wallet.private_key_export",
    "user_id": "did:privy:cfbsvtqo2c22202mo08847jdux2z",
    "wallet_id": "wallet-123",
    "wallet_address": "0x123"
  }
  ```
</Expandable>

### `wallet.recovery_setup`

Triggered when a user sets up wallet recovery.

<Expandable title="Example payload">
  ```json  theme={"system"}
  {
    "type": "wallet.recovery_setup",
    "user_id": "did:privy:cfbsvtqo2c22202mo08847jdux2z",
    "wallet_id": "wallet-123",
    "wallet_address": "0x123",
    "method": "recovery_encryption_key"
  }
  ```
</Expandable>

### `wallet.recovered`

Triggered when a user successfully recovers their wallet.

<Expandable title="Example payload">
  ```json  theme={"system"}
  {
    "type": "wallet.recovered",
    "user_id": "did:privy:cfbsvtqo2c22202mo08847jdux2z",
    "wallet_id": "wallet-123",
    "wallet_address": "0x123"
  }
  ```
</Expandable>

## MFA events

### `mfa.enabled`

Triggered when multi-factor authentication is enabled for a user.

<Expandable title="Example payload">
  ```json  theme={"system"}
  {
    "type": "mfa.enabled",
    "user_id": "did:privy:cfbsvtqo2c22202mo08847jdux2z",
    "method": "totp"
  }
  ```
</Expandable>

<Tip>**MFA methods:** sms, totp (authenticator app), passkey</Tip>

### `mfa.disabled`

Triggered when multi-factor authentication is disabled for a user.

<Expandable title="Example payload">
  ```json  theme={"system"}
  {
    "type": "mfa.disabled",
    "user_id": "did:privy:cfbsvtqo2c22202mo08847jdux2z",
    "method": "sms"
  }
  ```
</Expandable>


# Sponsoring transactions on Ethereum
Source: https://docs.privy.io/wallets/gas-and-asset-management/gas/ethereum



Privy makes it easy to create **smart wallets** for your users to sponsor gas fees for transactions on Ethereum. This is done by using a [paymaster](https://www.alchemy.com/docs/wallets/resources/terms#paymaster) to pay for users' gas fees.

<Tabs>
  <Tab title="NodeJS">
    This guide explains how to use smart wallets from your server to sponsor gas fees for transactions on Ethereum. Using wallets as smart wallets gives your application all the benefits of account abstraction, including gas sponsorship, with the flexibility of wallets.

    In this setup, an embedded wallet created on your wallet is the signer for the smart wallet. Note that the wallet's address is not the smart wallet address in this case - it simply authorizes actions taken by the smart wallet. All transactions and assets are tied to the smart wallet.

    <Note>
      This guide uses Kernel as the smart wallet contract provider, but your implementation can use any
      smart wallet provider.
    </Note>

    ### 0: Install necessary dependencies

    This guide uses Privy's server SDK to create the wallet, Pimlico's `permissionless` package, and `viem`. Install these packages with the following command:

    ```sh  theme={"system"}
    npm i @privy-io/node permissionless viem
    ```

    ### 1: Create a wallet

    Create a `privy` client and use the `create` method from [Privy's SDK](/wallets/wallets/create/create-a-wallet) to create a wallet. If you already have a wallet you wish to use, you can skip this step.

    ```ts  theme={"system"}
    import {PrivyClient} from '@privy-io/node';

    // Initialize your Privy client
    const privy = new PrivyClient({
      appId: 'your privy app id',
      appSecret: 'your privy app secret'
    });

    // Create a wallet
    const {
      id: walletId,
      address,
      chain_type: chainType
    } = await privy.wallets().create({chain_type: 'ethereum'});
    ```

    ### 2: Get a `viem` `LocalAccount` for the wallet

    Create a viem `LocalAccount` object representing the wallet. Use the `createViemAccount` method from [Privy's SDK](/wallets/using-wallets/ethereum/web3-integrations#node-js).

    ```tsx  theme={"system"}
    import {createViemAccount} from '@privy-io/node/viem';

    // Create a viem account instance for a wallet
    const serverWalletAccount = await createViemAccount(privy, {
      walletId,
      address
    });
    ```

    <Tip>
      If your wallet requires an [authorization context](/controls/authorization-keys/using-owners/sign/signing-on-the-server),
      you should pass it to the `createViemAccount` method like so:

      ```tsx  theme={"system"}
      const serverWalletAccount = await createViemAccount(privy, {
        walletId,
        address,
        authorizationContext: {
          authorization_private_keys: ['your authorization private key']
        }
      });
      ```
    </Tip>

    ### 3: Create a smart wallet

    Use [`permissionless`](https://docs.pimlico.io/references/permissionless/) to create a smart wallet with the wallet as the signer. Learn more about creating smart wallet accounts in the `permissionless` [docs](https://docs.pimlico.io/references/permissionless/how-to/accounts/use-kernel-account).

    ```tsx  theme={"system"}
    import {toKernelSmartAccount} from 'permissionless/accounts';
    import {entryPoint07Address} from 'viem/account-abstraction';

    const kernelSmartAccount = await toKernelSmartAccount({
      client: publicClient,
      entryPoint: {
        address: entryPoint07Address,
        version: '0.7'
      },
      owner: serverWalletAccount
    });
    ```

    ### 4: Create a client for the smart wallet

    You can use this smart wallet client to request signatures and transactions from the smart wallet. Learn more about making transactions on the client in the `permissonless` [docs](https://docs.pimlico.io/references/permissionless/how-to/accounts/use-kernel-account).

    ```tsx  theme={"system"}
    import {createSmartAccountClient, walletClientToCustomSigner} from 'permissionless';
    import {createPublicClient, http} from 'viem';

    const bundlerUrl = 'your bundler URL';
    const paymasterUrl = 'your paymaster URL';

    // Create a viem public client for RPC calls
    const publicClient = createPublicClient({
      chain: sepolia, // Replace this with the chain of your choice
      transport: http() // Optionally include an RPC override
    });

    // Create the paymaster client to sponsor gas fees on transactions
    const paymasterClient = createPimlicoClient({
      transport: http(paymasterUrl),
      entryPoint: kernelSmartAccount.entryPoint
    });

    // Create the SmartAccountClient for requesting signatures and transactions (RPCs)
    const smartAccountClient = createSmartAccountClient({
      account: kernelSmartAccount,
      chain: sepolia,
      paymaster: paymasterClient,
      bundlerTransport: http(bundlerUrl),
      userOperation: {
        estimateFeesPerGas: async () => (await paymasterClient.getUserOperationGasPrice()).fast
      }
    });
    ```
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    This guide explains how to use smart wallets from your server to sponsor gas fees for transactions on Ethereum. Using wallets as smart wallets gives your application all the benefits of account abstraction, including gas sponsorship, with the flexibility of wallets.

    In this setup, an embedded wallet created on your wallet is the signer for the smart wallet. Note that the wallet's address is not the smart wallet address in this case - it simply authorizes actions taken by the smart wallet. All transactions and assets are tied to the smart wallet.

    <Note>
      This guide uses Kernel as the smart wallet contract provider, but your implementation can use any
      smart wallet provider.
    </Note>

    ### 0: Install necessary dependencies

    This guide uses Privy's server SDK to create the wallet, Pimlico's `permissionless` package, and `viem`. Install these packages with the following command:

    ```sh  theme={"system"}
    npm i @privy-io/server-auth permissionless viem
    ```

    ### 1: Create a wallet

    Create a `privy` client and use the `create` method from [Privy's SDK](/wallets/wallets/create/create-a-wallet) to create a wallet. If you already have a wallet you wish to use, you can skip this step.

    ```ts  theme={"system"}
    import {PrivyClient} from '@privy-io/server-auth';

    // Initialize your Privy client
    const privy = new PrivyClient('your privy app id', 'your privy app secret');

    // Create a wallet
    const {
      id: walletId,
      address,
      chainType
    } = await privy.walletApi.createWallet({chainType: 'ethereum'});
    ```

    ### 2: Get a `viem` `LocalAccount` for the wallet

    Create a viem `LocalAccount` object representing the wallet. Use the `createViemAccount` method from [Privy's SDK](/wallets/using-wallets/ethereum/web3-integrations#node-js).

    ```tsx  theme={"system"}
    import {createViemAccount} from '@privy-io/server-auth/viem';

    // Create a viem account instance for a wallet
    const serverWalletAccount = await createViemAccount({
      walletId,
      address,
      privy
    });
    ```

    ### 3: Create a smart wallet

    Use [`permissionless`](https://docs.pimlico.io/references/permissionless/) to create a smart wallet with the wallet as the signer. Learn more about creating smart wallet accounts in the `permissionless` [docs](https://docs.pimlico.io/references/permissionless/how-to/accounts/use-kernel-account).

    ```tsx  theme={"system"}
    import {toKernelSmartAccount} from 'permissionless/accounts';
    import {entryPoint07Address} from 'viem/account-abstraction';

    const kernelSmartAccount = await toKernelSmartAccount({
      client: publicClient,
      entryPoint: {
        address: entryPoint07Address,
        version: '0.7'
      },
      owner: serverWalletAccount
    });
    ```

    ### 4: Create a client for the smart wallet

    You can use this smart wallet client to request signatures and transactions from the smart wallet. Learn more about making transactions on the client in the `permissonless` [docs](https://docs.pimlico.io/references/permissionless/how-to/accounts/use-kernel-account).

    ```tsx  theme={"system"}
    import {createSmartAccountClient, walletClientToCustomSigner} from 'permissionless';
    import {createPublicClient, http} from 'viem';

    const bundlerUrl = 'your bundler URL';
    const paymasterUrl = 'your paymaster URL';

    // Create a viem public client for RPC calls
    const publicClient = createPublicClient({
      chain: sepolia, // Replace this with the chain of your choice
      transport: http() // Optionally include an RPC override
    });

    // Create the paymaster client to sponsor gas fees on transactions
    const paymasterClient = createPimlicoClient({
      transport: http(paymasterUrl),
      entryPoint: kernelSmartAccount.entryPoint
    });

    // Create the SmartAccountClient for requesting signatures and transactions (RPCs)
    const smartAccountClient = createSmartAccountClient({
      account: kernelSmartAccount,
      chain: sepolia,
      paymaster: paymasterClient,
      bundlerTransport: http(bundlerUrl),
      userOperation: {
        estimateFeesPerGas: async () => (await paymasterClient.getUserOperationGasPrice()).fast
      }
    });
    ```
  </Tab>

  <Tab title="React">
    ### Gas sponsorship with paymasters

    With smart wallets, your app can pay for gas fees simply by registering a paymaster URL in the Privy Dashboard.

    Follow this guide to [setup smart wallets](/wallets/using-wallets/evm-smart-wallets/overview).

    Privy will automatically route gas payments from your registered paymaster instead of your users' wallets, allowing your users to transact on-chain *instantly* –– even if they don't have a balance in their smart wallet.
  </Tab>

  <Tab title="React Native">
    ### Gas sponsorship with paymasters

    With smart wallets, your app can pay for gas fees simply by registering a paymaster URL in the Privy Dashboard.

    Follow this guide to [setup smart wallets](/wallets/using-wallets/evm-smart-wallets/overview).

    Privy will automatically route gas payments from your registered paymaster instead of your users' wallets, allowing your users to transact on-chain *instantly* –– even if they don't have a balance in their smart wallet.
  </Tab>
</Tabs>


# Overview
Source: https://docs.privy.io/wallets/gas-and-asset-management/gas/overview



Privy's powerful **gas sponsorship** engine allows you to easily sponsor transaction fees across all of your wallets.
This feature allows you to seamlessly abstract away gas fees for your users, treasury or application,
creating a frictionless experience without the complexity of managing gas yourself.

<Info>
  Looking to get started quickly? Check out our [setup
  guide](/wallets/gas-and-asset-management/gas/setup).
</Info>

## Supported networks

<AccordionGroup>
  <Accordion title="Ethereum networks">
    **Mainnets:**

    * Ethereum
    * Base
    * Optimism
    * Polygon
    * Arbitrum
    * BNB Smart Chain
    * Unichain
    * Gnosis
    * Plasma
    * Berachain
    * Warden

    **Testnets:**

    * Sepolia
    * Base Sepolia
    * OP Sepolia
    * Polygon Amoy
    * Arbitrum Sepolia
    * Unichain Sepolia
    * MegaETH Testnet
  </Accordion>

  <Accordion title="Solana networks">
    **Mainnets:**

    * Solana

    **Testnets:**

    * Solana Devnet
  </Accordion>
</AccordionGroup>

Want support for more networks? [Reach out to us!](mailto:sales@privy.io)

## How it works

Privy provides gas sponsorship through different mechanisms optimized for each chain:

### Ethereum and EVM chains

Privy leverages [EIP-7702](https://eip7702.io/) with **paymasters** to sponsor gas fees:

* Your users receive embedded wallets that are upgraded to [Kernel smart contracts](https://github.com/zerodevapp/kernel)
* Paymasters (managed by Privy) cover gas costs automatically
* Users can transact immediately without needing to hold ETH or native tokens
* All sponsorship happens seamlessly in the background

<Info>
  **Native gas sponsorship vs smart wallets**

  Our [smart contract wallets offering](/wallets/using-wallets/evm-smart-wallets/overview) allows for easy setup of 4337-compatible contract
  accounts, where the embedded wallet is the signer for a smart contract.

  Our native gas sponsorship allows you to:

  * sponsor gas for user wallets without creating a separate contract account
  * easily get setup without having to work with extra bundler/paymaster providers
  * offers an easier developer experience - just pass in the `sponsor` param!

  *If you already have users with funds in their smart contract wallets,
  we recommend continuing to use smart contract wallets.*
</Info>

### Solana and SVM chains

Privy uses a **fee payer wallet** system to cover transaction costs:

* Privy manages a fee payer wallet funded with SOL
* Users send transactions to the Privy API.
* The fee payer wallet will update the transaction's feePayer address and latest blockhash
* The fee payer will also prefund any account that needs to pay rent
* Users transact without needing to hold SOL

## Calculating gas fees

Privy automatically handles gas fee calculation and optimization to deliver the best experience while maintaining cost efficiency.
The platform balances transaction speed with cost optimization across our entire customer base, and queries for the best prices.

Gas sponsorship includes the actual network gas costs plus a convenience fee for the managed service. Privy maintains discretion over gas price strategies to ensure optimal performance and reliability.

<Info>
  Looking for more granular control over gas pricing? Consider exploring [custom
  setup](/wallets/gas-and-asset-management/gas/ethereum) options that provide additional
  configuration flexibility.
</Info>


# Setting up sponsorship
Source: https://docs.privy.io/wallets/gas-and-asset-management/gas/setup



Setting up native gas sponsorship allows your app to pay for all transaction fees, creating a
frictionless experience across all networks.

## Getting started

<Steps>
  <Step title="Enable gas sponsorship in the dashboard">
    Go to the gas sponsorship tab in the [Privy
    Dashboard](https://dashboard.privy.io/apps?page=gas_sponsorship), and enable gas sponsorship for
    your application.

        <img src="https://mintcdn.com/privy-c2af3412/JsgMIYodAfYOjJAO/images/gas-sponsorship.png?fit=max&auto=format&n=JsgMIYodAfYOjJAO&q=85&s=67192ab8282dd9d4f560acc5e8650126" alt="images/gas-sponsorship.png" data-og-width="1843" width="1843" data-og-height="1317" height="1317" data-path="images/gas-sponsorship.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/JsgMIYodAfYOjJAO/images/gas-sponsorship.png?w=280&fit=max&auto=format&n=JsgMIYodAfYOjJAO&q=85&s=caf0cb618c798e2fd0d0359d106e5567 280w, https://mintcdn.com/privy-c2af3412/JsgMIYodAfYOjJAO/images/gas-sponsorship.png?w=560&fit=max&auto=format&n=JsgMIYodAfYOjJAO&q=85&s=ed9519a2ad9468ebca11cdbc8559e84d 560w, https://mintcdn.com/privy-c2af3412/JsgMIYodAfYOjJAO/images/gas-sponsorship.png?w=840&fit=max&auto=format&n=JsgMIYodAfYOjJAO&q=85&s=ed7dd6cd88e7c3280042e644761a0e0c 840w, https://mintcdn.com/privy-c2af3412/JsgMIYodAfYOjJAO/images/gas-sponsorship.png?w=1100&fit=max&auto=format&n=JsgMIYodAfYOjJAO&q=85&s=3c7bb3b42675e4a489cc449f829eb124 1100w, https://mintcdn.com/privy-c2af3412/JsgMIYodAfYOjJAO/images/gas-sponsorship.png?w=1650&fit=max&auto=format&n=JsgMIYodAfYOjJAO&q=85&s=1d8354422d6ef866b9592a619119ef64 1650w, https://mintcdn.com/privy-c2af3412/JsgMIYodAfYOjJAO/images/gas-sponsorship.png?w=2500&fit=max&auto=format&n=JsgMIYodAfYOjJAO&q=85&s=385e7660632af3fd6e7f74f25ab5361b 2500w" />
  </Step>

  <Step title="Configure chains">
    Select which chains you want to enable sponsorship for. Sponsored requests
    may only come from the chains that you have configured. Want support for more networks? [Reach out to us!](mailto:sales@privy.io)
  </Step>

  <Step title="Send transaction requests">
    <Info>
      Apps **must** use [TEE execution](/security/wallet-infrastructure/architecture) in order to use our native gas sponsorship feature. Learn how to migrate [here](/recipes/tee-wallet-migration-guide)!
    </Info>

    <Tabs>
      <Tab title="Ethereum (React)">
        With the React SDK, use the `useSendTransaction` hook with `sponsor: true`:

        ```tsx highlight={12} theme={"system"}
        import {useSendTransaction, useWallets} from '@privy-io/react-auth';

        const {sendTransaction} = useSendTransaction();
        const {wallets} = useWallets();

        sendTransaction(
          {
            to: '0xE3070d3e4309afA3bC9a6b057685743CF42da77C',
            value: 100000
          },
          {
            sponsor: true // Enable gas sponsorship
          }
        );
        ```
      </Tab>

      <Tab title="Solana (React)">
        With the React SDK, use the `useSignAndSendTransaction` hook with `sponsor: true`:

        ```tsx highlight={15} theme={"system"}
        import {useSignAndSendTransaction, useWallets} from '@privy-io/react-auth/solana';

        const {signAndSendTransaction} = useSignAndSendTransaction();
        const {wallets} = useWallets();

        const selectedWallet = wallets[0];

        // Create your transaction (example using @solana/kit)
        const transaction = new Uint8Array([/* your encoded transaction */]);

        const result = await signAndSendTransaction({
          transaction: transaction,
          wallet: selectedWallet,
          options: {
            sponsor: true // Enable gas sponsorship
          }
        });

        console.log('Transaction sent with signature:', result.signature);
        ```

        <Info>
          **Allow transactions from the client**

          To sponsor transactions from your client-side application, enable this setting in your gas sponsorship dashboard configuration. When disabled, transactions can only be sponsored from your server.
        </Info>
      </Tab>

      <Tab title="Ethereum (REST API)">
        Gas sponsored transactions share the same path and interfaces as our other RPC requests. Learn
        more about sending transactions [here.](/api-reference/wallets/ethereum/eth-send-transaction)
        You must also include the `sponsor: true` parameter for transactions to be sponsored.

        ```bash highlight={9} theme={"system"}
        $ curl --request POST https://api.privy.io/v1/wallets/<wallet_id>/rpc \
          -u "<your-privy-app-id>:<your-privy-app-secret>" \
          -H "privy-app-id: <your-privy-app-id>" \
          -H "privy-authorization-signature: <authorization-signature-for-request>" \
          -H 'Content-Type: application/json' \
          -d '{
              "method": "eth_sendTransaction",
              "caip2": "eip155:1",
              "sponsor": true
              "params": {
                  "transaction": {
                      "to": "0xE3070d3e4309afA3bC9a6b057685743CF42da77C",
                      "value": "0x2386F26FC10000",
                  },
              },
          }'
        ```

        <Info>
          To sponsor transactions that are initiated from a client SDK, you may [relay the transaction](/controls/authorization-keys/keys/create/user/request) from your server.
        </Info>
      </Tab>

      <Tab title="Ethereum (Rust SDK)">
        With the Rust SDK, use the `ethereum_send_transaction` method with `sponsor: true`:

        ```rust  theme={"system"}
        use privy_rs::{PrivyClient, generated::types::*};

        let client = PrivyClient::new(app_id, app_secret)?;

        // Create a sponsored ETH transfer
        let request = EthereumSendTransactionRpcInput {
            method: "eth_sendTransaction".to_string(),
            caip2: "eip155:1".to_string(), // Ethereum mainnet
            sponsor: Some(true), // Enable gas sponsorship
            params: EthereumSendTransactionRpcInputParams {
                transaction: EthereumSendTransactionRpcInputParamsTransaction {
                    to: Some("0xE3070d3e4309afA3bC9a6b057685743CF42da77C".to_string()),
                    value: Some("0x2386F26FC10000".to_string()), // 0.01 ETH
                    gas: None, // Let Privy estimate
                    gas_price: None, // Let Privy set optimal price
                    data: None,
                    nonce: None,
                }
            }
        };

        let response = client
            .wallets()
            .ethereum_send_transaction("wallet-id", request, &authorization_context)
            .await?;

        println!("Sponsored transaction hash: {}", response.data.transaction_hash);
        ```

        <Info>
          To sponsor transactions that are initiated from a client SDK, you may [relay the transaction](/controls/authorization-keys/keys/create/user/request) from your server.
        </Info>

        ### Parameters and Returns

        See the Rust SDK documentation for detailed parameter and return types, including embedded examples:

        * [WalletsClient::ethereum\_send\_transaction](https://docs.rs/privy-rs/latest/privy_rs/subclients/struct.WalletsClient.html#method.ethereum_send_transaction)
        * [EthereumSendTransactionRpcInput](https://docs.rs/privy-rs/latest/privy_rs/generated/types/struct.EthereumSendTransactionRpcInput.html)

        For REST API details, see the [API reference](/api-reference/wallets/ethereum/eth-send-transaction).
      </Tab>

      <Tab title="Solana (REST API)">
        Gas sponsored transactions share the same path and interfaces as our other RPC requests. Learn
        more about sending transactions [here.](/api-reference/wallets/solana/sign-and-send-transaction)
        You must also include the `sponsor: true` parameter for transactions to be sponsored.

        ```bash highlight={9} theme={"system"}
        $ curl --request POST https://api.privy.io/v1/wallets/<wallet_id>/rpc \
          -u "<your-privy-app-id>:<your-privy-app-secret>" \
          -H "privy-app-id: <your-privy-app-id>" \
          -H "privy-authorization-signature: <authorization-signature-for-request>" \
          -H 'Content-Type: application/json' \
          -d '{
              "method": "signAndSendTransaction",
              "caip2": "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
              "sponsor": true
              "params": {
                  "transaction": "insert-base-64-encoded-serialized-transaction",
                  "encoding": "base64"
              }
          }'
        ```

        <Info>
          To sponsor transactions that are initiated from a client SDK, you may [relay the transaction](/controls/authorization-keys/keys/create/user/request) from your server.
        </Info>
      </Tab>

      <Tab title="Solana (Rust SDK)">
        With the Rust SDK, use the `solana_sign_and_send_transaction` method with `sponsor: true`:

        ```rust  theme={"system"}
        use privy_rs::{PrivyClient, generated::types::*};

        let client = PrivyClient::new(app_id, app_secret)?;

        // Prepare your transaction (this example assumes you have a serialized transaction)
        let serialized_transaction = "base64-encoded-transaction-here";

        let request = SolanaSignAndSendTransactionRpcInput {
            method: "signAndSendTransaction".to_string(),
            caip2: "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1".to_string(), // Solana mainnet
            sponsor: Some(true), // Enable gas sponsorship
            params: SolanaSignAndSendTransactionRpcInputParams {
                transaction: serialized_transaction.to_string(),
                encoding: Some("base64".to_string()),
                send_options: None,
            }
        };

        let response = client
            .wallets()
            .solana_sign_and_send_transaction("wallet-id", request, &authorization_context)
            .await?;

        println!("Sponsored transaction signature: {}", response.signature);
        ```

        <Info>
          To sponsor transactions that are initiated from a client SDK, you may [relay the transaction](/controls/authorization-keys/keys/create/user/request) from your server.
        </Info>

        ### Parameters and Returns

        See the Rust SDK documentation for detailed parameter and return types, including embedded examples:

        * [WalletsClient::solana\_sign\_and\_send\_transaction](https://docs.rs/privy-rs/latest/privy_rs/subclients/struct.WalletsClient.html#method.solana_sign_and_send_transaction)
        * [SolanaSignAndSendTransactionRpcInput](https://docs.rs/privy-rs/latest/privy_rs/generated/types/struct.SolanaSignAndSendTransactionRpcInput.html)

        For REST API details, see the [API reference](/api-reference/wallets/solana/sign-and-send-transaction).
      </Tab>
    </Tabs>
  </Step>
</Steps>

<Warning>
  Certain flows that require on-chain ECDSA signature verification such as Permit2 are not supported
  by EIP-7702 upgraded wallets. We recommend using an approval based flow where possible.
</Warning>

## Security recommendations

When implementing gas sponsorship, it's critical to protect your application from abuse to prevent drainage of your gas sponsorship balance.
Privy natively offers controls to limit total spend and set logic for when to sponsor conditionally.

### Rate limiting

To protect against abuse, we recommend:

* **Implement strict rate limits**: Set per-user and per-wallet transaction limits appropriate for your use case
* **Monitor spending patterns**: Track unusual activity and implement automatic circuit breakers for suspicious behavior
* **Set maximum sponsorship amounts**: Configure spending caps to limit potential losses from exploitation
* **Send transactions from your backend**: Privy aggressively rate limits transactions sent from the client. In order to get more granular control
  over limiting, you can [relay the transaction](/controls/authorization-keys/keys/create/user/request) from your server.

<Note>
  For a detailed implementation guide on custom rate limiting for spending controls, see our [custom
  gas sponsorship rate limits recipe](/recipes/gas-sponsorship-rate-limits).
</Note>

### Example threat models

**Solana Rent Refund Vulnerability**: On Solana, when Associated Token Accounts (ATAs) are created
during sponsored transactions, the rent deposit refund upon account closure goes to the account
owner, not the fee payer. This creates a potential exploitation vector where users can profit from
the rent refunds while your application pays the creation fees. For example, a user swapping USDC
to SOL could gain \~\$0.40 per transaction from the rent refund, effectively draining your gas
sponsorship funds.

Some APIs (like Jupiter) will automatically include the CloseAccount instruction for transfers that will close
the ATA and refund the rent to the user. If your application plans to reuse a limited set of tokens, you should
strip the CloseAccount instruction from transactions to prevent users from profiting off the rent refunds.

Here's an example of how to remove the CloseAccount instruction from a Solana transaction:

```typescript  theme={"system"}
import {Transaction, TransactionInstruction} from '@solana/web3.js';

function stripCloseAccountInstruction(transaction) {
  // Filter out any CloseAccount instructions from the transaction
  const filteredInstructions = transaction.instructions.filter((instruction) => {
    // CloseAccount instruction has discriminator 0x0a (10 in decimal)
    const discriminator = instruction.data[0];
    return discriminator !== 0x0a;
  });

  // Create a new transaction with the filtered instructions
  const newTransaction = new Transaction();
  for (const instruction of filteredInstructions) {
    newTransaction.add(instruction);
  }

  // Copy signers from original transaction
  newTransaction.feePayer = transaction.feePayer;
  newTransaction.recentBlockhash = transaction.recentBlockhash;

  return newTransaction;
}
```

This approach keeps the ATAs open for future transactions, reducing creation costs and eliminating the rent refund exploit.


# Sponsoring transactions on Solana
Source: https://docs.privy.io/wallets/gas-and-asset-management/gas/solana



With embedded wallets, your app can sponsor gas fees for transactions on Solana, allowing users to transact without a SOL balance.
This is done by configuring the `feePayer` property of the sponsored transaction to be a fee payer wallet that your app manages to pay users' gas fees.

## Overview

Sponsoring transactions on Solana involves the following steps:

<Steps>
  <Step title="Set up a fee payer wallet">
    Create a fee payer wallet in your backend to pay for users' gas fees.
  </Step>

  <Step title="Prepare and sign the transaction">
    Prepare a transaction with a custom fee payer, sign it with the user's wallet, and send it to your
    backend.
  </Step>

  <Step title="Verify and complete the transaction">
    Verify the transaction, sign it with the fee payer wallet, and broadcast it
    to the network.
  </Step>
</Steps>

<Note>
  To prepare transactions with a fee payer, we recommend using the
  [@solana/web3.js](https://solana-foundation.github.io/solana-web3.js/) library.
</Note>

## Setting up a fee payer wallet

To start, create a fee payer wallet in your backend to sponsor transactions sent by users. You can either:

1. Generate a new keypair directly:

```javascript  theme={"system"}
import {Keypair} from '@solana/web3.js';
import bs58 from 'bs58';

// Generate a new keypair
const feePayerWallet = new Keypair();
const feePayerAddress = feePayerWallet.publicKey.toBase58();
const feePayerPrivateKey = bs58.encode(feePayerWallet.secretKey);

// Make sure to store the private key securely; it should never leave your server
console.log('Fee Payer Address:', feePayerAddress);
console.log('Fee Payer Private Key:', feePayerPrivateKey);
```

2. Or [create a Solana wallet](/wallets/wallets/create/create-a-wallet) to act as your fee payer for better security and key management.

Ensure you fund this wallet with SOL to pay for transaction fees.

## Implementing Sponsored Transactions

<Tabs>
  <Tab title="React">
    With the React SDK, follow these steps to prepare and send a sponsored transaction:

    ```javascript  theme={"system"}
    import {useWallets} from '@privy-io/react-auth/solana';
    import {
      TransactionMessage,
      PublicKey,
      VersionedTransaction,
      Connection
    } from '@solana/web3.js';

    // This function prepares and signs a sponsored transaction
    async function prepareSponsoredTransaction(instructions, feePayerAddress) {
      // Find the user's embedded wallet
      const { wallets } = useWallets();
      const embeddedWallet = wallets.find(wallet => wallet.standardWallet.name === 'Privy');

      if (!embeddedWallet) {
        throw new Error('No embedded wallet found');
      }

      // Create a connection to Solana
      const connection = new Connection('https://api.mainnet-beta.solana.com');
      const { blockhash } = await connection.getLatestBlockhash();

      // Create the transaction message with fee payer set to the backend wallet
      const message = new TransactionMessage({
        payerKey: new PublicKey(feePayerAddress),
        recentBlockhash: blockhash,
        instructions
      }).compileToV0Message();

      // Create transaction
      const transaction = new VersionedTransaction(message);

      // Serialize message for signing
      const serializedMessage = Buffer.from(transaction.message.serialize()).toString('base64');

      // Get provider and sign
      const {signature: serializedUserSignature} = await embeddedWallet.signMessage({message: serializedMessage})

      // Add user signature to transaction
      const userSignature = Buffer.from(serializedUserSignature, 'base64');
      transaction.addSignature(new PublicKey(embeddedWallet.address), userSignature);

      // Serialize the transaction to send to backend
      const serializedTransaction = Buffer.from(transaction.serialize()).toString('base64');

      // Send to your backend
      const response = await fetch('your-backend-endpoint', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ transaction: serializedTransaction })
      });

      const { transactionHash } = await response.json();
      return transactionHash;
    }
    ```
  </Tab>

  <Tab title="React Native">
    With the React Native SDK, follow these steps to prepare and send a sponsored transaction:

    ```javascript  theme={"system"}
    import {useEmbeddedSolanaWallet} from '@privy-io/expo';
    import {
      TransactionMessage,
      PublicKey,
      VersionedTransaction,
      Connection
    } from '@solana/web3.js';

    // This function prepares and signs a sponsored transaction
    async function prepareSponsoredTransaction(instructions, feePayerAddress) {
      // Get the embedded wallet
      const wallet = useEmbeddedSolanaWallet();
      const embeddedWallet = wallet.wallets[0];

      if (!embeddedWallet) {
        throw new Error('No embedded wallet found');
      }

      // Create a connection to Solana
      const connection = new Connection('https://api.mainnet-beta.solana.com');
      const { blockhash } = await connection.getLatestBlockhash();

      // Create the transaction message with fee payer set to the backend wallet
      const message = new TransactionMessage({
        payerKey: new PublicKey(feePayerAddress),
        recentBlockhash: blockhash,
        instructions
      }).compileToV0Message();

      // Create transaction
      const transaction = new VersionedTransaction(message);

      // Serialize message for signing
      const serializedMessage = Buffer.from(transaction.message.serialize()).toString('base64');

      // Get provider and sign
      const provider = await embeddedWallet.getProvider();
      const { signature: serializedUserSignature } = await provider.request({
        method: 'signMessage',
        params: {
          message: serializedMessage
        }
      });

      // Add user signature to transaction
      const userSignature = Buffer.from(serializedUserSignature, 'base64');
      transaction.addSignature(new PublicKey(embeddedWallet.address), userSignature);

      // Serialize the transaction to send to backend
      const serializedTransaction = Buffer.from(transaction.serialize()).toString('base64');

      // Send to your backend
      const response = await fetch('your-backend-endpoint', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ transaction: serializedTransaction })
      });

      const { transactionHash } = await response.json();
      return transactionHash;
    }
    ```
  </Tab>

  <Tab title="Swift">
    With the Swift SDK, follow these steps to prepare and send a sponsored transaction:

    ```swift  theme={"system"}
    import Foundation
    import SolanaSwift
    import PrivySDK

    // This function prepares and signs a sponsored transaction
    func prepareSponsoredTransaction(
        wallet: EmbeddedSolanaWallet,
        instructions: [TransactionInstruction],
        feePayerAddress: String,
        rpcUrl: String
    ) async throws -> String {
        // Create a Solana RPC client
        let solana = JSONRPCAPIClient(endpoint: URL(string: rpcUrl)!)

        // Get the latest blockhash
        let latestBlockhash = try await solana.getLatestBlockhash()

        // Create public keys
        let walletPK = try PublicKey(string: wallet.address)
        let feePayerPK = try PublicKey(string: feePayerAddress)

        // Create transaction
        var tx = Transaction()

        // Add instructions
        for instruction in instructions {
            tx.instructions.append(instruction)
        }

        // Set the fee payer and blockhash
        tx.recentBlockhash = latestBlockhash
        tx.feePayer = feePayerPK

        // Serialize the transaction message to base64
        let message = try tx.compileMessage().serialize().base64EncodedString()

        // Get the provider for wallet
        let provider = wallet.provider

        // Sign using the embedded wallet
        let userSignature = try await provider.signMessage(message: message)

        // Add the signature to the transaction
        try tx.addSignature(signature: Data(base64Encoded: userSignature)!, publicKey: walletPK)

        // Serialize the transaction for transmission to backend
        let serializedTransaction = tx.serialize().base64EncodedString()

        // Send to backend
        let url = URL(string: "your-backend-endpoint")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")

        let requestBody: [String: Any] = ["transaction": serializedTransaction]
        request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)

        let (data, response) = try await URLSession.shared.data(for: request)

        guard let httpResponse = response as? HTTPURLResponse,
              (200...299).contains(httpResponse.statusCode) else {
            throw NSError(domain: "HTTP Error", code: (response as? HTTPURLResponse)?.statusCode ?? 0)
        }

        let jsonResponse = try JSONSerialization.jsonObject(with: data) as? [String: Any]
        guard let transactionHash = jsonResponse?["transactionHash"] as? String else {
            throw NSError(domain: "Response Error", code: 0, userInfo: [NSLocalizedDescriptionKey: "Invalid response"])
        }

        return transactionHash
    }
    ```
  </Tab>

  <Tab title="Android">
    With the Android SDK, follow these steps to prepare and send a sponsored transaction:

    ```kotlin  theme={"system"}
    import android.util.Base64
    import kotlinx.coroutines.Dispatchers
    import kotlinx.coroutines.withContext
    import org.json.JSONObject
    import java.net.HttpURLConnection
    import java.net.URL

    // This function prepares and signs a sponsored transaction
    suspend fun prepareSponsoredTransaction(
        solanaWallet: EmbeddedSolanaWallet,
        instructions: List<Instruction>,
        feePayerAddress: String,
        rpcUrl: String
    ): Result<String> {
        return try {
            // Create connection to Solana
            val connection = Connection(rpcUrl)

            // Get recent blockhash
            val recentBlockhash = connection.getLatestBlockhash()

            // Create wallet public key
            val walletPublicKey = PublicKey(solanaWallet.address)
            val feePayerPublicKey = PublicKey(feePayerAddress)

            // Build transaction
            val transaction = Transaction()

            // Add instructions to transaction
            instructions.forEach { instruction ->
                transaction.add(instruction)
            }

            // Set blockhash and fee payer
            transaction.recentBlockhash = recentBlockhash
            transaction.feePayer = feePayerPublicKey

            // Serialize transaction message to base64
            val serializedMessage = transaction.serializeMessage().base64()

            // Sign the message with user's wallet
            val signatureResult = solanaWallet.provider.signMessage(serializedMessage)

            when (signatureResult) {
                is Result.Success -> {
                    // Get the signature
                    val userSignature = signatureResult.data

                    // Add signature to transaction
                    transaction.addSignature(
                        walletPublicKey,
                        Base64.decode(userSignature, Base64.DEFAULT)
                    )

                    // Serialize transaction for sending to backend
                    val serializedTransaction = Base64.encodeToString(
                        transaction.serialize(),
                        Base64.NO_WRAP
                    )

                    // Send to backend
                    val url = URL("your-backend-endpoint")
                    val connection = url.openConnection() as HttpURLConnection
                    connection.requestMethod = "POST"
                    connection.setRequestProperty("Content-Type", "application/json")
                    connection.doOutput = true

                    // Create request body
                    val requestBody = JSONObject().apply {
                        put("transaction", serializedTransaction)
                    }.toString()

                    // Send request
                    connection.outputStream.use { os ->
                        os.write(requestBody.toByteArray())
                    }

                    // Read response
                    val responseCode = connection.responseCode
                    if (responseCode in 200..299) {
                        val response = connection.inputStream.bufferedReader().use { it.readText() }
                        val jsonResponse = JSONObject(response)
                        val transactionHash = jsonResponse.getString("transactionHash")
                        Result.Success(transactionHash)
                    } else {
                        val error = connection.errorStream?.bufferedReader()?.use { it.readText() } ?: "Unknown error"
                        Result.Failure(Exception("HTTP Error: $responseCode - $error"))
                    }
                }
                is Result.Failure -> {
                    Result.Failure(signatureResult.error)
                }
            }
        } catch (e: Exception) {
            Result.Failure(e)
        }
    }
    ```
  </Tab>

  <Tab title="Flutter">
    With the Flutter SDK, follow these steps to prepare and send a sponsored transaction:

    ```dart  theme={"system"}
    import 'dart:convert';
    import 'package:http/http.dart' as http;
    import 'package:solana/solana.dart';

    // This function prepares and signs a sponsored transaction
    Future<Result<String>> prepareSponsoredTransaction({
      required EmbeddedSolanaWallet solanaWallet,
      required List<Instruction> instructions,
      required String feePayerAddress,
      required String rpcUrl,
      required String backendUrl,
    }) async {
      try {
        // Create connection to Solana
        final connection = Connection(rpcUrl);

        // Get recent blockhash
        final recentBlockhash = await connection.getLatestBlockhash();

        // Create wallet public key
        final walletPublicKey = PublicKey(solanaWallet.address);
        final feePayerPublicKey = PublicKey(feePayerAddress);

        // Build transaction
        final transaction = Transaction();

        // Add instructions to transaction
        for (final instruction in instructions) {
          transaction.add(instruction);
        }

        // Set blockhash and fee payer
        transaction.recentBlockhash = recentBlockhash;
        transaction.feePayer = feePayerPublicKey;

        // Serialize transaction message to base64
        final serializedMessage = base64Encode(transaction.serializeMessage());

        // Sign the message with user's wallet
        final signatureResult = await solanaWallet.provider.signMessage(serializedMessage);

        return signatureResult.when(
          success: (userSignature) async {
            // Add signature to transaction
            transaction.addSignature(
              walletPublicKey,
              base64Decode(userSignature)
            );

            // Serialize transaction for sending to backend
            final serializedTransaction = base64Encode(transaction.serialize());

            // Send to backend
            final response = await http.post(
              Uri.parse(backendUrl),
              headers: {'Content-Type': 'application/json'},
              body: jsonEncode({'transaction': serializedTransaction}),
            );

            if (response.statusCode >= 200 && response.statusCode < 300) {
              final jsonResponse = jsonDecode(response.body);
              final transactionHash = jsonResponse['transactionHash'] as String;
              return Success(transactionHash);
            } else {
              return Failure(
                Exception('HTTP Error: ${response.statusCode} - ${response.body}')
              );
            }
          },
          failure: (error) {
            return Failure(Exception('Failed to sign transaction: $error'));
          },
        );
      } catch (e) {
        return Failure(Exception('Error preparing transaction: $e'));
      }
    }
    ```
  </Tab>
</Tabs>

## Backend Implementation

Here's how to implement the server-side portion that receives the partially signed transaction, adds the fee payer signature, and broadcasts it:

```javascript  theme={"system"}
// Backend implementation (Node.js with Express)
import express from 'express';
import {Keypair, VersionedTransaction, Connection, clusterApiUrl, PublicKey} from '@solana/web3.js';
import bs58 from 'bs58';

const app = express();
app.use(express.json());

// Your fee payer wallet's private key (Keep this secure!)
const FEE_PAYER_PRIVATE_KEY = 'your-base58-encoded-private-key';
const FEE_PAYER_ADDRESS = 'your-fee-payer-address';

// Initialize fee payer keypair
const feePayerWallet = Keypair.fromSecretKey(bs58.decode(FEE_PAYER_PRIVATE_KEY));

// Connect to Solana
const connection = new Connection(clusterApiUrl('mainnet-beta'));

// Endpoint to handle sponsored transactions
app.post('/sponsor-transaction', async (req, res) => {
  try {
    // Get the partially signed transaction from the request
    const {transaction: serializedTransaction} = req.body;

    if (!serializedTransaction) {
      return res.status(400).json({error: 'Missing transaction data'});
    }

    // Deserialize the transaction
    const transactionBuffer = Buffer.from(serializedTransaction, 'base64');
    const transaction = VersionedTransaction.deserialize(transactionBuffer);

    // Verify the transaction
    // 1. Check that it's using the correct fee payer
    const message = transaction.message;
    const accountKeys = message.getAccountKeys();
    const feePayerIndex = 0; // Fee payer is always the first account
    const feePayer = accountKeys.get(feePayerIndex);

    if (!feePayer || feePayer.toBase58() !== FEE_PAYER_ADDRESS) {
      return res.status(403).json({
        error: 'Invalid fee payer in transaction'
      });
    }

    // 2. Check for any unauthorized fund transfers
    for (const instruction of message.compiledInstructions) {
      const programId = accountKeys.get(instruction.programIndex);

      // Check if instruction is for System Program (transfers)
      if (programId && programId.toBase58() === '11111111111111111111111111111111') {
        // Check if it's a transfer (command 2)
        if (instruction.data[0] === 2) {
          const senderIndex = instruction.accountKeyIndexes[0];
          const senderAddress = accountKeys.get(senderIndex);

          // Don't allow transactions that transfer tokens from fee payer
          if (senderAddress && senderAddress.toBase58() === FEE_PAYER_ADDRESS) {
            return res.status(403).json({
              error: 'Transaction attempts to transfer funds from fee payer'
            });
          }
        }
      }
    }

    // 3. Sign with fee payer
    transaction.sign([feePayerWallet]);

    // 4. Send transaction
    const signature = await connection.sendTransaction(transaction);

    // Return the transaction hash
    return res.status(200).json({
      transactionHash: signature,
      message: 'Transaction sent successfully'
    });
  } catch (error) {
    console.error('Error processing transaction:', error);
    return res.status(500).json({
      error: 'Failed to process transaction',
      details: error.message
    });
  }
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

## Security Considerations

When implementing transaction sponsorship, be mindful of these security considerations:

<CardGroup cols={2}>
  <Card title="Verify Transaction Contents" icon="shield-check">
    Always verify the transaction contents in your backend before signing with the fee payer. Ensure
    there are no unauthorized fund transfers.
  </Card>

  <Card title="Rate Limiting" icon="gauge-high">
    Implement rate limiting to prevent abuse of your sponsorship service. Consider limits per user,
    per session, or per wallet.
  </Card>

  <Card title="Amount Validation" icon="money-bill">
    Validate the transaction amount if applicable. Consider setting maximum sponsorship amounts to
    prevent excessive spending.
  </Card>

  <Card title="Program ID Whitelisting" icon="list-check">
    Only sponsor transactions for specific whitelisted program IDs that your app interacts with to
    prevent abuse.
  </Card>
</CardGroup>

<Note>
  Be extremely careful with your fee payer wallet's private key. Never expose it in client-side code
  or store it in unsecured environments. Consider using environment variables, secret management
  services, or HSMs to securely store private keys in production.
</Note>


# null
Source: https://docs.privy.io/wallets/global-wallets/integrate-a-global-wallet/connectkit-connector



Privy makes it easy to integrate cross-app wallets from various Privy apps into existing setups with ConnectKit, wagmi and more using the [`@privy-io/cross-app-connect`](https://www.npmjs.com/package/@privy-io/cross-app-connect) SDK.

Integrating apps do not need to use Privy themselves to integrate cross-app wallets; instead, they can create a custom wagmi connector using the SDK to configure with ConnectKit. Simply follow the instructions below to get set up!

<Tip>
  See our
  [`privy-io/cross-app-connect-demo`](https://github.com/privy-io/cross-app-connect-demo/tree/connectkit-demo)
  repo's ConnectKit branch for an example setup.
</Tip>

## 1. Install dependencies

Install the [`@privy-io/cross-app-connect`](https://www.npmjs.com/package/@privy-io/cross-app-connect) SDK and its peer dependencies:

```bash  theme={"system"}
npm i @privy-io/cross-app-connect wagmi connectkit @tanstack/react-query viem
```

## 2. Create the custom connector

Next, you'll create a custom wagmi connector that integrates with Privy's cross-app-connect functionality. This connector will be fully compatible with ConnectKit and handles all the connection logic for you:

```tsx privy-global-connector.ts expandable theme={"system"}
import {createConnector} from 'wagmi';
import {toPrivyWalletProvider} from '@privy-io/cross-app-connect';
import type {EIP1193Provider} from 'viem';

export interface PrivyGlobalWalletOptions {
  appId: string;
  name: string;
  iconUrl?: string;
  smartWalletMode?: boolean;
}

/**
 * Creates a Privy Global Wallet connector for use with wagmi and ConnectKit
 *
 * @param options - Configuration options for the Privy wallet
 * @returns A wagmi connector configured for Privy cross-app wallets
 */
export function privyGlobalWalletConnector(options: PrivyGlobalWalletOptions) {
  return createConnector((config) => ({
    id: options.appId,
    name: options.name,
    icon: options.iconUrl,
    type: 'injected', // Critical: Use 'injected' type for ConnectKit compatibility

    async setup() {
      // Setup is called when the connector is first created
      // No special setup needed for cross-app-connect
    },

    async connect({chainId} = {}) {
      const provider = await this.getProvider();

      // Request accounts - this triggers the Privy popup
      await provider.request({method: 'eth_requestAccounts'});

      // Switch to requested chain if provided
      if (chainId) {
        try {
          await this.switchChain({chainId});
        } catch (error) {
          console.warn('Failed to switch to requested chain:', error);
        }
      }

      const accounts = await this.getAccounts();
      const currentChainId = await this.getChainId();

      return {
        accounts,
        chainId: currentChainId
      };
    },

    async disconnect() {
      const provider = await this.getProvider();
      try {
        await provider.request({
          method: 'wallet_revokePermissions',
          params: [{eth_accounts: {}}]
        });
      } catch (error) {
        console.warn('Failed to revoke permissions:', error);
      }
    },

    async getAccounts() {
      const provider = await this.getProvider();
      const accounts = await (provider as EIP1193Provider).request({
        method: 'eth_accounts'
      });
      return accounts as `0x${string}`[];
    },

    async getChainId() {
      const provider = await this.getProvider();
      const chainId = await (provider as EIP1193Provider).request({
        method: 'eth_chainId'
      });
      return Number(chainId);
    },

    async getProvider(): Promise<EIP1193Provider> {
      return toPrivyWalletProvider({
        providerAppId: options.appId,
        chains: config.chains,
        smartWalletMode: options.smartWalletMode || false
      }) as EIP1193Provider;
    },

    async isAuthorized() {
      try {
        const accounts = await this.getAccounts();
        return accounts.length > 0;
      } catch {
        return false;
      }
    },

    async switchChain({chainId}) {
      const provider = await this.getProvider();
      const chain = config.chains.find((c) => c.id === chainId);

      if (!chain) {
        throw new Error(`Chain ${chainId} not configured`);
      }

      await provider.request({
        method: 'wallet_switchEthereumChain',
        params: [{chainId: `0x${chainId.toString(16)}`}]
      });

      return chain;
    },

    onAccountsChanged(accounts) {
      if (accounts.length === 0) {
        config.emitter.emit('disconnect');
      } else {
        config.emitter.emit('change', {
          accounts: accounts as `0x${string}`[]
        });
      }
    },

    onChainChanged(chainId) {
      const id = Number(chainId);
      config.emitter.emit('change', {chainId: id});
    },

    onConnect(connectInfo) {
      config.emitter.emit('connect', {
        accounts: [],
        chainId: Number(connectInfo.chainId)
      });
    },

    onDisconnect() {
      config.emitter.emit('disconnect');
    }
  }));
}
```

## 3. Configure wagmi with ConnectKit

Now you'll set up your wagmi configuration using ConnectKit's `getDefaultConfig` and pass in your custom Privy connector. This step brings everything together:

```tsx  theme={"system"}
import {WagmiProvider, createConfig, http} from 'wagmi';
import {mainnet} from 'wagmi/chains';
import {QueryClient, QueryClientProvider} from '@tanstack/react-query';
import {ConnectKitProvider, getDefaultConfig} from 'connectkit';
import {privyGlobalWalletConnector} from './privy-global-connector';

const privyWalletConnector = privyGlobalWalletConnector({
  appId: 'privy-wallet-app-id',
  name: 'Privy wallet app name',
  iconUrl: 'https://example.com/image.png'
});

const config = createConfig(
  getDefaultConfig({
    // Your dApp's chains
    chains: [mainnet],
    transports: {
      // RPC URL for each chain
      [mainnet.id]: http()
    },

    // Required API Keys
    walletConnectProjectId: process.env.NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID,

    // Required App Info
    appName: 'Your App Name',
    connectors: [privyWalletConnector],

    // Optional App Info
    appDescription: 'Your App Description',
    appUrl: 'https://yourapp.com',
    appIcon: 'https://yourapp.com/logo.png'
  })
);

const queryClient = new QueryClient();

export const Providers = ({children}: {children: React.ReactNode}) => {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        <ConnectKitProvider>{children}</ConnectKitProvider>
      </QueryClientProvider>
    </WagmiProvider>
  );
};
```

## 4. Wrap your app with providers

At the highest level of your application, wrap your components with the `Providers` component you just created:

```tsx  theme={"system"}
import {Providers} from './providers';

function MyApp({Component, pageProps}) {
  return (
    <Providers>
      <Component {...pageProps} />
    </Providers>
  );
}

export default MyApp;
```

### Complete example

Here's how all the pieces fit together in your project structure:

<Tabs>
  <Tab title="providers.tsx">
    ```tsx  theme={"system"}
    import {WagmiProvider, createConfig, http} from 'wagmi';
    import {mainnet} from 'wagmi/chains';
    import {QueryClient, QueryClientProvider} from '@tanstack/react-query';
    import {ConnectKitProvider, getDefaultConfig} from 'connectkit';
    import {privyGlobalWalletConnector} from './privy-global-connector';

    const privyWalletConnector = privyGlobalWalletConnector({
      appId: 'privy-wallet-app-id',
      name: 'Privy wallet app name',
      iconUrl: 'https://example.com/image.png'
    });

    const config = createConfig(
      getDefaultConfig({
        chains: [mainnet],
        transports: {
          [mainnet.id]: http()
        },
        walletConnectProjectId: process.env.NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID,
        appName: 'Your App Name',
        connectors: [privyWalletConnector],
        appDescription: 'Your App Description',
        appUrl: 'https://yourapp.com',
        appIcon: 'https://yourapp.com/logo.png'
      })
    );

    const queryClient = new QueryClient();

    export const Providers = ({children}: {children: React.ReactNode}) => {
      return (
        <WagmiProvider config={config}>
          <QueryClientProvider client={queryClient}>
            <ConnectKitProvider>{children}</ConnectKitProvider>
          </QueryClientProvider>
        </WagmiProvider>
      );
    };
    ```
  </Tab>

  <Tab title="privy-global-connector.ts">
    ```tsx privy-global-connector.ts expandable theme={"system"}
    import {createConnector} from 'wagmi';
    import {toPrivyWalletProvider} from '@privy-io/cross-app-connect';
    import type {EIP1193Provider} from 'viem';

    export interface PrivyGlobalWalletOptions {
      appId: string;
      name: string;
      iconUrl?: string;
      smartWalletMode?: boolean;
    }

    /**
     * Creates a Privy Global Wallet connector for use with wagmi and ConnectKit
     */
    export function privyGlobalWalletConnector(options: PrivyGlobalWalletOptions) {
      return createConnector((config) => ({
        id: options.appId,
        name: options.name,
        icon: options.iconUrl,
        type: 'injected',

        async connect({chainId} = {}) {
          const provider = await this.getProvider();
          await provider.request({method: 'eth_requestAccounts'});

          if (chainId) {
            try {
              await this.switchChain({chainId});
            } catch (error) {
              console.warn('Failed to switch to requested chain:', error);
            }
          }

          const accounts = await this.getAccounts();
          const currentChainId = await this.getChainId();

          return {accounts, chainId: currentChainId};
        },

        async getProvider(): Promise<EIP1193Provider> {
          return toPrivyWalletProvider({
            providerAppId: options.appId,
            chains: config.chains,
            smartWalletMode: options.smartWalletMode || false
          }) as EIP1193Provider;
        }

        // ... other connector methods
      }));
    }
    ```
  </Tab>
</Tabs>

## 5. Use the `ConnectKitButton`

Finally, import the `ConnectKitButton` and use it anywhere in your app to let users connect to their Privy global wallets:

```tsx  theme={"system"}
import {ConnectKitButton} from 'connectkit';

function Page() {
  return (
    <div>
      <h1>My app</h1>
      ...
      <ConnectKitButton />
    </div>
  );
}
```

That's it! You're all set up with Privy global wallets and ConnectKit.

You can now use any wagmi hook in your application to interact with the connected wallet. When users connect and transact with their wallet, Privy will open a secure pop-up for users to authorize any actions, ensuring their private keys never leave the original app.

This integration gives your users seamless access to their existing wallets from other Privy-powered apps, reducing onboarding friction and improving the overall user experience.


# null
Source: https://docs.privy.io/wallets/global-wallets/integrate-a-global-wallet/getting-global-wallets



Once a user has successfully linked their account from a provider app, an account of `type: 'cross_app'` will be added to the `linkedAccounts` array of their `user` object.

This `crossAppAccount` is an object with the following properties:

<Expandable title="properties" defaultOpen="true">
  <ParamField path="type" type="'cross_app'" required>
    Indicates that the linked account is a cross-app account.
  </ParamField>

  <ParamField path="embeddedWallets" type="Array<{address: string}>">
    An array of the user's embedded wallet(s) from the provider app for the cross-app account.
  </ParamField>

  <ParamField path="smartWallets" type="Array<{address: string}>">
    An array of the user's smart wallet(s) from the provider app for the cross-app account, if the
    provider has smart wallets enabled.
  </ParamField>

  <ParamField path="providerApp" type="ProviderAppMetadata">
    Metadata about the provider app for the cross-app account.

    <Expandable defaultOpen="true">
      <ParamField path="id" type="string" required>
        Privy app ID of the source app.
      </ParamField>

      <ParamField path="name" type="string">
        Name of the source app.
      </ParamField>

      <ParamField path="logoUrl" type="string">
        Logo of the source app.
      </ParamField>
    </Expandable>
  </ParamField>

  <ParamField path="firstVerifiedAt" type="Date">
    Datetime when the cross-app account was first linked to the user.
  </ParamField>

  <ParamField path="latestVerifiedAt" type="Date">
    Datetime for when the user last logged in/linked the cross-app account.
  </ParamField>
</Expandable>

To find a user's cross-app embedded wallet, first find the account of `type: 'cross_app'` from their `linkedAccounts` array. If your app permits users to link cross-app accounts from *multiple* provider apps, you should also filter the `linkedAccounts` by the `providerApp.id` on the cross-app account.

```tsx  theme={"system"}
// Replace `providerAppId` with the Privy app ID of your desired provider app
const providerAppId = 'insert-provider-app-id';
const crossAppAccount = user.linkedAccounts.find(
  (account) => account.type === 'cross_app' && account.providerApp.id === providerAppId
);
```

Next, from the `crossAppAccount`, inspect the `embeddedWallets` array to get the user's embedded wallet address(es) from the source app.

```tsx  theme={"system"}
const address = crossAppAccount.embeddedWallets[0].address;
```

<Info>
  Most users only have one embedded wallet per app. Certain apps, however, leverage multiple
  embedded wallets (e.g. HD wallets) per user to support certain use cases. In kind, the
  `embeddedWallets` field is designed as an array, but generally will be a singleton containing one
  entry.

  Similarly, the `smartWallets` field is designed as an array, but generally will be a singleton or empty
  depending on whether the provider app has smart wallets enabled.
</Info>


# null
Source: https://docs.privy.io/wallets/global-wallets/integrate-a-global-wallet/linking-a-global-wallet



<Tabs>
  <Tab title="React">
    To prompt users to link their embedded wallet from a provider app, use the `linkCrossAppAccount` method from the `useCrossAppAccounts` hook:

    ```tsx  theme={"system"}
    import {usePrivy} from '@privy-io/react-auth';

    function Button() {
      const {ready, authenticated} = usePrivy();
      const {linkCrossAppAccount} = useCrossAppAccounts();

      return (
        <button
          onClick={() => linkCrossAppAccount({appId: 'insert-provider-app-id'})}
          disabled={!ready || !authenticated}
        >
          Link your [insert-provider-app-name] account
        </button>
      );
    }
    ```

    ## Parameters

    <ParamField path="appId" type="string" required>
      The Privy app ID of the provider app from which you'd like a user to link their account. You can
      find a list of Privy app IDs for provider apps in the **Cross-app ecosystem** page of the Privy
      Dashboard.
    </ParamField>

    ## Behavior

    When `linkCrossAppAccount` is invoked, the user will be redirected to a page hosted on the domain of the provider app you specified to authorize access to your own app.

    If the user successfully authorizes access, the user will be redirected back to your app, and an account of `type: 'cross_app'` will be added to the `linkedAccounts` array of their `user` object.

    `linkCrossAppAccount` will throw an error if:

    * The user does not authorize access to your app or exits the flow prematurely.
    * The provider app you request has not opted-in to share their wallets.
    * The user is not `authenticated` and thus cannot link an account from the provider app to an existing account within your requester's app.

    <tip>
      If the user is already logged in on the domain of the source `appId` you specify in
      `linkCrossAppAccount`, they will not have to login again and will only have to consent to sharing
      access to that account in your app.
    </tip>
  </Tab>

  <Tab title="React Native">
    To prompt users to link their embedded wallet from a provider app, use the `linkWithCrossApp` method from the `useLinkWithCrossApp` hook:

    ```tsx  theme={"system"}
    import {usePrivy, useLinkWithCrossApp} from '@privy-io/expo';

    function LinkWithCrossAppButton() {
      const {isReady, user} = usePrivy();
      const {linkWithCrossApp} = useLinkWithCrossApp();

      return (
        <Button
          onPess={() => linkWithCrossApp({appId: 'insert-provider-app-id'})}
          disabled={!ready || !!user}
        >
          Link your [insert-provider-app-name] account
        </Button>
      );
    }
    ```

    ## Parameters

    <ParamField path="appId" type="string" required>
      The Privy app ID of the provider app from which you'd like a user to link their account. You can
      find a list of Privy app IDs for provider apps in the **Cross-app ecosystem** page of the Privy
      Dashboard.
    </ParamField>

    <ParamField path="redirectUri" type="string">
      A URL path that the provider will automatically redirect to after successful authentication. This
      defaults to a link back to your app root, eg. `'/'`, if not provided.
    </ParamField>

    ## Behavior

    When `linkWithCrossApp` is invoked, the user will be redirected to a page hosted on the domain of the provider app you specified to authorize access to your own app.

    If the user successfully authorizes access, the user will be redirected back to your app, and an account of `type: 'cross_app'` will be added to the `linked_accounts` array of their `user` object.

    `linkWithCrossApp` will throw an error if:

    * The user does not authorize access to your app or exits the flow prematurely.
    * The provider app you request has not opted-in to share their wallets.
    * The user is not `authenticated` and thus cannot link an account from the provider app to an existing account within your requester's app.

     
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/wallets/global-wallets/integrate-a-global-wallet/login-with-a-global-wallet



<Tabs>
  <Tab title="React">
    To prompt users to log into your app with an account from a provider app, use the `loginWithCrossAppAccount` method from the `useCrossAppAccounts` hook:

    ```tsx {5,9} theme={"system"}
    import {usePrivy, useCrossAppAccounts} from '@privy-io/react-auth';

    function Button() {
      const {ready, authenticated} = usePrivy();
      const {loginWithCrossAppAccount} = useCrossAppAccounts();

      return (
        <button
          onClick={() => loginWithCrossAppAccount({appId: 'insert-provider-app-id'})}
          disabled={!ready || !authenticated}
        >
          Log in with [insert-provider-app-name]
        </button>
      );
    }
    ```

    ### Parameters

    <ParamField path="appId" type="string" required>
      The Privy app ID of the provider app from which you'd like a user to link their account. You can
      find a list of Privy app IDs for provider apps in the **Cross-app ecosystem** page of the Privy
      Dashboard.
    </ParamField>

    ### Behavior

    When `loginWithCrossAppAccount` is invoked, the user will be redirected to a page hosted on the domain of the provider app you specified to authorize access to your own app.

    If the user successfully authorizes access, the user will be redirected back to your app, and an account of `type: 'cross_app'` will be added to the `linkedAccounts` array of their `user` object.

    `loginWithCrossAppAccount` will throw an error if:

    * The user does not authorize access to your app or exits the flow prematurely.
    * The provider app you request has not opted-in to share their wallets.
    * The user does not already have an account with the provider app.

    <Tip>
      If the user is already logged in on the domain of the source `appId` you specify in
      `loginWithCrossAppAccount`, they will not have to login again and will only have to consent to
      sharing access to that account in your app.
    </Tip>

    ## Using the Privy login modal

    You can add any provider app to the list of login options in the Privy login modal by adding `"privy:"` + the provider's app ID to `loginMethodsAndOrder` in the Privy SDK configuration.

    ```tsx  theme={"system"}
      <PrivyProvider
        appId={process.env.NEXT_PUBLIC_PRIVY_APP_ID || ""}
        config={{
          loginMethodsAndOrder: {
            primary: ['email', 'google', 'privy:insert-provider-app-id'],
          },
          ...
        }}
      >
    ```
  </Tab>

  <Tab title="React Native">
    To prompt users to log into your app with an account from a provider app, use the `loginWithCrossApp` method from the `useLoginWithCrossApp` hook:

    ```tsx  theme={"system"}
    import {usePrivy, useLoginWithCrossApp} from '@privy-io/expo';

    function LoginWithCrossAppButton() {
      const {ready, user} = usePrivy();
      const {loginWithCrossApp} = useLoginWithCrossApp();

      return (
        <Button
          onPress={() => loginWithCrossApp({appId: 'insert-provider-app-id'})}
          disabled={!ready || !!user}
        >
          Log in with [insert-provider-app-name]
        </Button>
      );
    }
    ```

    <ParamField path="appId" type="string" required>
      The Privy app ID of the provider app from which you'd like a user to link their account. You can
      find a list of Privy app IDs for provider apps in the **Cross-app ecosystem** page of the Privy
      Dashboard.
    </ParamField>

    <ParamField path="redirectUri" type="string">
      A URL path that the provider will automatically redirect to after successful authentication. This
      defaults to a link back to your app root, eg. `'/'`, if not provided.
    </ParamField>

    When `loginWithCrossApp` is invoked, an in-app browser will open for a page hosted on the domain of
    the provider app you specified to authorize access to your own app.

    If the user successfully authorizes access, the user will be redirected back to your app, and an account of `type: 'cross_app'` will be added to the `linked_accounts` array of their `user` object.

    `loginWithCrossApp` will throw an error if:

    * The user does not authorize access to your app or exits the flow prematurely.
    * The provider app you request has not opted-in to share their wallets.
    * The user does not already have an account with the provider app.

    <Tip>
      If the user is already logged in on the domain of the target `appId` you specify in `loginWithCrossApp`, they will not have to login again and will only have to consent to sharing access to that account in your app.
    </Tip>
  </Tab>
</Tabs>

## Using the access token

Once the user has authenticated with the provider app. You can get their access token for making requests directly to the provider app using `useGetAccessTokenForProvider`.

```tsx {4,8-13} theme={"system"}
import {useGetAccessTokenForProvider} from '@privy-io/react-auth';

function Button() {
  const {getAccessTokenForProvider} = useGetAccessTokenForProvider();

  return (
    <button
      onClick={async () => {
        const {token} = await getAccessTokenForProvider();
        if (token) {
          const res = await getDataFromProviderApp(token);
        }
      }}
    >
      Make API request to provider
    </button>
  );
}
```


# null
Source: https://docs.privy.io/wallets/global-wallets/integrate-a-global-wallet/overview



Privy allows you to easily integrate embedded wallets from other apps, to verify ownership of users' wallet addresses or even request signatures and transactions from.

This reduces friction around having users transact onchain in your app, as users can easily pull in their assets and identity from other apps where they may already have embedded wallets.

Within this setup, your app is known as the **requester** app.

## Finding available providers

To integrate embedded wallets from another app, first visit the [**Privy Dashboard**](https://dashboard.privy.io) and navigate to User management > Global Wallet > [**Integrations**](https://dashboard.privy.io/apps?tab=integrations\&page=ecosystem) tab to see a list of provider app IDs that consent to sharing their wallets with other apps.

For any providers you'd like to integrate, note down the provider's Privy app ID, as you will use this value in the interfaces outlined below.

<Tip>
  Some providers may only consent to sharing their users' wallets in read-only mode, in which case
  your app can verify that the user owns a particular address, but cannot request signatures or
  transactions from it.
</Tip>


# null
Source: https://docs.privy.io/wallets/global-wallets/integrate-a-global-wallet/rainbowkit-connector



Privy makes it easy to integrate cross-app wallets from various Privy apps into existing setups with RainbowKit, ConnectKit, wagmi and more using the [`@privy-io/cross-app-connect`](https://www.npmjs.com/package/@privy-io/cross-app-connect) SDK.

Integrating apps do not need to use Privy themselves to integrate cross-app wallets; instead, they can import a Privy cross-app connector directly from the SDK to configure with their wallet connector library. Simply follow the instructions below to get set up!

<img src="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/connect-only.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=e31dcae6b8dab81bcf6abb9f8e2f0789" alt="The Rainbowkit connector" data-og-width="1483" width="1483" data-og-height="1131" height="1131" data-path="images/connect-only.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/connect-only.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=0510a3ec225ed593499aed568576f954 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/connect-only.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=63104192f358ade00c97ed87e35dfc80 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/connect-only.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=ba15e6921b6cfcd4b57685c397ec1e9d 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/connect-only.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=37f5e3e23287f168a091d027dd62da20 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/connect-only.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=5a2bd23d3c6937566ceb1e189e14e9c9 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/connect-only.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=6460269a8e3a01e04fa986b78fe14be7 2500w" />

<Tip>
  See our
  [`privy-io/cross-app-connect-demo`](https://github.com/privy-io/examples/tree/main/examples/privy-next-cross-app-connect)
  repo for an example set up.
</Tip>

## 1. Install dependencies

Install the [`@privy-io/cross-app-connect`](https://www.npmjs.com/package/@privy-io/cross-app-connect) SDK and its peer dependencies:

```bash  theme={"system"}
npm i @privy-io/cross-app-connect wagmi @rainbow-me/rainbowkit @tanstack/react-query
```

## 2. Create the connector

Import the `toPrivyWallet` connector function from `@privy-io/cross-app-connect/rainbow-kit`:

```tsx  theme={"system"}
import {toPrivyWallet} from '@privy-io/cross-app-connect/rainbow-kit';
```

Use the `toPrivyWallet` method to create a wallet connector. The function takes `id`, `name`, and `iconUrl` (described below) and returns a connector that RainbowKit will use to connect to the provider wallet.

### Parameters

<ParamField path="id" type="string" required>
  Privy app ID for the provider application.
</ParamField>

<ParamField path="name" type="string" required>
  The name of the Privy provider application.
</ParamField>

<ParamField path="iconUrl" type="string">
  The URL for the icon that will appear in the modal.
</ParamField>

Call this method within RainbowKit's `connectorsForWallets` function like so:

```tsx  theme={"system"}
import {connectorsForWallets} from '@rainbow-me/rainbowkit';

import {toPrivyWallet} from '@privy-io/cross-app-connect/rainbow-kit';

const connectors = connectorsForWallets(
  [
    {
      groupName: 'Recommended',
      wallets: [
        toPrivyWallet({
          id: 'privy-wallet-app-id',
          name: 'Privy wallet app name',
          iconUrl: 'https://example.com/image.png'
        })
      ]
    }
  ],
  {
    appName: 'Privy',
    projectId: 'Demo'
  }
);
```

Then, pass this array of connectors to your wagmi configuration.

```tsx  theme={"system"}
import {createConfig, http} from 'wagmi';
import {mainnet} from 'wagmi/chains';

export const config = createConfig({
  chains: [mainnet],
  transports: {
    [mainnet.id]: http()
  },
  connectors,
  ssr: true
});
```

This `config` will be passed to the `WagmiProvider` in the next step.

## 3. Wrap app with providers

At the highest level of your applications, wrap the component with the `wagmi`, `QueryClient`, and `RainbowKit` providers. Pass the configuration you created in step 2 to the `wagmi` provider.

```tsx  theme={"system"}
import {RainbowKitProvider} from '@rainbow-me/rainbowkit';
import {QueryClient, QueryClientProvider} from '@tanstack/react-query';
import type {AppProps} from 'next/app';
import {WagmiProvider} from 'wagmi';

import {config} from '../wagmi';

const client = new QueryClient();

function MyApp({Component, pageProps}: AppProps) {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={client}>
        <RainbowKitProvider>
          <Component {...pageProps} />
        </RainbowKitProvider>
      </QueryClientProvider>
    </WagmiProvider>
  );
}

export default MyApp;
```

### Complete example

All together, this should look like:

<Tabs>
  <Tab title="config.ts">
    ```tsx  theme={"system"}
    import {connectorsForWallets} from '@rainbow-me/rainbowkit';
    import {createConfig, http} from 'wagmi';
    import {mainnet} from 'wagmi/chains';

    import {toPrivyWallet} from '@privy-io/cross-app-connect/rainbow-kit';

    const connectors = connectorsForWallets(
      [
        {
          groupName: 'Recommended',
          wallets: [
            toPrivyWallet({
              id: 'privy-wallet-app-id',
              name: 'Privy wallet app name',
              iconUrl: 'https://example.com/image.png'
            })
          ]
        }
      ],
      {
        appName: 'Privy',
        projectId: 'Demo'
      }
    );

    export const config = createConfig({
      chains: [mainnet],
      transports: {
        [mainnet.id]: http()
      },
      connectors,
      ssr: true
    });
    ```
  </Tab>

  <Tab title="providers.tsx">
    ```tsx  theme={"system"}
    import {RainbowKitProvider} from '@rainbow-me/rainbowkit';
    import {QueryClient, QueryClientProvider} from '@tanstack/react-query';
    import type {AppProps} from 'next/app';
    import {WagmiProvider} from 'wagmi';

    import {config} from '../wagmi';

    const client = new QueryClient();

    function MyApp({Component, pageProps}: AppProps) {
      return (
        <WagmiProvider config={config}>
          <QueryClientProvider client={client}>
            <RainbowKitProvider>
              <Component {...pageProps} />
            </RainbowKitProvider>
          </QueryClientProvider>
        </WagmiProvider>
      );
    }
    ```
  </Tab>
</Tabs>

## 4. Use the `ConnectButton`

Import the `ConnectButton` and use to prompt users to connect to their provider Privy wallet.

```tsx  theme={"system"}
import {ConnectButton} from '@rainbow-me/rainbowkit';

function Page() {
  return (
    <div>
      <h1> My app </h1>
      ...
      <ConnectButton />
    </div>
  );
}
```

Thats it! You can now use any wagmi hook in your application to interact with the connected wallet. When users connect and transact with their wallet, Privy will open a pop-up for users to authorize any actions.


# null
Source: https://docs.privy.io/wallets/global-wallets/integrate-a-global-wallet/using-global-wallets



<Tabs>
  <Tab title="React">
    <Info>
      When you request a signature or transaction from a user's embedded wallet from another app, Privy **requires** the user to explicitly confirm the signature or transaction. This is accomplished by opening a popup to the provider app's domain, where the user confirms the action in an isolated environment.
    </Info>

    To request signatures and transactions from a user's embedded wallet from a provider app, use the `signMessage`, `signTypedData`, and `sendTransaction` methods returned by Privy's `useCrossAppAccounts` hook

    ```tsx  theme={"system"}
    import {useCrossAppAccounts} from '@privy-io/react-auth';

    const {signMessage, signTypedData, sendTransaction} = useCrossAppAccounts();
    ```

    These methods are similar to the [`signMessage`](/wallets/using-wallets/ethereum/sign-a-message), [`signTypedData`](/wallets/using-wallets/ethereum/sign-typed-data), and [`sendTransaction`](/wallets/using-wallets/ethereum/send-a-transaction) methods returned by `usePrivy` except they all require an additional `CrossAppWalletOptions` object of the following type:

    <ParamField path="address" type="string" required>
      The address for the cross-app embedded wallet that you'd like to request a signature/transaction
      from.
    </ParamField>

    If the `address` you specify in this `CrossAppWalletOptions` object is not a valid embedded wallet
    that has been linked to the current user from a provider app, these wallet methods will error.

    ## signMessage

    To the `signMessage` method returned by `useCrossAppAccounts`, pass the following parameters:

    <ParamField path="message" type="string" required>
      The message the user must sign as a `string`.
    </ParamField>

    <ParamField path="options" type="CrossAppWalletOptions" required>
      Options for the cross-app embedded wallet, which must include the requested wallet's address.

      <Expandable title="properties" defaultOpen="true">
        <ParamField path="address" type="string" required>
          The address for the cross-app embedded wallet that you'd like to request a
          signature/transaction from.
        </ParamField>
      </Expandable>
    </ParamField>

    ## signTypedData

    To the `signTypedData` method returned by `useCrossAppAccounts`, pass the following parameters:

    <ParamField path="typedData" type="SignedTypedDataParams" required>
      A JSON object that conforms to the EIP-712 [`TypedData JSON
        schema.`](https://eips.ethereum.org/EIPS/eip-712#specification-of-the-eth_signtypeddata-json-rpc)
    </ParamField>

    <ParamField path="options" type="CrossAppWalletOptions" required>
      Options for the cross-app embedded wallet, which must include the requested wallet's address.

      <Expandable title="properties" defaultOpen="true">
        <ParamField path="address" type="string" required>
          The address for the cross-app embedded wallet that you'd like to request a
          signature/transaction from.
        </ParamField>
      </Expandable>
    </ParamField>

    ## sendTransaction

    To the `sendTransaction` method returned by `useCrossAppAccounts`, pass the following parameters:

    ```tsx  theme={"system"}
    import {usePrivy, useCrossAppAccounts} from '@privy-io/react-auth';

    function Button() {
      const {user} = usePrivy();
      const {sendTransaction} = useCrossAppAccounts();
      const crossAppAccount = user.linkedAccounts.find((account) => account.type === 'cross_app');
      const address = crossAppAccount.embeddedWallets[0].address;

      return (
        <button
          onClick={() =>
            sendTransaction(
              {
                chainId: 1, // Ethereum mainnet
                to: '0xRecipientAddress',
                value: 1000000000000000000,
                gasLimit: 21000,
                gasPrice: 20000000000,
                nonce: 0,
                data: '0x'
              },
              {address}
            )
          }
          disabled={!address}
        >
          Send transaction
        </button>
      );
    }
    ```

    <ParamField path="requestData" type="UnsignedTransactionRequest" required>
      The transaction request to be sent.
    </ParamField>

    <ParamField path="options" type="CrossAppWalletOptions" required>
      Options for the cross-app embedded wallet, which must include the requested wallet's address.

      <Expandable title="properties" defaultOpen="true">
        <ParamField path="address" type="string" required>
          The address for the cross-app embedded wallet that you'd like to request a
          signature/transaction from.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Example signature request

    As an example, you might request a signature from a user's cross-app wallet like so:

    ```tsx  theme={"system"}
    import {usePrivy, useCrossAppAccounts} from '@privy-io/react-auth';

    function Button() {
      const {user} = usePrivy();
      const {signMessage} = useCrossAppAccounts();
      const crossAppAccount = user.linkedAccounts.find((account) => account.type === 'cross_app');
      const address = crossAppAccount.embeddedWallets[0].address;

      return (
        <button onClick={() => signMessage('Hello world', {address: address})} disabled={!address}>
          Sign a message with your cross-app wallet
        </button>
      );
    }
    ```
  </Tab>

  <Tab title="React Native">
    <Info>
      When you request a signature or transaction from a user's embedded wallet from another app, Privy
      **requires** the user to explicitly confirm the signature or transaction. This is accomplished by
      opening a popup to the provider app's domain, where the user confirms the action in an isolated
      environment.
    </Info>

    To request signatures and transactions from a user's embedded wallet from a provider app, use the `signMessage`, `signTypedData`, and `sendTransaction` methods returned by Privy's hooks: `useSignMessageWithCrossApp`, `useSignTypedDataWithCrossApp` and `useSendTransactionWithCrossApp`.

    ```tsx  theme={"system"}
    const {signMessage} = useSignMessageWithCrossApp();
    const {signTypedData} = useSignTypedDataWithCrossApp();
    const {sendTransaction} = useSendTransactionWithCrossApp();
    ```

    These methods all require an additional `address` property, and an optional `redirectUri`, of the following types:

    <ParamField path="address" type="string" required>
      The address for the cross-app embedded wallet that you'd like to request a signature/transaction
      from.
    </ParamField>

    <ParamField path="redirectUri" type="string">
      A URL path that the provider will automatically redirect to after successful authentication. This
      defaults to a link back to your app root, eg. `'/'`, if not provided.
    </ParamField>

    If the `address` you specify in this `CrossAppWalletOptions` object is not a valid embedded wallet
    that has been linked to the current user from a provider app, these wallet methods will error.

    ### signMessage

    To the `signMessage` method returned by \`useSignMessageWithCrossApp\`\`, pass the following parameters:

    ```tsx  theme={"system"}
    import {usePrivy, useSignMessageWithCrossApp} from '@privy-io/expo';

    function Button() {
      const {user} = usePrivy();
      const {signMessage} = useSignMessageWithCrossApp();
      const crossAppAccount = user.linked_accounts.find((account) => account.type === 'cross_app');
      const address = crossAppAccount.embedded_wallets[0].address;

      return (
        <button onClick={() => signMessage({address, message: 'Hello world'})} disabled={!address}>
          Sign a message with your cross-app wallet
        </button>
      );
    }
    ```

    <ParamField path="message" type="string" required>
      The message the user must sign as a `string`.
    </ParamField>

    <ParamField path="address" type="string" required>
      The address for the cross-app embedded wallet that you'd like to request a signature/transaction
      from.
    </ParamField>

    <ParamField path="redirectUri" type="string">
      A URL path that the provider will automatically redirect to after successful authentication. This
      defaults to a link back to your app root, eg. `'/'`, if not provided.
    </ParamField>

    ### signTypedData

    To the `signTypedData` method returned by `useSignTypedDataWithCrossApp`, pass the following parameters:

    ```tsx  theme={"system"}
    import {usePrivy, useSignMessageWithCrossApp} from '@privy-io/expo';

    function Button() {
      const {user} = usePrivy();
      const {signTypedData} = useSignTypedDataWithCrossApp();
      const crossAppAccount = user.linked_accounts.find((account) => account.type === 'cross_app');
      const address = crossAppAccount.embedded_wallets[0].address;

      return (
        <button
          onClick={() => signTypedData({address, typedData: insertTypedDataObject})}
          disabled={!address}
        >
          Sign a message with your cross-app wallet
        </button>
      );
    }
    ```

    <ParamField path="typedData" type="TypedDataDefinition" required>
      A JSON object that conforms to the EIP-712 [`TypedData JSON
        schema.`](https://eips.ethereum.org/EIPS/eip-712#specification-of-the-eth_signtypeddata-json-rpc)
    </ParamField>

    <ParamField path="address" type="string" required>
      The address for the cross-app embedded wallet that you'd like to request a signature/transaction
      from.
    </ParamField>

    <ParamField path="redirectUri" type="string">
      A URL path that the provider will automatically redirect to after successful authentication. This
      defaults to a link back to your app root, eg. `'/'`, if not provided.
    </ParamField>

    ### sendTransaction

    To the `sendTransaction` method returned by `useSendTransactionWithCrossApp`, pass the following parameters:

    ```tsx  theme={"system"}
    import {usePrivy, useSendTransactionWithCrossApp} from '@privy-io/expo';
    import {Button as RNButton} from 'react-native';

    function Button() {
      const {user} = usePrivy();
      const {sendTransaction} = useSendTransactionWithCrossApp();
      const crossAppAccount = user.linked_accounts.find((account) => account.type === 'cross_app');
      const address = crossAppAccount.embedded_wallets[0].address;

      return (
        <RNButton
          title="Send Transaction"
          onPress={() =>
            sendTransaction({
              address,
              transaction: {
                to: '0xRecipientAddress',
                value: 1000000000000000000,
                gasLimit: 21000,
                gasPrice: 20000000000,
                nonce: 0,
                data: '0x'
              }
            })
          }
          disabled={!address}
        />
      );
    }
    ```

    <ParamField path="transaction" type="UnsignedTransactionRequest" required>
      The transaction request to be sent.
    </ParamField>

    <ParamField path="address" type="string" required>
      The address for the cross-app embedded wallet that you'd like to request a signature/transaction
      from.
    </ParamField>

    <ParamField path="redirectUri" type="string">
      A URL path that the provider will automatically redirect to after successful authentication. This
      defaults to a link back to your app root, eg. `'/'`, if not provided.
    </ParamField>
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/wallets/global-wallets/launch-your-wallet/custom-experience



<Warning>
  <b>This is an advanced feature.</b> It is recommended that you reach out to the Privy team if you
  are interested in building a custom global wallet experience.
</Warning>

Privy allows you to build your own custom global wallet experience, instead of using Privy's
default user interfaces. To build your own experience, you will create two new pages using
methods from the `@privy-io/cross-app-provider` library to communicate via the Privy
cross-app protocol. Your app handles the user interfaces, and Privy handles the rest.

<Note>
  The `@privy-io/cross-app-provider` SDK is a vanilla JavaScript library. We recommend using this
  library alongside `@privy-io/react-auth` for the best development experience.
</Note>

This guide highlights the core interfaces of the `@privy-io/cross-app-provider` SDK and how they
integrate with the **React SDK**. For a more complete reference implementation, see the
[**cross-app provider starter repo**](https://github.com/privy-io/examples/tree/main/examples/privy-next-cross-app-provider).

There are two clients in this SDK depending on what style of cross app you are looking to implement. Privy supports both connect and auth mode, where connect allows users to only connect their wallet via a Wagmi connector and auth mode which allows users to login or link with their Privy account.
Connect mode uses the [Mobile Wallet Protocol](https://mobilewalletprotocol.github.io/wallet-mobile-sdk/docs/spec) to connect the wallet, and auth mode uses the [OAuth2 protocol](https://oauth.net/2/) to securely authenticate the user across apps.

<Tabs>
  <Tab title="Connect mode">
    <Steps>
      <Step title="Set up a cross-app provider client">
        ```tsx  theme={"system"}
        // client.ts
        import {createClient} from '@privy-io/cross-app-provider/connect';

        export const client = createClient({
          appId: '<your-privy-app-id>',
          appClientId: '<your-privy-app-client-id>',
          // e.g. https://privy.your-app.com
          privyDomain: '<your-privy-auth-domain>'
        });
        ```
      </Step>

      <Step title="Build the connect experience">
        Allow user's to accept (or reject) a cross-app connection request by using the
        `client` to handle parsing input and responging to the requesting app.

        First, use the `client.getConnectionRequestFromUrlParams` method when the page loads
        to read the request into your app.

        ```tsx  theme={"system"}
        const connectionRequest = client.getConnectionRequestFromUrlParams();
        ```

        <Accordion title="The connection request">
          A connection request object contains:

          * the `requesterPublickey`, used to generate the shared secret for encrypted communication
          * the `callbackUrl`, used to identify the requester and as the `targetOrigin`
            in calls to `window.postMessage`
        </Accordion>

        Then, use `client.acceptConnection` and `client.rejectConnection` to allow your
        users to explicitly approve or deny the connection request respectively via clicking
        a button like so:

        ```tsx  theme={"system"}
        // Approve
        <button
          onClick={async () => {
            await client.acceptConnection({
              accessToken,
              address,
              userId: user.id,
              connectionRequest
            });
          }}
        >
          Accept
        </button>
        ```

        ```tsx  theme={"system"}
        // Deny
        <button
          onClick={async () => {
            await client.rejectConnection({
              accessToken,
              callbackUrl: connectionRequest.callbackUrl
            });
          }}
        >
          Deny
        </button>
        ```
      </Step>

      <Step title="Build the request experience">
        This page allows you to control the experience of a global wallet request.

        First read the request using `client.getVerifiedWalletRequest` to decrypt, parse and
        verify the input. This method will also return the `connection` object used to
        communicate a result back to the requester.

        ```tsx  theme={"system"}
        const {request, connection} = await client.getVerifiedWalletRequest({
          userId: user.id
        });
        ```

        Once you have the result of handling this request you can return the response to the
        requester using `client.handleRequestResult`, for example responding to a signature request:

        ```tsx  theme={"system"}
        const message = request.params[0];
        const {signature} = await signMessage({message});

        await client.handleRequestResult({
          accessToken,
          result: signature,
          connection
        });
        ```

        Similarly, if the user rejects the request use `client.rejectRequest` to send an
        error message to the requester:

        ```tsx  theme={"system"}
        await client.rejectRequest({
          accessToken,
          callbackUrl: connection.callbackUrl
        });
        ```

        If there are other errors (e.g. not enough funds for a transaction) use the
        `client.handleError` method to pass the error back to the requester:

        ```tsx  theme={"system"}
        await client.handleError({
          accessToken,
          error: new Error('<message>'),
          callbackUrl: connection.callbackUrl
        });
        ```
      </Step>

      <Step title="Upgrade your clients">
        Ensure client apps are using the [latest version](/changelogs/cross-app-connect) of
        `@privy-io/cross-app-connect`
      </Step>

      <Step title="Set up your custom URLs in the Privy Dashboard">
        <Tip>
          Prior to enabling the custom URLs in your dashboard, ensure that your integration is ready to
          receive production traffic, including [setting a strong
          CSP](/security/implementation-guide/content-security-policy) and adding your custom URLs as
          allowed domains for your Privy app.
        </Tip>

        From the Privy dashboard, navigate to [**Global Wallet >
        Advanced**](https://dashboard.privy.io/apps?page=ecosystem\&tab=advanced). Enable `Custom URLs`,
        input the URL(s) where your pages are hosted, and save your changes.
      </Step>
    </Steps>
  </Tab>

  <Tab title="Auth mode">
    <Steps>
      <Step title="Set up a cross-app provider client">
        ```tsx  theme={"system"}
        // client.ts
        import {createClient} from '@privy-io/cross-app-provider/auth';

        export const client = createClient({
          appId: '<your-privy-app-id>',
          appClientId: '<your-privy-app-client-id>',
          // e.g. https://privy.your-app.com
          privyDomain: '<your-privy-auth-domain>'
        });
        ```
      </Step>

      <Step title="Build the connect experience">
        Allow user's to accept (or reject) a cross-app connection request by using the
        `client` to handle parsing input and responging to the requesting app.

        First, use the `client.getConnectionRequestFromUrlParams` method when the page loads
        to read the request into your app.

        ```tsx  theme={"system"}
        const connectionRequest = client.getConnectionRequestFromUrlParams();
        ```

        Then, use `client.acceptConnection` and `client.rejectConnection` to allow your
        users to explicitly approve or deny the connection request respectively via clicking
        a button like so:

        ```tsx  theme={"system"}
        // Approve
        <button
          onClick={async () => {
            await client.acceptConnection({
              accessToken,
              codeChallenge: connectionRequest.codeChallenge!,
              codeChallengeMethod: connectionRequest.codeChallengeMethod!,
              state: connectionRequest.state,
              oauthClientId: connectionRequest.oauthClientId
            });
          }}
        >
          Accept
        </button>
        ```

        ```tsx  theme={"system"}
        // Deny
        <button
          onClick={async () => {
            await client.rejectConnection({
              accessToken,
              codeChallenge: connectionRequest.codeChallenge!,
              codeChallengeMethod: connectionRequest.codeChallengeMethod!,
              state: connectionRequest.state,
              oauthClientId: connectionRequest.oauthClientId
            });
          }}
        >
          Deny
        </button>
        ```
      </Step>

      <Step title="Build the request experience">
        This page allows you to control the experience of a global wallet request.

        First read the request using `client.getVerifiedTransactionRequest` to validate the JWT and request.
        This method will return a boolean `verified` and a `data` object.
        `verified` will be false if the JWT is invalid and the request should be ignored.
        In this case, the `data` object will contain a `callbackUrl` you can passed to `handleError` to gracefully exit the page.
        If the request is valid, the `data` object will contain a `request` and a `token` object which you can use to handle the request.

        ```tsx  theme={"system"}
        const {verified, data} = await client.getVerifiedTransactionRequest({
          accessToken
        });
        ```

        Once you have the result of handling this request you can return the response to the
        requester using `client.handleRequestResult`, for example responding to a signature request:

        ```tsx  theme={"system"}
        const message = request.params[0];
        const {signature} = await signMessage({message});

        await client.handleRequestResult({
          accessToken,
          result: signature,
          connection
        });
        ```

        Similarly, if the user rejects the request use `client.rejectRequest` to send an
        error message to the requester:

        ```tsx  theme={"system"}
        await client.rejectRequest({
          accessToken,
          callbackUrl: request.callbackUrl
        });
        ```

        If there are other errors (e.g. not enough funds for a transaction) use the
        `client.handleError` method to pass the error back to the requester:

        ```tsx  theme={"system"}
        await client.handleError({
          accessToken,
          error: new Error('<message>'),
          callbackUrl: request.callbackUrl
        });
        ```
      </Step>

      <Step title="Upgrade your clients">
        Ensure client apps are using the [latest version](/changelogs/cross-app-connect) of
        `@privy-io/cross-app-connect`
      </Step>

      <Step title="Set up your custom URLs in the Privy Dashboard">
        <Tip>
          Prior to enabling the custom URLs in your dashboard, ensure that your integration is ready to
          receive production traffic, including [setting a strong
          CSP](/security/implementation-guide/content-security-policy) and adding your custom URLs as
          allowed domains for your Privy app.
        </Tip>

        From the Privy dashboard, navigate to [**Global Wallet >
        Advanced**](https://dashboard.privy.io/apps?page=ecosystem\&tab=advanced). Enable `Custom URLs`,
        input the URL(s) where your pages are hosted, and save your changes.
      </Step>
    </Steps>
  </Tab>
</Tabs>

That's it, now your global wallet has a fully custom experience!


# Overview
Source: https://docs.privy.io/wallets/global-wallets/launch-your-wallet/overview



**Providers** are apps that enable their users' embedded wallets to be used in other apps. Becoming a provider enables your users to use their embedded wallets and assets from your app elsewhere, allowing them to transact from an existing balance, aggregate assets, and more.

<Tip>
  Before sharing your users' wallets as a provider app, you must enable a **base domain** for your app.

  **Enabling a base domain helps secure your users' wallets in a cross-app context.** Read more about [security for cross-app wallets](/wallets/global-wallets/overview) and follow [this guide](/recipes/react/cookies) to set up a base domain!
</Tip>

## Configuring your app as a provider

To become a provider and share your users' embedded wallets with other apps, simply visit the **Privy Dashboard** and navigate to the **User management > [Global Wallet](https://dashboard.privy.io/apps?page=ecosystem)** section.

Under the [**My app**](https://dashboard.privy.io/apps?tab=app\&page=ecosystem) tab of this page, enable the **Make my wallet available for other apps to integrate** toggle. You should also upload a square logo image with aspect ratio 1:1 to be shared with other apps. We recommend a JPEG or PNG with size 180px by 180px for best results.

Once enabled, your app will show up as an available wallet provider that other apps can integrate via the [**Integrations**](https://dashboard.privy.io/apps?tab=integrations\&page=ecosystem) tab of this page.

You can also see apps that have actively integrated your wallets under the [**My ecosystem**](https://dashboard.privy.io/apps?tab=ecosystem\&page=ecosystem) tab.

## Transaction scanning

As an additional security feature, Privy is integrated with [Blockaid](https://www.blockaid.io/) transaction scanning to ensure that all transactions from your users' global wallets are safe and secure.

Transaction scanning has two levels of security; **validation** and **simulation**. With transaction validation, users will be notified if the transaction has been flagged by Blockaid as suspicious or malicious. Blockaid will also simulate the transaction with the wallet, showing the token and USD value or exposure difference if the transaction is approved.

<img src="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/transaction-scan.png?fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=7eb889f9851cd020bee447b17c5c6c19" alt="Transaction scanning UI" data-og-width="1843" width="1843" data-og-height="1317" height="1317" data-path="images/transaction-scan.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/transaction-scan.png?w=280&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=28df4a6091ad5c31ad1baf53e34df233 280w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/transaction-scan.png?w=560&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=c8842ddd2bd8ab35788b65d0f6631690 560w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/transaction-scan.png?w=840&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=0245286c07569e6e21873e78566e4289 840w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/transaction-scan.png?w=1100&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=a67efa132b70993a5d614e97c59ec3ec 1100w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/transaction-scan.png?w=1650&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=41ab81a1eb5f86f3ca47196fed12a7cc 1650w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/transaction-scan.png?w=2500&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=09880ff7f76264669ea2160662d1284d 2500w" />

To enable transaction scanning for your global wallet users, navigate to the [Global wallet > My app](https://dashboard.privy.io/apps?page=ecosystem) page of the Privy Dashboard and toggle the **Blockaid transaction simulation** setting on.

Privy has a default API key your app can use for testing but to prevent rate limiting your app should **configure its own Blockaid API key** in the dashboard.

## Read-only mode

When sharing your users' embedded wallets with other apps, your users are protected from any malicious developer. Usage of embedded wallets across apps are strictly domain-segregated and every user action requires explicit consent in a third-party app.

If you would like to limit the scope of your users' wallets to only be read-only in other apps, click the **Read-only mode** checkbox within the [**My app**](https://dashboard.privy.io/apps?tab=app\&page=ecosystem) tab. With this setting enabled, requester apps may see your user's wallet addresses, but not request signatures or transactions from them.

This may be particularly useful for setups where users verifying ownership of assets from your app in other apps, but not necessarily transacting with them.


# null
Source: https://docs.privy.io/wallets/global-wallets/overview



Privy embedded wallets can be made interoperable across apps, making it easy for you to launch your own **global wallet**. In this setup, global wallets foster a cross-app ecosystem where users can easily port their wallets from one app to another, including by integrating wallet connector solutions like RainbowKit and wagmi.

Using **global wallets**, users can seamlessly move assets between different apps and can easily prove ownership of, sign messages, or send transactions with their existing wallets.

<img src="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Crossapp.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=a56d26b5b4a09624aec9726697762e15" alt="images/Crossapp.png" data-og-width="1229" width="1229" data-og-height="878" height="878" data-path="images/Crossapp.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Crossapp.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=ff90ec080f30d4dbd0ec397494f8c1b7 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Crossapp.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=4b7095a1dcf66834819db1b5542cca7d 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Crossapp.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=46e068b15d5f129648be4cb95a17e3a6 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Crossapp.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=80600c0a3e6cf3a7ef4a705ea654dba8 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Crossapp.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=66ca9b9acca1b5eab60d1333af98ccee 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Crossapp.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=71e9d1e635d27328a99ee3f7fe7895f9 2500w" />

## Providers and requesters

Suppose that Alice is logged in to **App A** and wants to connect with her **App B** wallet to prove she owns an asset. In this setup:

* App A is the **requester app**: it *requests* access to a third-party wallet.
* App B is the **provider app**: it *provides* access to embedded wallets generated on its app.

The **provider** and **requester** nomenclature will be used throughout this documentation and the SDK interfaces.

## User consent and security

<Info>Privy requires that users explicitly confirm all wallet actions in a cross-app context.</Info>

**Global wallets are built to safeguard user privacy and security.** No app developer can view user assets or learn about their address without both:

* The provider app opting into cross-app flows.
* The user explicitly consenting to share their wallet information with the requester app.

By enabling cross-app functionality, the provider's Privy app (hosted on an isolated subdomain) acts as an OAuth-compliant authentication provider. This means requesting apps can initiate the connection, and if the user approves:

* Users are granted a custom access token to make future requests to the provider wallet
* The user's wallet addresses are then attached to the requester's user object as a new cross-app linked account
* If the provider allows for the wallet to be used for signatures and transactions, the requester can request signatures and transactions using the custom access token. Providers can also choose to make their wallets available in read-only mode.

Privy enables the provider to opt into cross-app wallets in **read-only** mode, enabling the requester app to view the user's wallet address but not prompt the user to transact. If transactions are enabled, the user will always be redirected to the isolated subdomain to explicitly approve them, in addition to needing to be logged in to the provider site and holding the custom access token.

Concretely, this means that when a requester app requests a signature or transaction from a user's cross-app wallet, Privy will open up a pop-up to the isolated subdomain, where **the user must confirm the action explicitly.** This means requesters cannot customize wallet prompts when interacting with a provider wallet, and cannot prompt users to export private keys from a provider wallet.


# Overview
Source: https://docs.privy.io/wallets/overview



Privy builds wallet infrastructure that empowers users and applications to transact on hundreds of blockchains, including Ethereum, Solana, Base, [and more](/wallets/overview/chains).

These wallets can be embedded within your application to have users interact with them directly, or they can be controlled by your servers via Privy's API. Use Privy to instantly spin up self-custodial wallets for your users or create a wallet fleet of your own.

Privy embedded wallets are built on globally distributed infrastructure to ensure high uptime and low latency. They leverage secure hardware (TEEs) to ensure only the rightful owner can control their wallet or access its keys.

Privy also supports users connecting external wallets (like Metamask or Phantom) to your app so they can bring their assets and online identity with them to your product if they already have a wallet.

Regardless of what wallet you integrate (embedded or external wallets), you can easily request signatures and transactions from your users to interact with tokenized assets and onchain infrastructure. The logic for making these requests is similar across wallet types.

<img src="https://mintcdn.com/privy-c2af3412/Ih_Fo3QYM486gzWq/images/walletoverview.png?fit=max&auto=format&n=Ih_Fo3QYM486gzWq&q=85&s=6e373d3d51f224c076fccac9766c472a" alt="images/walletoverview.png" data-og-width="3687" width="3687" data-og-height="1680" height="1680" data-path="images/walletoverview.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/Ih_Fo3QYM486gzWq/images/walletoverview.png?w=280&fit=max&auto=format&n=Ih_Fo3QYM486gzWq&q=85&s=fa18006abd094bda3ef8caf692f71742 280w, https://mintcdn.com/privy-c2af3412/Ih_Fo3QYM486gzWq/images/walletoverview.png?w=560&fit=max&auto=format&n=Ih_Fo3QYM486gzWq&q=85&s=fcf5539560248bf740c75fdaa60c0427 560w, https://mintcdn.com/privy-c2af3412/Ih_Fo3QYM486gzWq/images/walletoverview.png?w=840&fit=max&auto=format&n=Ih_Fo3QYM486gzWq&q=85&s=fcc4a97b2d0f4ef06349a51b72b32d2d 840w, https://mintcdn.com/privy-c2af3412/Ih_Fo3QYM486gzWq/images/walletoverview.png?w=1100&fit=max&auto=format&n=Ih_Fo3QYM486gzWq&q=85&s=7755bb80ce152ae7f0c7d1f02440c38f 1100w, https://mintcdn.com/privy-c2af3412/Ih_Fo3QYM486gzWq/images/walletoverview.png?w=1650&fit=max&auto=format&n=Ih_Fo3QYM486gzWq&q=85&s=51d038ac704584fa0e34a7cdb99268ff 1650w, https://mintcdn.com/privy-c2af3412/Ih_Fo3QYM486gzWq/images/walletoverview.png?w=2500&fit=max&auto=format&n=Ih_Fo3QYM486gzWq&q=85&s=6eb3240d51087db3cb55f70bdb074f30 2500w" />

## Embedded wallets

Privy's embedded wallet system lets you build wallets directly into your app whether you're building self-custodial wallets for your users or a wallet fleet you control.

Privy's wallet infrastructure ensures only the appropriate party controls the wallet. This means you can set up wallets for any user, customer, or agent under a range of custody options.

Privy surfaces both user-centric abstractions enabling you to authenticate users and generate wallets for them, as well as wallet-centric abstractions whereby you can create wallets with assigned authorization keys to control them.

### Common usage

#### User wallets

You can generate self-custodial wallets for your users for a wallet experience that is directly embedded in your application—no separate wallet client, like a browser extension or a mobile app, required.

This means users have full custody of their wallets without needing to manage secret keys. Neither Privy nor your application ever sees the user's keys; secrets are only ever reconstituted in a secure environment under the user's control so they can sign messages or transactions.

Users can manage their embedded wallet seamlessly with their account; they never need to handle any unnecessary technical complexity. Your application can even [pregenerate wallets](/recipes/pregenerate-wallets) for an account, like an email address or phone number, before the user logs in. Users can also [export the key](/wallets/wallets/export) for their embedded wallet, providing an escape hatch to leave Privy at any time.

Your application can easily guide users to use their wallet with simple abstractions to prompt users to fund, transact, and sign with their wallet.

#### Programmatic controls

Set up a fleet of wallets to enable secure treasury management across use cases. Leverage wallets programmatically and safely via quorums of pre-approved signers and policies to move funds and manage complex flows.

Register webhooks to automate events based on onchain actions, assign specific policies to wallet signers to manage risk, and more.

Wallets leverage secure enclaves and key splitting to ensure secure key reconstitution and appropriate custody for all use cases.

### Features

Privy's wallet infrastructure gives you the flexibility to manage key signing directly or integrate onchain infrastructure like smart accounts out of the box. Wallets ship with:

* **Cross-chain usage**: Create and manage wallets on all EVM- and SVM-compatible blockchains, including Ethereum, Base, Arbitrum, HyperEVM, Solana, and Eclipse. Privy also supports [many other chains](/wallets/overview/chains), such as Bitcoin, Spark, TRON, Stellar, and more.
* **Robust transaction controls**: Execute arbitrary transactions with wallets, such as transferring funds and interactions with smart contracts. Make transactions idempotent to ensure that they are only submitted once in case of a retry.
* **Onchain indexing**: Broadcast transactions onchain and register event listeners (via [webhooks](/wallets/gas-and-asset-management/assets/transaction-event-webhooks)) on transaction status, deposits, and withdrawals.
* **Powerful policy engine**: Enforce granular policies what actions a wallet can take, set allowlisted contracts or recipients, maximum amounts to be transferred, restrictions on smart contract calldata, and more. Enforce MFA on transactions, require approval signatures from a quorum of parties, and more. [Learn more](/controls/overview)
* **Flexible custody model**: Cryptographically enforce a chain of custody on wallets, allowing you to require approvals from `m-of-n` parties to execute certain wallet actions.
* **Automated gas sponsorship**: Never worry about topping up a wallet. Keep wallets loaded to pay for transactions at all times. [Learn more](/wallets/gas-and-asset-management/overview)
* **Rich onchain integrations**: Leverage features like Privy's wallet UI components, RainbowKit connector, transaction and balance webhooks, or automated gas management to streamline your integration with the blockchain.

## External wallets

External wallets are managed by a third-party client, such as MetaMask, Phantom, or Rainbow. All browser extension wallets, hardware wallets, and mobile app wallets fall into this category.

If they choose, users may use multiple external wallets within your app and may link these wallets to their account. You can request signatures and transactions from an external wallet directly, or by integrating Privy alongside a library like `wagmi`, `viem`, or `@solana/web3.js`.

## Get started

<CardGroup>
  <Card title="Create a wallet" icon="rocket" href="/wallets/wallets/create/create-a-wallet">
    Create a wallet
  </Card>

  <Card title="Connect external wallets" icon="screwdriver-wrench" href="/wallets/connectors/usage/connecting-external-wallets">
    Connect external wallets to your app like MetaMask or Phantom
  </Card>

  <Card title="Provision session signers" icon="code" href="/wallets/using-wallets/session-signers/overview">
    Take actions on behalf of your users with session signers
  </Card>
</CardGroup>


# Chain support
Source: https://docs.privy.io/wallets/overview/chains



Privy offers support for multiple blockchain ecosystems, organized into three distinct tiers that provide different levels of functionality. By default, Privy supports all blockchains based on Ed25519 and secp256k1 cryptographic curves, and more blockchains are added regularly.

## Supported chains

### Tier 3

<CardGroup cols={2}>
  <Card title="Ethereum" href="/wallets/using-wallets/ethereum/send-a-transaction">
    Includes all EVM-compatible networks
  </Card>

  <Card title="Solana" href="/wallets/using-wallets/solana/send-a-transaction">
    Includes all SVM-compatible networks
  </Card>
</CardGroup>

### Tier 2

<CardGroup cols={3}>
  <Card title="Bitcoin" href="/wallets/using-wallets/bitcoin/sign-transaction-inputs" />

  <Card title="Cosmos" href="/recipes/use-tier-2#cosmos" />

  <Card title="Stellar" href="/recipes/use-tier-2#stellar" />

  <Card title="Spark" href="/recipes/use-tier-2#spark" />

  <Card title="Sui" href="/recipes/use-tier-2#sui" />

  <Card title="Tron" href="/recipes/use-tier-2#tron" />

  <Card title="Near" href="/recipes/use-tier-2#near" />

  <Card title="Ton" href="/recipes/use-tier-2#ton" />

  <Card title="Starknet" href="/recipes/use-tier-2#starknet" />

  <Card title="Aptos" href="/recipes/use-tier-2#aptos" />

  <Card title="Movement" href="/recipes/use-tier-2#movement" />
</CardGroup>

### Tier 1

<CardGroup cols={2}>
  <Card title="Bitcoin L2s" />

  <Card title="All other Ed25519 and secp256k1 chains" />
</CardGroup>

## Support tier definitions

### Tier 3: Full functionality

Chains with Tier 3 support receive comprehensive capabilities, including:

* Complete client-level support end-to-end
* Full wallet functionality
* Transaction building and submission
* Native gas sponsorship
* Advanced features like webhooks and policies

### Tier 2: Wallet abstractions

Tier 2 support focuses on core wallet functionality:

* Curve-level cryptographic signatures that can be used for transaction signing
* Basic wallet functionality
* Integration with chain-specific libraries
* Chain address derivation
* 0-index HD wallet creation and key derivation
* Embedded wallets

### Tier 1: Cryptographic signing

Tier 1 provides fundamental cryptographic capabilities:

* Raw cryptographic signatures
* Basic key management

### Smart wallets, policies and more

Beyond this, Privy has advanced support for smart contract parsing as part of policies, native smart-contract wallet support and more.

Please reach out if you need this for the chain your product leverages.

<Info>
  Our roadmap prioritizes both expanding to new chains and enhancing support for existing chains by
  moving them to higher tiers.
</Info>

## Choosing the right integration

When building your application with Privy, consider the tier of support available for your target blockchain:

* **Tier 3 chains** offer the most seamless experience with full native functionality
* **Tier 2 chains** provide core transaction capabilities but may require chain-specific code
* **Tier 1 chains** support basic signing operations and require more custom implementation

For questions about specific chain support or to request prioritization of particular chains, please contact the Privy team.

<Warning>
  While all tiers allow for blockchain integration, lower tiers may require additional development
  effort to handle chain-specific operations.
</Warning>

<Tip>
  Learn more about configuring your application for different
  [EVM](/basics/react/advanced/configuring-evm-networks) and
  [Solana](/basics/react/advanced/configuring-evm-networks) networks
</Tip>


# Sign transaction inputs
Source: https://docs.privy.io/wallets/using-wallets/bitcoin/sign-transaction-inputs



<Info>
  With Privy, you can create Bitcoin (segwit) wallets and sign over transactions and any other
  arbitrary input. See the [Tier 2](/wallets/overview/chains) section for more details. Taproot
  wallets are coming soon.
</Info>

## Signing transaction inputs

Bitcoin uses the UTXO model, where each transaction consumes one or more inputs and produces one or more outputs. To sign a transaction using Privy, use Privy's raw sign functionality to sign each input hash, and then add the signature(s) to the transaction.

### Example

The following is an example using the [scure/btc-signer](https://github.com/paulmillr/scure-btc-signer) library to sign a transaction input.

```typescript {skip-check} theme={"system"}
import {p2pkh, OutScript} from '@scure/btc-signer/payment';
import {getInputType, getPrevOut, Transaction} from '@scure/btc-signer/transaction';
import {concatBytes} from '@scure/btc-signer/utils';
import secp256k1 from 'secp256k1';

const publicKey = "<the wallet's public key>";

const publicKeyBuffer = Buffer.from(publicKey, 'hex');
const tx = new Transaction({version: 1, allowLegacyWitnessUtxo: true});
// add as many outputs as needed, in this example there is only one
tx.addOutputAddress(outputAddress, outputAmount);

tx.addInput({
  txid, // buffer of utxo txid
  index: 0, // index of the output in the tx
  witnessUtxo: {
    amount: inputAmount,
    script: p2pkh(publicKeyBuffer).script
  }
});

// Loop through each input and sign it
for (let i = 0; i < tx.inputsLength; i++) {
  const input = tx.getInput(i);
  const inputType = getInputType(input, tx.opts.allowLegacyWitnessUtxo);
  const prevOut = getPrevOut(input);
  let script = inputType.lastScript;
  if (inputType.last.type === 'wpkh') {
    script = OutScript.encode({type: 'pkh', hash: inputType.last.hash});
  }
  const hash = tx.preimageWitnessV0(i, script, inputType.sighash, prevOut.amount);

  const signature = ''; // call Privy's raw sign function with bytesToHex(hash), returns '0x...'

  // convert to DER format
  const derSig = secp256k1.signatureImport(signature);

  // update the input with the signature
  tx.updateInput(
    i,
    {
      partialSig: [[publicKeyBuffer, concatBytes(derSig, new Uint8Array([inputType.sighash]))]]
    },
    true
  );
}

// finalize the transaction. It is now ready to be sent!
tx.finalize();
```


# null
Source: https://docs.privy.io/wallets/using-wallets/ethereum/ethereum-provider



## Getting an EIP-1193 provider

All of Privy's **`ConnectedWallet`** objects export a standard [EIP-1193 provider](https://eips.ethereum.org/EIPS/eip-1193) object. This allows your app to request signatures and transactions from the wallet, using familiar JSON-RPC requests like `personal_sign` or `eth_sendTransaction`.

<Info>
  [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193), also known as the Ethereum JavaScript API, is
  a standardized interface for how applications can request information, signatures, and
  transactions from a connected wallet.
</Info>

To request signatures or transactions from a connected wallet, you can either:

* use the wallet's EIP-1193 provider to send JSON-RPC requests to the wallet directly
* pass the wallet to a library like `viem`, `ethers`, or `wagmi`
* for the embedded wallet specifically, use Privy's native **`signMessage`** and **`sendTransaction`** methods to customize the signature and transaction prompts for users

To get a wallet's EIP-1193 provider, use the **`ConnectedWallet`** object's **`getEthereumProvider`** method:

```tsx  theme={"system"}
const provider = await wallet.getEthereumProvider();
```

When requesting signatures and transactions from the wallet, you can either choose to interface with the EIP1193 provider directly, or to pass it to a library like `wagmi` or `viem`.


# null
Source: https://docs.privy.io/wallets/using-wallets/ethereum/send-a-transaction



<Info>
  When using Privy's server-side SDKs to sign transactions, you can use the authorization context to
  automatically sign requests. Learn more about [signing on the
  server](/controls/authorization-keys/using-owners/sign/signing-on-the-server).
</Info>

<Tabs>
  <Tab title="React">
    To send a transaction from a wallet using the React SDK, use the `sendTransaction` method from the `useSendTransaction` hook:

    ```javascript  theme={"system"}
    sendTransaction: (input: UnsignedTransactionRequest, options?: {
      sponsor?: boolean;
      uiOptions?: SendTransactionModalUIOptions;
      fundWalletConfig?: FundWalletConfig;
      address?: string;
    }) => Promise<{ hash: HexString }>
    ```

    ### Usage

    ```javascript  theme={"system"}
    import {useSendTransaction, useWallets} from '@privy-io/react-auth';

    const {sendTransaction} = useSendTransaction();
    const {wallets} = useWallets();

    sendTransaction(
      {
        to: '0xE3070d3e4309afA3bC9a6b057685743CF42da77C',
        value: 100000
      },
      {
        address: wallets[0].address // Optional: Specify the wallet to use for signing. If not provided, the first wallet will be used.
      }
    );
    ```

    ### Parameters

    <ParamField path="input" type="UnsignedTransactionRequest" required>
      The details of the transaction to send on the chain.
    </ParamField>

    <ParamField path="options.sponsor" type="boolean">
      Optional parameter to enable gas sponsorship for this transaction. [Learn
      more.](/wallets/gas-and-asset-management/gas/overview)
    </ParamField>

    <ParamField path="options.uiOptions" type="SendTransactionModalUIOptions">
      The options for the UI of the send transaction modal. [Learn
      more](/wallets/using-wallets/ui-components).

      <Tip>
        To hide confirmation modals, set `options.uiOptions.showWalletUIs` to `false`. Learn more about
        configuring modal prompts [here](/recipes/react/manage-wallet-UIs).
      </Tip>
    </ParamField>

    <ParamField path="options.fundWalletConfig" type="FundWalletConfig">
      The configuration for funding the wallet.
    </ParamField>

    <ParamField path="options.address" type="string">
      The address of the wallet to use for sending the transaction. **Recommended when working with
      external wallets** to ensure reliable functionality. If not provided, the first wallet will be
      used.
    </ParamField>

    ### Returns

    <ResponseField name="hash" type="HexString">
      The hash for the broadcasted transaction.
    </ResponseField>
  </Tab>

  <Tab title="React Native">
    To send a transaction from a wallet using the React Native SDK use the `request` method from the wallets EIP1193 provider:

    ```javascript  theme={"system"}
    request: (request: { method: 'eth_sendTransaction', params: [SendTransactionParams] }) => Promise<HexString>
    ```

    <Note>
      The Expo SDK does not support built-in UIs for sending transactions.
      The `eth_sendTransaction` method gives you complete control over the experience and UI.
    </Note>

    ### Usage

    ```javascript  theme={"system"}
    import {useEmbeddedEthereumWallet} from '@privy-io/expo';

    const {wallets} = useEmbeddedEthereumWallet();
    const wallet = wallets[0];

    const provider = await wallet.getProvider();
    const accounts = await provider.request({
        method: 'eth_requestAccounts',
    });

    // Send transaction (will be signed and populated)
    const response = await provider.request({
        method: 'eth_sendTransaction',
        params: [
            {
                from: accounts[0],
                to: '0x0000000000000000000000000000000000000000',
                value: '0x2386F26FC10000',
            },
        ],
    });
    ```

    ### Parameters

    <ParamField path="request.method" type="'eth_sendTransaction'" required>
      The RPC method executed with the wallet.
    </ParamField>

    <ParamField path="request.params" type="SendTransactionParams" required>
      The details of the transaction to send on the chain.
    </ParamField>

    ### Returns

    <ResponseField name="response" type="HexString">
      The hash for the broadcasted transaction.
    </ResponseField>
  </Tab>

  <Tab title="Swift">
    Use the `request` method on the Ethereum provider to send a transaction with an Ethereum wallet.

    ```swift  theme={"system"}
    func request(_ request: EthereumRpcRequest) async throws -> String
    ```

    ### Usage

    ```swift  theme={"system"}
    let provider = wallet.provider

    let transaction = EthereumRpcRequest.UnsignedEthTransaction(
        from: wallet.address,
        to: "0xE3070d3e4309afA3bC9a6b057685743CF42da77C",
        value: .int(10000),
        chainId: .hexadecimal("0x2105") // Base, in hex
    )

    let transactionHash = try await provider.request(.ethSendTransaction(transaction: transaction)
    ```

    ### Parameters

    <ParamField path="transaction" type="EthereumRpcRequest.UnsignedEthTransaction" required>
      The transaction to send.

      <Expandable title="child attributes" defaultOpen="true">
        <ParamField path="from" type="string">
          The address sending the transaction (the user's wallet address).
        </ParamField>

        <ParamField path="to" type="string" required>
          The address to send the transaction to.
        </ParamField>

        <ParamField path="value" type="Quantity">
          The amount of wei to send, as an integer or hexadecimal string.
        </ParamField>

        <ParamField path="chainId" type="Quantity">
          The chain ID as an integer or hexadecimal string. Defaults to mainnet (0x1) if omitted.
        </ParamField>

        <ParamField path="data" type="string">
          The data to include with the transaction, as a hexadecimal string.
        </ParamField>

        <ParamField path="gasLimit" type="string">
          The gas limit for the transaction, as a hexadecimal string.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="transactionHash" type="string">
      The hash of the broadcasted transaction.
    </ResponseField>
  </Tab>

  <Tab title="Android">
    Use the `request` method on the Ethereum wallet provider to send a transaction with an Ethereum wallet.

    ```kotlin  theme={"system"}
    public suspend fun request(request: EthereumRpcRequest): Result<EthereumRpcResponse>
    ```

    ### Usage

    ```kotlin  theme={"system"}
    val transaction = JSONObject().apply {
        put("to", "0xE3070d3e4309afA3bC9a6b057685743CF42da77C")
        put("value", "0x186a0") // 100000 in hex
        put("chainId", "0x2105") // 8453 (Base) in hex
        put("from", ethereumWallet.address)
    }.toString()

    val result = ethereumWallet.provider.request(
        request = EthereumRpcRequest.ethSendTransaction(transaction),
    )

    when (result) {
        is Result.Success -> {
            val transactionHash = result.data.data
            // Handle successful transaction
        }
        is Result.Failure -> {
            // Handle error
        }
    }
    ```

    ### Parameters

    <ParamField path="method" type="'eth_sendTransaction'" required>
      The RPC method to execute with the wallet.
    </ParamField>

    <ParamField path="params" type="List<String>" required>
      Array containing the transaction JSON as a single string element.

      <Expandable title="child attributes" defaultOpen="true" defaultOpen="true">
        <ParamField path="to" type="string" required>
          The address to send the transaction to.
        </ParamField>

        <ParamField path="value" type="string">
          The amount of wei to send, as a hexadecimal string.
        </ParamField>

        <ParamField path="chainId" type="string">
          The chain ID as a hexadecimal string. Defaults to mainnet (0x1) if omitted.
        </ParamField>

        <ParamField path="from" type="string">
          The address sending the transaction (the user's wallet address).
        </ParamField>

        <ParamField path="data" type="string">
          The data to include with the transaction, as a hexadecimal string.
        </ParamField>

        <ParamField path="gasLimit" type="string">
          The gas limit for the transaction, as a hexadecimal string.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="result" type="Result<EthereumRpcResponse>">
      A Result that, when successful, contains the EthereumRpcResponse with:

      <Expandable title="child attributes" defaultOpen="true">
        <ResponseField name="method" type="string">
          The RPC method that was executed (eth\_sendTransaction).
        </ResponseField>

        <ResponseField name="data" type="string">
          The transaction hash for the broadcasted transaction.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="Unity">
    Use the `Request` method on the wallet's RPC provider to send a transaction with an Ethereum wallet.

    ```csharp  theme={"system"}
    public Task<RpcResponse> Request(RpcRequest request);
    ```

    ### Usage

    ```csharp  theme={"system"}
    // Create transaction JSON
    string transactionJson = JsonUtility.ToJson(new {
        to = "0xE3070d3e4309afA3bC9a6b057685743CF42da77C",
        value = "0x186a0", // 100000 in hex
        chainId = "0x2105", // 8453 (Base) in hex
        from = embeddedWallet.Address
    });

    // Create RPC request
    var rpcRequest = new RpcRequest
    {
        Method = "eth_sendTransaction",
        Params = new string[] { transactionJson }
    };

    // Send transaction
    RpcResponse transactionResponse = await embeddedWallet.RpcProvider.Request(rpcRequest);

    // Transaction hash is in the response data
    string transactionHash = transactionResponse.Data;
    ```

    ### Parameters

    <ParamField path="Method" type="'eth_sendTransaction'" required>
      The RPC method to execute with the wallet.
    </ParamField>

    <ParamField path="Params" type="string[]" required>
      Array containing the transaction JSON as a single string element.

      <Expandable title="child attributes" defaultOpen="true" defaultOpen="true">
        <ParamField path="to" type="string" required>
          The address to send the transaction to.
        </ParamField>

        <ParamField path="value" type="string">
          The amount of wei to send, as a hexadecimal string.
        </ParamField>

        <ParamField path="chainId" type="string">
          The chain ID as a hexadecimal string. Defaults to mainnet (0x1) if omitted.
        </ParamField>

        <ParamField path="from" type="string">
          The address sending the transaction (the user's wallet address).
        </ParamField>

        <ParamField path="data" type="string">
          The data to include with the transaction, as a hexadecimal string.
        </ParamField>

        <ParamField path="gasLimit" type="string">
          The gas limit for the transaction, as a hexadecimal string.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="RpcResponse" type="RpcResponse">
      An RPC response object with:

      <Expandable title="child attributes" defaultOpen="true">
        <ResponseField name="method" type="string">
          The RPC method that was executed (eth\_sendTransaction).
        </ResponseField>

        <ResponseField name="data" type="string">
          The transaction hash for the broadcasted transaction.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="Flutter">
    Use the `request` method on the Ethereum wallet provider to send a transaction with an Ethereum wallet.

    ```dart  theme={"system"}
    Future<Result<EthereumRpcResponse>> request(EthereumRpcRequest request);
    ```

    ### Usage

    ```dart  theme={"system"}
    // Create transaction parameters as a Map
    final transactionMap = {
        'to': '0xE3070d3e4309afA3bC9a6b057685743CF42da77C',
        'value': '0x186a0', // 100000 in hex
        'chainId': '0x2105', // 8453 (Base) in hex
        'from': ethereumWallet.address
    };

    // Convert Map to JSON string
    final transactionJson = jsonEncode(transactionMap);

    // Create the RPC request
    final rpcRequest = EthereumRpcRequest(
        method: 'eth_sendTransaction',
        params: [transactionJson],
    );

    // Send the transaction
    final result = await ethereumWallet.provider.request(rpcRequest);

    // Handle the result
    result.when(
        success: (response) {
            final transactionHash = response.data;
            print('Transaction sent with hash: $transactionHash');
        },
        failure: (error) {
            print('Failed to send transaction: $error');
        },
    );
    ```

    ### Parameters

    <ParamField path="method" type="'eth_sendTransaction'" required>
      The RPC method to execute with the wallet.
    </ParamField>

    <ParamField path="params" type="List<dynamic>" required>
      List containing the transaction JSON as a single string element.

      <Expandable title="child attributes" defaultOpen="true" defaultOpen="true">
        <ParamField path="to" type="string" required>
          The address to send the transaction to.
        </ParamField>

        <ParamField path="value" type="string">
          The amount of wei to send, as a hexadecimal string.
        </ParamField>

        <ParamField path="chainId" type="string">
          The chain ID as a hexadecimal string. Defaults to mainnet (0x1) if omitted.
        </ParamField>

        <ParamField path="from" type="string">
          The address sending the transaction (the user's wallet address).
        </ParamField>

        <ParamField path="data" type="string">
          The data to include with the transaction, as a hexadecimal string.
        </ParamField>

        <ParamField path="gasLimit" type="string">
          The gas limit for the transaction, as a hexadecimal string.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="result" type="Result<EthereumRpcResponse>">
      A Result that, when successful, contains the EthereumRpcResponse with:

      <Expandable title="child attributes" defaultOpen="true">
        <ResponseField name="method" type="string">
          The RPC method that was executed (eth\_sendTransaction).
        </ResponseField>

        <ResponseField name="data" type="string">
          The transaction hash for the broadcasted transaction.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="NodeJS">
    <Tip>
      Privy is fully compatible with popular web3 libraries for interfacing wallets, including [`viem`](https://viem.sh/), learn more [here](/wallets/using-wallets/ethereum/web3-integrations#node-js).
    </Tip>

    Use the `sendTransaction` method on the Ethereum interface to send a transaction with an Ethereum wallet.

    ### Usage

    ```js  theme={"system"}
    const {hash, caip2} = await privy.wallets().ethereum().sendTransaction('insert-wallet-id', {
        caip2: 'eip155:8453',
        params: {
            transaction: {
                to: '0xE3070d3e4309afA3bC9a6b057685743CF42da77C',
                value: '0x2386F26FC10000',
                chain_id: 8453,
            },
        },
        sponsor: true,
    });
    ```

    ### Parameters and Returns

    Check out the [API reference](/api-reference/wallets/ethereum/eth-send-transaction) for more details.

    <Warning>
      A successful response indicates that the transaction has been broadcasted to the network.
      Transactions may get broadcasted but still fail to be confirmed by the network. To handle these
      scenarios, see our guide on [speeding up transactions](/recipes/speeding-up-transactions).
    </Warning>
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    <Tip>
      Privy is fully compatible with popular web3 libraries for interfacing wallets, including [`viem`](https://viem.sh/), learn more [here](/wallets/using-wallets/ethereum/web3-integrations#node-js).
    </Tip>

    Use the `sendTransaction` method on the Ethereum client to send a transaction with an Ethereum wallet.

    ```js  theme={"system"}
    sendTransaction: (input: EthereumSendTransactionInputType) => Promise<EthereumSendTransactionResponseType>
    ```

    ### Usage

    ```js  theme={"system"}
    const {hash, caip2} = await privy.walletApi.ethereum.sendTransaction({
        walletId: 'insert-wallet-id',
        caip2: 'eip155:8453',
        transaction: {
            to: '0xE3070d3e4309afA3bC9a6b057685743CF42da77C',
            value: '0x2386F26FC10000',
            chainId: 8453,
        },
        sponsor: true,
    });
    ```

    ### Parameters

    <ParamField path="walletId" type="string" required>
      The ID of the wallet to send the transaction from.
    </ParamField>

    <ParamField path="caip2" type="`eip155:${number}`" required>
      The CAIP2 chain ID of the chain the transaction is being sent on.
    </ParamField>

    <ParamField path="transaction" type="EthereumTransactionType" required>
      The transaction to send.
    </ParamField>

    <ParamField path="sponsor" type="boolean">
      Optional parameter to enable gas sponsorship for this transaction. [Learn more.](/wallets/gas-and-asset-management/gas/overview)
    </ParamField>

    ### Returns

    <ResponseField name="hash" type="string">
      The hash for the broadcasted transaction.
    </ResponseField>

    <ResponseField name="caip2" type="`eip155:${number}`">
      The CAIP2 chain ID of the chain the transaction was sent on.
    </ResponseField>

    <Warning>
      A successful response indicates that the transaction has been broadcasted to the network.
      Transactions may get broadcasted but still fail to be confirmed by the network. To handle these
      scenarios, see our guide on [speeding up transactions](/recipes/speeding-up-transactions).
    </Warning>
  </Tab>

  <Tab title="REST API">
    To send a transaction, make a `POST` request to

    ```bash  theme={"system"}
    https://api.privy.io/v1/wallets/<wallet_id>/rpc
    ```

    <Info>
      Wallets with `owner_id` present must provide an [authorization signature](/api-reference/authorization-signatures) as a request header.

      If you are transacting with a user wallet, you must provide the user's [authorization signature](/api-reference/authorization-signatures#get-an-authorization-key).
    </Info>

    ### Usage

    ```bash  theme={"system"}
    $ curl --request POST https://api.privy.io/v1/wallets/<wallet_id>/rpc \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H "privy-authorization-signature: <authorization-signature-for-request>" \
    -H 'Content-Type: application/json' \
    -d '{
        "method": "eth_sendTransaction",
        "caip2": "eip155:1",
        "params": {
            "transaction": {
                "to": "0xE3070d3e4309afA3bC9a6b057685743CF42da77C",
                "value": "0x2386F26FC10000",
            }
        },
        "sponsor": true
    }'
    ```

    A successful response will look like the following:

    ```json  theme={"system"}
    {
        "method": "eth_sendTransaction",
        "data": {
            "hash": "<transaction-hash>",
            "caip2": "eip155:1"
        }
    }
    ```

    ### Parameters

    <ParamField path="method" type="'eth_sendTransaction'" required>
      The RPC method executed with the wallet.
    </ParamField>

    <ParamField path="caip2" type="`eip155:${number}`" required>
      The CAIP2 chain ID of the chain the transaction is being sent on.
    </ParamField>

    <ParamField path="params.transaction" type="EthereumTransactionType" required>
      The details of the transaction to send on the chain.
    </ParamField>

    <ParamField path="sponsor" type="boolean">
      Optional parameter to enable gas sponsorship for this transaction. [Learn more.](/wallets/gas-and-asset-management/gas/overview)
    </ParamField>

    ### Returns

    <ResponseField name="method" type="'eth_sendTransaction'">
      The RPC method executed with the wallet.
    </ResponseField>

    <ResponseField name="data.hash" type="string">
      The hash for the broadcasted transaction.
    </ResponseField>

    <ResponseField name="data.caip2" type="`eip155:${number}`">
      The CAIP2 chain ID of the chain the transaction was sent on.
    </ResponseField>

    <Warning>
      A successful response indicates that the transaction has been broadcasted to the network.
      Transactions may get broadcasted but still fail to be confirmed by the network. To handle these
      scenarios, see our guide on [speeding up transactions](/recipes/speeding-up-transactions).
    </Warning>
  </Tab>

  <Tab title="Python">
    ```python  theme={"system"}
    from .internal_client import generate_client
    client = generate_client()

    tx = client.wallets.rpc(
        wallet_id=user.wallet_id,
        method="eth_sendTransaction",
        caip2="eip155:1",
        params={
            "transaction": {
                "to": "0xE3070d3e4309afA3bC9a6b057685743CF42da77C",
                "value": 100000,
            },
        },
    )
    return {"data": tx.data}
    ```
  </Tab>

  <Tab title="Java">
    To send a transaction from your wallet, use the `sendTransaction` method.
    It will populate missing network-related values (gas limit, gas fee values, nonce, type),
    sign your transaction, broadcast it to the network, and return the transaction hash to you.

    ### Usage

    ```java  theme={"system"}
    try {
        String caip2 = "eip155:11155111"; // Sepolia testnet

        EthereumSendTransactionRpcInputTransaction txn = EthereumSendTransactionRpcInputTransaction.builder()
            .to(recipientAddress)
            .value(EthereumSendTransactionRpcInputValue.of("0x1")) // 1 wei
            .chainId(EthereumSendTransactionRpcInputChainId.of(11_155_111)) // Sepolia testnet
            .build();

        // Example: If wallet's owner is an authorization private key
        AuthorizationContext authorizationContext = AuthorizationContext.builder()
            .addAuthorizationPrivateKey("authorization-key")
            .build();

        EthereumSendTransactionRpcResponseData response = privyClient
            .wallets()
            .ethereum()
            .sendTransaction(
                walletId,
                caip2,
                txn,
                authorizationContext
            );

        String transactionHash = response.hash();
    } catch (APIException e) {
        String errorBody = e.bodyAsString();
        System.err.println(errorBody);
    } catch (Exception e) {
        System.err.println(e.getMessage());
    }
    ```

    ### Parameters

    When defining a transaction, you may specify the following values on the `EthereumSendTransactionRpcInputTransaction` builder:

    <ParamField type="String" body="from">
      The address sending the transaction (the user's wallet address).
    </ParamField>

    <ParamField type="String" body="to">
      The address to send the transaction to.
    </ParamField>

    <ParamField type="EthereumSendTransactionRpcInputChainId" body="chainId">
      The ID of the chain the transaction is being sent on.
    </ParamField>

    <ParamField type="EthereumSendTransactionRpcInputNonce" body="nonce">
      The nonce for the transaction.
    </ParamField>

    <ParamField type="String" body="data">
      The data to include with the transaction, as a hexadecimal string.
    </ParamField>

    <ParamField type="EthereumSendTransactionRpcInputValue" body="value">
      The amount of wei to send, as an integer or hexadecimal string.
    </ParamField>

    <ParamField type="Object" body="type">
      The type of transaction to send.
    </ParamField>

    <ParamField type="EthereumSendTransactionRpcInputGasLimit" body="gasLimit">
      The gas limit for the transaction, as a hexadecimal string.
    </ParamField>

    <ParamField type="EthereumSendTransactionRpcInputGasPrice" body="gasPrice">
      The gas price for the transaction, as a hexadecimal string.
    </ParamField>

    <ParamField type="EthereumSendTransactionRpcInputMaxFeePerGas" body="maxFeePerGas">
      The maximum fee per gas for the transaction, as a hexadecimal string.
    </ParamField>

    <ParamField type="EthereumSendTransactionRpcInputMaxPriorityFeePerGas" body="maxPriorityFeePerGas">
      The maximum priority fee per gas for the transaction, as a hexadecimal string.
    </ParamField>

    ### Returns

    The `EthereumSendTransactionRpcResponseData` object contains a `hash()` field

    <ResponseField name="hash()" type="String">
      The hash of the broadcasted transaction.
    </ResponseField>
  </Tab>

  <Tab title="Rust">
    Use the `send_transaction` method on the Ethereum service to sign and broadcast a transaction.

    ### Usage

    ```rust  theme={"system"}
    use privy_rs::{AuthorizationContext, PrivyClient};

    let client = PrivyClient::new("app_id".to_string(), "app_secret".to_string())?;
    let ethereum_service = client.wallets().ethereum();
    let auth_ctx = AuthorizationContext::new();

    let transaction = EthereumSendTransactionRpcInputParamsTransaction {
        to: Some("0x742d35Cc6635C0532925a3b8c17d6d1E9C2F7ca".to_string()),
        value: None,
        gas_limit: None,
        max_fee_per_gas: None,
        max_priority_fee_per_gas: None,
        data: None,
        chain_id: None,
        from: None,
        gas_price: None,
        nonce: None,
        type_: None,
    };

    let result = ethereum_service
        .send_transaction(
            &wallet_id,
            "eip155:1",
            transaction,
            &auth_ctx,
            None,
        )
        .await?;

    println!("Transaction sent successfully");
    ```

    ### Parameters and Returns

    See the Rust SDK documentation for detailed parameter and return types, including embedded examples:

    * [EthereumService::send\_transaction](https://docs.rs/privy-rs/latest/privy_rs/ethereum/struct.EthereumService.html#method.send_transaction)

    For REST API details, see the [API reference](/api-reference/wallets/ethereum/eth-send-transaction).

    <Warning>
      A successful response indicates that the transaction has been broadcasted to the network.
      Transactions may get broadcasted but still fail to be confirmed by the network. To handle these
      scenarios, see our guide on [speeding up transactions](/recipes/speeding-up-transactions).
    </Warning>
  </Tab>
</Tabs>

<Note>
  For a complete example of sending USDC with Privy's SDKs, see our [Sending USDC
  recipe](/recipes/send-usdc).
</Note>


# Sign EIP-7702 authorization
Source: https://docs.privy.io/wallets/using-wallets/ethereum/sign-7702-authorization



[EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) enables externally owned accounts (EOAs) to delegate their execution to smart contract code. This allows EOA wallets to gain account abstraction capabilities such as transaction bundling, gas sponsorship, and custom permissions.

Privy provides methods to sign EIP-7702 authorizations, which allows your embedded wallets to be upgraded into any smart contract. Learn more about [EIP-7702](/recipes/react/eip-7702) and how to use it with various account abstraction providers.

<Info>EIP-7702 authorization signing is supported in the React SDK, REST API, and Node SDK.</Info>

<Info>
  When using Privy's server-side SDKs to sign EIP-7702 authorizations, you can use the authorization
  context to automatically sign requests. Learn more about [signing on the
  server](/controls/authorization-keys/using-owners/sign/signing-on-the-server).
</Info>

<Tabs>
  <Tab title="React">
    Use the `useSign7702Authorization` hook to sign an EIP-7702 authorization with your user's wallet.

    ```tsx  theme={"system"}
    import {useSign7702Authorization} from '@privy-io/react-auth';

    const {signAuthorization} = useSign7702Authorization();
    ```

    ### Usage

    ```tsx  theme={"system"}
    import {useSign7702Authorization, useWallets} from '@privy-io/react-auth';

    function Sign7702Button() {
        const {signAuthorization} = useSign7702Authorization();
        const {wallets} = useWallets();

        const handleSign = async () => {
            try {
                const authorization = await signAuthorization({
                    contractAddress: '0x1234567890abcdef1234567890abcdef12345678',
                    chainId: 1, // Ethereum mainnet
                    nonce: 0 // Optional, defaults to current nonce
                }, {
                    address: wallets[0].address // Optional: Specify the wallet to use for signing. If not provided, the first wallet will be used.
                });

                console.log('Signed authorization:', authorization);
                // Use the authorization with your AA provider
            } catch (error) {
                console.error('Failed to sign authorization:', error);
            }
        };

        return (
            <button onClick={handleSign}>
                Sign EIP-7702 Authorization
            </button>
        );
    }
    ```

    ### Parameters

    <ParamField path="contractAddress" type="string" required>
      The address of the smart contract whose code the EOA will delegate to. This is typically an account implementation contract from your AA provider.
    </ParamField>

    <ParamField path="chainId" type="number" required>
      The chain ID where the authorization will be used.
    </ParamField>

    <ParamField path="nonce" type="number">
      The nonce for the authorization. If not provided, the current transaction count for the wallet will be used.
    </ParamField>

    <ParamField path="options.address" type="string">
      The address of the wallet to use for signing the authorization. **Recommended when working with external wallets** to ensure reliable functionality. If not provided, the first wallet will be used.
    </ParamField>

    ### Returns

    <ResponseField name="authorization" type="Authorization">
      The signed EIP-7702 authorization object containing:

      <Expandable title="properties">
        <ResponseField name="contractAddress" type="string">
          The smart contract address the EOA is delegating to.
        </ResponseField>

        <ResponseField name="chainId" type="number">
          The chain ID for the authorization.
        </ResponseField>

        <ResponseField name="nonce" type="number">
          The nonce used in the authorization.
        </ResponseField>

        <ResponseField name="r" type="string">
          The r value of the ECDSA signature.
        </ResponseField>

        <ResponseField name="s" type="string">
          The s value of the ECDSA signature.
        </ResponseField>

        <ResponseField name="yParity" type="number">
          The yParity value of the ECDSA signature.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="React Native">
    Sign an EIP-7702 authorization using viem and the `@privy-io/expo` SDK.

    ### Usage

    ```ts  theme={"system"}
    import {useEmbeddedEthereumWallet} from '@privy-io/expo';
    import {createWalletClient, custom} from 'viem;
    import {hashAuthorization} from 'viem/utils';
    import {mainnet} from 'viem/chains';

    const {wallets} = useEmbeddedEthereumWallet();
    const wallet = wallets[0]
    const provider = await wallet.getProvider()

    const client = createWalletClient({
      account: wallet.address as `0x${string}`,
      chain: mainnet,
      transport: custom(provider) // or another provider
    });

    const authorizationPayload = await walletClient.prepareAuthorization({
      account: selectedWallet.address as `0x${string}`,
      contract: '0x1234567890abcdef1234567890abcdef12345678',
      chainId: 1,
    });

    const hashedAuthorization = hashAuthorization(authorizationPayload);

    const authorization = provider.request({
      method: 'secp256k1_sign',
      params: [hashedAuthorization]
    });
    ```

    ### Parameters and Returns

    Check out the [sign raw hash doc](/wallets/using-wallets/ethereum/sign-a-raw-hash#react-native) for more details.
  </Tab>

  <Tab title="REST API">
    Sign an EIP-7702 authorization by making a `POST` request to:

    ```bash  theme={"system"}
    https://api.privy.io/v1/wallets/<wallet_id>/rpc
    ```

    ### Usage

    ```bash  theme={"system"}
    $ curl --request POST https://api.privy.io/v1/wallets/<wallet_id>/rpc \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H "privy-authorization-signature: <authorization-signature-for-request>" \
    -H 'Content-Type: application/json' \
    -d '{
        "method": "eth_sign7702Authorization",
        "params": {
            "contract": "0x1234567890abcdef1234567890abcdef12345678",
            "chain_id": 1,
            "nonce": 0
        }
    }'
    ```

    A successful response will look like:

    ```json  theme={"system"}
    {
      "method": "eth_sign7702Authorization",
      "data": {
        "authorization": {
          "address": "0x1234567890abcdef1234567890abcdef12345678",
          "chain_id": 1,
          "nonce": 0,
          "r": "0x...",
          "s": "0x...",
          "y_parity": "0"
        }
      }
    }
    ```

    ### Parameters

    <ParamField path="method" type="'eth_sign7702Authorization'" required>
      The RPC method to execute.
    </ParamField>

    <ParamField path="params" type="Object" required>
      <ParamField path="contract" type="string" required>
        The address of the smart contract whose code the EOA will delegate to.
      </ParamField>

      <ParamField path="chain_id" type="number" required>
        The chain ID where the authorization will be used.
      </ParamField>

      <ParamField path="nonce" type="number">
        The nonce for the authorization. If not provided, the current transaction count will be used.
      </ParamField>
    </ParamField>

    ### Returns

    <ResponseField name="method" type="'eth_sign7702Authorization'">
      The RPC method that was executed.
    </ResponseField>

    <ResponseField name="data.authorization" type="Object">
      The signed EIP-7702 authorization containing:

      <Expandable title="properties">
        <ResponseField name="contract" type="Hex">
          The smart contract address the EOA is delegating to.
        </ResponseField>

        <ResponseField name="chain_id" type="number">
          The chain ID for the authorization.
        </ResponseField>

        <ResponseField name="nonce" type="number">
          The nonce used in the authorization.
        </ResponseField>

        <ResponseField name="r" type="Hex">
          The r value of the ECDSA signature.
        </ResponseField>

        <ResponseField name="s" type="Hex">
          The s value of the ECDSA signature.
        </ResponseField>

        <ResponseField name="y_parity" type="number">
          The yParity value of the ECDSA signature.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="NodeJS">
    Use the `sign7702Authorization` method on the Ethereum interface to sign an EIP-7702 authorization with an Ethereum wallet.

    ### Usage

    ```tsx  theme={"system"}
    const authorization = await privy.wallets().ethereum().sign7702Authorization('insert-wallet-id', {
      params: {
        contract: '0x1234567890abcdef1234567890abcdef12345678',
        chainId: 1,
        nonce: 0 // Optional
      }
    });
    ```

    ### Parameters and Returns

    Check out the [API reference](/api-reference/wallets/ethereum/eth-sign-7702-authorization) for more details.
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    Use the `sign7702Authorization` method on the Ethereum client to sign an EIP-7702 authorization with an Ethereum wallet.

    ```javascript  theme={"system"}
    sign7702Authorization: async ({walletId: string, contract: string, chainId: number, nonce?: number, idempotencyKey?: string}) => Promise<{chainId, contract, nonce, yParity, r, s}>
    ```

    ### Usage

    ```tsx  theme={"system"}
    const authorization = await privy.walletApi.ethereum.sign7702Authorization({
        walletId: 'insert-wallet-id',
        contract: '0x1234567890abcdef1234567890abcdef12345678',
        chainId: 1,
        nonce: 0 // Optional
    });
    ```

    ### Parameters

    <ParamField path="walletId" type="string" required>
      Unique ID of the wallet to take actions with.
    </ParamField>

    <ParamField path="contract" type="Hex" required>
      The address of the smart contract whose code the EOA will delegate to.
    </ParamField>

    <ParamField path="chainId" type="number" required>
      The chain ID where the authorization will be used.
    </ParamField>

    <ParamField path="nonce" type="number">
      The nonce for the authorization. If not provided, the current transaction count will be used.
    </ParamField>

    <ParamField path="idempotencyKey" type="string">
      [Idempotency key](/api-reference/idempotency-keys) to identify a unique request.
    </ParamField>

    ### Returns

    <ResponseField name="chainId" type="number">
      The chain ID for the authorization.
    </ResponseField>

    <ResponseField name="contract" type="Hex">
      The smart contract address the EOA is delegating to.
    </ResponseField>

    <ResponseField name="nonce" type="number">
      The nonce used in the authorization.
    </ResponseField>

    <ResponseField name="yParity" type="number">
      The yParity value of the ECDSA signature.
    </ResponseField>

    <ResponseField name="r" type="Hex">
      The r value of the ECDSA signature.
    </ResponseField>

    <ResponseField name="s" type="Hex">
      The s value of the ECDSA signature.
    </ResponseField>
  </Tab>

  <Tab title="Java">
    To sign an EIP-7702 authorization from your wallet, use the `sign7702Authorization` method.

    ### Usage

    ```java  theme={"system"}
    try {
        EthereumSign7702AuthorizationRpcInputParams authorization = EthereumSign7702AuthorizationRpcInputParams.builder()
            .contract("0x1234567890123456789012345678901234567890")
            .chainId(EthereumSign7702AuthorizationRpcInputChainId.of(1))
            .nonce(EthereumSign7702AuthorizationRpcInputNonce.of(1))
            .build();

        // Example: If wallet's owner is an authorization private key
        AuthorizationContext authorizationContext = AuthorizationContext.builder()
            .addAuthorizationPrivateKey("authorization-key")
            .build();

        EthereumSign7702AuthorizationRpcResponseData response = privyClient
            .wallets()
            .ethereum()
            .sign7702Authorization(
                walletId,
                authorization,
                authorizationContext
            );

        Authorization authorization = response.authorization();
    } catch (APIException e) {
        String errorBody = e.bodyAsString();
        System.err.println(errorBody);
    } catch (Exception e) {
        System.err.println(e.getMessage());
    }
    ```

    ### Parameters

    When defining an EIP-7702 authorization, you may specify the following values on the
    `EthereumSign7702AuthorizationRpcInputParams` builder:

    <ParamField type="String" body="contract">
      The address of the smart contract whose code the EOA will delegate to.
    </ParamField>

    <ParamField type="EthereumSign7702AuthorizationRpcInputChainId" body="chainId">
      The chain ID where the authorization will be used.
    </ParamField>

    <ParamField type="EthereumSign7702AuthorizationRpcInputNonce" body="nonce">
      The nonce for the authorization.
    </ParamField>

    ### Returns

    The `EthereumSign7702AuthorizationRpcResponseData` object contains a `authorization()` field

    <ResponseField name="authorization()" type="Authorization">
      The signed EIP-7702 authorization.

      <Expandable defaultOpen="true">
        <ResponseField name="contract" type="String">
          The smart contract address the EOA is delegating to.
        </ResponseField>

        <ResponseField name="chainId" type="EthereumSign7702AuthorizationRpcInputChainId">
          The chain ID for the authorization.
        </ResponseField>

        <ResponseField name="nonce" type="EthereumSign7702AuthorizationRpcInputNonce">
          The nonce used in the authorization.
        </ResponseField>

        <ResponseField name="r" type="String">
          The r value of the ECDSA signature.
        </ResponseField>

        <ResponseField name="s" type="String">
          The s value of the ECDSA signature.
        </ResponseField>

        <ResponseField name="yParity" type="double">
          The yParity value of the ECDSA signature.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="Rust">
    Use the `sign_7702_authorization` method on the Ethereum service to sign an EIP-7702 authorization.

    ### Usage

    ```rust  theme={"system"}
    use privy_rs::{AuthorizationContext, PrivyClient};

    let client = PrivyClient::new("app_id".to_string(), "app_secret".to_string())?;
    let ethereum_service = client.wallets().ethereum();
    let auth_ctx = AuthorizationContext::new();

    let params = EthereumSign7702AuthorizationRpcInputParams {
        chain_id: EthereumSign7702AuthorizationRpcInputParamsChainId::Integer(1),
        contract: "0x1234567890abcdef1234567890abcdef12345678".to_string(),
        nonce: None,
    };

    let authorization = ethereum_service
        .sign_7702_authorization(&wallet_id, params, &auth_ctx, None)
        .await?;

    println!("7702 authorization signed successfully");
    ```

    ### Parameters and Returns

    See the Rust SDK documentation for detailed parameter and return types, including embedded examples:

    * [EthereumService::sign\_7702\_authorization](https://docs.rs/privy-rs/latest/privy_rs/ethereum/struct.EthereumService.html#method.sign_7702_authorization)

    For REST API details, see the [API reference](/api-reference/wallets/ethereum/eth-sign-7702-authorization).
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/wallets/using-wallets/ethereum/sign-a-message



<Info>
  This method uses Ethereum's `personal_sign` RPC method. If you are looking for a low-level raw
  signature over a input hash, see
  [secp256k1\_sign](/wallets/using-wallets/ethereum/sign-a-raw-hash).
</Info>

<Info>
  When using Privy's server-side SDKs to sign messages, you can use the authorization context to
  automatically sign requests. Learn more about [signing on the
  server](/controls/authorization-keys/using-owners/sign/signing-on-the-server).
</Info>

<Tabs>
  <Tab title="React">
    Use the `signMessage` method exported from the `useSignMessage` hook to sign a message with an Ethereum embedded wallet.

    ### Usage

    ```tsx  theme={"system"}
    import {useSignMessage, useWallets} from '@privy-io/react-auth';

    const {signMessage} = useSignMessage();
    const {wallets} = useWallets();

    const uiOptions = {
      title: 'You are voting for foobar project'
    };

    const {signature} = await signMessage(
      {message: 'I hereby vote for foobar'},
      {
        uiOptions,
        address: wallets[0].address // Optional: Specify the wallet to use for signing. If not provided, the first wallet will be used.
      }
    );
    ```

    ### Parameters

    <ParamField path="message" type="string" required>
      Message to be signed.
    </ParamField>

    <ParamField path="options" type="Object">
      <Expandable title="properties" defaultOpen="true">
        <ParamField path="uiOptions" type="SignMessageModalUIOptions">
          UI options to customize the signature prompt modal. [Learn
          more](/wallets/using-wallets/ui-components)

          <Tip>
            To hide confirmation modals, set `options.uiOptions.showWalletUIs` to `false`. Learn more
            about configuring modal prompts [here](/recipes/react/manage-wallet-UIs).
          </Tip>
        </ParamField>

        <ParamField path="address" type="string">
          Address of the wallet to use for signing the message. **Recommended when working with external
          wallets** to ensure reliable functionality. If not provided, the first wallet will be used.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    {' '}

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>

    ### Callbacks

    Configure callbacks for Privy's `signMessage` method on the `useSignMessage` hook:

    ```tsx  theme={"system"}
    import {useSignMessage} from '@privy-io/react-auth';

    const {signMessage} = useSignMessage({
      onSuccess: ({signature}) => {
        console.log(signature);
        // Any logic you'd like to execute after a user successfully signs a message
      },
      onError: (error) => {
        console.log(error);
        // Any logic you'd like to execute after a user exits the message signing flow or there is an error
      }
    });

    // Then call `signMessage` in your code, which will invoke these callbacks on completion
    ```

    As parameters to **`useSignMessage`**, you may include an **`onSuccess`** callback and/or an **`onError`** callback.

    While this component is mounted, any invocation of **`signMessage`** will trigger the **`onSuccess`** callback or **`onError`** callback on completion, depending on if the message was successfully signed or not.

    #### onSuccess

    If set, the **`onSuccess`** callback will execute after a user has successfully signed the message. Within this callback, you can access a **`signature`** parameter, which is the **`signature`** string value generated by the wallet to sign the message.

    #### onError

    If set, the **`onError`** callback will execute after a user attempts to sign a message and there is an error, or if the user exits the signature flow prematurely. Within this callback, you may access an **`error`** code with more information about the error.
  </Tab>

  <Tab title="React Native">
    Request a message signature on the wallets Ethereum provider.

    ### Usage

    ```tsx  theme={"system"}
    import {useEmbeddedEthereumWallet} from '@privy-io/expo';

    const {wallets} = useEmbeddedEthereumWallet();
    const wallet = wallets[0];

    // Get an EIP-1193 Provider
    const provider = await wallet.getProvider();
    // Get address
    const accounts = await provider.request({
      method: 'eth_requestAccounts'
    });

    // Sign message
    const message = 'I hereby vote for foobar';
    const signature = await provider.request({
      method: 'personal_sign',
      params: [message, accounts[0]]
    });
    ```

    ### Parameters

    <ParamField path="method" type="'personal_sign'" required>
      The method for the wallet request. For signing messages, this is `'personal_sign'`.
    </ParamField>

    <ParamField path="params" type="Object" required>
      <Expandable title="properties" defaultOpen="true">
        <ParamField path="message" type="string | Uint8Array" required>
          The string or bytes to sign with the wallet.
        </ParamField>

        <ParamField path="address" type="string">
          The address of the wallet to sign the message with.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="Swift">
    Request a message signature on the wallet's Ethereum provider.

    ### Usage

    ```swift  theme={"system"}
    guard let user = privy.user else {
        // If user is null, user is not authenticated
        return
    }

    // Retrieve list of user's embedded Ethereum wallets
    let ethereumWallets = user.embeddedEthereumWallets

    // Grab the desired wallet. Here, we retrieve the first wallet
    guard let wallet = ethereumWallets.first else {
        // No ETH wallets
        return
    }

    let signature = try await wallet.provider.request(.personalSign(message: "A message to sign", address: wallet.add))

    print("Result signature: \(signature)")
    ```

    ### Parameters

    <ParamField path="message" type="string" required>
      The string to sign with the wallet.
    </ParamField>

    <ParamField path="address" type="string">
      The address of the wallet to sign the message with.
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="Android">
    ### Usage

    ```kotlin  theme={"system"}
    // Get Privy user
    val user = privy.user

    // check if user is authenticated
    if (user != null) {
      // Retrieve list of user's embedded Ethereum wallets
      val ethereumWallets = user.embeddedEthereumWallets

      if (ethereumWallets.isNotEmpty()) {
        // Grab the desired wallet. Here, we retrieve the first wallet
        val ethereumWallet = ethereumWallets.first()

        // Make an rpc request
        ethereumWallet.provider.request(
          request = EthereumRpcRequest.personalSign("A message to sign", ethereumWallet.address),
        )
      }
    }
    ```

    ### Parameters

    <ParamField path="method" type="'personal_sign'" required>
      The method for the wallet request. For signing messages, this is `'personal_sign'`.
    </ParamField>

    <ParamField path="params" type="Object" required>
      <Expandable title="properties" defaultOpen="true">
        <ParamField path="message" type="string | Uint8Array" required>
          The string or bytes to sign with the wallet.
        </ParamField>

        <ParamField path="address" type="string">
          The address of the wallet to sign the message with.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    {' '}

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="Unity">
    ### Usage

    ```csharp  theme={"system"}
    try {
        IEmbeddedEthereumWallet embeddedWallet = PrivyManager.Instance.User.EmbeddedWallets[0];
        var rpcRequest = new RpcRequest
        {m
            Method = "personal_sign",
            Params = new string[] { "A message to sign", embeddedWallet.Address }  // Use the 'new' keyword here
        };
        RpcResponse personalSignResponse = await embeddedWallet.RpcProvider.Request(rpcRequest);
        Debug.Log(personalSignResponse.Data);
    } catch (PrivyException.EmbeddedWalletException ex){
        Debug.LogError($"Could not sign message due to error: {ex.Error} {ex.Message}");
    } catch (Exception ex) {
        Debug.LogError($"Could not sign message exception {ex.Message}");
    }
    ```

    ### Parameters

    <ParamField path="method" type="'personal_sign'" required>
      The method for the wallet request. For signing messages, this is `'personal_sign'`.
    </ParamField>

    <ParamField path="params" type="Object" required>
      <Expandable title="properties" defaultOpen="true">
        <ParamField path="message" type="string | Uint8Array" required>
          The string or bytes to sign with the wallet.
        </ParamField>

        <ParamField path="address" type="string">
          The address of the wallet to sign the message with.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    {' '}

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="Flutter">
    ### Usage

    ```dart  theme={"system"}
    // Get an EIP-1193 Provider
    final ethereumWallet = privy.user.embeddedEthereumWallets.first;
    final provider = ethereumWallet.provider;

    // Sign message
    final message = 'A message to you Rudy';
    final request = EthereumRpcRequest(
      method: 'personal_sign',
      params: [message, ethereumWallet.address],
    );

    final result = await provider.request(request);

    result.fold(
      onSuccess: (response) {
        final signature = response.data;
        print('Signature: $signature');
      },
      onFailure: (error) {
        print('Error signing message: ${error.message}');
      },
    );
    ```

    ### Parameters

    <ParamField path="method" type="'personal_sign'" required>
      The method for the wallet request. For signing messages, this is `'personal_sign'`.
    </ParamField>

    <ParamField path="params" type="Object" required>
      <Expandable title="properties" defaultOpen="true">
        <ParamField path="message" type="string | Uint8Array" required>
          The string or bytes to sign with the wallet.
        </ParamField>

        <ParamField path="address" type="string">
          The address of the wallet to sign the message with.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="method" type="'personal_sign'">
      The RPC method executed with the wallet.
    </ResponseField>

    <ResponseField name="data" type="Object">
      Outputs for the RPC method executed with the wallet.

      <Expandable title="properties" defaultOpen="true">
        <ResponseField name="signature" type="string">
          An encoded string serializing the signature produced by the user's wallet.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="NodeJS">
    Use the `signMessage` method on the Ethereum interface to sign a message with an Ethereum wallet.

    ### Usage

    ```tsx  theme={"system"}
    const {signature, encoding} = await privy.wallets().ethereum().signMessage('insert-wallet-id', {
      message: 'Hello world'
    });
    ```

    ### Parameters and Returns

    Check out the [API reference](/api-reference/wallets/ethereum/personal-sign) for more details.
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    Use the `signMessage` method on the Ethereum client to sign a message with an Ethereum wallet.

    ```javascript  theme={"system"}
    signMessage: async ({walletId: string, message: string, idempotencyKey?: string}) => Promise<{signature: string, encoding: 'hex'}>
    ```

    ### Usage

    ```tsx  theme={"system"}
    const {signature, encoding} = await privy.walletApi.ethereum.signMessage({
      walletId: 'insert-wallet-id',
      message: 'Hello world'
    });
    ```

    ### Parameters

    <ParamField path="walletId" type="string" required>
      Unique ID of the wallet to take actions with.
    </ParamField>

    <ParamField path="message" type="string | Uint8Array" required>
      The string or bytes to sign with the wallet.
    </ParamField>

    <ParamField path="idempotencyKey" type="string">
      [Idempotency key](/api-reference/idempotency-keys) to identify a unique request.
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="string">
      An encoded string serializing the signature produced by the user's wallet.
    </ResponseField>

    <ResponseField name="encoding" type="'hex'">
      The encoding format for the returned `signature`. Currently, only `'hex'` is supported for
      Ethereum.
    </ResponseField>
  </Tab>

  <Tab title="Java">
    To sign a message from your wallet, use the `signMessage` method.
    It will sign your message, and return the signature to you.

    ### Usage

    ```java  theme={"system"}
    try {
        String message = "Hello, Ethereum.";

        // Example: If wallet's owner is an authorization private key
        AuthorizationContext authorizationContext = AuthorizationContext.builder()
            .addAuthorizationPrivateKey("authorization-key")
            .build();

        EthereumPersonalSignRpcResponseData response = privyClient
            .wallets()
            .ethereum()
            .signMessage(
                walletId,
                message.getBytes(StandardCharsets.UTF_8),
                authorizationContext
            );

        String signature = response.signature();
    } catch (APIException e) {
        String errorBody = e.bodyAsString();
        System.err.println(errorBody);
    } catch (Exception e) {
        System.err.println(e.getMessage());
    }
    ```

    ### Parameters

    When signing a message with your Ethereum wallet, you can sign over the raw bytes of the message or a hex string encoding.

    <ParamField type="byte[]" body="message">
      The raw bytes of the message to sign over.
    </ParamField>

    <ParamField type="String" body="message">
      Alternatively, a hex string encoding of the message to sign over.
    </ParamField>

    ### Returns

    The `EthereumPersonalSignRpcResponseData` object contains a `signature()` field

    <ResponseField name="signature()" type="String">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="Rust">
    Use the `sign_message` method on the Ethereum service to sign a UTF-8 message with an Ethereum wallet.

    ### Usage

    ```rust  theme={"system"}
    use privy_rs::{AuthorizationContext, PrivyClient};

    let client = PrivyClient::new("app_id".to_string(), "app_secret".to_string())?;
    let ethereum_service = client.wallets().ethereum();
    let auth_ctx = AuthorizationContext::new();

    let signature = ethereum_service
        .sign_message(
            &wallet_id,
            "Hello, Ethereum!",
            &auth_ctx,
            Some("unique-request-id-123"),
        )
        .await?;

    println!("Message signed successfully");
    ```

    ### Parameters and Returns

    See the Rust SDK documentation for detailed parameter and return types, including embedded examples:

    * [EthereumService::sign\_message](https://docs.rs/privy-rs/latest/privy_rs/ethereum/struct.EthereumService.html#method.sign_message)

    For REST API details, see the [API reference](/api-reference/wallets/ethereum/personal-sign).
  </Tab>

  <Tab title="REST API">
    To sign a message make a POST request to

    ```bash  theme={"system"}
    https://api.privy.io/v1/wallets/<wallet_id>/rpc
    ```

    ### Parameters

    <ParamField path="method" type="'personal_sign'" required>
      RPC method to execute with the wallet.
    </ParamField>

    <ParamField path="params" type="Object" required>
      Parameters for the RPC method to execute with the wallet.

      <Expandable title="properties" defaultOpen="true">
        <ParamField path="message" type="string" required>
          The message to sign with the wallet. If the message to sign is raw bytes, you must serialize
          the message as a hexadecimal string.
        </ParamField>

        <ParamField path="encoding" type="'utf-8' | 'hex'" required>
          The encoding format for `params.message`. Use `utf-8` for a string message and `hex` for
          bytes.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="method" type="'personal_sign'">
      The RPC method executed with the wallet.
    </ResponseField>

    <ResponseField name="data" type="Object">
      Outputs for the RPC method executed with the wallet.

      <Expandable title="properties" defaultOpen="true">
        <ResponseField name="signature" type="string">
          An encoded string serializing the signature produced by the user's wallet.
        </ResponseField>

        <ResponseField name="encoding" type="'hex'">
          The encoding format for the returned `signature`. Currently, only `'hex'` is supported for Ethereum.
        </ResponseField>
      </Expandable>
    </ResponseField>

    ### Usage

    ```bash  theme={"system"}
    $ curl --request POST https://api.privy.io/v1/wallets/<wallet_id>/rpc \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H "privy-authorization-signature: <authorization-signature-for-request>" \
    -H 'Content-Type: application/json' \
    -d '{
      "chain_type": "ethereum",
      "method": "personal_sign",
      "params": {
        "message": "Hello, Ethereum.",
        "encoding": "utf-8"
      }
    }'
    ```
  </Tab>
</Tabs>

<Info>
  Looking to send USDC or another ERC-20 token? See our [Send USDC](/recipes/send-usdc) recipe.
</Info>


# null
Source: https://docs.privy.io/wallets/using-wallets/ethereum/sign-a-raw-hash



<Info>
  This interface is for raw signing over a hash, which primarily applies to Coinbase Smart Wallet
  integrations, EIP-7702 authorizations and other scenarios requiring basic curve-level signing. For
  most use cases, such as authenticating to a website or proving ownership, we recommend [signing a
  message](/wallets/using-wallets/ethereum/sign-a-message).
</Info>

<Info>
  When using Privy's server-side SDKs to sign raw hashes, you can use the authorization context to
  automatically sign requests. Learn more about [signing on the
  server](/controls/authorization-keys/using-owners/sign/signing-on-the-server).
</Info>

<Tabs>
  <Tab title="React">
    To sign a raw hash from a wallet using the React SDK use the `request` method from the wallets EIP1193 provider:

    ```javascript  theme={"system"}
     request: (request: { method: 'secp256k1_sign', params: [hash: Hex] }) => Promise<HexString>
    ```

    ### Usage

    ```javascript  theme={"system"}
    import {useWallets} from '@privy-io/react-auth';

    const {wallets} = useWallets();
    const wallet = wallets[0];

    const provider = await wallet.getEthereumProvider();

    // Sign raw hash
    const response = await provider.request({
      method: 'secp256k1_sign',
      params: ['0xTheRawHash']
    });
    ```

    ### Parameters

    <ParamField path="request.method" type="'secp256k1_sign'" required>
      The RPC method executed with the wallet.
    </ParamField>

    <ParamField path="request.params" type="[hash: Hex]" required>
      The raw hash to sign over.
    </ParamField>

    ### Returns

    <ResponseField name="response" type="string">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="NodeJS">
    Use the `secp256k1Sign` method on the Ethereum interface to sign a raw hash along the secp256k1 curve.

    ### Usage

    ```tsx  theme={"system"}
    const {signature, encoding} = await privy
      .wallets()
      .ethereum()
      .secp256k1Sign('insert-wallet-id', {
        params: {
          hash: '0x6503b027a625549f7be691646404f275f149d17a119a6804b855bac3030037aa'
        }
      });
    ```

    ### Parameters and Returns

    Check out the [API reference](/api-reference/wallets/ethereum/secp256k1-sign) for more details.
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    Use the `secp256k1Sign` method on the Ethereum client to sign a raw hash along the secp256k1 curve.

    ```javascript  theme={"system"}
    secp256k1Sign: async ({walletId: string, hash: string}) => Promise<{signature: string, encoding: 'hex'}>
    ```

    ### Usage

    ```tsx  theme={"system"}
    const {signature, encoding} = await privy.walletApi.ethereum.secp256k1Sign({
      walletId: 'insert-wallet-id',
      hash: '0x6503b027a625549f7be691646404f275f149d17a119a6804b855bac3030037aa'
    });
    ```

    ### Parameters

    <ParamField path="walletId" type="string" required>
      Unique ID of the wallet to take actions with.
    </ParamField>

    <ParamField path="hash" type="hash" required>
      The hash to sign. Must start with '0x'.
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="string">
      An encoded string serializing the signature produced by the user's wallet.
    </ResponseField>

    <ResponseField name="encoding" type="'hex'">
      The encoding format for the returned `signature`. Currently, only `'hex'` is supported for
      Ethereum.
    </ResponseField>
  </Tab>

  <Tab title="Java">
    To sign a raw hash from your wallet, use the `signSecp256k1` method.
    It will sign your hash, and return the signature to you.

    ### Usage

    ```java  theme={"system"}
    try {
        String hash = "0x6503b027a625549f7be691646404f275f149d17a119a6804b855bac3030037aa";

        // Example: If wallet's owner is an authorization private key
        AuthorizationContext authorizationContext = AuthorizationContext.builder()
            .addAuthorizationPrivateKey("authorization-key")
            .build();

        EthereumSecp256k1SignRpcResponseData response = privyClient
            .wallets()
            .ethereum()
            .signSecp256k1(
                walletId,
                hash,
                authorizationContext
            );

        String signature = response.signature();
    } catch (APIException e) {
        String errorBody = e.bodyAsString();
        System.err.println(errorBody);
    } catch (Exception e) {
        System.err.println(e.getMessage());
    }
    ```

    ### Parameters

    <ParamField type="String" body="hash">
      The hash to sign. Must start with '0x'.
    </ParamField>

    ### Returns

    The `EthereumSecp256k1SignRpcResponseData` object contains a `signature()` field

    <ResponseField name="signature()" type="String">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="Rust">
    Use the `sign_secp256k1` method on the Ethereum service to sign a raw hash with an Ethereum wallet.

    ### Usage

    ```rust  theme={"system"}
    use privy_rs::{AuthorizationContext, PrivyClient};

    let client = PrivyClient::new("app_id".to_string(), "app_secret".to_string())?;
    let ethereum_service = client.wallets().ethereum();
    let auth_ctx = AuthorizationContext::new();

    // Pre-computed keccak256 hash
    let hash = "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef";
    let signature = ethereum_service
        .sign_secp256k1(&wallet_id, hash, &auth_ctx, None)
        .await?;

    println!("Hash signed with secp256k1");
    ```

    ### Parameters and Returns

    See the Rust SDK documentation for detailed parameter and return types, including embedded examples:

    * [EthereumService::sign\_secp256k1](https://docs.rs/privy-rs/latest/privy_rs/ethereum/struct.EthereumService.html#method.sign_secp256k1)

    For REST API details, see the [API reference](/api-reference/wallets/ethereum/secp256k1-sign).
  </Tab>

  <Tab title="REST API">
    To sign a message make a POST request to

    ```bash  theme={"system"}
    https://api.privy.io/v1/wallets/<wallet_id>/rpc
    ```

    ### Parameters

    <ParamField path="method" type="'secp256k1_sign'" required>
      RPC method to execute with the wallet.
    </ParamField>

    <ParamField path="params" type="Object" required>
      Parameters for the RPC method to execute with the wallet.

      <Expandable title="properties" defaultOpen="true">
        <ParamField path="hash" type="string" required>
          The hash to sign with the wallet. Must start with '0x'.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="method" type="'secp256k1_sign'">
      The RPC method executed with the wallet.
    </ResponseField>

    <ResponseField name="data" type="Object">
      Outputs for the RPC method executed with the wallet.

      <Expandable title="properties" defaultOpen="true">
        <ResponseField name="signature" type="string">
          An encoded string serializing the signature produced by the user's wallet.
        </ResponseField>

        <ResponseField name="encoding" type="'hex'">
          The encoding format for the returned `signature`. Currently, only `'hex'` is supported for Ethereum.
        </ResponseField>
      </Expandable>
    </ResponseField>

    ### Usage

    ```bash  theme={"system"}
    $ curl --request POST https://api.privy.io/v1/wallets/<wallet_id>/rpc \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H "privy-authorization-signature: <authorization-signature-for-request>" \
    -H 'Content-Type: application/json' \
    -d '{
      "chain_type": "ethereum",
      "method": "secp256k1_sign",
      "params": {
        "hash": "0x6503b027a625549f7be691646404f275f149d17a119a6804b855bac3030037aa",
        "encoding": "hex"
      }
    }'
    ```
  </Tab>

  <Tab title="React Native">
    Request a message signature on the wallets Ethereum provider.

    ### Usage

    ```tsx  theme={"system"}
    import {useEmbeddedEthereumWallet} from '@privy-io/expo';

    const {wallets} = useEmbeddedEthereumWallet();
    const wallet = wallets[0];

    // Get an EIP-1193 Provider
    const provider = await wallet.getProvider();

    // Sign raw hash
    const signature = await provider.request({
      method: 'secp256k1_sign',
      params: ['0xTheRawHash']
    });
    ```

    ### Parameters

    <ParamField path="request" type="Object" required>
      <Expandable title="properties" defaultOpen="true">
        <ParamField path="method" type="'secp256k1_sign'" required>
          The method for the wallet request. For signing a raw hash, this is `'secp256k1_sign'`.
        </ParamField>

        <ParamField path="params" type="[string]" required>
          The raw hash to sign over, as the first and only element of the array.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="Swift">
    To sign a raw hash from a wallet using the Swift SDK use the wallet's Ethereum provider.

    ### Usage

    ```swift  theme={"system"}
    import PrivySDK

    guard let user = privy.user else {
        // If user is null, user is not authenticated
        return
    }

    // Retrieve list of user's embedded Ethereum wallets
    let ethereumWallets = user.embeddedEthereumWallets

    // Grab the desired wallet. Here, we retrieve the first wallet
    guard let wallet = ethereumWallets.first else {
        // No ETH wallets
        return
    }

    let signature = try await wallet.provider.request(.secp256k1Sign(hash: "0xTheRawHash"))

    print("Result signature: \(signature)")
    ```

    ### Parameters

    <ParamField path="request" type="Object" required>
      <Expandable title="properties" defaultOpen="true">
        <ParamField path="method" type="'secp256k1_sign'" required>
          The method for the wallet request. For signing a raw hash, this is `'secp256k1_sign'`.
        </ParamField>

        <ParamField path="params" type="[string]" required>
          The raw hash to sign over, as the first and only element of the array.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="Unity">
    ### Usage

    ```csharp  theme={"system"}
    var privyUser = await PrivyManager.Instance.GetUser();
    if (privyUser == null)
    {
        // If user is null, user is not authenticated
        return;
    }

    // Grab the desired wallet. Here, we retrieve the first wallet
    var wallet = privyUser.EmbeddedWallets[0];
    if (wallet == null)
    {
        // User has no ETH wallets
        return;
    }

    try
    {
        var rpcRequest = new RpcRequest
        {
            Method = "secp256k1_sign",
            Params = new string[] { "0xTheRawHash" }
        };
        var rpcResponse = await wallet.RpcProvider.Request(rpcRequest);
        var signature = rpcResponse.Data;
        Debug.Log(signature);
    }
    catch (PrivyException.EmbeddedWalletException ex)
    {
        Debug.LogError($"Could not sign message due to error: {ex.Error} {ex.Message}");
    }
    catch (Exception ex)
    {
        Debug.LogError($"Could not sign hash exception {ex.Message}");
    }
    ```

    ### Parameters

    <ParamField path="method" type="'secp256k1_sign'" required>
      The method for the wallet request. For signing a raw hash, this is `'secp256k1_sign'`.
    </ParamField>

    <ParamField path="params" type="Object" required>
      <Expandable title="properties" defaultOpen="true">
        <ParamField path="hash" type="string" required>
          The hash to sign with the wallet. Must start with '0x'.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="Android">
    To sign a raw hash from a wallet using the Android SDK use the wallet's Ethereum provider.

    ### Usage

    ```kotlin  theme={"system"}
    // Get Privy user
    val user = privy.getUser()

    // Check if user is authenticated
    if (user != null) {
        // Retrieve list of user's embedded Ethereum wallets
        val ethereumWallets = user.embeddedEthereumWallets

        if (ethereumWallets.isNotEmpty()) {
            // Grab the desired wallet. Here, we retrieve the first wallet
            val ethereumWallet = ethereumWallets.first()

            // Sign raw hash
            val result = ethereumWallet.provider.request(
                request = EthereumRpcRequest.secp256k1Sign("0xTheRawHash")
            )

            when (result) {
                is Result.Success -> {
                    val signature = result.data.data
                    println("Signature: $signature")
                }
                is Result.Failure -> {
                    // Handle error
                }
            }
        }
    }
    ```

    ### Parameters

    <ParamField path="request" type="Object" required>
      <Expandable title="properties" defaultOpen="true">
        <ParamField path="method" type="'secp256k1_sign'" required>
          The method for the wallet request. For signing a raw hash, this is `'secp256k1_sign'`.
        </ParamField>

        <ParamField path="params" type="[string]" required>
          The raw hash to sign over, as the first and only element of the array.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="result" type="Result<EthereumRpcResponse>">
      A Result that, when successful, contains the EthereumRpcResponse with:

      <Expandable title="child attributes" defaultOpen="true">
        <ResponseField name="method" type="string">
          The RPC method that was executed (secp256k1\_sign).
        </ResponseField>

        <ResponseField name="data" type="string">
          The signature produced by the wallet.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="Flutter">
    To sign a raw hash from a wallet using the Flutter SDK use the wallet's Ethereum provider.

    ### Usage

    ```dart  theme={"system"}
    // Get the Privy User
    final user = await privy.getUser();
    // Get an EIP-1193 Provider
    final ethereumWallet = user.embeddedEthereumWallets.first;
    final provider = ethereumWallet.provider;

    // Sign raw hash
    final request = EthereumRpcRequest(
      method: 'secp256k1_sign',
      params: ['0xTheRawHash'],
    );

    final result = await provider.request(request);

    result.fold(
      onSuccess: (response) {
        final signature = response.data;
        print('Signature: $signature');
      },
      onFailure: (error) {
        print('Error signing hash: ${error.message}');
      },
    );
    ```

    ### Parameters

    <ParamField path="request" type="Object" required>
      <Expandable title="properties" defaultOpen="true">
        <ParamField path="method" type="'secp256k1_sign'" required>
          The method for the wallet request. For signing a raw hash, this is `'secp256k1_sign'`.
        </ParamField>

        <ParamField path="params" type="[string]" required>
          The raw hash to sign over, as the first and only element of the array.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="result" type="Result<EthereumRpcResponse>">
      A Result that, when successful, contains the EthereumRpcResponse with:

      <Expandable title="child attributes" defaultOpen="true">
        <ResponseField name="method" type="string">
          The RPC method that was executed (secp256k1\_sign).
        </ResponseField>

        <ResponseField name="data" type="string">
          The signature produced by the wallet.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/wallets/using-wallets/ethereum/sign-a-transaction



<Info>
  When using Privy's server-side SDKs to sign transactions, you can use the authorization context to
  automatically sign requests. Learn more about [signing on the
  server](/controls/authorization-keys/using-owners/sign/signing-on-the-server).
</Info>

<Tabs>
  <Tab title="React">
    To send a transaction from a wallet using the React SDK, use the `signTransaction` method from the `useSignTransaction` hook:

    ```javascript  theme={"system"}
    signTransaction: (input: UnsignedTransactionRequest, options?: SendTransactionOptions) => Promise<{ signature: HexString }>
    ```

    ### Usage

    ```javascript  theme={"system"}
    import {useSignTransaction, useWallets} from '@privy-io/react-auth';

    const {signTransaction} = useSignTransaction();
    const {wallets} = useWallets();

    signTransaction(
      {
        to: '0xE3070d3e4309afA3bC9a6b057685743CF42da77C',
        value: 100000
      },
      {
        address: wallets[0].address // Optional: Specify the wallet to use for signing. If not provided, the first wallet will be used.
      }
    );
    ```

    ### Parameters

    <ParamField path="input" type="UnsignedTransactionRequest" required>
      The details of the transaction to sign.
    </ParamField>

    <ParamField path="options.uiOptions" type="SendTransactionModalUIOptions">
      The options for the UI of the send transaction modal. [Learn
      more](/wallets/using-wallets/ui-components).

      <Tip>
        To hide confirmation modals, set `options.uiOptions.showWalletUIs` to `false`. Learn more about
        configuring modal prompts [here](/recipes/react/manage-wallet-UIs).
      </Tip>
    </ParamField>

    <ParamField path="options.fundWalletConfig" type="FundWalletConfig">
      The configuration for funding the wallet.
    </ParamField>

    <ParamField path="options.address" type="string">
      The address of the wallet to use for signing the transaction. **Recommended when working with
      external wallets** to ensure reliable functionality. If not provided, the first wallet will be
      used.
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="HexString">
      The signed transaction hash.
    </ResponseField>
  </Tab>

  <Tab title="React Native">
    To sign a transaction from a wallet using the React Native SDK use the `request` method from the wallets EIP1193 provider:

    ```javascript  theme={"system"}
    request: (request: { method: 'eth_signTransaction', params: [SignTransactionParams] }) => Promise<HexString>
    ```

    <Note>
      The Expo SDK does not support built-in UIs for sending transactions.
      The `eth_signTransaction` method gives you complete control over the experience and UI.
    </Note>

    ### Usage

    ```javascript  theme={"system"}
    import {useEmbeddedEthereumWallet} from '@privy-io/expo';

    const {wallets} = useEmbeddedEthereumWallet();
    const wallet = wallets[0];

    const provider = await wallet.getProvider();
    const accounts = await provider.request({
        method: 'eth_requestAccounts',
    });

    // Sign transaction (will be signed and populated)
    const response = await provider.request({
        method: 'eth_signTransaction',
        params: [
            {
                from: accounts[0],
                to: '0x0000000000000000000000000000000000000000',
                value: '1',
            },
        ],
    });
    ```

    ### Parameters

    <ParamField path="request.method" type="'eth_signTransaction'" required>
      The RPC method executed with the wallet.
    </ParamField>

    <ParamField path="request.params" type="SignTransactionParams" required>
      The details of the transaction to sign.
    </ParamField>

    ### Returns

    <ResponseField name="response" type="HexString">
      The hash for the broadcasted transaction.
    </ResponseField>
  </Tab>

  <Tab title="Swift">
    Use the `request` method on the Ethereum provider to sign a transaction with an Ethereum wallet.

    ```swift  theme={"system"}
    func request(_ request: EthereumRpcRequest) async throws -> String
    ```

    ### Usage

    ```swift  theme={"system"}
    let provider = wallet.provider

    let transaction = EthereumRpcRequest.UnsignedEthTransaction(
        from: wallet.address,
        to: "0xE3070d3e4309afA3bC9a6b057685743CF42da77C",
        value: .int(100000),
        chainId: .hexadecimal("0x2105"), // Base, in hex
    )

    let transactionSignature = try await provider.request(.ethSignTransaction(transaction: transaction))
    ```

    ### Parameters

    <ParamField path="transaction" type="EthereumRpcRequest.UnsignedEthTransaction" required>
      The transaction to send.

      <Expandable title="child attributes" defaultOpen="true">
        <ParamField path="from" type="string">
          The address sending the transaction (the user's wallet address).
        </ParamField>

        <ParamField path="to" type="string" required>
          The address to send the transaction to.
        </ParamField>

        <ParamField path="value" type="Quantity">
          The amount of wei to send, as an integer or hexadecimal string.
        </ParamField>

        <ParamField path="chainId" type="Quantity">
          The chain ID as an integer or hexadecimal string. Defaults to mainnet (0x1) if omitted.
        </ParamField>

        <ParamField path="data" type="string">
          The data to include with the transaction, as a hexadecimal string.
        </ParamField>

        <ParamField path="gasLimit" type="string">
          The gas limit for the transaction, as a hexadecimal string.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="transactionSignature" type="string">
      The signature of the transaction.
    </ResponseField>
  </Tab>

  <Tab title="Android">
    Use the `request` method on the Ethereum wallet provider to sign a transaction with an Ethereum wallet.

    ```kotlin  theme={"system"}
    public suspend fun request(request: EthereumRpcRequest): Result<EthereumRpcResponse>
    ```

    ### Usage

    ```kotlin  theme={"system"}
    val transaction = JSONObject().apply {
        put("to", "0xE3070d3e4309afA3bC9a6b057685743CF42da77C")
        put("value", "0x186a0") // 100000 in hex
        put("chainId", "0x2105") // 8453 (Base) in hex
        put("from", ethereumWallet.address)
    }.toString()

    val result = ethereumWallet.provider.request(
        request = EthereumRpcRequest.ethSignTransaction(transaction),
    )

    when (result) {
        is Result.Success -> {
            val transactionHash = result.data.data
            // Handle successful transaction
        }
        is Result.Failure -> {
            // Handle error
        }
    }
    ```

    ### Parameters

    <ParamField path="method" type="'eth_signTransaction'" required>
      The RPC method to execute with the wallet.
    </ParamField>

    <ParamField path="params" type="List<String>" required>
      Array containing the transaction JSON as a single string element.

      <Expandable title="child attributes" defaultOpen="true">
        <ParamField path="to" type="string" required>
          The address to send the transaction to.
        </ParamField>

        <ParamField path="value" type="string">
          The amount of wei to send, as a hexadecimal string.
        </ParamField>

        <ParamField path="chainId" type="string">
          The chain ID as a hexadecimal string. Defaults to mainnet (0x1) if omitted.
        </ParamField>

        <ParamField path="from" type="string">
          The address sending the transaction (the user's wallet address).
        </ParamField>

        <ParamField path="data" type="string">
          The data to include with the transaction, as a hexadecimal string.
        </ParamField>

        <ParamField path="gasLimit" type="string">
          The gas limit for the transaction, as a hexadecimal string.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="result" type="Result<EthereumRpcResponse>">
      A Result that, when successful, contains the EthereumRpcResponse with:

      <Expandable title="child attributes" defaultOpen="true">
        <ResponseField name="method" type="string">
          The RPC method that was executed (eth\_signTransaction).
        </ResponseField>

        <ResponseField name="data" type="string">
          The transaction hash for the broadcasted transaction.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="Unity">
    Use the `Request` method on the wallet's RPC provider to sign a transaction with an Ethereum wallet.

    ```csharp  theme={"system"}
    public Task<RpcResponse> Request(RpcRequest request);
    ```

    ### Usage

    ```csharp  theme={"system"}
    // Create transaction JSON
    string transactionJson = JsonUtility.ToJson(new {
        to = "0xE3070d3e4309afA3bC9a6b057685743CF42da77C",
        value = "0x186a0", // 100000 in hex
        chainId = "0x2105", // 8453 (Base) in hex
        from = embeddedWallet.Address
    });

    // Create RPC request
    var rpcRequest = new RpcRequest
    {
        Method = "eth_signTransaction",
        Params = new string[] { transactionJson }
    };

    // Sign transaction
    RpcResponse transactionResponse = await embeddedWallet.RpcProvider.Request(rpcRequest);

    // Transaction hash is in the response data
    string transactionHash = transactionResponse.Data;
    ```

    ### Parameters

    <ParamField path="Method" type="'eth_signTransaction'" required>
      The RPC method to execute with the wallet.
    </ParamField>

    <ParamField path="Params" type="string[]" required>
      Array containing the transaction JSON as a single string element.

      <Expandable title="child attributes" defaultOpen="true">
        <ParamField path="to" type="string" required>
          The address to send the transaction to.
        </ParamField>

        <ParamField path="value" type="string">
          The amount of wei to send, as a hexadecimal string.
        </ParamField>

        <ParamField path="chainId" type="string">
          The chain ID as a hexadecimal string. Defaults to mainnet (0x1) if omitted.
        </ParamField>

        <ParamField path="from" type="string">
          The address sending the transaction (the user's wallet address).
        </ParamField>

        <ParamField path="data" type="string">
          The data to include with the transaction, as a hexadecimal string.
        </ParamField>

        <ParamField path="gasLimit" type="string">
          The gas limit for the transaction, as a hexadecimal string.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="RpcResponse" type="RpcResponse">
      An RPC response object with:

      <Expandable title="child attributes" defaultOpen="true">
        <ResponseField name="method" type="string">
          The RPC method that was executed (eth\_signTransaction).
        </ResponseField>

        <ResponseField name="data" type="string">
          The transaction hash for the broadcasted transaction.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="Flutter">
    Use the `request` method on the Ethereum wallet provider to sign a transaction with an Ethereum wallet.

    ```dart  theme={"system"}
    Future<Result<EthereumRpcResponse>> request(EthereumRpcRequest request);
    ```

    ### Usage

    ```dart  theme={"system"}
    // Create transaction parameters as a Map
    final transactionMap = {
        'to': '0xE3070d3e4309afA3bC9a6b057685743CF42da77C',
        'value': '0x186a0', // 100000 in hex
        'chainId': '0x2105', // 8453 (Base) in hex
        'from': ethereumWallet.address
    };

    // Convert Map to JSON string
    final transactionJson = jsonEncode(transactionMap);

    // Create the RPC request
    final rpcRequest = EthereumRpcRequest(
        method: 'eth_signTransaction',
        params: [transactionJson],
    );

    // Sign the transaction
    final result = await ethereumWallet.provider.request(rpcRequest);

    // Handle the result
    result.when(
        success: (response) {
            final transactionHash = response.data;
            print('Transaction sent with hash: $transactionHash');
        },
        failure: (error) {
            print('Failed to sign transaction: $error');
        },
    );
    ```

    ### Parameters

    <ParamField path="method" type="'eth_signTransaction'" required>
      The RPC method to execute with the wallet.
    </ParamField>

    <ParamField path="params" type="List<dynamic>" required>
      List containing the transaction JSON as a single string element.

      <Expandable title="child attributes" defaultOpen="true">
        <ParamField path="to" type="string" required>
          The address to send the transaction to.
        </ParamField>

        <ParamField path="value" type="string">
          The amount of wei to send, as a hexadecimal string.
        </ParamField>

        <ParamField path="chainId" type="string">
          The chain ID as a hexadecimal string. Defaults to mainnet (0x1) if omitted.
        </ParamField>

        <ParamField path="from" type="string">
          The address sending the transaction (the user's wallet address).
        </ParamField>

        <ParamField path="data" type="string">
          The data to include with the transaction, as a hexadecimal string.
        </ParamField>

        <ParamField path="gasLimit" type="string">
          The gas limit for the transaction, as a hexadecimal string.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="result" type="Result<EthereumRpcResponse>">
      A Result that, when successful, contains the EthereumRpcResponse with:

      <Expandable title="child attributes" defaultOpen="true">
        <ResponseField name="method" type="string">
          The RPC method that was executed (eth\_signTransaction).
        </ResponseField>

        <ResponseField name="data" type="string">
          The transaction hash for the broadcasted transaction.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="NodeJS">
    <Tip>
      Privy is fully compatible with popular web3 libraries for interfacing wallets, including [`viem`](https://viem.sh/), learn more [here](/wallets/using-wallets/ethereum/web3-integrations#node-js).
    </Tip>

    Use the `signTransaction` method on the Ethereum interface to sign a transaction with an Ethereum wallet.

    ### Usage

    ```js  theme={"system"}
    const {signed_transaction, encoding} = await privy.wallets().ethereum().signTransaction('insert-wallet-id', {
        params: {
            transaction: {
                to: '0xE3070d3e4309afA3bC9a6b057685743CF42da77C',
                value: '0x2386F26FC10000',
                chain_id: 8453,
            },
        }
    });
    ```

    ### Parameters and Returns

    Check out the [API reference](/api-reference/wallets/ethereum/eth-sign-transaction) for more details.
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    <Tip>
      Privy is fully compatible with popular web3 libraries for interfacing wallets, including [`viem`](https://viem.sh/), learn more [here](/wallets/using-wallets/ethereum/web3-integrations#node-js).
    </Tip>

    Use the `signTransaction` method on the Ethereum client to sign a transaction with an Ethereum wallet.

    ```js  theme={"system"}
    signTransaction: (input: EthereumSignTransactionInputType) => Promise<EthereumSignTransactionResponseType>
    ```

    ### Usage

    ```js  theme={"system"}
    const {signedTransaction, encoding} = await privy.walletApi.ethereum.signTransaction({
        walletId: 'insert-wallet-id',
        transaction: {
            to: '0xE3070d3e4309afA3bC9a6b057685743CF42da77C',
            value: '0x2386F26FC10000',
            chainId: 8453,
        },
    });
    ```

    ### Parameters

    <ParamField path="walletId" type="string" required>
      The ID of the wallet to sign the transaction with.
    </ParamField>

    <ParamField path="transaction" type="EthereumTransactionType" required>
      The transaction to sign.
    </ParamField>

    ### Returns

    <ResponseField name="signedTransaction" type="string">
      The signed transaction.
    </ResponseField>

    <ResponseField name="encoding" type="'rlp'">
      The encoding format for the returned `signedTransaction`. Currently, only `'rlp'` is supported for Ethereum.
    </ResponseField>
  </Tab>

  <Tab title="Java">
    To sign a transaction from your wallet, use the `signTransaction` method.
    It will sign your transaction, and return the signed transaction to you.

    ### Usage

    ```java  theme={"system"}
    try {
        EthereumSignTransactionRpcInputTransaction txn = EthereumSignTransactionRpcInputTransaction.builder()
            .to(recipientAddress)
            .value(EthereumSignTransactionRpcInputValue.of("0x1")) // 1 wei
            .chainId(EthereumSignTransactionRpcInputChainId.of(11_155_111)) // Sepolia testnet
            .build();

        // Example: If wallet's owner is an authorization private key
        AuthorizationContext authorizationContext = AuthorizationContext.builder()
            .addAuthorizationPrivateKey("authorization-key")
            .build();

        EthereumSignTransactionRpcResponseData response = privyClient
            .wallets()
            .ethereum()
            .signTransaction(
                walletId,
                txn,
                authorizationContext
        );

        String signedTransaction = response.signedTransaction();
    } catch (APIException e) {
        String errorBody = e.bodyAsString();
        System.err.println(errorBody);
    } catch (Exception e) {
        System.err.println(e.getMessage());
    }
    ```

    ### Parameters

    When defining a transaction, you may specify the following values on the `EthereumSignTransactionRpcInputTransaction` builder:

    <ParamField type="String" body="from">
      The address sending the transaction (the user's wallet address).
    </ParamField>

    <ParamField type="String" body="to">
      The address to send the transaction to.
    </ParamField>

    <ParamField type="EthereumSignTransactionRpcInputChainId" body="chainId">
      The ID of the chain the transaction is being sent on.
    </ParamField>

    <ParamField type="EthereumSignTransactionRpcInputNonce" body="nonce">
      The nonce for the transaction.
    </ParamField>

    <ParamField type="String" body="data">
      The data to include with the transaction, as a hexadecimal string.
    </ParamField>

    <ParamField type="EthereumSignTransactionRpcInputValue" body="value">
      The amount of wei to send, as an integer or hexadecimal string.
    </ParamField>

    <ParamField type="Object" body="type">
      The type of transaction to send.
    </ParamField>

    <ParamField type="EthereumSignTransactionRpcInputGasLimit" body="gasLimit">
      The gas limit for the transaction, as a hexadecimal string.
    </ParamField>

    <ParamField type="EthereumSignTransactionRpcInputGasPrice" body="gasPrice">
      The gas price for the transaction, as a hexadecimal string.
    </ParamField>

    <ParamField type="EthereumSignTransactionRpcInputMaxFeePerGas" body="maxFeePerGas">
      The maximum fee per gas for the transaction, as a hexadecimal string.
    </ParamField>

    <ParamField type="EthereumSignTransactionRpcInputMaxPriorityFeePerGas" body="maxPriorityFeePerGas">
      The maximum priority fee per gas for the transaction, as a hexadecimal string.
    </ParamField>

    ### Returns

    The `EthereumSignTransactionRpcResponseData` object contains a `signedTransaction()` field

    <ResponseField name="signedTransaction()" type="String">
      The signed transaction.
    </ResponseField>
  </Tab>

  <Tab title="Rust">
    <Tip>
      Privy is fully compatible with popular libraries for interfacing wallets, including [`alloy`](https://crates.io/crates/alloy), learn more [here](/wallets/using-wallets/ethereum/web3-integrations#rust).
    </Tip>

    Use the `sign_transaction` method on the Ethereum service to sign a transaction with an Ethereum wallet.

    ### Usage

    ```rust  theme={"system"}
    use privy_rs::{AuthorizationContext, PrivyClient};

    let client = PrivyClient::new("app_id".to_string(), "app_secret".to_string())?;
    let ethereum_service = client.wallets().ethereum();
    let auth_ctx = AuthorizationContext::new();

    let transaction = EthereumSignTransactionRpcInputParamsTransaction {
        to: Some("0x742d35Cc6635C0532925a3b8c17d6d1E9C2F7ca".to_string()),
        value: None,
        gas_limit: None,
        gas_price: None,
        nonce: None,
        chain_id: None,
        data: None,
        from: None,
        max_fee_per_gas: None,
        max_priority_fee_per_gas: None,
        type_: None,
    };

    let signed_tx = ethereum_service
        .sign_transaction(&wallet_id, transaction, &auth_ctx, None)
        .await?;

    println!("Transaction signed successfully");
    ```

    ### Parameters and Returns

    See the Rust SDK documentation for detailed parameter and return types, including embedded examples:

    * [EthereumService::sign\_transaction](https://docs.rs/privy-rs/latest/privy_rs/ethereum/struct.EthereumService.html#method.sign_transaction)

    For REST API details, see the [API reference](/api-reference/wallets/ethereum/eth-sign-transaction).
  </Tab>

  <Tab title="REST API">
    To sign a transaction make a `POST` request to

    ```bash  theme={"system"}
    https://api.privy.io/v1/wallets/<wallet_id>/rpc
    ```

    ### Usage

    ```bash  theme={"system"}
    $ curl --request POST https://api.privy.io/v1/wallets/<wallet_id>/rpc \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H "privy-authorization-signature: <authorization-signature-for-request>" \
    -H 'Content-Type: application/json' \
    -d '{
        "method": "eth_signTransaction",
        "params": {
            "transaction": {
              "to": "0xE3070d3e4309afA3bC9a6b057685743CF42da77C",
              "value": "0x2386F26FC10000",
              "chain_id": 1,
              "type": 2,
              "gas_limit": "0x5208",
              "nonce": 1,
              "max_fee_per_gas": "0x14bf7dadac",
              "max_priority_fee_per_gas": "0xf4240"
            }
        }
    }'
    ```

    A successful response will look like the following:

    ```json  theme={"system"}
    {
      "method": "eth_signTransaction",
      "data": {
        "signed_transaction": "0x28eac519bf4051a624d4246a5788667baf84dcd7d2a439b314b339013b5cdb4c",
        "encoding": "rlp"
      }
    }
    ```

    ### Parameters

    <ParamField path="method" type="'eth_signTransaction'" required>
      The RPC method executed with the wallet.
    </ParamField>

    <ParamField path="params" type="Object" required>
      <ParamField path="transaction" type="EthereumTransactionType" required>
        The details of the transaction to send on the chain.
      </ParamField>
    </ParamField>

    ### Returns

    <ResponseField name="method" type="'eth_signTransaction'">
      The RPC method executed with the wallet.
    </ResponseField>

    <ResponseField name="data.signed_transaction" type="string">
      The signed transaction.
    </ResponseField>

    <ResponseField name="data.encoding" type="'rlp'">
      The encoding format for the signed transaction. Currently, only `'rlp'` is supported for Ethereum.
    </ResponseField>
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/wallets/using-wallets/ethereum/sign-typed-data



<Info>
  When using Privy's server-side SDKs to sign typed data, you can use the authorization context to
  automatically sign requests. Learn more about [signing on the
  server](/controls/authorization-keys/using-owners/sign/signing-on-the-server).
</Info>

<Tabs>
  <Tab title="React">
    Use the `signTypedData` method exported from the `useSignTypedData` hook to sign a message with an Ethereum embedded wallet.

    ```javascript  theme={"system"}
    signTypedData(input: SignTypedDataParams, options?: SignTypedDataOptions): Promise<{signature: string}>
    ```

    ### Usage

    ```tsx  theme={"system"}
    import {useSignTypedData, useWallets} from '@privy-io/react-auth';

    const {signTypedData} = useSignTypedData();
    const {wallets} = useWallets();

    const {signature} = await signTypedData({...}, {
      address: wallets[0].address // Optional: Specify the wallet to use for signing. If not provided, the first wallet will be used.
    });
    ```

    ### Parameters

    <ParamField path="input" type="Object" required>
      The typed data object to sign with the wallet, with the properties defined in
      [EIP-712](https://eips.ethereum.org/EIPS/eip-712).
    </ParamField>

    <ParamField path="options" type="Object">
      <Expandable title="properties" defaultOpen="true">
        <ParamField path="uiOptions" type="SignMessageModalUIOptions">
          UI options to customize the signature prompt modal. [Learn
          more](/wallets/using-wallets/ui-components)

          <Tip>
            To hide confirmation modals, set `options.uiOptions.showWalletUIs` to `false`. Learn more
            about configuring modal prompts [here](/recipes/react/manage-wallet-UIs).
          </Tip>
        </ParamField>

        <ParamField path="address" type="string">
          Address of the wallet to use for signing the typed data. **Recommended when working with
          external wallets** to ensure reliable functionality. If not provided, the first wallet will be
          used.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Response

    {' '}

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>

    ### Callbacks

    Configure callbacks for `signTypedData` with the `useSignTypedData` hook.

    ```tsx  theme={"system"}
    import {useSignTypedData} from '@privy-io/react-auth';

    const {signTypedData} = useSignTypedData({
      onSuccess: ({signature}) => {
        console.log(signature);
        // Any logic you'd like to execute after a user successfully signs the EIP-712 typed data
      },
      onError: (error) => {
        console.log(error);
        // Any logic you'd like to execute after a user exits the signing flow or there is an error
      }
    });

    // Then call `signTypedData` in your code, which will invoke these callbacks on completion
    ```

    As parameters to **`useSignTypedData`**, you may include an **`onSuccess`** callback and/or an **`onError`** callback.

    While this component is mounted, any invocation of **`signTypedData`** will trigger the **`onSuccess`** callback or **`onError`** callback on completion, depending on if the data was successfully signed or not.

    ### onSuccess

    If set, the **`onSuccess`** callback will execute after a user has successfully signed the message. Within this callback, you can access a **`signature`** parameter, which is the **`signature`** string value generated by the wallet to sign the data.

    ### onError

    If set, the **`onError`** callback will execute after a user attempts to sign the typed data and there is an error, or if the user exits the signature flow prematurely. Within this callback, you may access an **`error`** code with more information about the error.
  </Tab>

  <Tab title="React Native">
    Request a message signature on the wallets Ethereum provider.

    ```javascript  theme={"system"}
    request: ({method: 'eth_signTypedData_v4', params: [address, typedData]}) => Promise<{signature: string}>
    ```

    <Note>
      The Expo SDK does not support built-in UIs for signing typed data. The `eth_signTypedData_v4`
      method gives you complete control over the experience and UI.
    </Note>

    ### Usage

    ```tsx  theme={"system"}
    import {useEmbeddedEthereumWallet} from '@privy-io/expo';

    const {wallets} = useEmbeddedEthereumWallet();
    const wallet = wallets[0];

    // Get an EIP-1193 Provider
    const provider = await wallet.getProvider();
    // Get address
    const accounts = await provider.request({
      method: 'eth_requestAccounts'
    });

    const signature = await provider.request({
      method: 'eth_signTypedData_v4',
      params: [accounts[0], typedData]
    });
    ```

    ### Parameters

    <ParamField path="method" type="'eth_signTypedData_v4'" required>
      The method for the wallet request. For signing messages, this is `'eth_signTypedData_v4'`.
    </ParamField>

    <ParamField path="params" type="Object" required>
      <Expandable title="properties" defaultOpen="true">
        <ParamField path="address" type="string">
          The address of the wallet to sign the message with.
        </ParamField>

        <ParamField path="typeData" type="Object" required>
          The typed data to sign with the wallet.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    {' '}

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="Swift">
    To request an [EIP712](https://eips.ethereum.org/EIPS/eip-712) signature from a user's embedded wallet, send an [`eth_signTypedData_v4`](https://docs.metamask.io/wallet/reference/eth_signtypeddata_v4/) JSON-RPC request to the wallet's EIP1193 provider.

    ```swift  theme={"system"}
    struct Message: Encodable {
      struct W: Encodable {
        let name: String
        let wallet: String
      }

      let from: W
      let to: W
      let contents: String
    }

    func typedData() async throws {
      let wallets = user.embeddedEthereumWallets

      // Grab the desired wallet. Here, we retrieve the first wallet
      guard let wallet = wallets.first else {
        // No ETH wallets
        return
      }

      let typedData = EthereumRpcRequest.EIP712TypedData(
        types: [
          "EIP712Domain": [
            .init("name", type: "string"),
            .init("version", type: "string"),
            .init("chainId", type: "uint256"),
            .init("verifyingContract", type: "address"),
          ],
          "Person": [
            .init("name", type: "string"),
            .init("wallet", type: "address"),
          ],
          "Mail": [
            .init("from", type: "Person"),
            .init("to", type: "Person"),
            .init("contents", type: "string"),
          ],
        ],
        primaryType: "Mail",
        domain: .init(
          name: "Ether Mail",
          version: "1",
          chainId: 1,
          verifyingContract: "0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC",
        ),
        message: Message(
          from: Message.W(name: "Cow", wallet: "0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826"),
          to: Message.W(name: "Bob", wallet: "0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB"),
          contents: "Hello, Bob!"
        )
      )

      let signature = try await provider.request(.ethSignTypedDataV4(address: wallet.address, typedData: typedData))

      print(signature)
    }
    ```

    ### Parameters

    <ParamField path="address" type="string">
      The address of the wallet to sign the message with.
    </ParamField>

    <ParamField path="typeddata" type="EthereumRpcRequest.EIP712TypedData" required>
      The typed data to sign with the wallet.

      <Expandable title="child attributes" defaultOpen="true">
        <ParamField path="types" type="[String: [EIP712Type]]" required>
          The types of the typed data, as defined by mapping the type names to
          an array of `EIP712Type` objects for each of its fields.

          Make sure to include the `EIP712Domain` type.
        </ParamField>

        <ParamField path="primaryType" type="string" required>
          The primary type of the typed data.
        </ParamField>

        <ParamField path="domain" type="EIP712Domain" required>
          The domain of the typed data, per the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) specification.
          Use the `EIP712Domain` struct to define the domain.
        </ParamField>

        <ParamField path="message" type="Encodable" required>
          The message of the typed data.
          This can be any struct that conforms to the `Encodable` protocol.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="Android">
    ```kotlin  theme={"system"}
    // Get Privy user
    ethereumWallet.provider.request(
      request = EthereumRpcRequest.ethSignTypedDataV4(ethereumWallet.address, typedData),
    )
    ```

    ### Parameters

    <ParamField path="method" type="'eth_signTypedData_v4'" required>
      The method for the wallet request. For signing messages, this is `'eth_signTypedData_v4'`.
    </ParamField>

    <ParamField path="params" type="Object" required>
      <Expandable title="properties" defaultOpen="true">
        <ParamField path="address" type="string">
          The address of the wallet to sign the message with.
        </ParamField>

        <ParamField path="typeData" type="Object" required>
          The typed data to sign with the wallet.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    {' '}

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="Unity">
    ```csharp  theme={"system"}
    try {
        IEmbeddedEthereumWallet embeddedWallet = PrivyManager.Instance.User.EmbeddedWallets[0];
        var rpcRequest = new RpcRequest
        {m
            Method = "eth_signTypedData_v4",
            Params = new string[] {embeddedWallet.Address, typedData }  // Use the 'new' keyword here
        };
        RpcResponse signTypedDataResponse = await embeddedWallet.RpcProvider.Request(rpcRequest);
        Debug.Log(signTypedDataResponse.Data);
    } catch (PrivyException.EmbeddedWalletException ex){
        Debug.LogError($"Could not sign message due to error: {ex.Error} {ex.Message}");
    } catch (Exception ex) {
        Debug.LogError($"Could not sign message exception {ex.Message}");
    }
    ```

    ### Parameters

    <ParamField path="method" type="'eth_signTypedData_v4'" required>
      The method for the wallet request. For signing messages, this is `'eth_signTypedData_v4'`.
    </ParamField>

    <ParamField path="params" type="Object" required>
      <Expandable title="properties" defaultOpen="true">
        <ParamField path="address" type="string">
          The address of the wallet to sign the message with.
        </ParamField>

        <ParamField path="typedData" type="Object" required>
          The typed data to sign with the wallet.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    {' '}

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="Flutter">
    ```dart  theme={"system"}
    // Get an EIP-1193 Provider
    final ethereumWallet = privy.user.embeddedEthereumWallets.first;
    final provider = ethereumWallet.provider;

    // Define the typed data
    final typedData = {
      'types': {
        'EIP712Domain': [
          {'name': 'name', 'type': 'string'},
          {'name': 'version', 'type': 'string'},
          {'name': 'chainId', 'type': 'uint256'},
          {'name': 'verifyingContract', 'type': 'address'},
        ],
        'Person': [
          {'name': 'name', 'type': 'string'},
          {'name': 'wallet', 'type': 'address'},
        ],
        'Mail': [
          {'name': 'from', 'type': 'Person'},
          {'name': 'to', 'type': 'Person'},
          {'name': 'contents', 'type': 'string'},
        ],
      },
      'primaryType': 'Mail',
      'domain': {
        'name': 'Ether Mail',
        'version': '1',
        'chainId': 1,
        'verifyingContract': '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
      },
      'message': {
        'from': {
          'name': 'Cow',
          'wallet': '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
        },
        'to': {
          'name': 'Bob',
          'wallet': '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
        },
        'contents': 'Hello, Bob!',
      },
    };

    // Create the RPC request
    final request = EthereumRpcRequest(
      method: 'eth_signTypedData_v4',
      params: [ethereumWallet.address, jsonEncode(typedData)],
    );

    // Sign the typed data
    final result = await provider.request(request);

    result.fold(
      onSuccess: (response) {
        final signature = response.data;
        print('Signature: $signature');
      },
      onFailure: (error) {
        print('Error signing typed data: ${error.message}');
      },
    );
    ```

    ### Parameters

    <ParamField path="method" type="'eth_signTypedData_v4'" required>
      The method for the wallet request. For signing typed data, this is `'eth_signTypedData_v4'`.
    </ParamField>

    <ParamField path="params" type="Object" required>
      <Expandable title="properties" defaultOpen="true">
        <ParamField path="address" type="string">
          The address of the wallet to sign the message with.
        </ParamField>

        <ParamField path="typedData" type="Object" required>
          The typed data to sign with the wallet.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="method" type="'eth_signTypedData_v4'">
      The RPC method executed with the wallet.
    </ResponseField>

    <ResponseField name="data" type="Object">
      Outputs for the RPC method executed with the wallet.

      <Expandable title="properties" defaultOpen="true">
        <ResponseField name="signature" type="string">
          An encoded string serializing the signature produced by the user's wallet.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="NodeJS">
    Use the `signTypedData` method on the Ethereum interface to sign a message with an Ethereum wallet.

    ### Usage

    ```tsx  theme={"system"}
    // Get the signature and encoding from the response
    const {signature, encoding} = await privy
      .wallets()
      .ethereum()
      .signTypedData('insert-wallet-id', {
        params: {
          typed_data: {
            domain: {
              name: 'Ether Mail',
              version: '1',
              chainId: 1,
              verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC'
            },
            types: {
              EIP712Domain: [
                {name: 'name', type: 'string'},
                {name: 'version', type: 'string'},
                {name: 'chainId', type: 'uint256'},
                {name: 'verifyingContract', type: 'address'}
              ],
              Person: [
                {name: 'name', type: 'string'},
                {name: 'wallet', type: 'address'}
              ],
              Mail: [
                {name: 'from', type: 'Person'},
                {name: 'to', type: 'Person'},
                {name: 'contents', type: 'string'}
              ]
            },
            primary_type: 'Mail',
            message: {
              from: {
                name: 'Cow',
                wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826'
              },
              to: {
                name: 'Bob',
                wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB'
              },
              contents: 'Hello, Bob!'
            }
          }
        }
      });
    ```

    ### Parameters and Returns

    Check out the [API reference](/api-reference/wallets/ethereum/eth-signtypeddata-v4) for more details.
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    Use the `signTypedData` method on the Ethereum client to sign a message with an Ethereum wallet.

    ```javascript  theme={"system"}
    signTypedData: (input: {walletId: string, typedData: TypedData}) => Promise<{signature: string, encoding: 'hex'}>
    ```

    ### Usage

    ```tsx  theme={"system"}
    // Get the signature and encoding from the response
    const {signature, encoding} = await privy.walletApi.ethereum.signTypedData({
      walletId: 'insert-wallet-id',
      typedData: {
        domain: {
          name: 'Ether Mail',
          version: '1',
          chainId: 1,
          verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC'
        },
        types: {
          EIP712Domain: [
            {name: 'name', type: 'string'},
            {name: 'version', type: 'string'},
            {name: 'chainId', type: 'uint256'},
            {name: 'verifyingContract', type: 'address'}
          ],
          Person: [
            {name: 'name', type: 'string'},
            {name: 'wallet', type: 'address'}
          ],
          Mail: [
            {name: 'from', type: 'Person'},
            {name: 'to', type: 'Person'},
            {name: 'contents', type: 'string'}
          ]
        },
        primaryType: 'Mail',
        message: {
          from: {
            name: 'Cow',
            wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826'
          },
          to: {
            name: 'Bob',
            wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB'
          },
          contents: 'Hello, Bob!'
        }
      }
    });
    ```

    ### Parameters

    <ParamField path="walletId" type="string" required>
      Unique ID of the wallet to take actions with.
    </ParamField>

    <ParamField path="idempotencyKey" type="string">
      [Idempotency key](/api-reference/idempotency-keys) to identify a unique request.
    </ParamField>

    <ParamField path="typedData" type="Object" required>
      The typed data object to sign with the wallet, with the properties defined in
      [EIP-712](https://eips.ethereum.org/EIPS/eip-712).

      <Expandable title="properties" defaultOpen="true">
        <ParamField path="domain" type="Object" required>
          The typed data's domain, per the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) specification.
        </ParamField>

        <ParamField path="types" type="Object" required>
          The typed data's types, per the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) specification.
        </ParamField>

        <ParamField path="primaryType" type="string" required>
          The typed data's primary type, per the [EIP-712](https://eips.ethereum.org/EIPS/eip-712)
          specification.
        </ParamField>

        <ParamField path="message" type="Object" required>
          The typed data's message, per the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) specification.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="string">
      An encoded string serializing the signature produced by the user's wallet.
    </ResponseField>

    <ResponseField name="encoding" type="'hex'">
      The encoding format for the returned `signature`. Currently, only `'hex'` is supported for
      Ethereum.
    </ResponseField>
  </Tab>

  <Tab title="Java">
    To sign typed data from your wallet, use the `signTypedData` method.
    It will sign your payload, and return the signature to you.

    ### Usage

    ```java  theme={"system"}
    try {
        // Create typed data for EIP-712 signing
        Map<String, Object> domain = Map.of(
            "name", "Ether Mail",
            "version", "1",
            "chainId", 1,
            "verifyingContract", "0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC"
        );

        Map<String, List<EthereumSignTypedDataRpcInputType>> types = Map.of(
            "EIP712Domain", List.of(
                EthereumSignTypedDataRpcInputType.builder().name("name").type("string").build(),
                EthereumSignTypedDataRpcInputType.builder().name("version").type("string").build(),
                EthereumSignTypedDataRpcInputType.builder().name("chainId").type("uint256").build(),
                EthereumSignTypedDataRpcInputType.builder().name("verifyingContract").type("address").build()
            ),
            "Person", List.of(
                EthereumSignTypedDataRpcInputType.builder().name("name").type("string").build(),
                EthereumSignTypedDataRpcInputType.builder().name("wallet").type("address").build()
            ),
            "Mail", List.of(
                EthereumSignTypedDataRpcInputType.builder().name("from").type("Person").build(),
                EthereumSignTypedDataRpcInputType.builder().name("to").type("Person").build(),
                EthereumSignTypedDataRpcInputType.builder().name("contents").type("string").build()
            )
        );

        Map<String, Object> message = Map.of(
            "from", Map.of(
                "name", "Cow",
                "wallet", "0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826"
            ),
            "to", Map.of(
                "name", "Bob",
                "wallet", "0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB"
            ),
            "contents", "Hello, Bob!"
        );

        EthereumSignTypedDataRpcInputTypedData typedData = EthereumSignTypedDataRpcInputTypedData.builder()
            .domain(domain)
            .types(types)
            .primaryType("TestMessage")
            .message(message)
            .build();

        // Example: If wallet's owner is an authorization private key
        AuthorizationContext authorizationContext = AuthorizationContext.builder()
            .addAuthorizationPrivateKey("authorization-key")
            .build();

        EthereumSignTypedDataRpcResponseData response = privyClient
            .wallets()
            .ethereum()
            .signTypedData(
                walletId,
                typedData,
                authorizationContext
            );

        String signature = response.signature();
    } catch (APIException e) {
        String errorBody = e.bodyAsString();
        System.err.println(errorBody);
    } catch (Exception e) {
        System.err.println(e.getMessage());
    }
    ```

    ### Parameters

    When defining a typed data payload, you may specify the following values on the `EthereumSignTypedDataRpcInputTypedData` builder:

    <ParamField type="Map<String, Object>" body="domain">
      The domain of the typed data payload.
    </ParamField>

    <ParamField type="Map<String, List<EthereumSignTypedDataRpcInputType>>" body="types">
      The types of the typed data payload.
    </ParamField>

    <ParamField type="Map<String, Object>" body="message">
      The message of the typed data payload.
    </ParamField>

    <ParamField type="String" body="primaryType">
      The primary type of the typed data payload.
    </ParamField>

    ### Returns

    The `EthereumSignTypedDataRpcResponseData` object contains a `signature()` field

    <ResponseField name="signature()" type="String">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="Rust">
    Use the `sign_typed_data` method on the Ethereum service to sign EIP-712 typed data with an Ethereum wallet.

    ### Usage

    ```rust  theme={"system"}
    use privy_rs::{AuthorizationContext, PrivyClient};

    let client = PrivyClient::new("app_id".to_string(), "app_secret".to_string())?;
    let ethereum_service = client.wallets().ethereum();
    let auth_ctx = AuthorizationContext::new();

    // Create EIP-712 typed data structure
    let typed_data = EthereumSignTypedDataRpcInputParamsTypedData {
        domain: Default::default(),
        message: Default::default(),
        primary_type: "Mail".to_string(),
        types: Default::default(),
    };

    let signature = ethereum_service
        .sign_typed_data(&wallet_id, typed_data, &auth_ctx, None)
        .await?;

    println!("Typed data signed successfully");
    ```

    ### Parameters and Returns

    See the Rust SDK documentation for detailed parameter and return types, including embedded examples:

    * [EthereumService::sign\_typed\_data](https://docs.rs/privy-rs/latest/privy_rs/ethereum/struct.EthereumService.html#method.sign_typed_data)

    For REST API details, see the [API reference](/api-reference/wallets/ethereum/eth-signtypeddata-v4).
  </Tab>

  <Tab title="REST API">
    To sign typed data make a POST request to

    ```bash  theme={"system"}
    https://api.privy.io/v1/wallets/<wallet_id>/rpc
    ```

    ### Parameters

    <ParamField path="method" type="'eth_signTypedData_v4'" required>
      RPC method to execute with the wallet.
    </ParamField>

    <ParamField path="params" type="Object" required>
      Parameters for the RPC method to execute with the wallet.

      <Expandable title="properties" defaultOpen="true">
        <ParamField path="message" type="string" required>
          The message to sign with the wallet. If the message to sign is raw bytes, you must serialize
          the message as a hexadecimal string.
        </ParamField>

        <ParamField path="encoding" type="'utf-8' | 'hex'" required>
          The encoding format for `params.message`. Use `utf-8` for a string message and `hex` for
          bytes.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="method" type="'eth_signTypedData_v4'">
      The RPC method executed with the wallet.
    </ResponseField>

    <ResponseField name="data" type="Object">
      Outputs for the RPC method executed with the wallet.

      <Expandable title="properties" defaultOpen="true">
        <ResponseField name="signature" type="string">
          An encoded string serializing the signature produced by the user's wallet.
        </ResponseField>

        <ResponseField name="encoding" type="'hex'">
          The encoding format for the returned `signature`. Currently, only `'hex'` is supported for Ethereum.
        </ResponseField>
      </Expandable>
    </ResponseField>

    ### Usage

    ```bash  theme={"system"}
    curl --request POST https://api.privy.io/v1/wallets/<wallet_id>/rpc \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H "privy-authorization-signature: <authorization-signature-for-request>" \
    -H 'Content-Type: application/json' \
    -d '{
      "method": "eth_signTypedData_v4",
      "params": {
        "typed_data": {
          "types": {
            "EIP712Domain": [
              { "name": "name", "type": "string" },
              { "name": "version", "type": "string" },
              { "name": "chainId", "type": "uint256" },
              { "name": "verifyingContract", "type": "address" }
            ],
            "Person": [
              { "name": "name", "type": "string" },
              { "name": "wallet", "type": "address" }
            ],
            "Mail": [
              { "name": "from", "type": "Person" },
              { "name": "to", "type": "Person" },
              { "name": "contents", "type": "string" }
            ]
          },
          "message": {
            "from": {
              "name": "Alice",
              "wallet": "0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826"
            },
            "to": {
              "name": "Bob",
              "wallet": "0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB"
            },
            "contents": "Hello, Bob!"
          },
          "primary_type": "Mail",
          "domain": {
            "name": "DApp Mail",
            "version": "1",
            "chainId": 1,
            "verifyingContract": "0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC"
          }
        }
      }
    }'
    ```
  </Tab>
</Tabs>


# Switch chains
Source: https://docs.privy.io/wallets/using-wallets/ethereum/switch-chain



<Tabs>
  <Tab title="React">
    To switch the network of a connected wallet, first [find the corresponding **`ConnectedWallet`** object](/wallets/wallets/get-a-wallet) from the **`wallets`** array.

    ```tsx  theme={"system"}
    const {wallets} = useWallets();
    const wallet = wallets[0]; // Replace this with your desired wallet
    ```

    Then, call the wallet's **`switchChain`** method. As a parameter to the method, pass the chain ID for your desired network as a `number` or hexadecimal `string`:

    ```tsx  theme={"system"}
    await wallet.switchChain(7777777);
    ```

    For embedded wallets, **`switchChain`** will update the network of the embedded wallet behind the scenes. For external wallets, **`switchChain`** will prompt the user to switch to the target network within the external wallet's client (e.g. their browser extension or mobile app).

    **`switchChain`** returns a Promise that resolves to `void` once the wallet has successfully been switched to the target network. The Promise will reject with an error if:

    * The target chain has [not been configured](/basics/react/advanced/configuring-evm-networks).
    * The user declines the request to switch their network, if using an external wallet.
  </Tab>

  <Tab title="React Native">
    By default, embedded wallets will be connected to the first network specified in your **`supportedChains`** array, and to Ethereum mainnet if no **`supportedChains`** are specified.

    To switch the embedded wallet to a different network, **send a [`wallet_switchEthereumChain`](https://docs.metamask.io/wallet/reference/wallet_switchethereumchain/) JSON-RPC request to the wallet's EIP-1193 provider.** In the request's **`params`**, specify your target **`chainId`** as a hexadecimal string.

    ```ts  theme={"system"}
    import {useEmbeddedEthereumWallet} from '@privy-io/expo';

    const {wallets} = useEmbeddedEthereumWallet();
    const wallet = wallets[0]; // Replace this with your desired wallet

    const provider = await wallet.getProvider();
    await provider.request({
      method: 'wallet_switchEthereumChain',
      // Replace '0x5' with the chainId of your target network
      params: [{chainId: '0x5'}]
    });
    ```

    You can also use the **`eth_chainId`** request (with no **`params`**) to get the current network of the embedded wallet.
  </Tab>
</Tabs>


# Interfacing with common libraries
Source: https://docs.privy.io/wallets/using-wallets/ethereum/web3-integrations



<Tabs>
  <Tab title="React">
    <Tip>
      Privy is fully compatible with popular web3 libraries for interfacing wallets, including [`viem`](https://viem.sh/), [`wagmi`](https://wagmi.sh/), [`ethers`](https://docs.ethers.org/), and [`web3js`](https://web3js.readthedocs.io/en/v1.10.0/).
    </Tip>

    Read below to learn how to best integrate Privy alongside these libraries.

    ## Viem

    Viem represents connected wallets as either an [**account**](https://viem.sh/docs/accounts/local.html) object, which can sign with the wallet, or a [**wallet client**](https://viem.sh/docs/clients/wallet.html) object, which can also send transactions from the wallet.

    ### Getting an account

    To get an account for a user's connected wallet, import the `toViemAccount` method and the `useWallets` hook from the React SDK.

    ```tsx  theme={"system"}
    import {toViemAccount, useWallets} from '@privy-io/react-auth';
    ```

    Then, pass the `ConnectedWallet` object for your user's wallet to the method, which will return a `LocalAccount` instance.

    ```tsx  theme={"system"}
    const {wallets} = useWallets();

    const wallet = wallets.find((wallet) => (wallet.address === 'your-desired-address'));
    const account = await toViemAccount({wallet});
    ```

    You can then use the `account` to sign messages, typed data payloads, and transactions.

    ### Getting a wallet client

    To get a viem wallet client for a user's connected wallet, first import your desired network from the **`viem/chains`** package and import the **`createWalletClient`** method and **`custom`** transport from **`viem`**:

    ```tsx  theme={"system"}
    import {createWalletClient, custom} from 'viem';
    // Replace `sepolia` with your desired network
    import {sepolia} from 'viem/chains';
    ```

    Then, find your desired wallet from the **`wallets`** array and switch its network to the chain you imported, using the wallet's **`switchChain`** method:

    ```tsx  theme={"system"}
    const {wallets} = useWallets();
    const wallet = wallets[0]; // Replace this with your desired wallet
    await wallet.switchChain(sepolia.id);
    ```

    Lastly, get the wallet's EIP1193 provider using the wallet's **`getEthereumProvider`** method and pass it to viem's **`createWalletClient`** method like so:

    ```tsx  theme={"system"}
    const provider = await wallet.getEthereumProvider();
    const walletClient = createWalletClient({
        account: wallet.address as Hex,
        chain: sepolia,
        transport: custom(provider),
    });
    ```

    You can then use the [**wallet client**](https://viem.sh/docs/clients/wallet) to get information about the wallet or request signatures and transactions.

    ## Wagmi

    Privy is fully compatible with **`wagmi`**. Please see our [**wagmi guide**](/wallets/connectors/ethereum/integrations/wagmi) for setting up the integration.

    ## Ethers

    ### Ethers v5

    ```tsx  theme={"system"}
    const privyProvider = await wallet.getEthereumProvider();
    const provider = new ethers.providers.Web3Provider(privyProvider);
    ```

    ### Ethers v6

    ```tsx  theme={"system"}
    const provider = await wallet.getEthereumProvider();
    const ethersProvider = new ethers.BrowserProvider(provider);
    const signer = ethersProvider.getSigner();
    ```

    ## Web3.js

    Web3.js represents connected wallets as a [**Web3**](https://docs.web3js.org/guides/web3_providers_guide/#providers-types) object, which you can use to get information about the current wallet or the request signatures and transactions.

    To get a Web3js provider for a user's connected wallet, first [find your desired wallet](/wallets/wallets/get-a-wallet/get-connected-wallet) from the **`wallets`** array and switch it to your desired network, using the wallet's **`switchChain`** method:

    ```ts  theme={"system"}
    const {wallets} = useWallets();
    const wallet = wallets[0]; // Replace this with your desired wallet
    await wallet.switchChain(sepolia.id);
    ```

    Then, get the wallet's EIP1193 provider using the wallet's **`getEthereumProvider`** method and pass it to Web3js's **`Web3`** constructor like so:

    ```ts  theme={"system"}
    const provider = await wallet.getEthereumProvider();
    const web3 = new Web3(provider);
    ```

    You can then use the [**Web3 provider**](https://docs.web3js.org/guides/web3_providers_guide/) to get information about the wallet or request signatures and transactions.
  </Tab>

  <Tab title="React Native">
    <Tip>
      Privy is fully compatible with popular web3 libraries for interfacing wallets, including [`viem`](https://viem.sh/), [`ethers`](https://docs.ethers.org/), and [`web3js`](https://web3js.readthedocs.io/en/v1.10.0/).
    </Tip>

    <Warning>
      Third-party libraries may require additional shims to be used in a React Native environment.
    </Warning>

    ### Integrating with `viem`

    First, import the necessary methods, objects, and networks from `viem`:

    ```ts  theme={"system"}
    import {createWalletClient, custom} from 'viem';
    // Replace 'mainnet' with your desired network
    import {mainnet} from 'viem/chains';
    ```

    Next, get an EIP-1193 provider for the user's embedded wallet, and switch its network to your desired network:

    ```ts  theme={"system"}
    const provider = await wallet.getProvider();
    await provider.request({
        method: 'wallet_switchEthereumChain',
        // Replace '0x1' with the chain ID of your desired network
        params: [{chainId: '0x1'}],
    });
    ```

    Lastly, initialize a viem Wallet Client from the EIP-1193 provider:

    ```ts  theme={"system"}
    const walletClient = createWalletClient({
        // Replace this with your desired network that you imported from viem
        chain: mainnet,
        transport: custom(provider),
    });
    ```

    You can now use methods implemented by viem's [Wallet Client](https://viem.sh/docs/clients/wallet.html), including [`signMessage`](https://viem.sh/docs/actions/wallet/signMessage.html#signmessage), [`signTypedData`](https://viem.sh/docs/actions/wallet/signTypedData.html#signtypeddata), and [`sendTransaction`](https://viem.sh/docs/actions/wallet/sendTransaction.html#sendtransaction)!

    ### Integrating with `ethers`

    First, import `ethers`:

    ```ts  theme={"system"}
    import {ethers} from 'ethers';
    ```

    Next, get an EIP-1193 provider for the user's embedded wallet, and switch its network to your desired network:

    ```ts  theme={"system"}
    await provider.request({
        method: 'wallet_switchEthereumChain',
        // Replace '0x1' with the chain ID of your desired network
        params: [{chainId: '0x1'}],
    });
    ```

    Lastly, initialize an ethers provider and signer from this EIP-1193 provider:

    ```ts  theme={"system"}
    const ethersProvider = new ethers.providers.Web3Provider(provider);
    const ethersSigner = ethersProvider.getSigner();
    ```

    You can then use methods implemented by ethers' [providers](https://docs.ethers.org/v5/api/providers/) and [signers](https://docs.ethers.org/v5/api/signer/), including [`signMessage`](https://docs.ethers.org/v5/api/signer/#Signer-signMessage) and [`sendTransaction`](https://docs.ethers.org/v5/api/signer/#Signer-sendTransaction).

    ### Integrating with `web3.js`

    First, import `web3`:

    ```ts  theme={"system"}
    import {Web3} from 'web3';
    ```

    Next, get an EIP-1193 provider for the user's embedded wallet, and switch its network to your desired network:

    ```ts  theme={"system"}
    await wallet.provider.request({
        method: 'wallet_switchEthereumChain',
        // Replace '0x1' with the chain ID of your desired network
        params: [{chainId: '0x1'}],
    });
    ```

    Lastly, initialize an ethers provider and signer from this EIP-1193 provider:

    ```ts  theme={"system"}
    const web3 = new Web3(wallet.getEthereumProvider());
    ```

    You can then use interfaces by web3.js for [signing messages](https://docs.web3js.org/guides/wallet/signing), [sending transactions](https://docs.web3js.org/guides/wallet/transactions), and [more](https://docs.web3js.org/guides/web3_eth/eth).
  </Tab>

  <Tab title="NodeJS">
    ### Viem

    [`viem`](https://viem.sh/docs/accounts/local.html) is a popular TypeScript library on EVM for executing onchain actions with wallets. Privy's wallets on EVM natively integrate with `viem`, allowing you to use the library's interfaces for signing messages, signing typed data, sending transactions, and more.

    To integrate with `viem`, first install version `2^` of the library as a peer dependency:

    ```sh  theme={"system"}
    npm i viem@latest
    ```

    Then, use Privy's `createViemAccount` method to initialize an instance of a viem [`Account`](https://viem.sh/docs/accounts/local) for an EVM wallet. As a parameter to this method, pass an object with the following:

    | Field      | Type          | Description                                |
    | ---------- | ------------- | ------------------------------------------ |
    | `privy`    | `PrivyClient` | Instance of the Privy client for your app. |
    | `walletId` | `string`      | ID of the wallet.                          |
    | `address`  | `0x${string}` | Ethereum address of the wallet.            |

    As an example, you can initialize an `Account` like so:

    ```tsx  theme={"system"}
    import {PrivyClient} from '@privy-io/node';
    import {createViemAccount} from '@privy-io/node/viem';

    // Initialize your Privy client
    const privy = new PrivyClient(...);
    // Create a viem account instance for a wallet
    const account = await createViemAccount(privy, {
        walletId: 'insert-wallet-id',
        address: 'insert-address'
    });
    ```

    <Tip>
      If your wallet requires an [authorization context](/controls/authorization-keys/using-owners/sign/signing-on-the-server),
      you should pass it to the `createViemAccount` method like so:

      ```tsx  theme={"system"}
      const serverWalletAccount = await createViemAccount(privy, {
        walletId: 'insert-wallet-id',
        address: 'insert-address',
        authorizationContext: {
          authorization_private_keys: ['your authorization private key']
        }
      });
      ```
    </Tip>

    From the returned `Account`, you can then initialize a viem [`WalletClient`](https://viem.sh/docs/clients/wallet) to sign messages and execute transactions with the wallet like so:

    ```tsx  theme={"system"}
    import {createWalletClient, http, parseEther} from 'viem';
    import {base} from 'viem/chains';

    const client = createWalletClient({
        account, // `Account` instance from above
        chain: base, // Replace with your desired network
        transport: http()
    });

    const hash = await client.sendTransaction({
        to: '0x59D3eB21Dd06A211C89d1caBE252676e2F3F2218',
        value: parseEther('0.001')
    });
    ```
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    ### Viem

    [`viem`](https://viem.sh/docs/accounts/local.html) is a popular TypeScript library on EVM for executing onchain actions with wallets. Privy's wallets on EVM natively integrate with `viem`, allowing you to use the library's interfaces for signing messages, signing typed data, sending transactions, and more.

    To integrate with `viem`, first install version `2^` of the library as a peer dependency:

    ```sh  theme={"system"}
    npm i viem@latest
    ```

    Then, use Privy's `createViemAccount` method to initialize an instance of a viem [`Account`](https://viem.sh/docs/accounts/local) for an EVM wallet. As a parameter to this method, pass an object with the following:

    | Field      | Type          | Description                                |
    | ---------- | ------------- | ------------------------------------------ |
    | `walletId` | `string`      | ID of the wallet.                          |
    | `address`  | `0x${string}` | Ethereum address of the wallet.            |
    | `privy`    | `PrivyClient` | Instance of the Privy client for your app. |

    As an example, you can initialize an `Account` like so:

    ```tsx  theme={"system"}
    import {PrivyClient} from '@privy-io/server-auth';
    import {createViemAccount} from '@privy-io/server-auth/viem';

    // Initialize your Privy client
    const privy = new PrivyClient(...);
    // Create a viem account instance for a wallet
    const account = await createViemAccount({
        walletId: 'insert-wallet-id',
        address: 'insert-address',
        privy
    });
    ```

    From the returned `Account`, you can then initialize a viem [`WalletClient`](https://viem.sh/docs/clients/wallet) to sign messages and execute transactions with the wallet like so:

    ```tsx  theme={"system"}
    import {createWalletClient, http, parseEther} from 'viem';
    import {base} from 'viem/chains';

    const client = createWalletClient({
        account, // `Account` instance from above
        chain: base, // Replace with your desired network
        transport: http()
    });

    const hash = await client.sendTransaction({
        to: '0x59D3eB21Dd06A211C89d1caBE252676e2F3F2218',
        value: parseEther('0.001')
    });
    ```

    ### Ethers

    Ethers is a popular TypeScript library for interacting with the Ethereum blockchain. Privy's wallets on EVM natively integrate with ethers, allowing you to use the library's interfaces for signing messages, signing typed data, sending transactions, and more.

    To integrate with `ethers`, first install version 6^ of the library as a peer dependency:

    ```sh  theme={"system"}
    npm i ethers@latest
    ```

    Then, use Privy's `createEthersSigner` method to initialize an instance of an ethers [`Wallet`](https://docs.ethers.org/v6/api/wallet/) for an EVM wallet. As a parameter to this method, pass an object with the following:

    | Field         | Type                     | Description                                |
    | ------------- | ------------------------ | ------------------------------------------ |
    | `walletId`    | `string`                 | ID of the wallet.                          |
    | `address`     | `0x${string}`            | Ethereum address of the wallet.            |
    | `provider`    | `ethers.JsonRpcProvider` | Instance of the ethers provider.           |
    | `privyClient` | `PrivyClient`            | Instance of the Privy client for your app. |

    ```typescript  theme={"system"}
    import {ethers, TransactionRequest} from 'ethers';

    import {PrivyClient} from '@privy-io/server-auth';
    import {createEthersSigner} from '@privy-io/server-auth/ethers';

    // Initialize your Privy client
    const privyClient = new PrivyClient(...);

    // Initialize your ethers provider
    const provider = new ethers.JsonRpcProvider('https://base.llamarpc.com');

    // Get your wallet
    const walletId = 'insert-wallet-id';
    const wallet = await privyClient.walletApi.getWallet({id: walletId});
    const address = wallet.address;

    // Create an ethers signer
    const signer = createEthersSigner({
        walletId,
        address,
        provider,
        privyClient,
    });
    ```

    Once you have an ethers signer, you can use it to sign messages and send transactions with the wallet like so:

    ```typescript  theme={"system"}
    const transaction: TransactionRequest = {
        to: TO_ADDRESS,
        value: 100,
        chainId: 8453,
    };

    const signedMessage = await signer.signMessage('foobar');
    const signedTransaction = await signer.signTransaction(transaction);
    const result = await signer.sendTransaction(transaction);
    ```
  </Tab>

  <Tab title="Python">
    ### Integrating with [`eth-account`](https://pypi.org/project/eth-account/)

    Privy EVM wallets natively integrate with the Python `eth-account` library, allowing you to use the library's interfaces for signing messages, signing typed data, sending transactions, and more.

    To integrate with `eth-account`, first install the library as a dependency:

    ```sh  theme={"system"}
    pip install privy-eth-account
    ```

    Then, use Privy's `create_eth_account` function to initialize an instance of an Account for an EVM wallet. As parameters to this function, pass:

    | Parameter   | Type              | Description                                     |
    | ----------- | ----------------- | ----------------------------------------------- |
    | `client`    | `PrivyHTTPClient` | Instance of the Privy HTTP client for your app. |
    | `address`   | `str`             | Ethereum address of the wallet.                 |
    | `wallet_id` | `str`             | ID of the wallet.                               |

    Here's an example showing how to integrate with `eth-account`:

    ```Python  theme={"system"}
    from privy_eth_account import create_eth_account, PrivyHTTPClient
    from eth_account.messages import encode_typed_data, encode_defunct

    # Initialize your Privy client
    client = PrivyHTTPClient(
        app_id="YOUR_APP_ID",
        app_secret="YOUR_APP_SECRET",
        authorization_key="YOUR_AUTHORIZATION_KEY"
    )

    # Create an account instance for a wallet
    wallet_id = "insert-wallet-id"
    wallet_address = "insert-wallet-address"
    account = create_eth_account(client, wallet_address, wallet_id)
    ```

    Once you created an account instance, you can use it to sign messages, sign transactions, and sign typed data:

    ### Sign a message

    ```Python  theme={"system"}
    # Signing a message (personal_sign)
    message = encode_defunct(text="Hello, Privy!")
    signed_message = account.sign_message(message)
    print(f"Signed message: {signed_message}")
    ```

    ### Sign a transaction

    ```Python  theme={"system"}
    # Signing a transaction
    transaction = {
        "to": "0x123...789",
        "value": 100,
        "chain_id": 8453
    }
    signed_tx = account.sign_transaction(transaction)
    print(f"Signed transaction: {signed_tx}")
    ```

    ### Signing EIP-712 Typed Data

    ```Python  theme={"system"}
    # Example EIP-712 typed data
    # Structure your typed data as a full message
    full_message = {
        "domain": {
            "name": "My App",
            "version": "1",
            "chainId": 8453,
            "verifyingContract": "0xCc9c3D98163F4F6Af884e259132e15D6d27A5c57",
            "salt": "pepper"
        },
        "types": {
            'EIP712Domain': [
                {'name': 'name', 'type': 'string'},
                {'name': 'version', 'type': 'string'},
                {'name': 'chainId', 'type': 'uint256'},
                {'name': 'verifyingContract', 'type': 'address'},
                {'name': 'salt', 'type': 'string'}
            ],
            'Person': [
                {'name': 'name', 'type': 'string'},
                {'name': 'wallet', 'type': 'address'}
            ],
            'Mail': [
                {'name': 'from', 'type': 'Person'},
                {'name': 'to', 'type': 'Person'},
                {'name': 'contents', 'type': 'string'}
            ]
        },
        "message": {
            "from": {
                "name": "Alice",
                "wallet": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
            },
            "to": {
                "name": "Bob",
                "wallet": "0xCc9c3D98163F4F6Af884e259132e15D6d27A5c57"
            },
            "contents": "Hello, Bob!"
        },
        "primaryType": "Mail"
    }

    # Sign the typed data using the full_message parameter
    signed_typed_data = account.sign_typed_data(full_message=full_message)
    print(f"Signed typed data: {signed_typed_data}")
    ```
  </Tab>

  <Tab title="Rust">
    ### Alloy

    [`alloy`](https://alloy.rs/) is a comprehensive Rust library for Ethereum that provides type-safe, high-performance blockchain interactions. Privy's Rust SDK integrates seamlessly with alloy, allowing you to leverage alloy's powerful types and utilities while using Privy for wallet management and signing.

    <Callout>
      Coming soon.
    </Callout>
  </Tab>
</Tabs>


# Smart wallets
Source: https://docs.privy.io/wallets/using-wallets/evm-smart-wallets/overview



Privy makes it easy to create **smart wallets** for your users. Smart wallets are **programmable, onchain accounts** that incorporate the features of [account abstraction](https://ethereum.org/en/roadmap/account-abstraction/). With just a few lines of code, you can create smart wallets for your users to sponsor gas payments, send batched transactions, and more.

<Tip>
  We recommend using our native gas sponsorship offering to sponsor transactions on EVM and Solana.
  [Learn more](/wallets/gas-and-asset-management/gas/overview)
</Tip>

<Info>
  Please note that this native smart wallet integration is only available in the React and React
  Native SDKs. To configure smart wallets with wallets created using server-side SDKs or APIs,
  follow [this guide](/wallets/gas-and-asset-management/gas/ethereum).
</Info>

<img src="https://mintcdn.com/privy-c2af3412/zeEEdrxSbmZQCA-7/images/wallets/smart-wallets.png?fit=max&auto=format&n=zeEEdrxSbmZQCA-7&q=85&s=af4dd0c0e048cb8fe71daf516ee1e85e" alt="Sample enable smart wallets" data-og-width="3686" width="3686" data-og-height="2633" height="2633" data-path="images/wallets/smart-wallets.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/zeEEdrxSbmZQCA-7/images/wallets/smart-wallets.png?w=280&fit=max&auto=format&n=zeEEdrxSbmZQCA-7&q=85&s=d6f39a99d7265206c1f03df225c7632a 280w, https://mintcdn.com/privy-c2af3412/zeEEdrxSbmZQCA-7/images/wallets/smart-wallets.png?w=560&fit=max&auto=format&n=zeEEdrxSbmZQCA-7&q=85&s=e393540f7fb8aa33022537e1e1de5c84 560w, https://mintcdn.com/privy-c2af3412/zeEEdrxSbmZQCA-7/images/wallets/smart-wallets.png?w=840&fit=max&auto=format&n=zeEEdrxSbmZQCA-7&q=85&s=d08157333f7faffcf534818a60ec73d4 840w, https://mintcdn.com/privy-c2af3412/zeEEdrxSbmZQCA-7/images/wallets/smart-wallets.png?w=1100&fit=max&auto=format&n=zeEEdrxSbmZQCA-7&q=85&s=1992e7c79d49c685b7405f25f053b1c8 1100w, https://mintcdn.com/privy-c2af3412/zeEEdrxSbmZQCA-7/images/wallets/smart-wallets.png?w=1650&fit=max&auto=format&n=zeEEdrxSbmZQCA-7&q=85&s=46315712f250c0870ae829bdd26e6caf 1650w, https://mintcdn.com/privy-c2af3412/zeEEdrxSbmZQCA-7/images/wallets/smart-wallets.png?w=2500&fit=max&auto=format&n=zeEEdrxSbmZQCA-7&q=85&s=efbe6022bc7646202af09cb1379fd4d1 2500w" />

To set up with smart wallets, start by [enabling smart wallets in the Privy Dashboard](/wallets/using-wallets/evm-smart-wallets/setup/configuring-dashboard). This will configure your app to create smart wallets for your users controlled by Privy embedded signers.

### Native ERC-4337 support with embedded signers

Under the hood, a smart wallet is an [ERC-4337](https://www.erc4337.io/)-compatible smart contract deployed onchain. This smart contract can be programmed to support features like transaction batching, gas sponsorship, delegating permissions, and more.

When using a smart wallet, a user's assets are held by the smart contract itself. This smart contract is controlled by an **embedded signer** (an externally-owned account) secured by Privy's self-custodial wallet infrastructure. Privy automatically takes care of creating signers for users and generating smart contract wallets controlled by these signers.

Your app can customize which ERC-4337 account *implementation* powers your users' smart wallets, between Kernel (ZeroDev), Safe, LightAccount (Alchemy), Biconomy, Thirdweb, and the Coinbase Smart Wallet.

<Info>
  Privy partners with the ERC-4337 account providers above to ensure a smooth experience. If you'd
  like us to add support for another, please [reach out](https://privy.io/slack)!
</Info>

### Gas sponsorship with paymasters

With smart wallets, your app can pay for gas fees simply by registering a paymaster URL in the Privy Dashboard. Privy will automatically route gas payments from your registered paymaster instead of your users' wallets, allowing your users to transact on-chain *instantly* –– even if they don't have a balance in their smart wallet.

### Future-proofed for the latest standards

Privy works closely with the teams building the next generation of account abstraction standards on top of ERC-4337, such as permissions & session keys ([ERC-7715](https://ethereum-magicians.org/t/erc-7715-grant-permissions-from-wallets/20100)), smart wallet modules ([ERC-7579](https://erc7579.com/)), and smart account discovery ([ERC-7555](https://ethereum-magicians.org/t/erc-7555-single-sign-on-for-account-discovery/16536)) across different applications. As these standards become ratified, Privy will incorporate native support for these features.


# Configure smart wallets in the dashboard
Source: https://docs.privy.io/wallets/using-wallets/evm-smart-wallets/setup/configuring-dashboard



<Tip>
  Enable smart wallets in the [Privy Dashboard](https://dashboard.privy.io/apps?page=smart-wallets)
  before implementing this feature.
</Tip>

## 1. Enable smart wallets

First, enable the smart wallets toggle and select a smart wallet type. Privy currently supports [Kernel](https://zerodev.app/), [Biconomy](https://www.biconomy.io/smart-accounts), [Light Account](https://www.alchemy.com/account-contracts), [Safe](https://safe.global/), [Thirdweb](https://thirdweb.com/contracts) and the [Coinbase Smart Wallet](https://github.com/coinbase/smart-wallet) as smart wallet types.

<img src="https://mintcdn.com/privy-c2af3412/zeEEdrxSbmZQCA-7/images/wallets/configure-smart-wallets.png?fit=max&auto=format&n=zeEEdrxSbmZQCA-7&q=85&s=53ae6c45633e66dafc817bea19ea6ad4" alt="Sample enable smart wallets" data-og-width="3686" width="3686" data-og-height="2633" height="2633" data-path="images/wallets/configure-smart-wallets.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/zeEEdrxSbmZQCA-7/images/wallets/configure-smart-wallets.png?w=280&fit=max&auto=format&n=zeEEdrxSbmZQCA-7&q=85&s=5547a01691757237475ef0a1702769ef 280w, https://mintcdn.com/privy-c2af3412/zeEEdrxSbmZQCA-7/images/wallets/configure-smart-wallets.png?w=560&fit=max&auto=format&n=zeEEdrxSbmZQCA-7&q=85&s=6fe0676570a1e359b460d260c1958817 560w, https://mintcdn.com/privy-c2af3412/zeEEdrxSbmZQCA-7/images/wallets/configure-smart-wallets.png?w=840&fit=max&auto=format&n=zeEEdrxSbmZQCA-7&q=85&s=72ac1821c5b6ce3bade5b75ea24d7605 840w, https://mintcdn.com/privy-c2af3412/zeEEdrxSbmZQCA-7/images/wallets/configure-smart-wallets.png?w=1100&fit=max&auto=format&n=zeEEdrxSbmZQCA-7&q=85&s=2d005df361c5dc800ee8a26c2eeab83f 1100w, https://mintcdn.com/privy-c2af3412/zeEEdrxSbmZQCA-7/images/wallets/configure-smart-wallets.png?w=1650&fit=max&auto=format&n=zeEEdrxSbmZQCA-7&q=85&s=719ad71983b6ee708d06c6f02f5d7fd5 1650w, https://mintcdn.com/privy-c2af3412/zeEEdrxSbmZQCA-7/images/wallets/configure-smart-wallets.png?w=2500&fit=max&auto=format&n=zeEEdrxSbmZQCA-7&q=85&s=a14bdcd98c06b1bcc994c417245232db 2500w" />

<Info>
  If you modify your smart wallet type after users have already created smart wallets, Privy will
  provision the original smart wallet type for existing users to ensure they can access the accounts
  they already use.
</Info>

## 2. Configure the supported networks

Next, configure the networks for your smart wallets. You should do this for *any* network that your app plans to use smart wallets on.

<img src="https://mintcdn.com/privy-c2af3412/zeEEdrxSbmZQCA-7/images/wallets/configure-smart-wallets-configure-chain.png?fit=max&auto=format&n=zeEEdrxSbmZQCA-7&q=85&s=af3c0c9712235a26d2afa9fa3ee7c2d1" alt="Sample enable smart wallets" data-og-width="3686" width="3686" data-og-height="2633" height="2633" data-path="images/wallets/configure-smart-wallets-configure-chain.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/zeEEdrxSbmZQCA-7/images/wallets/configure-smart-wallets-configure-chain.png?w=280&fit=max&auto=format&n=zeEEdrxSbmZQCA-7&q=85&s=93b69f44673eec477978f0da39fcd9f3 280w, https://mintcdn.com/privy-c2af3412/zeEEdrxSbmZQCA-7/images/wallets/configure-smart-wallets-configure-chain.png?w=560&fit=max&auto=format&n=zeEEdrxSbmZQCA-7&q=85&s=90d793779ceb9951f4add2987bd1c041 560w, https://mintcdn.com/privy-c2af3412/zeEEdrxSbmZQCA-7/images/wallets/configure-smart-wallets-configure-chain.png?w=840&fit=max&auto=format&n=zeEEdrxSbmZQCA-7&q=85&s=c3fe83a10f6c5fd6c06c2972818e9ad3 840w, https://mintcdn.com/privy-c2af3412/zeEEdrxSbmZQCA-7/images/wallets/configure-smart-wallets-configure-chain.png?w=1100&fit=max&auto=format&n=zeEEdrxSbmZQCA-7&q=85&s=99a8cd9476e50f685efc5f0ea5d2517d 1100w, https://mintcdn.com/privy-c2af3412/zeEEdrxSbmZQCA-7/images/wallets/configure-smart-wallets-configure-chain.png?w=1650&fit=max&auto=format&n=zeEEdrxSbmZQCA-7&q=85&s=2615cbfb3699d5bae4d1c1c490c98452 1650w, https://mintcdn.com/privy-c2af3412/zeEEdrxSbmZQCA-7/images/wallets/configure-smart-wallets-configure-chain.png?w=2500&fit=max&auto=format&n=zeEEdrxSbmZQCA-7&q=85&s=d45ff0dc5ee5369de4faabc80add1622 2500w" />

For each configured network, you can optionally provide a bundler URL and/or a paymaster URL.

#### Bundler

The **bundler URL** specifies the node you want to use bundle operations from multiple users into a single transaction. If a bundler URL is not set for a network, Privy defaults to Pimlico's public bundler (`https://public.pimlico.io/v2/{chainId}/rpc`).

<Tip>
  **We strongly recommend setting your own bundler URL when taking smart wallets to production**, to
  give you more control over bundler rate limits. Privy's default bundler is heavily rate limited
  and is not suitable for production usage.
</Tip>

#### Paymaster

The **paymaster URL** specifies the paymaster used to sponsor gas fees for the smart wallets on the network. If a paymaster URL is set, Privy will use that paymaster to sponsor gas fees for your users' transactions. If a paymaster URL is not set, your users' smart wallets must have a balance of the network's native currency to pay for gas fees for transactions.

For additional security, we strongly recommend setting **Allowed domains** for your paymaster and/or bundler through your provider's dashboard, to restrict usage of these URLs to only your website.

#### Recommended providers

If you are looking to set up a paymaster or bundler for your app, we suggest the following providers:

| Provider | Get started                                                                                                                      |
| -------- | -------------------------------------------------------------------------------------------------------------------------------- |
| Pimlico  | [https://dashboard.pimlico.io](https://dashboard.pimlico.io)                                                                     |
| ZeroDev  | [https://dashboard.zerodev.app/](https://dashboard.zerodev.app/)                                                                 |
| Alchemy  | [https://dashboard.alchemy.com/](https://dashboard.alchemy.com/)                                                                 |
| Biconomy | [https://dashboard.biconomy.io/](https://dashboard.biconomy.io/)                                                                 |
| Thirdweb | [https://thirdweb.com](https://thirdweb.com)                                                                                     |
| Coinbase | [https://www.coinbase.com/developer-platform/products/paymaster](https://www.coinbase.com/developer-platform/products/paymaster) |

<Tip>
  If using **Alchemy** for your paymaster, please provide your Alchemy gas policy ID. Each gas
  policy ID is tied to a specific chain and Alchemy project.
</Tip>

<Tip>
  If using **Biconomy** as a paymaster with `@privy-io/react-auth`, you can override our default
  paymaster context in the `SmartAccountsProvider`. View more in [our setup
  notes](/wallets/using-wallets/evm-smart-wallets/usage).
</Tip>

#### Custom chains

If you do not see the chain you wish to configure on the drop down, you can configure a custom chain. Before configuring a custom chain on the Privy dashboard, please ensure the chain is supported by your smart wallet provider. Custom chain configuration requires an EIP155 chain ID, chain name, paymaster URL, bundler URL, and RPC URL; none of these values can be defaulted as they are in supported chains.


# Configure smart wallets in the SDK
Source: https://docs.privy.io/wallets/using-wallets/evm-smart-wallets/setup/configuring-sdk



Once you have [configured](/wallets/using-wallets/evm-smart-wallets/setup/configuring-dashboard) smart wallets in the Privy Dashboard, you can use them in your application with just a few lines of code.

<Tabs>
  <Tab title="React">
    <Info>
      Looking to get started quickly? Check out our [Smart Wallets starter
      repo](https://github.com/privy-io/examples/tree/main/examples/privy-next-smart-wallets). You can
      see a deployed version of the starter app [here](https://smart-wallets-starter.privy.io/).
    </Info>

    ## Setup

    First install the necessary peer dependencies:

    ```bash  theme={"system"}
    npm install permissionless viem
    ```

    To set up your app with smart wallets, first import the `SmartWalletsProvider` component from `@privy-io/react-auth/smart-wallets` and wrap your app with it.

    The `SmartWalletsProvider` must wrap any component or page that will use smart wallets. We recommend rendering it as close to the root of your application as possible, nested *within* your `PrivyProvider`.

    ```tsx  theme={"system"}
    import {PrivyProvider} from '@privy-io/react-auth';
    import {SmartWalletsProvider} from '@privy-io/react-auth/smart-wallets';

    export default function Providers({children}: {children: React.ReactNode}) {
      return (
        <PrivyProvider appId="your-privy-app-id">
          <SmartWalletsProvider>{children}</SmartWalletsProvider>
        </PrivyProvider>
      );
    }
    ```

    <Tip>
      Make sure that the networks you've configured for smart wallets in the Dashboard are also
      configured for your app's [`defaultChain` and
      `supportedChains`](/wallets/using-wallets/evm-smart-wallets/setup/configuring-dashboard).
    </Tip>

    ## Creating smart wallets

    Once the `SmartWalletsProvider` component is rendered and a smart wallet configuration has been set up for your app in the [Dashboard](/wallets/using-wallets/evm-smart-wallets/setup/configuring-dashboard), Privy will automatically generate smart wallets for your users once they have an embedded wallet. The embedded wallet is used as the primary **signer** controlling the smart wallet.

    You can configure your app to [create embedded wallets](/wallets/wallets/create/create-a-wallet) automatically on login or manually; smart wallets will be created following the same configuration.

    ## Overriding paymaster context

    Certain paymasters, like Alchemy and Biconomy, use an additional `paymasterContext` for gas sponsorship. Privy constructs this paymaster context based on either dashboard provided gas policy ID for Alchemy or a default set of values for Biconomy. However, you can override these defaults by passing a `paymasterContext` prop to the `SmartWalletsProvider`. See an example of how to set this below:

    ```tsx  theme={"system"}
    <SmartWalletsProvider
      config={{
        paymasterContext: {
          mode: 'SPONSORED',
          calculateGasLimits: true,
          expiryDuration: 300,
          sponsorshipInfo: {
            webhookData: {},
            smartAccountInfo: {
              name: 'BICONOMY',
              version: '2.0.0'
            }
          }
        }
      }}
    >
      {children}
    </SmartWalletsProvider>
    ```
  </Tab>

  <Tab title="React Native">
    ## Setup

    ### 0. Set up your build configuration (for old React native and Expo Versions)

    <Warning>
      If you are running an Expo version before SDK 53 (or a React Native version before 0.79.0) then **please make sure to follow this step.**

      Otherwise, skip to step #1 ("Install peer dependencies").
    </Warning>

    Ensure you've followed the steps in [custom build configuration](/basics/react-native/installation#metro-build-configuration).

    Additionally, add `permissionless` to the list of modules that require package exports in your `metro.config.js` file.

    ```js  theme={"system"}
    //...other config logic

    // Enable package exports for select libraries
    ...
    const resolveRequestWithPackageExports = (context, moduleName, platform) => {
      if (moduleName.startsWith('@privy-io/') || moduleName.startsWith('permissionless')) {
        const ctx = {
          ...context,
          unstable_enablePackageExports: true,
        };
        return ctx.resolveRequest(ctx, moduleName, platform);
      }

      if (
        moduleName.endsWith(".js") &&
        context.originModulePath.includes("node_modules/ox/")
      ) {
        const newModuleName = moduleName.replace(/\.js$/, "");
        return context.resolveRequest(context, newModuleName, platform);
      }

      return context.resolveRequest(context, moduleName, platform);
    };
    ```

    ### 1. Install peer dependencies

    ```sh  theme={"system"}
    npx expo install viem permissionless
    ```

    ### 2. Import and wrap your app with the `SmartWalletsProvider`

    The `SmartWalletsProvider` must wrap any component or page that will use smart wallets. We recommend rendering it as close to the root of your application as possible, nested *within* your `PrivyProvider`.

    ```tsx  theme={"system"}
    import {PrivyProvider} from '@privy-io/expo';
    import {SmartWalletsProvider} from '@privy-io/expo/smart-wallets';

    export default function Providers({children}: {children: React.ReactNode}) {
      return (
        <PrivyProvider
          appId={Constants.expoConfig?.extra?.privyAppId}
          clientId={Constants.expoConfig?.extra?.privyAppClientId}
        >
          <SmartWalletsProvider>{children}</SmartWalletsProvider>
        </PrivyProvider>
      );
    }
    ```

    ## Creating smart wallets

    Once the `SmartWalletsProvider` component is rendered and a smart wallet configuration has been set up for your app in the [Dashboard](/wallets/using-wallets/evm-smart-wallets/setup/configuring-dashboard), Privy will automatically generate smart wallets for your users once they have an embedded wallet. The embedded wallet is used as the primary **signer** controlling the smart wallet.

    You can configure your app to [create embedded wallets](/wallets/wallets/create/create-a-wallet) manually; smart wallets will be created following the same configuration.
  </Tab>
</Tabs>


# Using smart wallets
Source: https://docs.privy.io/wallets/using-wallets/evm-smart-wallets/usage



<Tabs>
  <Tab title="React">
    <Tip>
      Follow the [smart wallets setup guide](/wallets/using-wallets/evm-smart-wallets/setup/configuring-dashboard) to configure smart wallets for your application.
    </Tip>

    ## Get the smart wallet address

    Once a smart wallet has been created for a user, you can get the address for the smart wallet by finding the account of `type: 'smart_wallet'` from the user's `linkedAccounts` array.

    ```jsx  theme={"system"}
    const {user} = usePrivy();
    const smartWallet = user.linkedAccounts.find((account) => account.type === 'smart_wallet');
    console.log(smartWallet.address);
    // Logs the smart wallet's address
    console.log(smartWallet.type);
    // Logs the smart wallet type (e.g. 'safe', 'kernel', 'light_account', 'biconomy', 'thirdweb', 'coinbase_smart_wallet')
    ```

    ## Sign a message

    Use the `signMessage` function from the `client` returned by `useSmartWallets` hook in your React component to sign a message using the user's smart wallet.

    ```jsx  theme={"system"}
    signMessage: (input: {message: SignableMessage}, opts?: {uiOptions?: SignMessageModalUIOptions}) => Promise<Hex>
    ```

    ### Usage

    ```jsx  theme={"system"}
    import {useSmartWallets} from '@privy-io/react-auth/smart-wallets';
    const {client} = useSmartWallets();
    const uiOptions = {
        title: 'Sample title text',
        description: 'Sample description text',
        buttonText: 'Sample button text'
    };
    client.signMessage({message: 'Hello, world!'}, {uiOptions}).then((signature) => {
        console.log(signature);
    });
    ```

    ### Parameters

    The `signMessage` method accepts the following parameters:

    <ParamField path="input.message" type="string | {raw: Hex | ByteArray}" required>
      The message to sign by the smart account.
    </ParamField>

    <ParamField path="opts.uiOptions" type="SignMessageModalUIOptions">
      Optional UI customization options for the signature prompt.
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="Hex">
      The signed message by the smart wallet.
    </ResponseField>

    ## Sign typed data

    Use the `signTypedData` function from the `client` returned by `useSmartWallets` hook in your React component to sign structured data using the user's smart wallet.

    ```jsx  theme={"system"}
    signTypedData: (input: SignTypedDataParameters, opts?: {uiOptions?: SignMessageModalUIOptions}) => Promise<Hex>
    ```

    ### Usage

    ```jsx  theme={"system"}
    import {useSmartWallets} from '@privy-io/react-auth/smart-wallets';
    const {client} = useSmartWallets();
    const uiOptions = {
        title: 'Sample title text',
        description: 'Sample description text',
        buttonText: 'Sample button text'
    };
    client.signTypedData(typedDataRequestParams, {uiOptions}).then((signature) => {
        console.log(signature);
    });
    ```

    ### Parameters

    The `signTypedData` method accepts the following parameters:

    <ParamField path="input" type="SignTypedDataParameters" required>
      The typed data to sign by the smart account.
    </ParamField>

    <ParamField path="opts.uiOptions" type="SignMessageModalUIOptions">
      Optional UI customization options for the signature prompt.
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="Hex">
      The signed message by the smart wallet.
    </ResponseField>

    ## Send a transaction

    Use the `sendTransaction` function from the `client` returned by `useSmartWallets` hook in your React component to send a transaction using the user's smart wallet.

    ```jsx  theme={"system"}
    sendTransaction: (input: SendTransactionParameters, opts?: {uiOptions?: SendTransactionModalUIOptions}) => Promise<Hex>
    ```

    ### Usage

    ```jsx  theme={"system"}
    import {useSmartWallets} from '@privy-io/react-auth/smart-wallets';
    const {client} = useSmartWallets();
    const uiOptions = {
        title: 'Sample title text',
        description: 'Sample description text',
        buttonText: 'Sample button text'
    };
    client.sendTransaction({
        chain: base,
        to: 'insert-recipient-address',
        value: 0.1
    }, {uiOptions}).then((txHash) => {
        console.log(txHash);
    });
    ```

    ### Parameters

    The `sendTransaction` method accepts the following parameters:

    <ParamField path="input" type="SendTransactionParameters" required>
      The transaction to send by the smart account.
    </ParamField>

    <ParamField path="opts.uiOptions" type="SendTransactionModalUIOptions">
      Optional UI customization options for the transaction prompt.
    </ParamField>

    ### Returns

    <ResponseField name="txHash" type="Hex">
      The transaction hash of the sent transaction.
    </ResponseField>

    ## Batch transactions

    Smart wallets support sending a batch of transactions in a single, atomic submission to the network.

    ```jsx  theme={"system"}
    sendTransaction: (input: {calls: Array<{to: string, value?: bigint, data?: string}>}, opts?: {uiOptions?: SendTransactionModalUIOptions}) => Promise<Hex>
    ```

    ### Usage

    ```jsx  theme={"system"}
    import {useSmartWallets} from '@privy-io/react-auth/smart-wallets';
    const {client} = useSmartWallets();
    client.sendTransaction({
        calls: [
            // Approve transaction
            {
                to: USDC_ADDRESS,
                data: encodeFunctionData({
                    abi: USDC_ABI,
                    functionName: 'approve',
                    args: ['insert-spender-address', BigInt(1e6)]
                })
            },
            // Transfer transaction
            {
                to: USDC_ADDRESS,
                data: encodeFunctionData({
                    abi: USDC_ABI,
                    functionName: 'transfer',
                    args: ['insert-recipient-address', BigInt(1e6)]
                })
            }
        ]
    }).then((txHash) => {
        console.log(txHash);
    });
    ```

    ### Parameters

    The `sendTransaction` method for batching accepts the following parameters:

    <ParamField path="input.calls" type="Array<{to: string, value?: bigint, data?: string}>" required>
      Array of transactions to batch together.
    </ParamField>

    <ParamField path="opts.uiOptions" type="SendTransactionModalUIOptions">
      Optional UI customization options for the transaction prompt.
    </ParamField>

    ### Returns

    <ResponseField name="txHash" type="Hex">
      The transaction hash of the batched transaction.
    </ResponseField>

    ## Switch chains

    Use the `getClientForChain` method to create a new smart wallet client for a specific chain.

    ```jsx  theme={"system"}
    getClientForChain: ({id: number}) => Promise<SmartWalletClient>
    ```

    ### Usage

    ```jsx  theme={"system"}
    import {base} from 'viem/chains';
    const {getClientForChain} = useSmartWallets();
    const baseClient = await getClientForChain({
        id: base.id,
    });
    // Client will send transaction on Base
    baseClient.sendTransaction({
        ...
    });
    ```

    ### Parameters

    The `getClientForChain` method accepts the following parameters:

    <ParamField path="id" type="number" required>
      The chain ID to create a client for.
    </ParamField>

    ### Returns

    <ResponseField name="client" type="SmartWalletClient">
      A new smart wallet client configured for the specified chain.
    </ResponseField>

    <Tip>
      If configured `defaultChain` does not have a smart wallet network configuration, the smart wallet client will default to using the first configured chain that has a smart wallet network configuration.
    </Tip>
  </Tab>

  <Tab title="React Native">
    <Tip>
      Follow the [React Native setup guide](/wallets/using-wallets/evm-smart-wallets/setup/configuring-dashboard) to configure smart wallets for your React Native application.
    </Tip>

    ## Get the smart wallet address

    Once a smart wallet has been created for a user, you can get the address for the smart wallet by finding the account of `type: 'smart_wallet'` from the user's `linked_accounts` array.

    ```jsx  theme={"system"}
    const {user} = usePrivy();
    const smartWallet = user.linked_accounts.find((account) => account.type === 'smart_wallet');
    console.log(smartWallet.address);
    // Logs the smart wallet's address
    console.log(smartWallet.type);
    // Logs the smart wallet type (e.g. 'safe', 'kernel', 'light_account', 'biconomy', 'thirdweb', 'coinbase_smart_wallet')
    ```

    ## Sign a message

    Use the `signMessage` function from the `client` returned by `useSmartWallets` hook in your React Native component to sign a message using the user's smart wallet.

    ```jsx  theme={"system"}
    signMessage: ({message: SignableMessage}) => Promise<Hex>
    ```

    ### Usage

    ```jsx  theme={"system"}
    import {useSmartWallets} from '@privy-io/expo/smart-wallets';
    const {client} = useSmartWallets();
    client.signMessage({message: 'Hello, world!'}).then((signature) => {
        console.log(signature);
    });
    ```

    ### Parameters

    The `signMessage` method accepts the following parameters:

    <ParamField path="input.message" type="string | {raw: Hex | ByteArray}" required>
      The message to sign by the smart account.
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="Hex">
      The signed message by the smart wallet.
    </ResponseField>

    ## Sign typed data

    Use the `signTypedData` function from the `client` returned by `useSmartWallets` hook in your React Native component to sign structured data using the user's smart wallet.

    ```jsx  theme={"system"}
    signTypedData: (input: SignTypedDataParameters) => Promise<Hex>
    ```

    ### Usage

    ```jsx  theme={"system"}
    import {useSmartWallets} from '@privy-io/expo/smart-wallets';
    const {client} = useSmartWallets();
    client.signTypedData(...).then((signature) => {
        console.log(signature);
    });
    ```

    ### Parameters

    The `signTypedData` method accepts the following parameters:

    <ParamField path="input" type="SignTypedDataParameters" required>
      The typed data to sign by the smart account.
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="Hex">
      The signed message by the smart wallet.
    </ResponseField>

    ## Send a transaction

    Use the `sendTransaction` function from the `client` returned by `useSmartWallets` hook in your React Native component to send a transaction using the user's smart wallet.

    ```jsx  theme={"system"}
    sendTransaction: (input: SendTransactionParameters) => Promise<Hex>
    ```

    ### Usage

    ```jsx  theme={"system"}
    import {useSmartWallets} from '@privy-io/expo/smart-wallets';
    const {client} = useSmartWallets();
    client.sendTransaction({
        account: client.account,
        chain: base,
        to: 'insert-recipient-address',
        value: 0.1
    }).then((txHash) => {
        console.log(txHash);
    });
    ```

    ### Parameters

    The `sendTransaction` method accepts the following parameters:

    <ParamField path="input" type="SendTransactionParameters" required>
      The transaction to send by the smart account.
    </ParamField>

    ### Returns

    <ResponseField name="txHash" type="Hex">
      The transaction hash of the sent transaction.
    </ResponseField>

    ## Batch transactions

    Smart wallets support sending a batch of transactions in a single, atomic submission to the network.

    ```jsx  theme={"system"}
    sendTransaction: (input: {calls: Array<{to: string, value?: bigint, data?: string}>}) => Promise<Hex>
    ```

    ### Usage

    ```jsx  theme={"system"}
    import {useSmartWallets} from '@privy-io/expo/smart-wallets';
    const {client} = useSmartWallets();
    client.sendTransaction({
        account: client.account,
        calls: [
            // Approve transaction
            {
                to: USDC_ADDRESS,
                data: encodeFunctionData({
                    abi: USDC_ABI,
                    functionName: 'approve',
                    args: ['insert-spender-address', BigInt(1e6)]
                })
            },
            // Transfer transaction
            {
                to: USDC_ADDRESS,
                data: encodeFunctionData({
                    abi: USDC_ABI,
                    functionName: 'transfer',
                    args: ['insert-recipient-address', BigInt(1e6)]
                })
            }
        ]
    }).then((txHash) => {
        console.log(txHash);
    });
    ```

    ### Parameters

    The `sendTransaction` method for batching accepts the following parameters:

    <ParamField path="input.calls" type="Array<{to: string, value?: bigint, data?: string}>" required>
      Array of transactions to batch together.
    </ParamField>

    ### Returns

    <ResponseField name="txHash" type="Hex">
      The transaction hash of the batched transaction.
    </ResponseField>

    <Tip>
      The smart wallet client will default to using the first configured chain that has a smart wallet network configuration.
    </Tip>
  </Tab>
</Tabs>


# Add signers
Source: https://docs.privy.io/wallets/using-wallets/session-signers/add-session-signers



To allow a third-party to transact on wallets, follow the guide below.

<Info>
  This guide assumes your application has already [configured session signers](/wallets/using-wallets/session-signers/configure-session-signers) in the Dashboard.
</Info>

<Tabs>
  <Tab title="React">
    To provision server-side access for user's wallets, use the `addSessionSigners` method from the `useSessionSigners` hook:

    ```tsx  theme={"system"}
    addSessionSigners: async ({address: string, signers: {signerId: string, policyIds: string[]}[]}) => Promise<{user: User}>
    ```

    ### Usage

    ```tsx  theme={"system"}
    import {useSessionSigners} from '@privy-io/react-auth';
    const {addSessionSigners} = useSessionSigners();
    ```

    <Tip>
      Check out the [starter repo](https://github.com/privy-io/examples/blob/main/privy-next-starter/src/components/sections/session-signers.tsx) for an end to end example of how to use session signers.
    </Tip>

    ### Parameters

    The `addSessionSigners` method accepts a `params` object with the following fields:

    <ParamField path="address" type="string" required>
      Address of the embedded wallet to add a session signer to.
    </ParamField>

    <ParamField path="signers" type="object[]" required>
      <Expandable defaultOpen="true">
        <ParamField path="signerId" type="string" required>
          The key quorum ID that will be allowed to transact on the wallet. This is the same key quorum ID you generated in the [Generate an authorization key](/wallets/using-wallets/session-signers/configure-session-signers) step.
        </ParamField>

        <ParamField path="policyIds" type="string[]">
          An ID for a policy that any transaction from the session signer must satisfy to be signed. This is an optional field, if not provided, no policies will apply to the signers requests. Note that at this time, each signer can only have one override policy.
        </ParamField>
      </Expandable>
    </ParamField>
  </Tab>

  <Tab title="React Native">
    To provision server-side access for user's wallets, use the `addSessionSigners` method from the `useSessionSigners` hook:

    ```tsx  theme={"system"}
    addSessionSigners: async ({address: string, signers: {signerId: string, policyIds: string[]}[]}) => Promise<{user: PrivyUser}>
    ```

    ### Usage

    ```tsx  theme={"system"}
    import {useSessionSigners} from '@privy-io/expo';
    const {addSessionSigners} = useSessionSigners();
    ```

    ### Parameters

    The `addSessionSigners` method accepts a `params` object with the following fields:

    <ParamField path="address" type="string" required>
      Address of the embedded wallet to add a session signer to.
    </ParamField>

    <ParamField path="signers" type="object[]" required>
      <Expandable defaultOpen="true">
        <ParamField path="signerId" type="string" required>
          The key quorum ID that will be allowed to transact on the wallet. This is the same key quorum ID you generated in the [Generate an authorization key](/wallets/using-wallets/session-signers/configure-session-signers) step.
        </ParamField>

        <ParamField path="policyIds" type="string[]">
          An ID for a policy that any transaction from the session signer must satisfy to be signed. This is an optional field, if not provided, no policies will apply to the signers requests. Note that at this time, each signer can only have one override policy.
        </ParamField>
      </Expandable>
    </ParamField>
  </Tab>

  <Tab title="NodeJS & REST API">
    Make a request to [update the wallet](/wallets/wallets/update-a-wallet) with the desired `additional_signers` you'd like to add. The wallet owner must [sign](/controls/authorization-keys/using-owners/sign) the request.
  </Tab>
</Tabs>


# Configure signers
Source: https://docs.privy.io/wallets/using-wallets/session-signers/configure-session-signers



Follow the guide below to configure session signers your app can use to transact on user's embedded wallets.

## 1. Create a key quorum

Fundamentally, a session signer is a [key quorum](/controls/authorization-keys/overview) that is authorized to submit transaction request for signature from a user's wallet.

You can create key quorums in the [Privy Dashboard](https://dashboard.privy.io//apps?page=authorization-keys) or via an [API request](/api-reference/key-quorums/create),

To generate a key quorum in the [Dashboard](https://dashboard.privy.io//apps?page=authorization-keys), navigate to the **Wallet infrastructure > Authorization keys** page and click on the **Create new key** button. The modal will show the key quorum ID and the private key used for signing.

Save both these values in a secure location. **Privy never sees this private key and cannot help you recover it.** The private key will be used to sign transaction requests on the wallet.

<Info>
  The **authorization key** is the private key of a P-256 keypair. Privy never sees the private key,
  and verifies signatures on your requests against the corresponding public key to ensure your
  server authorizes the action to take with a user's delegated wallet.
</Info>

## 2. Create policies to configure permissions \[optional]

Session signers can also have policies that any transaction must satisfy to be signed by the wallet. To configure permissions to control what kinds of actions your app can take with users wallets, set up [policies](/controls/policies/overview) in your Privy dashboard under **Wallet infrastructure > Policies**.

## 3. Add the session signer to the wallet

To use session signers, the owner of a wallet must first grant consent for your app to take certain actions on their behalf. To have owners grant consent, follow the guides below depending on the SDK(s) you integrate.


# null
Source: https://docs.privy.io/wallets/using-wallets/session-signers/overview



Privy enables your app to add **signers** to wallets that can take actions within the scope of certain permissions. You can use signers to enable various use cases, like:

* **Offline actions**: execute limit orders or agentic trades even while a user is offline in your app.
* **Recurring actions**: implement subscriptions, portfolio rebalancing, and more.
* **Scoping wallet policies to specific parties**: set specific policies on wallets that apply to specific signers (authorization keys, users, or key quorums)
* **Delegating access to third-parties**: allow third-parties to execute certain actions on behalf of a wallet.

Signers can be added to wallets owned by [users, authorization keys, or key quorums](/controls/authorization-keys/owners/overview).

Privy’s architecture guarantees that a **session signer** will never see the wallet's private key. All signing takes place in a secure enclave that only your application can make authorized requests to.

Follow the guides below to provision session signers for your users' wallets and enable your app to securely interact with these wallets from your servers.

## Get started

<CardGroup>
  <Card title="Add a session signer" icon="stamp" href="/wallets/using-wallets/session-signers/add-session-signers">
    Add a session signer to a user's wallet and start interacting with the wallet from your servers.
  </Card>

  <Card title="Send transactions from your server" icon="gear" href="/wallets/using-wallets/session-signers/use-session-signers">
    Send transactions on behalf of your users from a server environment.
  </Card>
</CardGroup>


# Enabling users or servers to execute transactions
Source: https://docs.privy.io/wallets/using-wallets/session-signers/quickstart



A common setup for Privy apps is to configure wallets such that both users and apps themselves can execute transactions from user wallets. This serves a variety of use cases:

* Allowing apps to execute limit orders on behalf of a user, even when a user is offline
* Allowing apps to rebalance user portfolios based on market data, even when the user is offline
* Creating Telegram trading bots or other agents controlled by your app's server that can execute transactions on behalf of users

You can accomplish these use cases via [session signers](/wallets/using-wallets/session-signers/overview), which enable user to grant specific permissions to your app to transact on their behalf. Follow the guide below to learn how to integrate session signers for your use case.

<Tip>
  View an [implementation of session
  signers](https://github.com/privy-io/examples/blob/main/privy-next-starter/src/components/sections/session-signers.tsx)
  in Privy's NextJS starter repo to learn about how to use session signers end-to-end.
</Tip>

## 0. Prerequisites

Prior to following this guide, follow the quickstart for Privy's [React SDK](/basics/react/quickstart) or [React Native SDK](/basics/react-native/quickstart) to get your app instrumented with Privy's basic functionality.

<Tip>
  If you plan to use this setup as part of a Telegram trading bot, check out the guide to integrate
  [Telegram seamless login](/recipes/react/seamless-telegram) with the React SDK for a smoother user
  experience when signing into Telegram mini-apps.
</Tip>

## 1. Create an app authorization key

To allow your app to be send transactions from user wallets, you must first create an **app authorization key**. Your app's server will sign API requests with this key to authorize sending transactions from user wallets.

Create an authorization key locally on your machine like so:

```sh  theme={"system"}
openssl ecparam -name prime256v1 -genkey -noout -out private.pem && \
openssl ec -in private.pem -pubout -out public.pem
```

Retrieve the public key from the `public.pem` file and the private key from the `private.pem` file in your working directory.

**Make sure to save both files securely.** Privy does not store your private key and cannot help you recover it.

## 2. Register the app authorization key in a key quorum

Next, register the public key you created with Privy so that Privy can appropriately verify signed requests from your app.

To do so, visit the [**Authorization keys**](https://dashboard.privy.io/apps?authorization-keys) page of the Privy Dashboard and click the **New key** button in the top right. Then, click the **Register key quorum instead** option.

In the modal that pops up, enter the public key you generated in step 1 in the **Public keys** field. Set the **Authorization threshold** to 1, to allow that single key to sign on behalf of the key quorum, and set the **Quorum name** to a human readable name of your choice.

Save the `id` of the key quorum that is created. You will need this value later.

This creates a 1-of-1 [key quorum](/controls/quorum-approvals/overview) that can be granted permission to execute actions from a user's wallet.

<Tip>
  You can also register the public key with Privy programmatically via the [REST
  API](/api-reference/key-quorums/create).
</Tip>

## 3. Configure your Privy app to create embedded wallets on login

Next, configure your Privy app to automatically create embedded wallets when users login.

This ensures that all users have an embedded wallet, regardless of whether they login via a web app, a Telegram mini app, or a native mobile app.

<Tabs>
  <Tab title="React (web apps and Telegram mini apps)">
    In your `PrivyProvider` component, set the `config.embeddedWallets.ethereum.createOnLogin` property to `'all'` to automatically create embedded wallets for users, regardless of what login method they use.

    ```tsx  theme={"system"}
    <PrivyProvider
      appId="your-privy-app-id"
      config={{
        embeddedWallets: {
          ethereum: {
            createOnLogin: 'all'
          }
        }
      }}
    >
      {children}
    </PrivyProvider>
    ```
  </Tab>

  <Tab title="React Native (mobile apps)">
    In your `PrivyProvider` component, set the `config.embeddedWallets.ethereum.createOnLogin` property to `'all'` to automatically create embedded wallets for users, regardless of what login method they use.

    ```tsx  theme={"system"}
    <PrivyProvider
      appId="your-privy-app-id"
      clientId="your-app-client-id"
      config={{
        embedded: {
          ethereum: {
            createOnLogin: 'all'
          }
        }
      }}
    >
      {children}
    </PrivyProvider>
    ```
  </Tab>
</Tabs>

## 4. (Optional) Create a policy for your signer

If you'd like your signer to only have specific permissions on users' wallets, [create a policy](/controls/policies/overview) for your signer based on the transaction it needs to execute. For example, you might create a policy that [expires the signer's permissions after a certain date](/controls/policies/example-policies/timebound), or limits only allows transacting under a certain amount with a specific contract, in order to execute a limit order when a user is offline. You can also create multiple policies to allow your signer to execute a set of actions.

Once you've created your desired policy for the signer, make sure to save the policy ID. You will need this when adding your signer to users' wallets.

<Tip>
  See example policies for [Ethereum](/controls/policies/example-policies/ethereum) and
  [Solana](/controls/policies/example-policies/solana) that you can modify for your use case.
</Tip>

## 5. Add a session signer to the user's wallet

Once a user logs in, an embedded wallet will automatically be created for them.

Once a user has an embedded wallet, add the key quorum you created in step 3 as a [session signer](/wallets/using-wallets/session-signers/overview) to the user's wallet. This allows your app to sign transaction requests from the user's wallet via your app's authorization key.

<Tabs>
  <Tab title="React (web apps and Telegram mini apps)">
    Once a user logs in, you can use the [`addSessionSigners`](/wallets/using-wallets/session-signers/add-session-signers) method of `useSessionSigners` hook to add your app's authorization key as a session signer on the wallet.

    ```tsx  theme={"system"}
    import {useSessionSigners} from '@privy-io/react-auth';

    ...

    const {addSessionSigners} = useSessionSigners();
    // Call this method after a user logs in and has an embedded wallet
    await addSessionSigners({
        address: 'insert-user-embedded-wallet-address',
        signers: [{
            signerId: 'insert-key-quorum-id-from-step-2',
            // Replace the `policyIds` array with an array of valid policy IDs if you'd like the session signer to only be able to execute certain transaction requests allowed by a policy. If you'd like the session signer to have full permission, pass an empty array ([]).
            policyIds: ['insert-policy-id-1', 'insert-policy-id-2']
        }]
    })
    ```

    <AccordionGroup>
      <Accordion title="Add a session signer to a user's wallet immediately after they login.">
        If you'd like to immediately add your session signer to a user's wallet when they login, use the `onComplete` callback of the `useLogin` hook:

        ```tsx  theme={"system"}
        import {useLogin} from '@privy-io/react-auth';

        const {login} = useLogin({
          onComplete: () => {
            console.log(
              "Execute any logic you'd like to run after a user logs in, such as adding a session signer"
            );
          }
        });
        ```

        All together, you can add a session signer after a user logs in like so:

        ```tsx  theme={"system"}
        import {useLogin} from '@privy-io/react-auth';
        import {useSessionSigners} from '@privy-io/react-auth';

        ...

        const {addSessionSigners} = useSessionSigners();
        const {login} = useLogin({
            onComplete: (user, isNewUser) => {
                if (isNewUser) {
                  await addSessionSigners({
                    address: user.wallet.address,
                    signers: [{
                        signerId: 'insert-key-quorum-id-from-step-2',
                        // Replace the empty `policyIds` array with an array of valid policy IDs if you'd like the session signer to only be able to execute certain transaction requests allowed by a policy
                        policyIds: []
                    }]
                 });
                }
            }
        })

        // Call login somewhere in your app
        ```
      </Accordion>

      <Accordion title="Add a session signer for limit orders.">
        If your app offers limit orders to users, we recommend the following flow for using session signers to execute limit orders.

        <Steps>
          <Step title="Create your limit order policy">
            Create a policy that allows your session signer to execute the limit order from the user's wallet.
          </Step>

          <Step title="Add your session signer">
            Add your session signer to the user's wallet via the `addSessionSigner` method, using the policy from step 1.
          </Step>

          <Step title="Execute the limit order">
            When the conditions to execute the limit order are met, see step 6 of this guide to learn how to send transactions with your session signer.
          </Step>
        </Steps>
      </Accordion>
    </AccordionGroup>
  </Tab>

  <Tab title="React Native (mobile apps)">
    Once a user logs in, you can use the [`addSessionSigners`](/wallets/using-wallets/session-signers/add-session-signers#react-native) method of `useSessionSigners` hook to add your app's authorization key as a session signer on the wallet.

    ```tsx  theme={"system"}
    import {useSessionSigners} from '@privy-io/expo';

    ...

    const {addSessionSigners} = useSessionSigners();
    // Call this method after a user logs in and has an embedded wallet
    await addSessionSigners({
        address: 'insert-user-embedded-wallet-address',
        signers: [{
            signerId: 'insert-key-quorum-id-from-step-2',
            // Replace the empty `policyIds` array with an array of valid policy IDs if you'd like the session signer to only be able to execute certain transaction requests allowed by a policy
            policyIds: []
        }]
    })
    ```

    <Accordion title="Add a session signer for limit orders.">
      If your app offers limit orders to users, when a user places an order, we recommend:

      1. Create a policy that allows your session signer to execute the limit order from the user's wallet.
      2. Add your session signer to the user's wallet via the `addSessionSigner` method, using the policy from step 1.
      3. When the conditions to execute the limit order are met, execute the transaction with your session signer. See step 6 of this guide to learn how to use session signers to execute transactions via the NodeJS SDK or REST API.
    </Accordion>
  </Tab>
</Tabs>

## 6. Send transactions from the user's wallet

That's it! Now, both users and your app can send transactions from a user's wallet.

### User-initiated transactions

Users can send transactions from your app's frontend by taking actions in a web app (via Privy's React SDK), a mobile app (via Privy's React Native SDK), or a Telegram mini-app (via Privy's React SDK).

Follow the guides below to learn how to send [transactions](/wallets/using-wallets/ethereum/send-a-transaction) from these environments.

#### Ethereum

<CardGroup>
  <Card title="React" href="/wallets/using-wallets/ethereum/send-a-transaction">
    Send Ethereum transactions from a web app or a Telegram mini-app using Privy's React SDK.
  </Card>

  <Card title="React Native" href="/wallets/using-wallets/ethereum/send-a-transaction#react-native">
    Send Ethereum transactions from a mobile app or a Telegram mini-app using Privy's React Native
    SDK.
  </Card>
</CardGroup>

#### Solana

<CardGroup>
  <Card title="React" href="/wallets/using-wallets/solana/send-a-transaction">
    Send Solana transactions from a web app or a Telegram mini-app using Privy's React SDK.
  </Card>

  <Card title="React Native" href="/wallets/using-wallets/solana/send-a-transaction#react-native">
    Send Solana transactions from a mobile app or a Telegram mini-app using Privy's React Native
    SDK.
  </Card>
</CardGroup>

### App-initiated transactions

Your app can also now initiate transactions from users' wallets via Privy's NodeJS SDK or REST API. This allows your app to send transactions from users' wallets even when the user is offline, allowing for various use cases:

* Executing limit orders
* Rebalancing portfolios
* Having a Telegram trading bot execute transactions on behalf of users

Follow the guides below to send transactions from your app's server using your app's authorization key.

<Info>
  Using Privy's REST API directly is an advanced integration. If your app uses a JavaScript or
  TypeScript backend, we strongly recommend using Privy's [NodeJS
  SDK](/basics/nodeJS-server-auth/setup).
</Info>

<Tabs>
  <Tab title="NodeJS (server-auth)">
    To start, initialize your `PrivyClient` with the private key of the authorization key you created in step 1. Pass this value into the `walletApi.authorizationPrivateKey` field of the third positional parameter to the client's constructor.

    ```tsx  theme={"system"}
    const privy = new PrivyClient('insert-your-app-id', 'insert-your-app-secret', {
        walletApi: {
            authorizationPrivateKey: 'insert-the-private-key-from-step-1'
        }
    })
    ```

    Next, follow the guides to send transactions on [Ethereum](/wallets/using-wallets/ethereum/send-a-transaction#nodejs) and [Solana](/wallets/using-wallets/solana/send-a-transaction#nodejs) with the NodeJS SDK.
  </Tab>

  <Tab title="REST API">
    Since your app is a session signer on the user's wallet, your app must sign transaction requests to Privy's API with the private key of the authorization key you generated in step 1. Your app must then include this signature in the `privy-authorization-signature` header of the request.

    Follow [this guide](/controls/authorization-keys/using-owners/sign) to learn how to sign requests to Privy's API with your app's authorization key.

    Once you've learned and implemented how to sign requests, you can now follow the guides to send transactions on [Ethereum](/wallets/using-wallets/ethereum/send-a-transaction#rest-api) and [Solana](/wallets/using-wallets/solana/send-a-transaction#rest-api) with the NodeJS SDK.
  </Tab>
</Tabs>

<Tip>
  **Building a Telegram trading bot?** Check out the [Telegram trading bot
  recipe](/recipes/telegram-bot) to learn how to have your app initiate transactions on behalf of
  users with a trading bot.
</Tip>


# Remove signers
Source: https://docs.privy.io/wallets/using-wallets/session-signers/remove-session-signers



Once a wallet has [session signers](/wallets/using-wallets/session-signers/add-session-signers), they may also revoke consent to prevent your app from taking any further wallet actions on their behalf.

<Tabs>
  <Tab title="React">
    To remove all the session signers on the wallet, use the `removeSessionSigners` method from the `useSessionSigners` hook:

    ```tsx  theme={"system"}
    removeSessionSigners: async ({address: string}) => Promise<{user: User}>
    ```

    ### Usage

    ```tsx  theme={"system"}
    import {useSessionSigners} from '@privy-io/react-auth';
    ...
    const {removeSessionSigners} = useSessionSigners();
    ```

    When invoked, the `removeSessionSigners` method will remove all the session signers, so only the user can transact on the wallet.

    <Warning>
      After this action, your app will no longer be able to take actions on behalf of the user with
      their wallet unless the user adds more [session
      signers](/wallets/using-wallets/session-signers/add-session-signers).
    </Warning>

    <Tip>
      Check out the [starter repo](https://github.com/privy-io/examples/blob/main/privy-next-starter/src/components/sections/session-signers.tsx)
      for an end to end example of how to use session signers.
    </Tip>

    ### Parameters

    The `removeSessionSigners` method accepts a `params` object with the following fields:

    <ParamField path="address" type="string" required>
      Address of the embedded wallet to delegate.
    </ParamField>

    As an example, you might have a button within your app to allow users to remove all session signers like so:

    ```tsx Example remove session signers button theme={"system"}
    import {usePrivy, useSessionSigners, type WalletWithMetadata} from '@privy-io/react-auth';

    function RemoveSessionSignersButton() {
      const {user} = usePrivy();
      const {removeSessionSigners} = useSessionSigners();

      // Check if the user's wallets already has session signers by searching the linkedAccounts array for wallets
      // with `delegated: true` set
      const delegatedWallet = user.linkedAccounts.filter(
        (account): account is WalletWithMetadata => account.type === 'wallet' && account.delegated
      );

      const onRevoke = async () => {
        if (!hasDelegatedWallets) return; // Button is disabled to prevent this case
        await removeSessionSigners({address: delegatedWallet.address});
      };

      return (
        <button disabled={!hasDelegatedWallets} onClick={onRevoke}>
          Revoke permission for this app to transact on my behalf
        </button>
      );
    }
    ```
  </Tab>

  <Tab title="React Native">
    To remove all the session signers on the wallet, use the `removeSessionSigners` method from the `useSessionSigners` hook:

    ```tsx  theme={"system"}
    removeSessionSigners: async ({address: string}) => Promise<{user: PrivyUser}>;
    ```

    ### Usage

    ```tsx  theme={"system"}
    import {useSessionSigners} from '@privy-io/expo';
    ...
    const {removeSessionSigners} = useSessionSigners();
    ```

    When invoked, the `removeSessionSigners` method will remove all the session signers, so only the user can transact on the wallet.

    <Warning>
      After this action, your app will no longer be able to take actions on behalf of the user with
      their wallet unless the user adds more [session
      signers](/wallets/using-wallets/session-signers/add-session-signers).
    </Warning>

    ### Parameters

    The `removeSessionSigners` method accepts a `params` object with the following fields:

    <ParamField path="address" type="string" required>
      Address of the embedded wallet to delegate.
    </ParamField>

    As an example, you might have a button within your app to allow users to remove all session signers like so:

    ```tsx Example remove session signers button theme={"system"}
    import {usePrivy, useSessionSigners, type PrivyEmbeddedWalletAccount} from '@privy-io/expo';

    function RemoveSessionSignersButton() {
      const {user} = usePrivy();
      const {removeSessionSigners} = useSessionSigners();

      // Check if the user's wallets already has session signers by searching the linked_accounts array for wallets
      // with `delegated: true` set
      const delegatedWallet = user.linked_accounts.find(
        (account): account is PrivyEmbeddedWalletAccount =>
          account.type === 'wallet' && account.delegated
      );

      const onRevoke = async () => {
        if (!delegatedWallet) return; // Button is disabled to prevent this case
        await removeSessionSigners({address: delegatedWallet.address});
      };

      return (
        <Button disabled={!delegatedWallet} onPress={onRevoke}>
          Revoke permission for this app to transact on my behalf
        </Button>
      );
    }
    ```
  </Tab>

  <Tab title="NodeJS & REST API">
    Make a request to [update the wallet](/wallets/wallets/update-a-wallet) with the updated list of `additional_signers` you'd like on the wallet. The wallet owner must [sign](/controls/authorization-keys/using-owners/sign) the request.
  </Tab>
</Tabs>


# Use signers
Source: https://docs.privy.io/wallets/using-wallets/session-signers/use-session-signers



Once your user's have session signers on their wallets, your app can take actions on their behalf. This is done by sending requests to the Privy API to sign transactions with the user's wallet. Follow the guide below to get started with signing transactions on behalf of users.

## Requesting signatures

Wallets provisioned for session signers can be used to transact and sign messages on behalf of a user from your server.

To get started, configure the [NodeJS SDK](/basics/nodeJS/setup) or the [REST API](/basics/rest-api/setup). This is how your application will make requests to the Privy API to sign transactions on behalf of users. The signing key you configured in the dashboard is the authorization signing key used to produce authorization signatures when submitting requests.

Once you have configured the NodeJS SDK or REST API, your application can send or sign transactions from a users wallet. Follow the NodeJS or REST API guides in the `Using wallets` section to learn more about signing requests with wallets.

## Getting wallets

From your server, you can query Privy to determine what wallets have been provisioned session signers by a given user to allow your app to take actions on their behalf.

<Tabs>
  <Tab title="NodeJS">
    Use the Privy client's `_get` method on the users interface to get the user object for your user. As a parameter to this method, pass the user's ID as a `string`:

    ```tsx  theme={"system"}
    const user = await privy.users()._get('insert-user-did');
    ```

    To get a list of the user's wallets, find all of the user's wallets from the user's linked accounts. Filter the `user.linkedAccounts` array for wallet entries with `type: 'wallet'`:

    ```tsx  theme={"system"}
    const walletsWithSessionSigners = user.linked_accounts.filter(
      (account) => account.type === 'wallet' && 'id' in account && account.delegated
    );
    ```

    This constitutes the user's wallets with session signers. Wallets with session signers will always have the `delegated` flag set to `true`.

    For wallets included in this array, your app may make requests to Privy to execute actions on behalf of the user.
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    Use the Privy client's `getUser` method to get the user object for your user. As a parameter to this method, pass the user's DID as a `string`:

    ```tsx  theme={"system"}
    const user = await client.getUser({identityToken});
    ```

    To get a list of the user's wallets with session signers, first find all of the user's embedded wallets from the user's linked accounts. Filter the `user.linkedAccounts` array for wallet entries with `type: 'wallet'` and `delegated: true`:

    ```tsx  theme={"system"}
    // The `WalletWithMetadata` type can be imported from '@privy-io/server-auth'
    const walletsWithSessionSigners = user.linkedAccounts.filter(
      (account): account is WalletWithMetadata =>
        account.type === 'wallet' && account.delegated === true
    );
    ```

    This constitutes the user's wallets with session signers. Wallets with session signers will always have the `delegated` flag set to `true`.

    For wallets included in this array, your app may make requests to Privy to execute actions on behalf of the user.
  </Tab>

  <Tab title="REST API">
    Make a `GET` request to:

    ```bash  theme={"system"}
    https://auth.privy.io/api/v1/users/<user-did>
    ```

    Replace `<did>` with your desired Privy DID. It should have the format `did:privy:XXXXXX`.

    Below is a sample cURL command for this request:

    ```bash  theme={"system"}
    curl --request GET https://auth.privy.io/api/v1/users/<user-did> \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>"
    ```

    Then, to get a list of the user's delegated wallets, inspect the `linked_accounts` field of the response body for all entries with the fields `type: 'wallet'` and `delegated: true`.
  </Tab>
</Tabs>


# Integrating with @solana/kit
Source: https://docs.privy.io/wallets/using-wallets/solana/kit-integrations



<Tabs>
  <Tab title="React">
    Privy's **ConnectedStandardSolanaWallet** object is fully compatible with popular web3 libraries for interfacing wallets and signing transactions and messages, such as [`@solana/kit`](https://www.solanakit.com/).

    Read below to learn how to best integrate Privy alongside `@solana/kit`.

    First find your desired wallet from the **`wallets`** array:

    ```tsx  theme={"system"}
    import {useWallets} from '@privy-io/react-auth/solana';

    const {wallets} = useWallets();
    const wallet = wallets[0]; // Replace this with your desired wallet
    ```

    ## Signing Transactions

    Transactions generated by `@solana/kit` can be signed using the `signTransaction` method from the `useStandardSignTransaction` hook.

    ```tsx  theme={"system"}
    import {
      pipe,
      createTransactionMessage,
      setTransactionMessageFeePayer,
      setTransactionMessageLifetimeUsingBlockhash,
      appendTransactionMessageInstructions,
      compileTransaction,
      createNoopSigner,
      createSolanaRpc,
      getTransactionEncoder
    } from '@solana/kit';
    import {getTransferSolInstruction} from '@solana-program/system';
    import {useStandardSignTransaction} from '@privy-io/react-auth/solana';

    const {signTransaction} = useStandardSignTransaction();

    const LAMPORTS_PER_SOL = 1_000_000_000;

    const transferInstruction = getTransferSolInstruction({
      amount: LAMPORTS_PER_SOL * 1,
      destination: address(to),
      source: createNoopSigner(address(wallet.address))
    });

    const {getLatestBlockhash} = createSolanaRpc('YOUR_SOLANA_RPC_URL');
    const {value: latestBlockhash} = await getLatestBlockhash().send();

    // Create transaction
    const transaction = pipe(
      createTransactionMessage({version: 0}),
      (tx) => setTransactionMessageFeePayer(address(wallet.address), tx),
      (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
      (tx) => appendTransactionMessageInstructions([transferInstruction], tx),
      (tx) => compileTransaction(tx)
    );
    const encodedTransaction = getTransactionEncoder().encode(transaction);

    // Sign the transaction
    const signedTransaction = await signTransaction({
      transaction: new Uint8Array(encodedTransaction),
      wallet: wallet
    });
    ```

    ## Sending Transactions

    Transactions signed using the `signTransaction` method can be sent using the `signAndSendTransaction` method from the `useStandardSignAndSendTransaction` hook.

    ```tsx  theme={"system"}
    import {useStandardSignAndSendTransaction} from '@privy-io/react-auth/solana';

    const {signAndSendTransaction} = useStandardSignAndSendTransaction();

    const signature = await signAndSendTransaction({
      transaction: new Uint8Array(transaction), // The transaction to send, from the previous example
      wallet: wallet
    }).signature;
    ```
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/wallets/using-wallets/solana/send-a-transaction



<Tip>
  To rely on Privy's API to fill in the recentBlockhash field of the Solana transaction, pass in the
  dummy value `11111111111111111111111111111111` for the recentBlockhash field.
</Tip>

<Info>
  When using Privy's server-side SDKs to send transactions, you can use the authorization context to
  automatically sign requests. Learn more about [signing on the
  server](/controls/authorization-keys/using-owners/sign/signing-on-the-server).
</Info>

<Tabs>
  <Tab title="React">
    To send a transaction from a wallet using the React SDK, use the `signAndSendTransaction` method from the `useSignAndSendTransaction` hook:

    ```javascript theme={"system"} theme={"system"}
    signAndSendTransaction: (input: {
      transaction: Uint8Array;
      wallet: ConnectedStandardSolanaWallet;
      chain?: SolanaChain;
      options?: SolanaSignAndSendTransactionOptions & {
        uiOptions?: SendTransactionModalUIOptions;
        sponsor?: boolean;
      };
    }) => Promise<{ signature: Uint8Array }>
    ```

    ### Usage

    ```javascript theme={"system"} theme={"system"}
    import {useSignAndSendTransaction, useWallets} from '@privy-io/react-auth/solana';
    import {
      pipe,
      createSolanaRpc,
      getTransactionEncoder,
      createTransactionMessage,
      setTransactionMessageFeePayer,
      setTransactionMessageLifetimeUsingBlockhash,
      appendTransactionMessageInstructions,
      compileTransaction,
      address,
      createNoopSigner
    } from '@solana/kit';
    import {getTransferSolInstruction} from '@solana-program/system';

    // Inside your component
    const {signAndSendTransaction} = useSignAndSendTransaction();
    const {wallets} = useWallets();

    const selectedWallet = wallets[0];

    const amount = 1;

    const transferInstruction = getTransferSolInstruction({
      amount: BigInt(parseFloat(amount) * 1_000_000_000), // Convert SOL to lamports
      destination: address('RecipientAddressHere'),
      source: createNoopSigner(address(selectedWallet.address))
    });

    // Configure your RPC connection to point to the correct Solana network
    const {getLatestBlockhash} = createSolanaRpc('https://api.mainnet-beta.solana.com'); // Replace with your Solana RPC endpoint
    const {value: latestBlockhash} = await getLatestBlockhash().send();

    // Create a transaction using @solana/kit
    const transaction = pipe(
      createTransactionMessage({version: 0}),
      (tx) => setTransactionMessageFeePayer(address(selectedWallet.address), tx), // Set the message fee payer
      (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx), // Set recent blockhash
      (tx) => appendTransactionMessageInstructions([transferInstruction], tx), // Add your instructions to the transaction
      (tx) => compileTransaction(tx), // Compile the transaction
      (tx) => new Uint8Array(getTransactionEncoder().encode(tx)) // Finally encode the transaction
    );

    // Send the transaction
    const result = await signAndSendTransaction({
      transaction: transaction,
      wallet: selectedWallet
    });

    console.log('Transaction sent with signature:', result.signature);
    ```

    ### Parameters

    <Expandable title="parameters" defaultOpen="true">
      <ParamField path="transaction" type="Uint8Array" required>
        The encoded transaction to be sent.
      </ParamField>

      <ParamField path="wallet" type="ConnectedStandardSolanaWallet" required>
        The Solana wallet to use for sending the transaction.
      </ParamField>

      <ParamField path="chain" type="SolanaChain">
        Type of all Solana chains supported by Privy.
      </ParamField>

      <ParamField path="options" type="SolanaSignAndSendTransactionOptions & {uiOptions?: SendTransactionModalUIOptions; sponsor?: boolean}">
        Additional options for sending the transaction.

        <Expandable title="child attributes">
          <ParamField path="sponsor" type="boolean">
            Optional parameter to enable gas sponsorship for this transaction. [Learn
            more.](/wallets/gas-and-asset-management/gas/overview)
          </ParamField>

          <ParamField path="uiOptions" type="SendTransactionModalUIOptions">
            UI options to customize the transaction request modal.

            <Tip>
              To hide confirmation modals, set `options.uiOptions.showWalletUIs` to `false`. Learn more
              about configuring modal prompts [here](/recipes/react/manage-wallet-UIs).
            </Tip>
          </ParamField>
        </Expandable>
      </ParamField>
    </Expandable>

    ### Returns

    <ResponseField name="signature" type="Uint8Array">
      The signature of the transaction.
    </ResponseField>

    ## Sign and send all transactions

    To sign and send multiple transactions in a single call, use the `signAndSendTransaction` method with multiple inputs:

    ```tsx theme={"system"} theme={"system"}
    signAndSendTransaction(...inputs: SignAndSendTransactionInput[]): Promise<SignAndSendTransactionOutput[]>
    ```

    ### Usage

    ```typescript theme={"system"} theme={"system"}
    import {useSignAndSendTransaction, useWallets} from '@privy-io/react-auth/solana';
    import {
      pipe,
      createSolanaRpc,
      getTransactionEncoder,
      createTransactionMessage,
      setTransactionMessageFeePayer,
      setTransactionMessageLifetimeUsingBlockhash,
      appendTransactionMessageInstructions,
      compileTransaction,
      address,
      createNoopSigner
    } from '@solana/kit';
    import {getTransferSolInstruction} from '@solana-program/system';

    // Inside your component
    const {signAndSendTransaction} = useSignAndSendTransaction();
    const {wallets} = useWallets();

    const selectedWallet = wallets[0];

    const amount = 1; // Amount of SOL to send

    const transferInstruction = getTransferSolInstruction({
      amount: BigInt(amount * 1_000_000_000), // Convert SOL to lamports
      destination: address('RecipientAddressHere'),
      source: createNoopSigner(address(selectedWallet.address))
    });

    // Configure your RPC connection to point to the correct Solana network
    const {getLatestBlockhash} = createSolanaRpc('https://api.mainnet-beta.solana.com'); // Replace with your Solana RPC endpoint
    const {value: latestBlockhash} = await getLatestBlockhash().send();

    // Create transactions using @solana/kit
    const transactions = [
      pipe(
        createTransactionMessage({version: 0}),
        (tx) => setTransactionMessageFeePayer(address(selectedWallet.address), tx), // Set the message fee payer
        (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx), // Set recent blockhash
        (tx) => appendTransactionMessageInstructions([transferInstruction], tx), // Add your instructions to the transaction
        (tx) => compileTransaction(tx), // Compile the transaction
        (tx) => new Uint8Array(getTransactionEncoder().encode(tx)) // Finally encode the transaction
      ),
      pipe(
        createTransactionMessage({version: 0}),
        (tx) => setTransactionMessageFeePayer(address(selectedWallet.address), tx),
        (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
        (tx) => appendTransactionMessageInstructions([transferInstruction], tx),
        (tx) => compileTransaction(tx),
        (tx) => new Uint8Array(getTransactionEncoder().encode(tx))
      )
    ];

    // Send multiple transactions
    const results = await signAndSendTransaction(
      {
        transaction: transactions[0],
        wallet: selectedWallet
      },
      {
        transaction: transactions[1],
        wallet: selectedWallet
      }
    );

    console.log(
      'Transactions sent with signatures:',
      results.map((result) => result.signature.toString()).join(',')
    );
    ```

    ### Parameters

    <Expandable title="parameters" defaultOpen="true">
      <ParamField path="inputs" type="SignAndSendTransactionInput[]" required>
        <ParamField path="transaction" type="Uint8Array" required>
          The encoded transaction to be sent.
        </ParamField>

        <ParamField path="wallet" type="ConnectedStandardSolanaWallet" required>
          The Solana wallet to use for sending the transaction.
        </ParamField>

        <ParamField path="chain" type="SolanaChain">
          Type of all Solana chains supported by Privy.
        </ParamField>

        <ParamField path="options" type="SolanaSignAndSendTransactionOptions & {uiOptions?: SendTransactionModalUIOptions; sponsor?: boolean}">
          Additional options for sending the transaction.

          <Expandable title="child attributes">
            <ParamField path="sponsor" type="boolean">
              Optional parameter to enable gas sponsorship for this transaction. [Learn
              more.](/wallets/gas-and-asset-management/gas/overview)
            </ParamField>

            <ParamField path="uiOptions" type="SendTransactionModalUIOptions">
              UI options to customize the transaction request modal.
            </ParamField>
          </Expandable>
        </ParamField>
      </ParamField>
    </Expandable>
  </Tab>

  <Tab title="React Native">
    To send a transaction from a wallet using the React Native SDK, use the `request` method from the wallet's provider:

    ```javascript  theme={"system"}
    request: (request: {
      method: 'signAndSendTransaction',
      params: {
        transaction: Transaction | VersionedTransaction,
        connection: Connection
      }
    }) => Promise<{ signature: string }>
    ```

    <Note>
      The Expo SDK does not support built-in UIs for sending transactions.
      The `signAndSendTransaction` method gives you complete control over the experience and UI.
    </Note>

    ### Usage

    ```javascript  theme={"system"}
    import {Connection} from '@solana/web3.js';
    import {useEmbeddedSolanaWallet} from '@privy-io/expo';

    const { wallets } = useEmbeddedSolanaWallet();
    const wallet = wallets[0];

    // Get the provider
    const provider = await wallet.getProvider();

    // Create a connection to the Solana network
    const connection = new Connection('insert-your-rpc-url-here');

    // Create your transaction (either legacy Transaction or VersionedTransaction)
    // transaction = ...

    // Send the transaction
    const { signature } = await provider.request({
      method: 'signAndSendTransaction',
      params: {
        transaction: transaction,
        connection: connection,
      },
    });

    console.log("Transaction sent with signature:", signature);
    ```

    ### Parameters

    <ParamField path="method" type="'signAndSendTransaction'" required>
      The RPC method executed with the wallet.
    </ParamField>

    <ParamField path="params" type="Object" required>
      Parameters for the transaction.

      <Expandable title="child attributes" defaultOpen="true">
        <ParamField path="transaction" type="Transaction | VersionedTransaction" required>
          The transaction to sign and send. This can be either a legacy Transaction or a VersionedTransaction object from [@solana/web3.js](https://solana-foundation.github.io/solana-web3.js/classes/Transaction.html).
        </ParamField>

        <ParamField path="connection" type="Connection" required>
          Connection to an SVM (Solana) network.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="string">
      The signature of the transaction.
    </ResponseField>
  </Tab>

  <Tab title="Swift">
    Sending a Solana transaction involves building the transaction, signing it, and then submitting it to the network.

    ```swift  theme={"system"}
    public protocol EmbeddedSolanaWalletProvider {
        func signMessage(message: String) async throws -> String
    }
    ```

    ### Usage

    ```swift  theme={"system"}
    import SolanaSwift

    // Get the provider for wallet (assumes wallet is already obtained)
    let provider = wallet.provider

    // Create a Solana RPC client
    let solana = JSONRPCAPIClient(endpoint: URL(string: "https://api.mainnet-beta.solana.com")!)

    // Build the transaction using your preferred method
    let latestBlockhash = try await solana.getLatestBlockhash()
    let walletPK = try PublicKey(string: wallet.address)
    var tx = Transaction()
    tx.instructions.append(
        SystemProgram.transferInstruction(
            from: walletPK,
            to: try PublicKey(string: "9NvE68JVWHHHGLp5NNELtM5fiBw6SXHrzqQJjUqaykC1"),
            lamports: 100000000000000
        )
    )
    tx.recentBlockhash = latestBlockhash
    tx.feePayer = walletPK

    // Serialize the transaction for signing as base64
    let message = try tx.compileMessage().serialize().base64EncodedString()

    // Sign using the Privy Embedded Wallet
    let signature = try await provider.signMessage(message: message)

    // Add the signature back to the transaction
    try tx.addSignature(signature: Data(base64Encoded: signature)!, publicKey: walletPK)

    // Send the transaction via a JSON-RPC call
    let txHash = try await solana.sendTransaction(transaction: tx.serialize().base64EncodedString())

    print("Transaction sent with hash: \(txHash)")
    ```

    ### Parameters

    <ParamField path="message" type="String" required>
      The base64-encoded serialized transaction message to sign.
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="String">
      The base64-encoded signature for the transaction.
    </ResponseField>
  </Tab>

  <Tab title="Android">
    Use the `signAndSendTransaction` method to sign and submit a Solana transaction in a single call.

    ```kotlin  theme={"system"}
    public suspend fun signAndSendTransaction(
        transaction: ByteArray,
        cluster: SolanaCluster = SolanaCluster.MainNet,
        rpcUrl: String? = null,
        sendOptions: SendOptions? = null
    ): Result<String>
    ```

    ### Usage

    ```kotlin  theme={"system"}
    val solanaWallet = user.embeddedSolanaWallets.first()

    // Fetch latest blockhash from network
    val blockhash = fetchLatestBlockhash(SolanaCluster.DevNet).getOrThrow()
    // For apps with TEE execution: use "11111111111111111111111111111111" instead - Privy auto-populates it

    // Build the transaction
    val fromPubkey = SolanaPublicKey.from(solanaWallet.address)
    val instruction = SystemProgram.transfer(
        fromPubkey = fromPubkey,
        toPubkey = SolanaPublicKey.from(recipientAddress),
        lamports = 1000000
    )

    val txMessage = Message.Builder()
        .addInstruction(instruction)
        .setRecentBlockhash(blockhash)
        .build()

    val transaction = Transaction(txMessage).serialize()

    // Sign and send
    val result = solanaWallet.provider.signAndSendTransaction(
        transaction = transaction,
        cluster = SolanaCluster.DevNet
    )

    result.fold(
        onSuccess = { signature ->
            println("Success: https://explorer.solana.com/tx/$signature?cluster=devnet")
        },
        onFailure = { error ->
            println("Failed: ${error.message}")
        }
    )
    ```

    ### With SendOptions

    ```kotlin  theme={"system"}
    val result = solanaWallet.provider.signAndSendTransaction(
        transaction = transaction,
        cluster = SolanaCluster.DevNet,
        sendOptions = SendOptions(
            preflightCommitment = "confirmed",
            maxRetries = 5
        )
    )
    ```

    ### Parameters

    <ParamField path="transaction" type="ByteArray" required>
      The serialized transaction bytes to sign and send.
    </ParamField>

    <ParamField path="cluster" type="SolanaCluster">
      The Solana network cluster. Defaults to `SolanaCluster.MainNet`.
    </ParamField>

    <ParamField path="rpcUrl" type="String?">
      Optional custom RPC URL. If not provided, uses the default RPC for the specified cluster.
    </ParamField>

    <ParamField path="sendOptions" type="SendOptions?">
      Optional configuration for transaction submission.

      <Expandable title="child attributes">
        <ParamField path="skipPreflight" type="Boolean?">
          Whether to skip preflight transaction checks. Defaults to `false`.
        </ParamField>

        <ParamField path="preflightCommitment" type="String?">
          Commitment level for preflight checks (e.g., `"confirmed"`, `"finalized"`).
        </ParamField>

        <ParamField path="maxRetries" type="Int?">
          Maximum number of retry attempts for sending the transaction.
        </ParamField>

        <ParamField path="minContextSlot" type="Long?">
          Minimum slot number at which the transaction can be evaluated.
        </ParamField>
      </Expandable>
    </ParamField>

    <Note>
      The `cluster`, `rpcUrl`, and `sendOptions` parameters are only valid for apps using [on-device execution](/security/wallet-infrastructure/advanced/user-device).
    </Note>

    ### Returns

    <ResponseField name="result" type="Result<String>">
      A Result that, when successful, contains the transaction signature.
    </ResponseField>
  </Tab>

  <Tab title="Flutter">
    Use the `signMessage` method on the Solana wallet provider to sign a transaction and then submit it to the network.

    ```dart  theme={"system"}
    Future<Result<String>> signMessage(String message);
    ```

    ### Usage

    ```dart  theme={"system"}
    import 'dart:convert';
    import 'package:solana/solana.dart';

    // Retrieve the user's Solana wallet (assumes wallet is already obtained)
    final solanaWallet = user.embeddedSolanaWallets.first;

    // Create a Solana RPC client
    final rpcClient = RpcClient('https://api.mainnet-beta.solana.com');

    // Build the transaction
    final walletPublicKey = Ed25519HDPublicKey.fromBase58(solanaWallet.address);
    final recipientPublicKey = Ed25519HDPublicKey.fromBase58(recipientAddress);

    final instruction = SystemInstruction.transfer(
        fundingAccount: walletPublicKey,
        recipientAccount: recipientPublicKey,
        lamports: amount,
    );

    // Get recent blockhash
    final recentBlockhash = await rpcClient.getLatestBlockhash();

    // Create transaction
    final transaction = Transaction.v0(
        payer: walletPublicKey,
        recentBlockhash: recentBlockhash.value.blockhash,
        instructions: [instruction],
    );

    // Serialize transaction message to base64
    final serializedMessage = base64Encode(transaction.serializeMessage());

    // Sign the transaction message
    final result = await solanaWallet.provider.signMessage(serializedMessage);

    // Handle the result
    result.when(
        success: (signature) {
            // Add signature to transaction
            transaction.addSignature(walletPublicKey, base64Decode(signature));

            // Send the transaction
            rpcClient.sendRawTransaction(base64Encode(transaction.serialize()))
              .then((txHash) {
                print('Transaction sent with hash: $txHash');
              });
        },
        failure: (error) {
            print('Failed to sign transaction: $error');
        },
    );
    ```

    ### Parameters

    <ParamField path="message" type="String" required>
      The base64-encoded serialized transaction message to sign.
    </ParamField>

    ### Returns

    <ResponseField name="result" type="Result<String>">
      A Result that, when successful, contains the base64-encoded signature.
    </ResponseField>
  </Tab>

  <Tab title="NodeJS">
    Use the `signAndSendTransaction` method on the Solana interface to send a transaction with a Solana wallet.

    ### Usage

    ```js  theme={"system"}
    import {
      PublicKey,
      SystemProgram,
      VersionedTransaction,
      TransactionMessage,
    } from '@solana/web3.js';

    const walletPublicKey = new PublicKey(wallet.address);
    const instruction = SystemProgram.transfer({
      fromPubkey: walletPublicKey,
      toPubkey: new PublicKey(recipientAddress),
      lamports: amount,
    });

    const message = new TransactionMessage({
      payerKey: walletPublicKey,
      instructions: [instruction],
      recentBlockhash,
    });

    const transaction = new VersionedTransaction(message.compileToV0Message());

    const {hash} = await privy.wallets().solana().signAndSendTransaction('insert-wallet-id', {
      caip2: 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp', // Mainnet
      transaction: Buffer.from(transaction.serialize()).toString('base64'),
      sponsor: true,
    });
    ```

    ### Parameters and Returns

    Check out the [API reference](/api-reference/wallets/solana/sign-and-send-transaction) for more details.
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    Use the `signAndSendTransaction` method on the Solana client to send a transaction with a Solana wallet.

    ```js  theme={"system"}
    signAndSendTransaction: (input: SolanaSignAndSendTransactionInputType) => Promise<SolanaSignAndSendTransactionResponseType>
    ```

    ### Usage

    ```js  theme={"system"}
    import {
      PublicKey,
      SystemProgram,
      VersionedTransaction,
      TransactionMessage,
    } from '@solana/web3.js';

    const walletPublicKey = new PublicKey(wallet.address);
    const instruction = SystemProgram.transfer({
      fromPubkey: walletPublicKey,
      toPubkey: new PublicKey(recipientAddress),
      lamports: amount,
    });

    const message = new TransactionMessage({
      payerKey: walletPublicKey,
      instructions: [instruction],
      recentBlockhash,
    });

    const transaction = new VersionedTransaction(message.compileToV0Message());

    const {hash} = await privy.walletApi.solana.signAndSendTransaction({
      walletId: 'insert-wallet-id',
      caip2: 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp', // Mainnet
      transaction: transaction,
      sponsor: true,
    });
    ```

    ### Parameters

    <ParamField path="walletId" type="string" required>
      The ID of the wallet to send the transaction from.
    </ParamField>

    <ParamField path="caip2" type="string" required>
      The CAIP2 chain ID of the chain the transaction is being sent on.
    </ParamField>

    <ParamField path="transaction" type="Transaction | VersionedTransaction" required>
      The transaction to sign and send. This can be either a legacy Transaction or a VersionedTransaction object from [@solana/web3.js](https://solana-foundation.github.io/solana-web3.js/classes/Transaction.html).
    </ParamField>

    <ParamField path="sponsor" type="boolean">
      Optional parameter to enable gas sponsorship for this transaction. [Learn more.](/wallets/gas-and-asset-management/gas/overview)
    </ParamField>

    ### Returns

    <ResponseField name="hash" type="string">
      The hash for the broadcasted transaction.
    </ResponseField>

    <ResponseField name="caip2" type="string">
      The CAIP2 chain ID of the chain the transaction was sent on.
    </ResponseField>
  </Tab>

  <Tab title="Java">
    To send a transaction from your wallet, use the `signAndSendTransaction` method.
    It will sign your transaction, broadcast it to the network, and return the transaction hash to you.

    ### Usage

    ```java  theme={"system"}
    try {
        String caip2 = "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp"; // Solana Mainnet

        // A base64 encoded serialized transaction to sign
        String transaction = "insert-base-64-encoded-serialized-transaction";

        // Example: If wallet's owner is an authorization private key
        AuthorizationContext authorizationContext = AuthorizationContext.builder()
            .addAuthorizationPrivateKey("authorization-key")
            .build();

        SolanaSignAndSendTransactionRpcResponseData response = privyClient.wallets().solana()
            .signAndSendTransaction(
                walletId,
                caip2,
                transaction,
                authorizationContext,
                true // sponsor
            );

        String transactionHash = response.hash();
    } catch (APIException e) {
        String errorBody = e.bodyAsString();
        System.err.println(errorBody);
    } catch (Exception e) {
        System.err.println(e.getMessage());
    }
    ```

    ### Parameters

    <ParamField type="String" body="transaction">
      A base64 encoded serialized transaction to sign.
    </ParamField>

    <ParamField type="String" body="caip2">
      The CAIP2 chain ID of the chain the transaction is being sent on.
    </ParamField>

    <ParamField type="Boolean" body="sponsor">
      Optional parameter to enable gas sponsorship for this transaction. [Learn more.](/wallets/gas-and-asset-management/gas/overview)
    </ParamField>

    ### Returns

    The `SolanaSignAndSendTransactionRpcResponseData` object contains the following fields:

    <ResponseField name="hash()" type="String">
      The hash of the broadcasted transaction.
    </ResponseField>

    <ResponseField name="caip2()" type="String">
      The CAIP2 chain ID of the chain the transaction was sent on.
    </ResponseField>

    <ResponseField name="transactionId()" type="Optional<String>">
      The transaction ID of the broadcasted transaction.
    </ResponseField>
  </Tab>

  <Tab title="REST API">
    To send a transaction make a POST request to

    ```bash  theme={"system"}
    https://api.privy.io/v1/wallets/<wallet_id>/rpc
    ```

    ### Usage

    ```bash  theme={"system"}
    $ curl --request POST https://api.privy.io/v1/wallets/<wallet_id>/rpc \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H "privy-authorization-signature: <authorization-signature-for-request>" \
    -H 'Content-Type: application/json' \
    -d '{
        "method": "signAndSendTransaction",
        "caip2": "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
        "sponsor": true,
        "params": {
            "transaction": "insert-base-64-encoded-serialized-transaction",
            "encoding": "base64"
        }
    }'
    ```

    A successful response will look like the following:

    ```json  theme={"system"}
    {
        "method": "signAndSendTransaction",
        "data": {
            "hash": "insert-transaction-hash",
            "caip2": "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1"
        }
    }
    ```

    ### Parameters

    <ParamField path="method" type="'signAndSendTransaction'" required>
      The RPC method executed with the wallet.
    </ParamField>

    <ParamField path="caip2" type="string" required>
      The CAIP2 chain ID to broadcast the transaction on.
    </ParamField>

    <ParamField path="params" type="Object" required>
      Parameters for the RPC method to execute with the wallet.

      <Expandable title="child attributes" defaultOpen="true">
        <ParamField path="transaction" type="string" required>
          An encoded string serializing the transaction to be signed with the wallet.
        </ParamField>

        <ParamField path="encoding" type="'base64'" required>
          The encoding format for `params.transaction`. Currently, only `'base64'` is supported.
        </ParamField>
      </Expandable>
    </ParamField>

    <ParamField path="sponsor" type="boolean">
      Optional parameter to enable gas sponsorship for this transaction. [Learn more.](/wallets/gas-and-asset-management/gas/overview)
    </ParamField>

    ### Returns

    <ResponseField name="method" type="'signAndSendTransaction'">
      The RPC method executed with the wallet.
    </ResponseField>

    <ResponseField name="data.hash" type="string">
      The hash for the broadcasted transaction.
    </ResponseField>

    <ResponseField name="data.caip2" type="string">
      The CAIP2 chain ID the transaction was submitted on.
    </ResponseField>
  </Tab>

  <Tab title="Rust">
    Use the `sign_and_send_transaction` method on the Solana service to sign and broadcast a transaction. Use the [`solana_sdk`](https://docs.rs/solana-sdk/) crate to construct your transactions.

    ### Usage

    ```rust  theme={"system"}
    use privy_rs::{AuthorizationContext, PrivyClient};
    use solana_sdk::{pubkey::Pubkey, transaction::Transaction};
    use base64::{engine::general_purpose::STANDARD, Engine};
    use std::str::FromStr;

    let client = PrivyClient::new("app_id".to_string(), "app_secret".to_string())?;
    let solana_service = client.wallets().solana();
    let auth_ctx = AuthorizationContext::new();

    // Build transaction using solana_sdk and solana_system_interface
    let from_pubkey = Pubkey::from_str("DTeASnDsQ1z9Le77MjuiPH4MyqLDWa9vB6R3ZZKRd8d3")?;
    let to_pubkey = Pubkey::from_str("9NvE68JVWHHHGLp5NNELtM5fiBw6SXHrzqQJjUqaykC1")?;
    let lamports = 1000000; // 0.001 SOL

    let transaction = Transaction::new_with_payer(
        &[solana_system_interface::instruction::transfer(
            &from_pubkey,
            &to_pubkey,
            lamports,
        )],
        Some(&from_pubkey),
    );

    // Serialize and encode transaction as base64
    let serialized_transaction = STANDARD.encode(bincode::serialize(&transaction)?);

    let result = solana_service.sign_and_send_transaction(
        &wallet_id,
        "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1", // Solana devnet
        &serialized_transaction,
        &auth_ctx,
        Some(true) // sponsor
    ).await?;

    println!("Transaction sent successfully");
    ```

    For transaction construction, use the [`solana_sdk`](https://docs.rs/solana-sdk/) crate for core transaction types and the [`solana_system_interface`](https://docs.rs/solana-system-interface/) crate for system instructions like transfers.

    ### Parameters and Returns

    See the Rust SDK documentation for detailed parameter and return types, including embedded examples:

    * [SolanaService::sign\_and\_send\_transaction](https://docs.rs/privy-rs/latest/privy_rs/solana/struct.SolanaService.html#method.sign_and_send_transaction)
    * [solana\_sdk crate documentation](https://docs.rs/solana-sdk/)
    * [solana\_system\_interface crate documentation](https://docs.rs/solana-system-interface/)

    For REST API details, see the [API reference](/api-reference/wallets/solana/sign-and-send-transaction).
  </Tab>
</Tabs>

<Note>
  For complete examples of sending SOL and SPL tokens using Privy's SDKs, check out the [sending a
  SOL transaction recipe](/recipes/solana/send-sol) and the [sending SPL tokens
  recipe](/recipes/solana/send-spl-tokens).
</Note>


# null
Source: https://docs.privy.io/wallets/using-wallets/solana/sign-a-message



<Info>
  When using Privy's server-side SDKs to sign messages, you can use the authorization context to
  automatically sign requests. Learn more about [signing on the
  server](/controls/authorization-keys/using-owners/sign/signing-on-the-server).
</Info>

<Tabs>
  <Tab title="React">
    Use the `signMessage` method exported from the `useSignMessage` hook to sign a message with a Solana wallet.

    ```tsx  theme={"system"}
    signMessage: ({
      message,
      options
    }: {
      message: Uint8Array;
      wallet: ConnectedStandardSolanaWallet;
      options?: {
        uiOptions?: SignMessageModalUIOptions;
      };
    }) =>
      Promise<{
        signature: Uint8Array;
      }>;
    ```

    ### Usage

    ```tsx  theme={"system"}
    import {useWallets, useSignMessage} from '@privy-io/react-auth/solana';
    import bs58 from 'bs58';

    const {wallets} = useWallets();
    const {signMessage} = useSignMessage();

    const selectedWallet = wallets[0];

    const message = 'Hello world';
    const signatureUint8Array = (
      await signMessage({
        message: new TextEncoder().encode(message),
        wallet: selectedWallet,
        options: {
          uiOptions: {
            title: 'Sign this message'
          }
        }
      })
    ).signature;
    const signature = bs58.encode(signatureUint8Array);
    ```

    ### Parameters

    <ParamField path="message" type="Uint8Array" required>
      Message to be signed as a Uint8Array.
    </ParamField>

    <ParamField path="wallet" type="string">
      The Solana wallet to use for signing the message.
    </ParamField>

    <ParamField path="options" type="{uiOptions?: SignMessageModalUIOptions}">
      Additional options for signing the message.

      <Expandable title="uiOptions">
        <ParamField path="uiOptions" type="SignMessageModalUIOptions">
          UI options to customize the transaction request modal.

          <Tip>
            To hide confirmation modals, set `options.uiOptions.showWalletUIs` to `false`. Learn more
            about configuring modal prompts [here](/recipes/react/manage-wallet-UIs).
          </Tip>
        </ParamField>
      </Expandable>
    </ParamField>

    ### Response

    <ResponseField name="signature" type="Uint8Array">
      The signature produced by the wallet.
    </ResponseField>

    <ResponseField name="signedMessage" type="Uint8Array">
      The original message that was signed.
    </ResponseField>
  </Tab>

  <Tab title="React Native">
    Request a message signature on the wallets Ethereum provider.

    ```tsx  theme={"system"}
    import {useEmbeddedSolanaWallet} from '@privy-io/expo';

    const wallet = useEmbeddedSolanaWallet();
    const provider = await wallet.getProvider();

    const message = 'Hello world';
    const {signature} = await provider.request({
      method: 'signMessage',
      params: {message}
    });
    ```

    ### Parameters

    <ParamField path="method" type="'signMessage'" required>
      The method for the wallet request. For signing messages, this is `'signMessage'`.
    </ParamField>

    <ParamField path="params" type="Object" required>
      <Expandable title="properties" defaultOpen="true">
        <ParamField path="message" type="string" required>
          The string to sign with the wallet. If the message is a string, you should pass the string as
          the message directly. If the message is an array of bytes (Uint8Array), you should
          base64-encode the array as a string before passing it to message.
        </ParamField>

        <ParamField path="address" type="string">
          The address of the wallet to sign the message with.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="Swift">
    Request a message signature on the wallet's Solana provider.

    ```swift  theme={"system"}
    guard let user = privy.user else {
        // If user is null, user is not authenticated
        return
    }

    // Retrieve list of user's embedded Solana wallets
    let solanaWallets = user.embeddedSolanaWallets

    // Grab the desired wallet. Here, we retrieve the first wallet
    guard let wallet = solanaWallets.first else {
        // No SOL wallets
        return
    }

    // Sign a Base64 encoded message
    let signature = try await wallet.provider.signMessage(message: "SGVsbG8hIEkgYW0gdGhlIGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2UgdG8gYmUgc2lnbmVkLg==")

    print("Result signature: \(signature)")
    ```

    ### Parameters

    <ParamField path="message" type="string" required>
      The message to sign, as a base64-encoded string.
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="Android">
    Use the `signMessage` method on the Solana wallet provider to sign a message with the wallet.

    ```kotlin  theme={"system"}
    // Get current auth state
    val user = privy.user

    // check if user is authenticated
    if (user != null) {
        // Retrieve list of user's Solana wallet
        val solanaWallet = user.embeddedSolanaWallets.first()

        if (solanaWallet != null) {
            // Sign a message
            val result = solanaWallet.provider.signMessage("SGVsbG8hIEkgYW0gdGhlIGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2UgdG8gYmUgc2lnbmVkLg==")
        }
    }
    ```

    ### Parameters

    <ParamField path="message" type="string" required>
      The message to sign, as a base64-encoded string.
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="Unity">
    ### Usage

    ```csharp  theme={"system"}
    try {
        IEmbeddedSolanaWallet embeddedWallet = PrivyManager.Instance.User.EmbeddedSolanaWallets[0];
        IEmbeddedSolanaWalletProvider provider = embeddedWallet.EmbeddedSolanaWalletProvider;
        string signature = await provider.SignMessage("A message to sign");
        Debug.Log(signature);
    } catch (PrivyException.EmbeddedWalletException ex){
        Debug.LogError($"Could not sign message due to error: {ex.Error} {ex.Message}");
    } catch (Exception ex) {
        Debug.LogError($"Could not sign message exception {ex.Message}");
    }
    ```

    ### Parameters

    <ParamField path="message" type="string" required>
      The base64 encoded bytes of the message or transaction to sign.
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="string">
      The base64 encoded signature of the message, produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="Flutter">
    Use the `signMessage` method on the Solana wallet provider to sign a message with the wallet.

    ```dart  theme={"system"}
    // Get the current user
    final user = privy.user;

    // Check if the user is authenticated
    if (user != null) {
      // Retrieve the user's Solana wallet
      final solanaWallet = user.embeddedSolanaWallets.first;

      if (solanaWallet != null) {
        // Sign a message
        final result = solanaWallet.provider.signMessage("SGVsbG8hIEkgYW0gdGhlIGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2UgdG8gYmUgc2lnbmVkLg==")
      }
    }
    ```

    ### Parameters

    <ParamField path="message" type="string" required>
      The message to sign, as a base64-encoded string.
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="NodeJS">
    Use the `signMessage` method on the solana interface to sign a message with an Solana wallet.

    ### Usage

    ```tsx  theme={"system"}
    const {signature, encoding} = await privy.wallets().solana().signMessage('insert-wallet-id', {
      message: 'Hello world'
    });
    ```

    ### Parameters and Returns

    Check out the [API reference](/api-reference/wallets/solana/sign-message) for more details.
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    Use the `signMessage` method on the ethereum client to sign a message with an Solana wallet.

    ```tsx  theme={"system"}
    signMessage: (message: string, options: {uiOptions: SignMessageModalUIOptions; address?: string}) =>
      Promise<{signature: string}>;
    ```

    ### Usage

    ```tsx  theme={"system"}
    const {signature, encoding} = await privy.walletApi.solana.signMessage({
      walletId: 'insert-wallet-id',
      message: 'Hello world'
    });
    ```

    ### Parameters

    <ParamField path="walletId" type="string" required>
      Unique ID of the wallet to take actions with.
    </ParamField>

    <ParamField path="message" type="string | Uint8Array" required>
      The string or bytes to sign with the wallet.
    </ParamField>

    <ParamField path="idempotencyKey" type="string">
      [Idempotency key](/api-reference/idempotency-keys) to identify a unique request.
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="string">
      An encoded string serializing the signature produced by the user's wallet.
    </ResponseField>

    <ResponseField name="encoding" type="'hex'">
      The encoding format for the returned `signature`. Currently, only `'base64'` is supported for
      Solana.
    </ResponseField>
  </Tab>

  <Tab title="Java">
    To sign a message from your wallet, use the `signMessage` method.
    It will sign your message, and return the signature to you.

    ### Usage

    ```java  theme={"system"}
    try {
        // Base64 encoded message
        String message = "SGVsbG8hIEkgYW0gdGhlIGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2UgdG8gYmUgc2lnbmVkLg";

        // Example: If wallet's owner is an authorization private key
        AuthorizationContext authorizationContext = AuthorizationContext.builder()
            .addAuthorizationPrivateKey("authorization-key")
            .build();

        SolanaSignMessageRpcResponseData response = privyClient
            .wallets()
            .solana()
            .signMessage(
                walletId,
                message,
                authorizationContext
            );

        String signature = response.signature();
    } catch (APIException e) {
        String errorBody = e.bodyAsString();
        System.err.println(errorBody);
    } catch (Exception e) {
        System.err.println(e.getMessage());
    }
    ```

    ### Parameters

    When signing a message with your solana wallet, you can sign over a base64 string encoding.

    <ParamField type="String" body="message">
      The base64 encoded message to sign over.
    </ParamField>

    ### Returns

    The `SolanaSignMessageRpcResponseData` object contains a `signature()` field

    <ResponseField name="signature()" type="String">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="Rust">
    Use the `sign_message` method on the Solana service to sign a message with a Solana wallet.

    ### Usage

    ```rust  theme={"system"}
    use privy_rs::{AuthorizationContext, PrivyClient};

    let client = PrivyClient::new("app_id".to_string(), "app_secret".to_string())?;
    let solana_service = client.wallets().solana();
    let auth_ctx = AuthorizationContext::new();

    // Base64 encode your message first
    let message = base64::encode("Hello, Solana!");
    let signature = solana_service
        .sign_message(
            &wallet_id,
            &message,
            &auth_ctx,
            Some("unique-request-id-456"),
        )
        .await?;

    println!("Message signed successfully");
    ```

    ### Parameters and Returns

    See the Rust SDK documentation for detailed parameter and return types, including embedded examples:

    * [SolanaService::sign\_message](https://docs.rs/privy-rs/latest/privy_rs/solana/struct.SolanaService.html#method.sign_message)

    For REST API details, see the [API reference](/api-reference/wallets/solana/sign-message).
  </Tab>

  <Tab title="REST API">
    To sign a message make a POST request to

    ```bash  theme={"system"}
    https://api.privy.io/v1/wallets/<wallet_id>/rpc
    ```

    ### Parameters

    <ParamField path="method" type="'signMessage'" required>
      RPC method to execute with the wallet.
    </ParamField>

    <ParamField path="params" type="Object" required>
      Parameters for the RPC method to execute with the wallet.

      <Expandable title="properties" defaultOpen="true">
        <ParamField path="message" type="string" required>
          The message to sign with the wallet. If the message to sign is raw bytes, you must serialize
          the message as a base64 string.
        </ParamField>

        <ParamField path="encoding" type="'base64'" required>
          The encoding format for `message`. Currently, only `'base64'` is supported for Solana.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="method" type="'signMessage'">
      The RPC method executed with the wallet.
    </ResponseField>

    <ResponseField name="data" type="Object">
      Outputs for the RPC method executed with the wallet.

      <Expandable title="properties" defaultOpen="true">
        <ResponseField name="signature" type="string">
          An encoded string serializing the signature produced by the user's wallet.
        </ResponseField>

        <ResponseField name="encoding" type="'base64'">
          The encoding format for the returned `signature`. Currently, only `'base64'` is supported for Solana.
        </ResponseField>
      </Expandable>
    </ResponseField>

    ### Usage

    ```bash  theme={"system"}
    $ curl --request POST https://api.privy.io/v1/wallets/<wallet_id>/rpc \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H "privy-authorization-signature: <authorization-signature-for-request>" \
    -H 'Content-Type: application/json' \
    -d '{
      "chain_type": "solana",
      "method": "signMessage",
      "params": {
        "message": "Hello, Solana.",
        "encoding": "base64"
      }
    }'
    ```
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/wallets/using-wallets/solana/sign-a-transaction



<Info>
  When using Privy's server-side SDKs to sign transactions, you can use the authorization context to
  automatically sign requests. Learn more about [signing on the
  server](/controls/authorization-keys/using-owners/sign/signing-on-the-server).
</Info>

<Tabs>
  <Tab title="React">
    Use the `signTransaction` method exported from the `useSignTransaction` hook to sign a transaction with a Solana wallet.

    ```tsx  theme={"system"}
    signTransaction: (input: {
      transaction: SupportedSolanaTransaction;
      wallet: ConnectedStandardSolanaWallet;
      options?: SolanaSignTransactionOptions & {uiOptions?: SendTransactionModalUIOptions};
    }) =>
      Promise<{
        signedTransaction: Uint8Array;
      }>;
    ```

    ### Usage

    ```tsx  theme={"system"}
    import {useSignTransaction, useWallets} from '@privy-io/react-auth/solana';
    import {pipe, createSolanaRpc, getTransactionEncoder, createTransactionMessage} from '@solana/kit';

    // Inside your component
    const {signTransaction} = useSignTransaction();
    const {wallets} = useWallets();

    const selectedWallet = wallets[0];

    // Configure your connection to point to the correct Solana network
    const {getLatestBlockhash} = createSolanaRpc('https://api.mainnet-beta.solana.com');

    // Get the latest blockhash
    const {value} = await getLatestBlockhash().send();

    // Create your transaction (either legacy Transaction or VersionedTransaction)
    const transaction = pipe(
      createTransactionMessage({version: 0}),
      // Set the message fee payer...
      // Set recent blockhash...
      // Add your instructions to the transaction...
      // Finally encode the transaction
      (tx) => new Uint8Array(getTransactionEncoder().encode(tx))
    );

    // Sign the transaction
    const signedTransaction = await signTransaction({
      transaction: transaction,
      wallet: selectedWallet
    });

    console.log('Transaction signed successfully');
    ```

    ### Parameters

    <ParamField path="transaction" type="Uint8Array" required>
      The encoded transaction to be signed.
    </ParamField>

    <ParamField path="wallet" type="ConnectedStandardSolanaWallet" required>
      The Solana wallet to use for signing the transaction.
    </ParamField>

    <ParamField path="chain" type="SolanaChain">
      Type of all Solana chains supported by Privy.
    </ParamField>

    <ParamField path="options" type="SolanaSignTransactionOptions & {uiOptions?: SendTransactionModalUIOptions}">
      Additional options for signing the transaction.

      <Expandable title="uiOptions">
        <ParamField path="uiOptions" type="SendTransactionModalUIOptions">
          UI options to customize the transaction request modal.

          <Tip>
            To hide confirmation modals, set `options.uiOptions.showWalletUIs` to `false`. Learn more
            about configuring modal prompts [here](/recipes/react/manage-wallet-UIs).
          </Tip>
        </ParamField>
      </Expandable>
    </ParamField>

    ### Response

    <ResponseField name="signedTransaction" type="Uint8Array">
      The signed transaction that can be sent to the network.
    </ResponseField>
  </Tab>

  <Tab title="React Native">
    To sign a transaction from a wallet using the React Native SDK, use the `request` method from the wallet's provider:

    ```javascript  theme={"system"}
    request: (request: {
      method: 'signTransaction',
      params: {
        transaction: Transaction | VersionedTransaction,
      }
    }) => Promise<{ signedTransaction: Transaction }>
    ```

    <Note>
      The Expo SDK does not support built-in UIs for signing transactions.
      The `signTransaction` method gives you complete control over the experience and UI.
    </Note>

    ### Usage

    ```javascript  theme={"system"}
    import {useEmbeddedSolanaWallet} from '@privy-io/expo';

    const { wallets } = useEmbeddedSolanaWallet();
    const wallet = wallets[0];

    // Get the provider
    const provider = await wallet.getProvider();

    // Create your transaction (either legacy Transaction or VersionedTransaction)
    // transaction = ...

    // Sign the transaction
    const { signedTransaction } = await provider.request({
      method: 'signTransaction',
      params: {
        transaction: transaction,
      },
    });

    console.log("Transaction signed successfully", signedTransaction);
    ```

    ### Parameters

    <ParamField path="method" type="'signTransaction'" required>
      The RPC method executed with the wallet.
    </ParamField>

    <ParamField path="params" type="Object" required>
      Parameters for the transaction.

      <Expandable title="child attributes" defaultOpen="true">
        <ParamField path="transaction" type="Transaction | VersionedTransaction" required>
          The transaction to sign. This can be either a legacy Transaction or a VersionedTransaction object from [@solana/web3.js](https://solana-foundation.github.io/solana-web3.js/classes/Transaction.html).
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="signedTransaction" type="Transaction">
      The signature of the transaction.
    </ResponseField>
  </Tab>

  <Tab title="Swift">
    Sign a Solana transaction without submitting it to the network.

    ```swift  theme={"system"}
    public protocol EmbeddedSolanaWalletProvider {
        func signMessage(message: String) async throws -> String
    }
    ```

    ### Usage

    ```swift  theme={"system"}
    import SolanaSwift

    // Get the provider for wallet (assumes wallet is already obtained)
    let provider = wallet.provider

    // Create a Solana RPC client
    let solana = JSONRPCAPIClient(endpoint: URL(string: "https://api.mainnet-beta.solana.com")!)

    // Build the transaction using your preferred method
    let latestBlockhash = try await solana.getLatestBlockhash()
    let walletPK = try PublicKey(string: wallet.address)
    var tx = Transaction()
    tx.instructions.append(
        SystemProgram.transferInstruction(
            from: walletPK,
            to: try PublicKey(string: "9NvE68JVWHHHGLp5NNELtM5fiBw6SXHrzqQJjUqaykC1"),
            lamports: 100000000000000
        )
    )
    tx.recentBlockhash = latestBlockhash
    tx.feePayer = walletPK

    // Serialize the transaction for signing as base64
    let message = try tx.compileMessage().serialize().base64EncodedString()

    // Sign using the Privy Embedded Wallet
    let signature = try await provider.signMessage(message: message)
    ```

    ### Parameters

    <ParamField path="message" type="String" required>
      The base64-encoded serialized transaction message to sign.
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="String">
      The base64-encoded signature for the transaction.
    </ResponseField>
  </Tab>

  <Tab title="Android">
    Use the `signMessage` method on the Solana wallet provider to sign a transaction and then submit it to the network.

    ```kotlin  theme={"system"}
    public suspend fun signMessage(message: String): Result<String>
    ```

    ### Usage

    ```kotlin  theme={"system"}
    // Retrieve user's Solana wallet (assumes wallet is already obtained)
    val solanaWallet = user.embeddedSolanaWallets.first()

    // Create a Solana RPC client
    val connection = Connection("https://api.mainnet-beta.solana.com")

    // Build the transaction
    val walletPublicKey = PublicKey(solanaWallet.address)
    val instruction = SystemProgram.transfer(
        fromPubkey = walletPublicKey,
        toPubkey = PublicKey(recipientAddress),
        lamports = amount
    )

    // Get recent blockhash
    val recentBlockhash = connection.getLatestBlockhash()

    // Create transaction
    val transaction = Transaction()
    transaction.add(instruction)
    transaction.recentBlockhash = recentBlockhash
    transaction.feePayer = walletPublicKey

    // Serialize transaction to base64
    val serializedTransaction = transaction.serializeMessage().base64()

    // Sign the transaction message
    val result = solanaWallet.provider.signMessage(serializedTransaction)
    ```

    ### Parameters

    <ParamField path="message" type="String" required>
      The base64-encoded serialized transaction message to sign.
    </ParamField>

    ### Returns

    <ResponseField name="result" type="Result<String>">
      A Result that, when successful, contains the base64-encoded signature.
    </ResponseField>
  </Tab>

  <Tab title="Flutter">
    Use the `signMessage` method on the Solana wallet provider to sign a transaction and then submit it to the network.

    ```dart  theme={"system"}
    Future<Result<String>> signMessage(String message);
    ```

    ### Usage

    ```dart  theme={"system"}
    // Retrieve the user's Solana wallet (assumes wallet is already obtained)
    final solanaWallet = user.embeddedSolanaWallets.first;

    // Create a Solana RPC client
    final connection = Connection('https://api.mainnet-beta.solana.com');

    // Build the transaction
    final walletPublicKey = PublicKey(solanaWallet.address);
    final instruction = SystemProgram.transfer(
        fromPubkey: walletPublicKey,
        toPubkey: PublicKey(recipientAddress),
        lamports: amount
    );

    // Get recent blockhash
    final recentBlockhash = await connection.getLatestBlockhash();

    // Create transaction
    final transaction = Transaction();
    transaction.add(instruction);
    transaction.recentBlockhash = recentBlockhash;
    transaction.feePayer = walletPublicKey;

    // Serialize transaction to base64
    final serializedTransaction = base64Encode(transaction.serializeMessage());

    // Sign the transaction message
    final result = await solanaWallet.provider.signMessage(serializedTransaction);
    ```

    ### Parameters

    <ParamField path="message" type="String" required>
      The base64-encoded serialized transaction message to sign.
    </ParamField>

    ### Returns

    <ResponseField name="result" type="Result<String>">
      A Result that, when successful, contains the base64-encoded signature.
    </ResponseField>
  </Tab>

  <Tab title="NodeJS">
    Use the `signTransaction` method on the Solana interface to sign a transaction with an Solana wallet.

    ### Usage

    ```js  theme={"system"}
    import {
      clusterApiUrl,
      Connection,
      LAMPORTS_PER_SOL,
      PublicKey,
      SystemProgram,
      Transaction,
      VersionedTransaction,
      TransactionMessage
    } from '@solana/web3.js';

    const walletPublicKey = new PublicKey(wallet.address);
    const connection = new Connection(clusterApiUrl('devnet'));
    const instruction = SystemProgram.transfer({
      fromPubkey: walletPublicKey,
      toPubkey: new PublicKey(address),
      lamports: value * LAMPORTS_PER_SOL
    });

    const {blockhash: recentBlockhash} = await connection.getLatestBlockhash();

    const message = new TransactionMessage({
      payerKey: walletPublicKey,
      // Replace with your desired instructions
      instructions: [instruction],
      recentBlockhash
    });

    const yourSolanaTransaction = new VersionedTransaction(message.compileToV0Message());

    // Get the signed transaction object from the response
    const {signedTransaction} = await privy.wallets().solana().signTransaction(wallet.id, {
      transaction: Buffer.from(yourSolanaTransaction.serialize()).toString('base64')
    });
    ```

    ### Parameters and Returns

    Check out the [API reference](/api-reference/wallets/solana/sign-transaction) for more details.
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    Use the `signTransaction` method on the Solana client to sign a transaction with an Solana wallet.

    ```js  theme={"system"}
    signTransaction: (input: SolanaSignTransactionInputType) => Promise<SolanaSignTransactionResponseType>
    ```

    ### Usage

    ```js  theme={"system"}
    import {
      clusterApiUrl,
      Connection,
      LAMPORTS_PER_SOL,
      PublicKey,
      SystemProgram,
      Transaction,
      VersionedTransaction,
      TransactionMessage
    } from '@solana/web3.js';

    const walletPublicKey = new PublicKey(wallet.address);
    const connection = new Connection(clusterApiUrl('devnet'));
    const instruction = SystemProgram.transfer({
      fromPubkey: walletPublicKey,
      toPubkey: new PublicKey(address),
      lamports: value * LAMPORTS_PER_SOL
    });

    const {blockhash: recentBlockhash} = await connection.getLatestBlockhash();

    const message = new TransactionMessage({
      payerKey: walletPublicKey,
      // Replace with your desired instructions
      instructions: [instruction],
      recentBlockhash
    });

    const yourSolanaTransaction = new VersionedTransaction(message.compileToV0Message());

    // Get the signed transaction object from the response
    const {signedTransaction} = await privy.walletApi.solana.signTransaction({
      walletId: wallet.id,
      transaction: yourSolanaTransaction
    });
    ```

    ### Parameters

    <ParamField path="walletId" type="string" required>
      The ID of the wallet to send the transaction from.
    </ParamField>

    <ParamField path="transaction" type="Transaction | VersionedTransaction" required>
      The transaction to sign. This can be either a legacy Transaction or a VersionedTransaction object from [@solana/web3.js](https://solana-foundation.github.io/solana-web3.js/classes/Transaction.html).
    </ParamField>

    ### Returns

    <ResponseField name="signedTransaction" type="string">
      The signed transaction.
    </ResponseField>

    <ResponseField name="encoding" type="'base64'">
      The encoding format for the returned `signedTransaction`. Currently, only `'base64'` is supported for Solana.
    </ResponseField>
  </Tab>

  <Tab title="Java">
    To sign a transaction from your wallet, use the `signTransaction` method.
    It will sign your transaction, and return the signed transaction to you.

    ### Usage

    ```java  theme={"system"}
    try {
        // A base64 encoded serialized transaction to sign
        String transaction = "insert-base-64-encoded-serialized-transaction";

        // Example: If wallet's owner is an authorization private key
        AuthorizationContext authorizationContext = AuthorizationContext.builder()
            .addAuthorizationPrivateKey("authorization-key")
            .build();

        SolanaSignTransactionRpcResponseData response = privyClient.wallets().solana()
            .signTransaction(
                transaction,
                authorizationContext
            );

        String signedTransaction = response.signedTransaction();
    } catch (APIException e) {
        String errorBody = e.bodyAsString();
        System.err.println(errorBody);
    } catch (Exception e) {
        System.err.println(e.getMessage());
    }
    ```

    ### Parameters

    <ParamField type="String" body="transaction">
      A base64 encoded serialized transaction to sign.
    </ParamField>

    ### Returns

    The `SolanaSignTransactionRpcResponseData` object contains the following fields:

    <ResponseField name="signedTransaction()" type="String">
      The signed transaction.
    </ResponseField>
  </Tab>

  <Tab title="Rust">
    Use the `sign_transaction` method on the Solana service to sign a transaction.

    ### Usage

    ```rust  theme={"system"}
    use privy_rs::{AuthorizationContext, PrivyClient};

    let client = PrivyClient::new("app_id".to_string(), "app_secret".to_string())?;
    let solana_service = client.wallets().solana();
    let auth_ctx = AuthorizationContext::new();

    // Base64-encoded Solana transaction (example)
    let transaction = "AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEDArczbMia1tLmq7zz4DinMNN0pJ1JtLdqIJPUw3YrGCzYAMHBsgN27lcgB6H2WQvFgyZuJYHa46puOQo9yQ8CVQbd9uHXZaGT2cvhRs7reawctIXtX1s3kTqM9YV+/wCp20C7Wj2aiuk5TReAXo+VTVg8QTHjs0UjNMMKCvpzZ+ABAgEBARU=";

    let signed_tx = solana_service.sign_transaction(
        &wallet_id,
        transaction,
        &auth_ctx,
        None
    ).await?;

    println!("Transaction signed successfully");
    ```

    <Tip>
      For transaction construction, you'll typically use the
      [@solana/web3.js](https://solana-foundation.github.io/solana-web3.js/) library or
      [solana\_sdk](https://docs.rs/solana-sdk/) to create your transaction, serialize it to base64, and
      then sign it with Privy.
    </Tip>

    ### Parameters and Returns

    See the Rust SDK documentation for detailed parameter and return types, including embedded examples:

    * [SolanaService::sign\_transaction](https://docs.rs/privy-rs/latest/privy_rs/solana/struct.SolanaService.html#method.sign_transaction)

    For REST API details, see the [API reference](/api-reference/wallets/solana/sign-transaction).
  </Tab>

  <Tab title="REST API">
    To sign a transaction make a `POST` request to

    ```bash  theme={"system"}
    https://api.privy.io/v1/wallets/<wallet_id>/rpc
    ```

    ### Usage

    ```bash  theme={"system"}
    $ curl --request POST https://api.privy.io/v1/wallets/<wallet_id>/rpc \
        -u "<your-privy-app-id>:<your-privy-app-secret>" \
        -H "privy-app-id: <your-privy-app-id>" \
        -H "privy-authorization-signature: <authorization-signature-for-request>" \
        -H 'Content-Type: application/json' \
        -d '{
            "method": "signTransaction",
            "params": {
            "transaction": "insert-base-64-encoded-serialized-transaction",
            "encoding": "base64"
            }
        }'
    ```

    A successful response will look like the following:

    ```json  theme={"system"}
    {
    "method": "signTransaction",
    "data": {
        "signed_transaction": "base64-encoded-serialized-signed-transaction",
        "encoding": "base64"
    }
    }
    ```

    ### Parameters

    <ParamField path="method" type="'signTransaction'" required>
      The RPC method executed with the wallet.
    </ParamField>

    <ParamField path="params" type="Object" required>
      <ParamField path="transaction" type="string" required>
        The transaction to sign with the wallet. If the transaction to sign is raw bytes,
        you must serialize the transaction as a base64 string.
      </ParamField>

      <ParamField path="encoding" type="'base64'" required>
        The encoding format for `transaction`. Currently, only `'base64'` is supported
        for Solana.
      </ParamField>
    </ParamField>

    ### Returns

    <ResponseField name="method" type="'signTransaction'">
      The RPC method executed with the wallet.
    </ResponseField>

    <ResponseField name="data.signed_transaction" type="string">
      The signed transaction.
    </ResponseField>

    <ResponseField name="data.encoding" type="'base64'">
      The encoding format for the signed transaction. Currently, only `'base64'` is supported for Ethereum.
    </ResponseField>
  </Tab>
</Tabs>


# Integrating with @solana/web3.js
Source: https://docs.privy.io/wallets/using-wallets/solana/web3-integrations



<Tabs>
  <Tab title="React">
    Privy's **`ConnectedStandardSolanaWallet`** object is fully compatible with popular web3 libraries for interfacing wallets, such as [`@solana/web3js`](https://solana-foundation.github.io/solana-web3.js/).

    Read below to learn how to best integrate Privy alongside @solana/web3.js.

    First find your desired wallet from the **`wallets`** array:

    ```tsx  theme={"system"}
    import {PublicKey, Transaction, Connection, SystemProgram} from '@solana/web3.js';

    const {wallets} = useWallets();
    const wallet = wallets[0]; // Replace this with your desired wallet
    ```

    Then, use this wallet to then send Transactions using the @solana/web3.js Transaction and Connection classes:

    ```tsx  theme={"system"}
    // Build out the transaction object for your desired program
    // https://solana-foundation.github.io/solana-web3.js/classes/Transaction.html
    let transaction = new Transaction();

    // Send transaction
    console.log(
      await wallet.signAndSendTransaction!({
        chain: 'solana:devnet',
        transaction: new Uint8Array(
          transaction.serialize({
            requireAllSignatures: false,
            verifySignatures: false
          })
        )
      })
    );
    ```
  </Tab>
</Tabs>


# UI components
Source: https://docs.privy.io/wallets/using-wallets/ui-components



<Tabs>
  <Tab title="React">
    Privy comes with out-of-the-box UIs for signing messages and sending transactions.

    These wallet UIs are highly-customizable, allowing your application to communicate relevant context to the user or abstract away the fact that a wallet is being used under the hood.

    ## Sign message

    Below is a sample message signature UI.

        <img src="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Sign.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=d53afa26ed87352a61dbf1477c651442" alt="images/Sign.png" data-og-width="1843" width="1843" data-og-height="1317" height="1317" data-path="images/Sign.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Sign.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=497faffb0e9a9258b154f378f58f78c9 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Sign.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=2d4124fdcd55dc74775cf1fe34d57d68 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Sign.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=efeaf7b5616dcfb09b7e242f95ae3464 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Sign.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=20725f037bed2e1e3af8777075499b35 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Sign.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=7782b79cdf3be5d27ca512d97d47b651 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Sign.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=80d47580bb562f983fbc67c495feb357 2500w" />

    This UI can also be customized by passing a `uiOptions` object of the following type to the  method.

    ### Parameters

    <ParamField path="showWalletUIs" type="boolean">
      Whether to overwrite the configured wallet UI for the signature prompt. Defaults to `undefined`,
      which will respect the server-side or SDK configured option.
    </ParamField>

    <ParamField path="title" type="string">
      The title text for the signature prompt. Defaults to 'Sign message'.
    </ParamField>

    <ParamField path="description" type="string">
      The description text for the signature prompt. Defaults to 'Signing this message will not cost you any fees.'.
    </ParamField>

    <ParamField path="buttonText" type="string">
      The description text for the signature prompt. Defaults to 'Sign and continue'.
    </ParamField>

    ## Send transaction

    Below is a sample transaction UI.

        <img src="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Trans.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=e8c2eaf51c49ab7d5bd0bb300a6153f2" alt="images/Trans.png" data-og-width="1843" width="1843" data-og-height="1317" height="1317" data-path="images/Trans.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Trans.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=333f835ff6c9ce7676f8007524f4a141 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Trans.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=b4826f5a99b9b1e2e2c767b44fa44ff9 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Trans.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=fb59575670b7c9eeb5e528d600e2567f 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Trans.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=17fb32cd9aa1de515b978169c9b89e6e 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Trans.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=e52dd4524b64aad926330b93a91efa0e 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/Trans.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=d484a4f66a2d6a770ac26c0081d6072d 2500w" />

    This UI can also be customized by passing a `uiOptions` object of the following type to the\
    method.

    ### Parameters

    <ParamField path="showWalletUIs" type="boolean">
      Whether or not to show wallet UIs for this action. Defaults to the wallet UI setting enabled for your app.
    </ParamField>

    <ParamField path="description" type="string">
      Description of the transaction being sent.
    </ParamField>

    <ParamField path="buttonText" type="string">
      Text to show on CTA button for Send Transaction screen. Defaults to 'Submit' or 'Approve'.
    </ParamField>

    <ParamField path="transactionInfo" type="Object">
      <Expandable defaultOpen="true">
        <ParamField path="title" type="string">
          Title for transaction details accordion.
        </ParamField>

        <ParamField path="action" type="string">
          Short action description (e.g., 'Buy NFT').
        </ParamField>

        <ParamField path="contractInfo" type="Object">
          <Expandable defaultOpen="true">
            <ParamField path="url" type="string">
              Smart contract information URL.
            </ParamField>

            <ParamField path="name" type="string">
              Smart contract name.
            </ParamField>

            <ParamField path="imgUrl" type="string">
              Contract image URL.
            </ParamField>

            <ParamField path="imgAltText" type="string">
              Alternative text for contract image.
            </ParamField>

            <ParamField path="imgSize" type="'sm' | 'lg'">
              Image size for contract ('sm' or 'lg').
            </ParamField>
          </Expandable>
        </ParamField>
      </Expandable>
    </ParamField>

    <ParamField path="successHeader" type="string">
      Text displayed at the top of the success screen. Defaults to 'Transaction complete!'.
    </ParamField>

    <ParamField path="successDescription" type="string">
      Description for the success screen. Defaults to 'You're all set.'.
    </ParamField>

    <ParamField path="isCancellable" type="boolean">
      Whether to display a cancel button on the confirmation screen.
    </ParamField>
  </Tab>

  <Tab title="React Native">
    When building an application using the React Native SDK, Privy gives you complete control over
    the experience and UI.

    If you do with to use Privy's default UIs for message signing or login, make sure you have
    [properly configured `PrivyElements`](/basics/react-native/advanced/setup-privyelements), and
    use the hooks exported from `@privy-io/expo/ui`, such as `useLogin`, `useSignMessage`, or
    `useFundWallet`.

    <Note>
      The React Native SDK does not yet support default UIs for signing typed data or sending
      transactions. Consumers of the SDK typically attach their own UIs to the Privy SDK methods for
      signing messages and sending transactions
    </Note>

    | Use case                | Hook                                 |
    | ----------------------- | ------------------------------------ |
    | Login users             | `useLogin`                           |
    | Sign message (Ethereum) | `useSignMessage`                     |
    | Sign message (Solana)   | `useSolanaSignMessage`               |
    | Fund wallets (Ethereum) | `useFundWallet`                      |
    | Fund wallets (Solana)   | `useFundSolanaWallet`                |
    | Enroll in MFA           | `useMfaEnrollmentUI`                 |
    | Verify MFA              | Set `enableMfaVerificationUIs: true` |
  </Tab>
</Tabs>


# Whitelabel
Source: https://docs.privy.io/wallets/using-wallets/whitelabel



Privy’s frontend SDKs let you fully customize embedded wallet experiences. Match wallet flows to your app’s look and feel.

* Use your own components and branding to customize wallet creation, signing, and transaction flows.
* Create seamless, one-click signature and transaction experiences by disabling modals entirely.

<Tabs>
  <Tab title="React">
    Privy enables developers to whitelabel embedded wallet functionality. You can abstract away wallet UIs entirely or selectively use Privy's default UI for specific flows.

    To whitelabel embedded wallets, you can configure this globally across your app in the `PrivyProvider` config, or selectively for specific flows at runtime.

    <Accordion title="Provider config (globally)">
      In your `PrivyProvider` config you can control the default wallet UI for all flows in your app.

      ```tsx {5} theme={"system"}
      <PrivyProvider
        appId={process.env.NEXT_PUBLIC_PRIVY_APP_ID || ''}
        config={{
          embeddedWallets: {
            showWalletUIs: false,
            priceDisplay: {primary: 'native-token', secondary: null}
          }
        }}
      >
        <YourApp />
      </PrivyProvider>
      ```

      For more granular control, you can also control wallet UIs for specific flows in the sections below.
    </Accordion>

    <Accordion title="Create a wallet" defaultOpen>
      Privy supports whitelabeling wallet creation for Ethereum, Solana, and other chains.

      <Tabs>
        <Tab title="Ethereum">
          ```tsx  theme={"system"}
          import {useCreateWallet} from '@privy-io/react-auth';
          ```

          ```tsx  theme={"system"}
          const {createWallet} = useCreateWallet();
          createWallet();
          ```
        </Tab>

        <Tab title="Solana">
          ```tsx  theme={"system"}
          import {useWallets} from '@privy-io/react-auth/solana';
          ```

          ```tsx  theme={"system"}
          const {createWallet} = useWallets();
          createWallet();
          ```
        </Tab>

        <Tab title="Other chains">
          ```tsx  theme={"system"}
          import {useCreateWallet} from '@privy-io/react-auth/extended-chains';
          ```

          ```tsx  theme={"system"}
          const {createWallet} = useCreateWallet();
          const {user, wallet} = await createWallet({chainType: 'cosmos'}); // or 'stellar', 'sui', etc.
          ```
        </Tab>
      </Tabs>
    </Accordion>

    <Accordion title="Signing a message">
      To whitelabel Privy's message signing functionality, use the `useSignMessage` hook and call `signMessage` with your desired message.

      <Tabs>
        <Tab title="Ethereum">
          ```tsx  theme={"system"}
          import {useSignMessage} from '@privy-io/react-auth';
          ```

          ```tsx  theme={"system"}
          const {signMessage} = useSignMessage();
          const signature = await signMessage(
            {message: 'Hello, world!'},
            {uiOptions: {showWalletUIs: false}}
          );
          ```
        </Tab>

        <Tab title="Solana">
          ```tsx  theme={"system"}
          import {useSignMessage} from '@privy-io/react-auth/solana';
          ```

          ```tsx  theme={"system"}
          const {signMessage} = useSignMessage();
          signMessage({
            message: 'messageinUint8Array',
            options: {uiOptions: {showWalletUIs: false}}
          });
          ```
        </Tab>

        <Tab title="Other chains">
          ```tsx  theme={"system"}
          import {useSignRawHash} from '@privy-io/react-auth/extended-chains';
          ```

          ```tsx  theme={"system"}
          const {signature} = await signRawHash({
            address: 'insert-wallet-address',
            chainType: 'cosmos', // or 'stellar', 'sui', etc.
            hash: '0x1acab030f479bda7829de07e9db4138cec5d38574df17d65af1617b7268541c0'
          });
          ```
        </Tab>
      </Tabs>
    </Accordion>

    <Accordion title="Sending a transaction">
      To whitelabel Privy's transaction sending functionality, use the `useSendTransaction` hook and call `sendTransaction` with your desired transaction.

      <Tabs>
        <Tab title="Ethereum">
          ```tsx  theme={"system"}
          import {useSendTransaction} from '@privy-io/react-auth';
          ```

          ```tsx  theme={"system"}
          const {sendTransaction} = useSendTransaction();
          sendTransaction(
            {
              to: '0xE3070d3e4309afA3bC9a6b057685743CF42da77C',
              value: 100000
            },
            {
              uiOptions: {showWalletUIs: false}
            }
          );
          ```
        </Tab>

        <Tab title="Solana">
          ```tsx  theme={"system"}
          import {useSendTransaction} from '@privy-io/react-auth/solana';
          ```

          ```tsx  theme={"system"}
          const {sendTransaction} = useSendTransaction();
          sendTransaction({
            transaction: 'insert-solana-transaction',
            uiOptions: {showWalletUIs: false}
          });
          ```
        </Tab>
      </Tabs>
    </Accordion>
  </Tab>

  <Tab title="React Native">
    Privy’s React Native SDK is whitelabel by default, enabling apps to implement custom authentication UI and flows using the SDK’s functions. Get started with `sendTransaction` [here](/wallets/using-wallets/ethereum/send-a-transaction#react-native).
  </Tab>

  <Tab title="Swift">
    Privy’s Swift SDK is whitelabel by default, enabling apps to implement custom wallet UI and flows using the SDK’s functions. Get started with sending a transaction [here](/wallets/using-wallets/ethereum/send-a-transaction#swift).
  </Tab>

  <Tab title="Android">
    Privy’s Android SDK is whitelabel by default, enabling apps to implement custom wallet UI and flows using the SDK’s functions. Get started with sending a transaction [here](/wallets/using-wallets/ethereum/send-a-transaction#android).
  </Tab>

  <Tab title="Flutter">
    Privy’s Flutter SDK is whitelabel by default, enabling apps to implement custom wallet UI and flows using the SDK’s functions. Get started with sending a transaction [here](/wallets/using-wallets/ethereum/send-a-transaction#flutter).
  </Tab>

  <Tab title="Unity">
    Privy’s Unity SDK is whitelabel by default, enabling apps to implement custom wallet UI and flows using the SDK’s functions. Get started with sending a transaction [here](/wallets/using-wallets/ethereum/send-a-transaction#unity).
  </Tab>
</Tabs>


# Create a wallet
Source: https://docs.privy.io/wallets/wallets/create/create-a-wallet



Privy enables you to programmatically create wallets embedded within your application. When you create a wallet, you can specify its `owner`, which defines who controls the wallet.

* To create a user wallet, specify a **user ID** as an owner of the wallet. This ensures only the authenticated user has access to their wallet. All client-side SDKs create user wallets by default and automatically set the wallet owner as the authenticated user.
* Or, you can specify an **authorization key** as an `owner` on a wallet. The holder of the authorization key, typically your application backend, controls the wallet. You must use a server-side SDK to create wallets owned by an authorization key.

<Tabs>
  <Tab title="React">
    <Tip>
      The React SDK supports automatically creating embedded wallets for your users when they log in to your app. View [this guide](/basics/react/advanced/automatic-wallet-creation) to learn more and configure automatic wallet creation.
    </Tip>

    <Tabs>
      <Tab title="Ethereum">
        To create a wallet with the React SDK, use the `createWallet` method from the `useCreateWallet` hook:

        ```tsx  theme={"system"}
        createWallet: async ({createAdditional?: boolean}) => Promise<Wallet>
        ```

        ### Usage

        ```tsx  theme={"system"}
        import {useCreateWallet} from '@privy-io/react-auth';
        const {createWallet} = useCreateWallet();
        ```

        ### Parameters

        <ParamField path="opts.createAdditional" type="boolean">
          Whether or not to create an additional Ethereum wallet for the user if they already have an existing Ethereum embedded wallet. Must be set to `true` to create additional wallets. Defaults to `false`. [Learn more](/recipes/hd-wallets)
        </ParamField>

        ### Returns

        <ResponseField name="wallet" type="Promise<Wallet>">
          A `Promise` for the linked account object for the created wallet.
        </ResponseField>

        ### Callbacks

        You can optionally register an `onSuccess` or `onError` callback on the `useCreateWallet` hook.

        ```tsx  theme={"system"}
        const {createWallet} = useCreateWallet({
            onSuccess: ({wallet}) => {
                console.log('Created wallet ', wallet);
            },
            onError: (error) => {
                console.error('Failed to create wallet with error ', e)
            }
        })
        ```

        <ParamField path="onSuccess" type="({wallet: Wallet}) => void">
          Optional callback to run after a user successfully creates a wallet.
        </ParamField>

        <ParamField path="onError" type="(error: string) => void">
          Optional callback to run after there is an error during wallet creation.
        </ParamField>
      </Tab>

      <Tab title="Solana">
        To create a wallet with the React SDK, use the `createWallet` method from the `useCreateWallet` hook:

        ```tsx  theme={"system"}
        createWallet: async ({createAdditional?: boolean}) => Promise<Wallet>
        ```

        ### Usage

        ```tsx  theme={"system"}
        import {useCreateWallet} from '@privy-io/react-auth/solana';
        const {createWallet} = useCreateWallet();
        ```

        ### Parameters

        The `createWallet` method optionally accepts as a parameter an `opts` object with the following fields:

        <ParamField path="opts.createAdditional" type="boolean">
          Whether or not to create an additional Solana wallet for the user if they already have an existing Solana embedded wallet. Must be set to `true` to create additional wallets. Defaults to `false`. [Learn more](/recipes/hd-wallets)
        </ParamField>

        ### Returns

        <ResponseField name="wallet" type="Wallet">
          The linked account object for the created wallet.
        </ResponseField>
      </Tab>

      <Tab title="Other chains">
        To create a wallet in any of the chains supported at the [Tier 2 level](/wallets/overview/chains)
        with the React SDK, use the `createWallet` method from the `useCreateWallet` hook,
        imported from `@privy-io/react-auth/extended-chains`:

        ```tsx  theme={"system"}
        createWallet: async ({chainType: ExtendedChainType}) => Promise<{user: User; wallet: Wallet}>
        ```

        ### Usage

        ```tsx  theme={"system"}
        import {useCreateWallet} from '@privy-io/react-auth/extended-chains';
        const {createWallet} = useCreateWallet();

        const {user, wallet} = await createWallet({chainType: 'cosmos'}); // or 'stellar', 'sui', etc.
        ```

        ### Parameters

        <ParamField path="opts.chainType" type="ExtendedChainType">
          The chain type of the wallet to create. This could be any of the chains supported at the [Tier 2 level](/wallets/overview/chains).
        </ParamField>

        ### Returns

        <ResponseField path="output" type="Promise<{user: User; wallet: Wallet}>">
          <Expandable title="child properties" defaultOpen="true">
            <ResponseField name="user" type="User">
              The updated user object with the new wallet added to the user's `linkedAccounts` array.
            </ResponseField>

            <ResponseField name="wallet" type="Wallet">
              The newly created wallet.
            </ResponseField>
          </Expandable>
        </ResponseField>
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="React Native">
    <Tip>
      The React Native SDK supports automatically creating embedded wallets for your users when they log in to your app. View [this guide](/basics/react/advanced/automatic-wallet-creation) to learn more and configure automatic wallet creation.
    </Tip>

    <Tabs>
      <Tab title="Ethereum">
        To create a wallet with the React Native SDK, use the `create` method from the `useEmbeddedEthereumWallet` hook:

        ```tsx  theme={"system"}
        create: async ({createAdditional?: boolean}) => Promise<{user: User}>
        ```

        ### Usage

        ```tsx  theme={"system"}
        import {useEmbeddedEthereumWallet} from '@privy-io/expo';
        const {create} = useEmbeddedEthereumWallet();
        ```

        ### Parameters

        The `create` method optionally accepts as a parameter an `opts` object with the following fields:

        <ParamField path="opts.createAdditional" type="boolean">
          Whether or not to create an additional Ethereum wallet for the user if they already have an existing Ethereum embedded wallet. Must be set to `true` to create additional wallets. Defaults to `false`. [Learn more](/recipes/hd-wallets)
        </ParamField>

        ### Returns

        <ResponseField name="user" type="Promise<{user: User}>">
          A `Promise` for an object containing the updated `user` object for the user.
        </ResponseField>
      </Tab>

      <Tab title="Solana">
        To create a wallet with the React Native SDK, use the `create` method from the `useEmbeddedSolanaWallet` hook:

        ```tsx  theme={"system"}
        create: async ({createAdditional?: boolean}) => Promise<{user: User}>
        ```

        ### Usage

        ```tsx  theme={"system"}
        import {useEmbeddedSolanaWallet} from '@privy-io/expo';
        const {create} = useEmbeddedSolanaWallet();
        ```

        ### Parameters

        The `create` method optionally accepts as a parameter an `opts` object with the following fields:

        <ParamField path="opts.createAdditional" type="boolean">
          Whether or not to create an additional Solana wallet for the user if they already have an existing Solana embedded wallet. Must be set to `true` to create additional wallets. Defaults to `false`. [Learn more](/recipes/hd-wallets)
        </ParamField>

        ### Returns

        <ResponseField name="user" type="Promise<{user: User}>">
          A `Promise` for an object containing the updated `user` object.
        </ResponseField>
      </Tab>

      <Tab title="Other chains">
        To create a wallet in any of the chains supported at the [Tier 2 level](/wallets/overview/chains)
        with the React Native SDK, use the `createWallet` method from the `useCreateWallet` hook,
        imported from `@privy-io/expo/extended-chains`:

        ```tsx  theme={"system"}
        createWallet: async ({chainType: ExtendedChainType}) => Promise<{user: PrivyUser; wallet: Wallet}>
        ```

        ### Usage

        ```tsx  theme={"system"}
        import {useCreateWallet} from '@privy-io/expo/extended-chains';
        const {createWallet} = useCreateWallet();

        const {user, wallet} = await createWallet({chainType: 'cosmos'}); // or 'stellar', 'sui', etc.
        ```

        ### Parameters

        <ParamField path="opts.chainType" type="ExtendedChainType">
          The chain type of the wallet to create. This could be any of the chains supported at the [Tier 2 level](/wallets/overview/chains).
        </ParamField>

        ### Returns

        <ResponseField path="output" type="Promise<{user: PrivyUser; wallet: Wallet}>">
          <Expandable title="child properties" defaultOpen="true">
            <ResponseField name="user" type="PrivyUser">
              The updated user object with the new wallet added to the user's `linked_accounts` array.
            </ResponseField>

            <ResponseField name="wallet" type="Wallet">
              The newly created wallet.
            </ResponseField>
          </Expandable>
        </ResponseField>
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Swift">
    <Tabs>
      <Tab title="Ethereum">
        To create a wallet with the Swift SDK, use the `createEthereumWallet` method from the `PrivyUser` instance:

        ```swift  theme={"system"}
        func createEthereumWallet(allowAdditional: Bool) async throws -> EmbeddedEthereumWallet
        ```

        ### Parameters

        The `createEthereumWallet` method optionally accepts the following parameters:

        <ParamField path="allowAdditional" type="Boolean">
          Whether or not to create an additional Ethereum wallet for the user if they already have an existing Ethereum embedded wallet. Must be set to `true` to create additional wallets. Defaults to `false`.
        </ParamField>

        ### Returns

        <ResponseField name="wallet" type="EmbeddedEthereumWallet">
          The newly created `EmbeddedEthereumWallet`.
        </ResponseField>
      </Tab>

      <Tab title="Solana">
        To create a wallet with the Swift SDK, use the `createSolanaWallet` method from the `PrivyUser` instance:

        ```swift  theme={"system"}
        func createSolanaWallet() async throws -> EmbeddedSolanaWallet
        ```

        ### Returns

        <ResponseField name="wallet" type="EmbeddedSolanaWallet">
          The newly created `EmbeddedSolanaWallet`.
        </ResponseField>
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Android">
    <Tabs>
      <Tab title="Ethereum">
        To create a wallet with the Android SDK, use the `createEthereumWallet` method from the `PrivyUser` instance:

        ```kotlin  theme={"system"}
        public suspend fun createEthereumWallet: (allowAdditional?: Boolean) => Result<EmbeddedEthereumWallet>
        ```

        ### Parameters

        The `createEthereumWallet` method optionally accepts the following parameters:

        <ParamField path="allowAdditional" type="Boolean">
          Whether or not to create an additional Ethereum wallet for the user if they already have an existing Ethereum embedded wallet. Must be set to `true` to create additional wallets. Defaults to `false`.
        </ParamField>

        ### Returns

        <ResponseField name="wallet" type="Result<EmbeddedEthereumWallet>">
          A `Result` containing the `EmbeddedEthereumWallet` for the user.
        </ResponseField>
      </Tab>

      <Tab title="Solana">
        To create a wallet with the Android SDK, use the `createSolanaWallet` method from the `PrivyUser` instance:

        ```kotlin  theme={"system"}
        public suspend fun createEthereumWallet: (allowAdditional?: Boolean) => Result<EmbeddedSolanaWallet>
        ```

        ### Returns

        <ResponseField name="wallet" type="Result<EmbeddedSolanaWallet>">
          A `Result` containing the `EmbeddedSolanaWallet` for the user.
        </ResponseField>
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Unity">
    <Tabs>
      <Tab title="Ethereum">
        To create a wallet with the Unity SDK, use the `CreateWallet` method on your `PrivyUser` instance:

        ```csharp  theme={"system"}
        Task<IEmbeddedEthereumWallet> CreateWallet(bool allowAdditional)
        ```

        ### Parameters

        The `CreateWallet` method accepts the following parameter:

        <ParamField path="allowAdditional" type="Boolean">
          Whether or not to create an additional wallet for the user if they already have an existing ethereum wallet.
          Must be set to `true` to create additional wallets.
          Defaults to `false`.
        </ParamField>

        ### Returns

        <ResponseField name="wallet" type="Task<IEmbeddedEthereumWallet>">
          A `Task` for the created ethereum wallet object.
        </ResponseField>
      </Tab>

      <Tab title="Solana">
        To create a wallet with the Unity SDK, use the `CreateSolanaWallet` method on your `PrivyUser` instance:

        ```csharp  theme={"system"}
        Task<IEmbeddedSolanaWallet> CreateSolanaWallet(bool allowAdditional)
        ```

        ### Parameters

        The `CreateSolanaWallet` method accepts the following parameter:

        <ParamField path="allowAdditional" type="Boolean">
          Whether or not to create an additional wallet for the user if they already have an existing solana wallet.
          Must be set to `true` to create additional wallets.
          Defaults to `false`.
        </ParamField>

        ### Returns

        <ResponseField name="wallet" type="Task<IEmbeddedSolanaWallet>">
          A `Task` for the created solana wallet object.
        </ResponseField>
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Flutter">
    <Tabs>
      <Tab title="Ethereum">
        To create a wallet with the Flutter SDK, use the `createEthereumWallet` method from the `PrivyUser` instance:

        ```dart  theme={"system"}
        Future<Result<EmbeddedEthereumWallet>> createEthereumWallet({bool allowAdditional = false});
        ```

        ### Parameters

        The `createEthereumWallet` method optionally accepts as a parameter an `opts` object with the following fields:

        <ParamField path="allowAdditional" type="bool">
          Whether or not to create an additional Ethereum wallet for the user if they already have an existing Ethereum embedded wallet. Must be set to `true` to create additional wallets. Defaults to `false`.
        </ParamField>

        ### Returns

        <ResponseField name="wallet" type="Future<Result<EmbeddedEthereumWallet>>">
          A `Result` containing the `EmbeddedEthereumWallet` for the user.
        </ResponseField>
      </Tab>

      <Tab title="Solana">
        To create a wallet with the Android SDK, use the `createSolanaWallet` method from the `PrivyUser` instance:

        ```dart  theme={"system"}
        Future<Result<EmbeddedSolanaWallet>> createSolanaWallet()
        ```

        ### Parameters

        The `createSolanaWallet` method optionally accepts the following parameters:

        <ParamField path="allowAdditional" type="Boolean">
          Whether or not to create an additional Solana wallet for the user if they already have an existing Solana embedded wallet. Must be set to `true` to create additional wallets. Defaults to `false`.
        </ParamField>

        ### Returns

        <ResponseField name="wallet" type="Future<Result<EmbeddedSolanaWallet>>">
          A `Result` containing the `EmbeddedSolanaWallet` for the user.
        </ResponseField>
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="NodeJS">
    To create a new wallet with the NodeJS SDK, use the `create` method on the `wallets()` interface of the Privy client.

    <Info>
      If you are creating a user wallet, you must specify the user ID as the owner of the wallet. You can obtain a user ID by first [creating a user](/user-management/migrating-users-to-privy/create-or-import-a-user) before creating the wallet.

      Or, you can [create a user and wallet at the same time](/user-management/migrating-users-to-privy/create-or-import-a-user).
    </Info>

    ### Usage

    ```ts  theme={"system"}
    const {id, address, chain_type} = await privy.wallets().create({chain_type: 'ethereum', owner: {user_id: 'privy:did:xxxxx'}});
    ```

    ### Parameters and Returns

    Check out the [API reference](/api-reference/wallets/create) for more details.

    <Tip>
      Your app can provision a smart account with the wallet as a signer by following [this guide](/wallets/gas-and-asset-management/gas/ethereum).
    </Tip>
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    To create a new wallet with the NodeJS SDK, use the `createWallet` method from the Privy client's `walletApi` class:

    ```ts  theme={"system"}
    createWallet: (input: WalletApiCreateRequestType) => Promise<WalletApiCreateResponseType>
    ```

    <Info>
      If you are creating a user wallet, you must specify the user ID as the owner of the wallet. You can obtain a user ID by first [creating a user](/user-management/migrating-users-to-privy/create-or-import-a-user) before creating the wallet.

      Or, you can [create a user and wallet at the same time](/user-management/migrating-users-to-privy/create-or-import-a-user).
    </Info>

    ### Usage

    ```ts  theme={"system"}
    const {id, address, chainType} = await privy.walletApi.createWallet({chainType: 'ethereum', owner: {userId: 'privy:did:xxxxx'}});
    ```

    ### Parameters

    The `createWallet` method accepts as a parameter an `input` object with the following fields:

    <ParamField type="'ethereum' | 'solana' | 'stellar' | 'cosmos' | 'sui' | 'tron' | 'bitcoin-segwit' | 'near' | 'ton' | 'starknet' | 'aptos'" path="chainType" required>
      Chain type of the wallet to create.
    </ParamField>

    <ParamField type="{'userId': string} | {'publicKey': string}" path="owner">
      The user ID to set as the owner of the wallet, or the P-256 public key to set as the owner of the wallet.

      If you provide this, do not specify an `ownerId` as it will be generated automatically.

      View [this guide](/controls/authorization-keys/owners/overview) to learn more about owners.
    </ParamField>

    <ParamField type="string" path="ownerId">
      The key quorum ID of the owner of the wallet. If you provide this, do not specify an `owner`.

      View [this guide](/controls/authorization-keys/owners/overview) to learn more about owners.
    </ParamField>

    <ParamField type="string[]" path="policyIds">
      List of policy IDs for policies that should be enforced on the wallet. Currently, only one policy is supported per wallet.
    </ParamField>

    <ParamField type="string" path="idempotencyKey">
      [Idempotency key](/api-reference/idempotency-keys) to identify a unique request.
    </ParamField>

    <ParamField type="{'signerId': string}[]" path="additionalSigners">
      List of key quorum IDs that should be allowed to approve transactions for the wallet.
    </ParamField>

    ### Returns

    <ResponseField type="string" name="id">
      Unique ID of the created wallet. This will be the primary identifier when using the wallet in the future.
    </ResponseField>

    <ResponseField type="string" name="address">
      Address of the created wallet.
    </ResponseField>

    <ResponseField type="'ethereum' | 'solana' | 'stellar' | 'cosmos' | 'sui' | 'tron' | 'bitcoin-segwit' | 'near' | 'ton' | 'starknet' | 'aptos'" name="chainType">
      Chain type of the created wallet.
    </ResponseField>

    <ResponseField type="string[]" name="policyIds">
      List of policy IDs for policies that are enforced on the wallet.
    </ResponseField>

    <ResponseField type="string | null" name="ownerId">
      The key quorum ID of the owner of the wallet. If an `ownerId` was passed in, this response is the input `ownerId`. If a user ID or authorization key was passed in as the `owner`, this response is a newly created key quorum containing the input user ID or authorization key.
    </ResponseField>

    <ResponseField type="{signerId: string}[]" name="additionalSigners">
      The key quorum IDs of the additional signers for the wallet.
    </ResponseField>

    <Tip>
      Your app can provision a smart account with the wallet as a signer by following [this guide](/wallets/gas-and-asset-management/gas/ethereum).
    </Tip>
  </Tab>

  <Tab title="Java">
    To create a new wallet with the Java SDK, use the `create` method from the Privy client's `wallets()` helper:

    ### Usage

    ```java  theme={"system"}
    try {
        // Example 1: Create an ethereum wallet with no owner
        WalletCreateRequestBody walletRequest1 = WalletCreateRequestBody.builder()
            .chainType(WalletChainType.ETHEREUM)
            .build();

        // Example 2: Create an ethereum wallet with a user owner
        WalletCreateRequestBody walletRequest2 = WalletCreateRequestBody.builder()
            .chainType(WalletChainType.ETHEREUM)
            .owner(OwnerInput.of(UserOwner.builder().userId("privy-user-id").build()))
            .build();

        // Example 3: Create an ethereum wallet with a public key owner
        WalletCreateRequestBody walletRequest3 = WalletCreateRequestBody.builder()
            .chainType(WalletChainType.ETHEREUM)
            .owner(OwnerInput.of(PublicKeyOwner.builder().publicKey("authorization-key").build()))
            .build();

        // Example 4: Create an ethereum wallet with a key quorum owner
        WalletCreateRequestBody walletRequest4 = WalletCreateRequestBody.builder()
            .chainType(WalletChainType.ETHEREUM)
            .ownerId("key-quorum-id")
            .build();

        WalletCreateResponse response = privyClient.wallets()
            .create(walletRequest1); // or walletRequest2, walletRequest3, or walletRequest4

        if (response.wallet().isPresent()) {
            Wallet createdWallet = response.wallet().get();
        }
    } catch (APIException e) {
        String errorBody = e.bodyAsString();
        System.err.println(errorBody);
    } catch (Exception e) {
        System.err.println(e.getMessage());
    }
    ```

    ### Parameters

    When creating a wallet, you may specify the following values on the `WalletCreateRequestBody`:

    <ParamField body="chainType" type="String" required>
      The chain to create the wallet on.
    </ParamField>

    <ParamField body="policyIds" type="List<String>">
      List of policy IDs for policies that should be enforced on the wallet. Currently, only one policy
      is supported per wallet.
    </ParamField>

    <ParamField body="owner" type="OwnerInput">
      The owner of the resource, which can either be a public key from a p256 keypair, or a user ID. If
      you provide this, do not specify an `ownerId` as it will be generated automatically.
    </ParamField>

    <ParamField body="ownerId" type="String">
      The key quorum ID to set as the owner of the resource. If you provide this, do not specify
      an`owner`.
    </ParamField>

    <ParamField body="additionalSigners" type="WalletAdditionalSigner">
      Additional signers for the wallet.
    </ParamField>

    ### Returns

    The `WalletCreateResponse` object contains an optional `wallet()` field, present if the
    wallet was created successfully.

    <ResponseField name="wallet()" type="Optional<Wallet>">
      The newly created `Wallet` object.

      <Expandable defaultOpen="true">
        <ResponseField type="String" name="id">
          Unique ID of the created wallet. This will be the primary identifier when using the wallet in the future.
        </ResponseField>

        <ResponseField type="String" name="address">
          Address of the created wallet.
        </ResponseField>

        <ResponseField type="WalletChainType" name="chainType">
          Chain type of the created wallet.
        </ResponseField>

        <ResponseField type="List<String>" name="policyIds">
          List of policy IDs for policies that are enforced on the wallet.
        </ResponseField>

        <ResponseField type="String" name="ownerId">
          The key quorum ID of the owner of the wallet. If an `ownerId` was passed in, this response is the input `ownerId`. If a user ID or authorization key was passed in as the `owner`, this response is a newly created key quorum containing the input user ID or authorization key.
        </ResponseField>

        <ResponseField type="List<WalletAdditionalSigner>" name="additionalSigners">
          The key quorum IDs of the additional signers for the wallet.
        </ResponseField>

        <ResponseField type="double" name="createdAt">
          The creation date of the wallet, as Unix time.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="REST API">
    To create a new wallet for a user, make a `POST` request to

    ```bash  theme={"system"}
    https://api.privy.io/v1/wallets
    ```

    <Info>
      If you are creating a user wallet, you must specify the user ID as the owner of the wallet. You can obtain a user ID by first [creating a user](/user-management/migrating-users-to-privy/create-or-import-a-user) before creating the wallet.

      Or, you can [create a user and wallet at the same time](/user-management/migrating-users-to-privy/create-or-import-a-user).
    </Info>

    ### Body

    In the request body, include the following fields.

    <ParamField type="'ethereum' | 'solana' | 'stellar' | 'cosmos' | 'sui' | 'tron' | 'bitcoin-segwit' | 'near' | 'ton' | 'starknet' | 'aptos'" path="chain_type" required>
      Chain type of the wallet to create.
    </ParamField>

    <ParamField type="{user_id: string} | {public_key: string} | null" path="owner">
      The user ID to set as the owner of the wallet, or the P-256 public key to set as the owner of the wallet.

      If you provide this, do not specify an `owner_id` as it will be generated automatically.

      View [this guide](/controls/authorization-keys/owners/overview) to learn more about owners.
    </ParamField>

    <ParamField type="string | null" path="owner_id">
      The key quorum ID of the owner of the wallet. If you provide this, do not specify an `owner`.

      View [this guide](/controls/authorization-keys/owners/overview) to learn more about owners.
    </ParamField>

    <ParamField type="string[]" path="policy_ids">
      List of policy IDs for policies that should be enforced on the wallet. Currently, only one policy is supported per wallet.
    </ParamField>

    <ParamField type="string" path="idempotency_key">
      [Idempotency key](/api-reference/idempotency-keys) to identify a unique request.
    </ParamField>

    <ParamField type="{signer_id: string}[]" path="additional_signers">
      The key quorum IDs to add as additional signers for the wallet.
    </ParamField>

    ### Response

    In the response, Privy will send back the following if successful:

    <ResponseField type="string" name="id">
      Unique ID of the created wallet. This will be the primary identifier when using the wallet in the future.
    </ResponseField>

    <ResponseField type="string" name="address">
      Address of the created wallet.
    </ResponseField>

    <ResponseField type="'ethereum' | 'solana' | 'stellar' | 'cosmos' | 'sui' | 'tron' | 'bitcoin-segwit' | 'near' | 'ton' | 'starknet' | 'aptos'" name="chain_type">
      Chain type of the created wallet.
    </ResponseField>

    <ResponseField type="string[]" name="policy_ids">
      List of policy IDs for policies that are enforced on the wallet.
    </ResponseField>

    <ResponseField type="string | null" name="owner_id">
      The key quorum ID of the owner of the wallet. If an `ownerId` was passed in, this response is the input `ownerId`. If a user ID or authorization key was passed in as the `owner`, this response is a newly created key quorum containing the input user ID or authorization key.
    </ResponseField>

    <ResponseField type="{signer_id: string}[]" name="additional_signers">
      The key quorum IDs of the additional signers for the wallet.
    </ResponseField>

    <ResponseField name="created_at" type="number">
      The creation date of the wallet, in milliseconds since midnight, January 1, 1970 UTC.
    </ResponseField>

    ### Example

    A sample request might look like the following:

    ```bash  theme={"system"}
    curl --request POST https://api.privy.io/v1/wallets \
        -u "<your-privy-app-id>:<your-privy-app-secret>" \
        -H "privy-app-id: <your-privy-app-id>" \
        -H 'Content-Type: application/json' \
        -d '{
        "owner": {
            "user_id": "did:privy:xxxxxx"
        },
        "chain_type": "ethereum"
        }'
    ```

    A successful response will look like the following:

    ```json  theme={"system"}
    {
        "id": "fmfdj6yqly31huorjqzq38zc",
        "address": "0xf9f284C7Eaf97b0f9B5542d83Af7F785D12E803a",
        "chain_type": "ethereum",
        "policy_ids": [],
        "owner_id": null,
        "additional_signers": [],
        "created_at": 1733923425155
    }
    ```
  </Tab>

  <Tab title="Rust">
    To create a new wallet with the Rust SDK, use the `create` method on the `wallets()` interface of the Privy client.

    <Info>
      If you are creating a user wallet, you must specify the user ID as the owner of the wallet. You can obtain a user ID by first [creating a user](/user-management/migrating-users-to-privy/create-or-import-a-user) before creating the wallet.

      Or, you can [create a user and wallet at the same time](/user-management/migrating-users-to-privy/create-or-import-a-user).
    </Info>

    ### Usage

    ```rust  theme={"system"}
    use privy_rs::{PrivyClient, generated::types::*};

    let client = PrivyClient::new(app_id, app_secret)?;

    // Create an Ethereum wallet with a user owner
    let wallet = client
        .wallets()
        .create(
            None, // idempotency key (optional)
            &CreateWalletBody {
                chain_type: WalletChainType::Ethereum,
                owner: Some(Owner::UserOwner(UserOwner {
                    user_id: "did:privy:xxxxx".to_string(),
                })),
                policy_ids: vec![],
                additional_signers: vec![],
            },
        )
        .await?;

    println!("Created wallet {} with address {}", wallet.id, wallet.address);
    ```

    ### Parameters and Returns

    See the Rust SDK documentation for detailed parameter and return types, including embedded examples:

    * [WalletsClient::create](https://docs.rs/privy-rs/latest/privy_rs/subclients/struct.WalletsClient.html#method.create)
    * [CreateWalletBody](https://docs.rs/privy-rs/latest/privy_rs/generated/types/struct.CreateWalletBody.html)
    * [Wallet](https://docs.rs/privy-rs/latest/privy_rs/generated/types/struct.Wallet.html)

    For REST API details, see the [API reference](/api-reference/wallets/create).

    <Tip>
      Your app can provision a smart account with the wallet as a signer by following [this guide](/wallets/gas-and-asset-management/gas/ethereum).
    </Tip>
  </Tab>
</Tabs>


# Export a wallet
Source: https://docs.privy.io/wallets/wallets/export



**Privy enables your users to export the private key for their embedded wallet**. This allows them to use their embedded wallet address with another wallet client, such as MetaMask or Phantom.

## Availability

Key export is only available in certain environments depending on how the wallet was created, due to the characteristics of the wallet ownership model.

<Expandable title="environments where key export is available.">
  The environments where key export is available depends on the environment where the wallet was created.

  ### Wallets created client-side

  Wallets created client-side (e.g. through Privy's React, React Native, Swift, etc. SDKs) can only be exported via the `exportWallet` method in the React SDK.

  Due to the sensitive nature of key export, it is only available in web environments where the operation can be secured with strict browser security guarantees.

  If you'd like to enable key export with one of Privy's other client-side SDKs, we encourage setting up a minimal web page with Privy's React SDK and export wallet functionality that you can direct users to.

  ### Wallets created server-side

  Wallets created server-side can only be exported via Privy's server-side SDKs or REST API. This ensures that wallets are securely exported in an encrypted interaction between your app's and Privy's infrastructure.
</Expandable>

## Usage

<Tabs>
  <Tab title="React">
    To have your user export their embedded wallet's private key, **use Privy's `exportWallet` method:**

    <Tabs>
      <Tab title="EVM">
        ```tsx  theme={"system"}
        import {usePrivy} from '@privy-io/react-auth';
        ...
        const {exportWallet} = usePrivy();
        ```
      </Tab>

      <Tab title="Solana">
        ```tsx  theme={"system"}
        import {useExportWallet} from '@privy-io/react-auth/solana';
        ...
        const {exportWallet} = useExportWallet();
        ```
      </Tab>
    </Tabs>

    When invoked, **`exportWallet`** will open a modal where your user can copy the full private key for their embedded wallet. The modal will also link your user to [a guide](https://privy-io.notion.site/Transferring-Your-App-Account-9dab9e16c6034a7ab1ff7fa479b02828) for how to load their embedded wallet into another wallet client, such as MetaMask or Phantom.

    If your user is not **`authenticated`** or has not yet created an embedded wallet in your app, this method will fail.

    As an example, you might attach **`exportWallet`** to an export wallet button in your app:

    <Tabs>
      <Tab title="EVM">
        ```tsx  theme={"system"}
        import {usePrivy} from '@privy-io/react-auth';

        function ExportWalletButton() {
          const {ready, authenticated, user, exportWallet} = usePrivy();
          // Check that your user is authenticated
          const isAuthenticated = ready && authenticated;
          // Check that your user has an embedded wallet
          const hasEmbeddedWallet = !!user.linkedAccounts.find(
            (account) =>
              account.type === 'wallet' &&
              account.walletClientType === 'privy' &&
              account.chainType === 'ethereum'
          );

          return (
            <button onClick={exportWallet} disabled={!isAuthenticated || !hasEmbeddedWallet}>
              Export my wallet
            </button>
          );
        }
        ```
      </Tab>

      <Tab title="Solana">
        ```tsx  theme={"system"}
        import {usePrivy, type WalletWithMetadata} from '@privy-io/react-auth';
        import {useExportWallet} from '@privy-io/react-auth/solana';

        function ExportWalletButton() {
          const {ready, authenticated, user} = usePrivy();
          const {exportWallet} = useExportWallet();
          // Check that your user is authenticated
          const isAuthenticated = ready && authenticated;
          // Check that your user has an embedded wallet
          const hasEmbeddedWallet = !!user.linkedAccounts.find(
            (account): account is WalletWithMetadata =>
              account.type === 'wallet' &&
              account.walletClientType === 'privy' &&
              account.chainType === 'solana'
          );

          return (
            <button onClick={exportWallet} disabled={!isAuthenticated || !hasEmbeddedWallet}>
              Export my wallet
            </button>
          );
        }
        ```
      </Tab>
    </Tabs>

    <Info>
      If your application uses [smart wallets](/wallets/using-wallets/evm-smart-wallets/overview) on EVM
      networks, exporting the wallet will export the private key for the **smart wallet's signer**, and
      not the smart wallet itself. Users can control their smart wallet via this private key, but will
      be required to manually use it to sign calls to the contract for their smart wallet directly to
      use the smart wallet outside of your app.
    </Info>

    ### Exporting HD wallets

    If your user has multiple embedded wallets, you can export the private key for a specific wallet by passing the address of your desired wallet as an `address` parameter to the `exportWallet` method:

    <Tabs>
      <Tab title="EVM">
        ```tsx  theme={"system"}
        import {exportWallet} from '@privy-io/react-auth';
        ...
        const {exportWallet} = usePrivy();
        await exportWallet({address: 'insert-your-desired-address'});
        ```
      </Tab>

      <Tab title="Solana">
        ```tsx  theme={"system"}
        import {useExportWallet} from '@privy-io/react-auth/solana';
        ...
        const {exportWallet} = useExportWallet();
        await exportWallet({address: 'insert-your-desired-address'});
        ```

        If no `address` is passed to `exportWallet`, Privy will default to exporting the wallet at `walletIndex: 0`.
      </Tab>
    </Tabs>

    <Info>
      When your user exports their embedded wallet, their private key is assembled on a different origin
      than your app's origin. This means neither you nor Privy can ever access your user's private key.{' '}
      <b>Your user is the only party that can ever access their full private key.</b>
    </Info>
  </Tab>

  <Tab title="NodeJS">
    <Info>
      This guide is for the **`@privy-io/node`** library only, as the feature is not available in the
      **`@privy-io/server-auth`** library.
    </Info>

    To export a wallet's private key with the NodeJS / Typescript SDK, use the `export` method from the client’s `wallets()` interface.
    This will internally generate an ECDH P-256 keypair and use it to perform an encrypted HPKE operation with the Wallet API to export the wallet's private key.

    ```ts  theme={"system"}
    import {PrivyClient} from '@privy-io/node';

    const privy = new PrivyClient({
      appId: 'your-app-id',
      appSecret: 'your-app-secret'
    });

    try {
      const {private_key} = await privy.wallets().export('wallet-id', {});
    } catch (error) {
      console.error('Failed to export wallet:', error);
    }
    ```

    If the wallet is owned by an authorization key, a user, or a key quorum, you must provide in the
    owner's information in the [authorization context](/controls/authorization-keys/using-owners/sign/signing-on-the-server) when exporting the wallet.

    ```ts  theme={"system"}
    import {PrivyClient} from '@privy-io/node';

    const privy = new PrivyClient({
      appId: 'your-app-id',
      appSecret: 'your-app-secret'
    });

    const {private_key} = await privy.wallets().export('wallet-id', {
      authorization_context: {
        authorization_private_keys: ['authorization-key'],
        user_jwts: ['user-jwt', 'user-jwt-2']
      }
    });
    ```
  </Tab>

  <Tab title="REST API">
    To export a wallet's private key via the REST API, use the `/v1/wallets/{wallet_id}/export` endpoint. This endpoint uses Hybrid Public Key Encryption (HPKE) to securely transmit the private key.

    <Warning>
      Wallet export is restricted to wallet owners and enabled by default, unless explicitly disabled by
      a [`DENY` policy](/controls/policies/overview#policies). Wallets without owners cannot be
      exported.
    </Warning>

    <Tabs>
      <Tab title="cURL">
        ```bash  theme={"system"}
        curl --request POST \
          --url https://api.privy.io/v1/wallets/{wallet_id}/export \
          --header 'Authorization: Basic <encoded-value>' \
          --header 'Content-Type: application/json' \
          --header 'privy-app-id: <privy-app-id>' \
          --header 'privy-authorization-signature: <privy-authorization-signature>'
          --data '{
            "encryption_type": "HPKE",
            "recipient_public_key": "<base64-encoded-recipient-public-key>"
          }'
        ```
      </Tab>

      <Tab title="Typescript/Javascript">
        ```ts  theme={"system"}
        import {generateAuthorizationSignature} from "@privy-io/server-auth/wallet-api"

        // Generate a base64-encoded key pair for the recipient
        const keypair = await crypto.subtle.generateKey(
          {
            name: "ECDH",
            namedCurve: "P-256"
          },
          true,
          ["deriveKey", "deriveBits"]
        )
        const [publicKey, privateKey] = await Promise.all([
          crypto.subtle.exportKey("spki", keypair.value.publicKey),
          crypto.subtle.exportKey("pkcs8", keypair.value.privateKey)
        ])
        const [publicKeyBase64, privateKeyBase64] = [
          Buffer.from(publicKey).toString("base64"),
          Buffer.from(privateKey).toString("base64")
        ]

        // Create the signature for the request
        const input = {
          headers: {
            "privy-app-id": "your-privy-app-id",
          },
          method: "POST",
          url: `https://api.privy.io/v1/wallets/${walletId}/export`,
          version: 1,
          body: {
            encryption_type: "HPKE",
            recipient_public_key: publicKeyBase64,
          },
        };
        const signature = generateAuthorizationSignature({
          input: input,
          authorizationPrivateKey: "your-privy-authorization-private-key" // This should be the private key of your authorization key
        })

        // Make the request to export the wallet
        const res = await fetch(
          `https://api.privy.io/v1/wallets/${walletId}/export`,
          {
            method: input.method,
            headers: {
              ...input.headers,
              "Content-Type": "application/json",
              "privy-authorization-signature": signature as string,
              Authorization: generateBasicAuthHeader(
                "your-privy-app-id",
                "your-privy-app-secret"
              ),
            },
            body: JSON.stringify(input.body),
          }
        );
        ```
      </Tab>

      <Tab title="Python">
        ```python  theme={"system"}
        import requests
        import base64
        from cryptography.hazmat.primitives.asymmetric import ec
        from cryptography.hazmat.primitives import serialization

        # Generate a key pair for the recipient
        private_key = ec.generate_private_key(ec.SECP256R1())
        public_key = private_key.public_key()

        # Export keys to base64
        public_key_base64 = base64.b64encode(
            public_key.public_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PublicFormat.SubjectPublicKeyInfo
            )
        ).decode('utf-8')

        # Prepare the request data
        data = {
            "encryption_type": "HPKE",
            "recipient_public_key": public_key_base64,
        }

        # Make the request to export the wallet
        response = requests.post(
            f'https://api.privy.io/v1/wallets/{wallet_id}/export',
            headers={
                'Authorization': 'Basic <encoded-value>',
                'Content-Type': 'application/json',
                'privy-app-id': '<privy-app-id>',
                'privy-authorization-signature': '<privy-authorization-signature>'
            },
            json=data
        )
        ```
      </Tab>
    </Tabs>

    The endpoint will return the encrypted private key along with the encapsulation information needed for decryption:

    ```json  theme={"system"}
    {
      "encryption_type": "HPKE",
      "ciphertext": "Zb2XqqIpPlQKJhkb9GRoXa8N6pKLAlozYnXg713g7mCu5vvn6tGIRbeJj4XOUQkFeB9DRxKg",
      "encapsulated_key": "BLplgxEpMz+WMxDSOzGZe+Oa5kkt9FTxUudRRyO5zRj/OaDbUaddlE18uNv8UKxpecnrSy+UByG2C3oJTgTnGNk="
    }
    ```

    ### Decrypting the Private Key

    The exported private key is encrypted using Hybrid Public Key Encryption (HPKE) with the following configuration:

    * KEM: DHKEM\_P256\_HKDF\_SHA256
    * KDF: HKDF\_SHA256
    * AEAD: CHACHA20\_POLY1305
    * Mode: BASE

    To decrypt the private key, you'll need to use these same parameters along with your recipient private key. Here's how to implement the decryption in several languages:

    <Tabs>
      <Tab title="TypeScript">
        <CodeGroup>
          ```ts decrypt.ts theme={"system"}
          import {CipherSuite, DhkemP256HkdfSha256, HkdfSha256} from '@hpke/core';
          import {Chacha20Poly1305} from '@hpke/chacha20poly1305';

          /**
           * Decrypts a message using HPKE (Hybrid Public Key Encryption).
           *
           * Uses P-256 keys with HPKE to decrypt an encrypted message. The function expects base64-encoded
           * inputs and handles all necessary key imports and context creation for HPKE decryption.
           *
           * @param privateKeyBase64 Base64-encoded private key in PKCS8 format used for decryption.
           * @param encapsulatedKeyBase64 Base64-encoded raw public key bytes representing the
           *     encapsulated key.
           * @param ciphertextBase64 Base64-encoded encrypted message using base64url encoding that
           *     will be decrypted.
           * @returns A Promise that resolves to the decrypted message as a UTF-8 string.
           * @throws {Error} If decryption fails or if any of the inputs are incorrectly formatted.
           */
          async function decryptHPKEMessage(
            privateKeyBase64: string,
            encapsulatedKeyBase64: string,
            ciphertextBase64: string
          ): Promise<string> {
            // Initialize the cipher suite
            const suite = new CipherSuite({
              kem: new DhkemP256HkdfSha256(),
              kdf: new HkdfSha256(),
              aead: new Chacha20Poly1305()
            });

            // Convert base64 to ArrayBuffer using browser APIs
            const base64ToBuffer = (base64: string) =>
              Uint8Array.from(atob(base64), (c) => c.charCodeAt(0)).buffer;

            // Import private key using WebCrypto
            const privateKey = await crypto.subtle.importKey(
              'pkcs8',
              base64ToBuffer(privateKeyBase64),
              {
                name: 'ECDH',
                namedCurve: 'P-256'
              },
              true,
              ['deriveKey', 'deriveBits']
            );

            // Create recipient context and decrypt
            const recipient = await suite.createRecipientContext({
              recipientKey: privateKey,
              enc: base64ToBuffer(encapsulatedKeyBase64)
            });

            return new TextDecoder().decode(await recipient.open(base64ToBuffer(ciphertextBase64)));
          }
          ```

          ```ts example.ts {skip-check} theme={"system"}
          // The response from the export API endpoint
          const response = {
            encryption_type: 'HPKE',
            ciphertext: 'Zb2XqqIpPlQKJhkb9GRoXa8N6pKLAlozYnXg713g7mCu5vvn6tGIRbeJj4XOUQkFeB9DRxKg',
            encapsulated_key:
              'BLplgxEpMz+WMxDSOzGZe+Oa5kkt9FTxUudRRyO5zRj/OaDbUaddlE18uNv8UKxpecnrSy+UByG2C3oJTgTnGNk='
          };

          // Replace with your base64-encoded private key
          const privateKeyBase64 =
            'MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgU4RP++trEcTL2CPSgX9dKZAQ+XW3Pt49PNI4Elwia1qhRANCAAROjlGlaxrE9rIRc2jy0xmW7ajzkRqccVJsc2WMsXKoB2lG5NllwkSHwWsZkDbmqhYFk/WlDYl/MCiLnYYVtJf+';

          try {
            const privateKey = await decryptHPKEMessage(
              privateKeyBase64,
              response.encapsulated_key,
              response.ciphertext
            );
            console.log('Decrypted private key:', privateKey);
          } catch (error) {
            console.error('Failed to decrypt:', error);
          }
          ```
        </CodeGroup>
      </Tab>

      <Tab title="Python">
        <CodeGroup>
          ```python decrypt.py theme={"system"}
          from cryptography.hazmat.primitives import serialization
          from hpke import CipherSuite, KEMId, KDFId, AEADId
          import base64

          async def decrypt_hpke_message(
              private_key_base64: str,
              encapsulated_key_base64: str,
              ciphertext_base64: str
          ) -> str:
              """
              Decrypts a message using HPKE (Hybrid Public Key Encryption) with P-256 keys

              Args:
                  private_key_base64: Base64-encoded private key in PKCS8 format used for decryption.
                  encapsulated_key_base64: Base64-encoded raw public key bytes representing the
                                          encapsulated key.
                  ciphertext_base64: Base64-encoded encrypted message using base64url encoding that
                                    will be decrypted.

              Returns:
                  str: The decrypted message as a UTF-8 string

              Raises:
                  ValueError: If decryption fails or if inputs are incorrectly formatted
              """
              # Initialize the cipher suite
              suite = CipherSuite.new(
                  KEMId.DHKEM_P256_HKDF_SHA256,
                  KDFId.HKDF_SHA256,
                  AEADId.CHACHA20_POLY1305
              )

              # Convert base64 to bytes
              raw_public_key = base64.b64decode(encapsulated_key_base64)
              private_key_bytes = base64.b64decode(private_key_base64)
              ciphertext = base64.b64decode(ciphertext_base64)

              # Import private key
              loaded_private_key = serialization.load_der_private_key(
                  private_key_bytes,
                  password=None
              )
              private_number = loaded_private_key.private_numbers().private_value
              private_bytes = private_number.to_bytes(32, byteorder="big")  # P-256 uses 32 bytes
              private_kem_key = suite.kem.deserialize_private_key(private_bytes)

              # Create recipient context and decrypt
              encapsulated_kem_key = suite.kem.deserialize_public_key(raw_public_key)
              recipient_context = suite.create_recipient_context(
                  encapsulated_kem_key.to_public_bytes(),
                  private_kem_key
              )

              # Decrypt and return as UTF-8 string
              return recipient_context.open(ciphertext).decode("utf-8")
          ```

          ```python example.py theme={"system"}
          # The response from the export API endpoint
          response = {
              "encryption_type": "HPKE",
              "ciphertext": "Zb2XqqIpPlQKJhkb9GRoXa8N6pKLAlozYnXg713g7mCu5vvn6tGIRbeJj4XOUQkFeB9DRxKg",
              "encapsulated_key": "BLplgxEpMz+WMxDSOzGZe+Oa5kkt9FTxUudRRyO5zRj/OaDbUaddlE18uNv8UKxpecnrSy+UByG2C3oJTgTnGNk="
          }

          # Replace with your base64-encoded private key
          private_key_base64 = "MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgU4RP++trEcTL2CPSgX9dKZAQ+XW3Pt49PNI4Elwia1qhRANCAAROjlGlaxrE9rIRc2jy0xmW7ajzkRqccVJsc2WMsXKoB2lG5NllwkSHwWsZkDbmqhYFk/WlDYl/MCiLnYYVtJf+"

          # Decrypt the private key
          private_key = decrypt_hpke_message(
              private_key_base64, response["encapsulated_key"], response["ciphertext"]
          )
          print(private_key)
          ```
        </CodeGroup>
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Rust">
    To export a wallet's private key with the Rust SDK, use the `export` method from the client's `wallets()` interface. This will internally generate an ECDH P-256 keypair and use it to perform an encrypted HPKE operation with the Wallet API to export the wallet's private key.

    <Warning>
      Wallet export is restricted to wallet owners and enabled by default, unless explicitly disabled by a [`DENY` policy](/controls/policies/overview#policies). Wallets without owners cannot be exported.
    </Warning>

    ### Usage

    ```rust  theme={"system"}
    use privy_rs::{PrivyClient, AuthorizationContext, JwtUser};

    let client = PrivyClient::new(app_id, app_secret)?;

    // Create authorization context with user JWT
    let jwt_user = JwtUser(client.clone(), "user-jwt-token".to_string());
    let ctx = AuthorizationContext::new().push(jwt_user);

    // Export the wallet - encryption is handled automatically
    let exported = client
        .wallets()
        .export("wallet-id", &ctx)
        .await?;

    println!("Wallet exported successfully: {:?}", exported);
    ```

    ### Parameters and Returns

    See the Rust SDK documentation for detailed parameter and return types, including embedded examples:

    * [WalletsClient::export](https://docs.rs/privy-rs/latest/privy_rs/subclients/struct.WalletsClient.html#method.export)
    * [AuthorizationContext](https://docs.rs/privy-rs/latest/privy_rs/struct.AuthorizationContext.html)

    For REST API details, see the [API reference](/api-reference/wallets/export).

    <Info>
      The Rust SDK automatically handles HPKE encryption internally. The `export` method returns the decrypted private key directly, simplifying the export process while maintaining security through encrypted transmission.
    </Info>
  </Tab>
</Tabs>


# Get all wallets
Source: https://docs.privy.io/wallets/wallets/get-a-wallet/get-all-wallets



Get all wallets for your application.

<Tabs>
  <Tab title="NodeJS">
    To fetch all your application's wallets, use the Privy client's `walletApi.getWallets` method. This is a paginated query.

    ```tsx  theme={"system"}
    getWallets: ({cursor?: string, limit?: number, chainType?: 'ethereum' | 'solana'}) => Promise<{data: WalletApiWalletResponseType[], nextCursor?: string}>
    ```

    ### Usage

    ```ts  theme={"system"}
    // Will iterate automatically until all wallets are fetched
    for await (const wallet of privy.wallets().list({chain_type: 'ethereum'})) {
        // Do something with the wallet
    }
    ```

    ### Parameters and Returns

    Check out the [API reference](/api-reference/wallets/get-all) for more details.
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    To fetch all your application's wallets, use the Privy client's `walletApi.getWallets` method. This is a paginated query.

    ```tsx  theme={"system"}
    getWallets: ({cursor?: string, limit?: number, chainType?: 'ethereum' | 'solana'}) => Promise<{data: WalletApiWalletResponseType[], nextCursor?: string}>
    ```

    ### Usage

    ```tsx  theme={"system"}
    const wallets = [];
    let nextCursor;

    do {
        const result = await privy.walletApi.getWallets({chainType: 'ethereum', cursor: nextCursor});
        wallets.push(...result.data);
        nextCursor = result.nextCursor;
    } while (nextCursor);
    const wallet = wallets.find((wallet) => wallet.address === desiredAddress);
    ```

    ### Parameters

    The `getWallets` method optionally accepts an object with the following fields:

    <ParamField path="cursor" type="string">
      ID of the wallet from which start the search
    </ParamField>

    <ParamField path="limit" type="number">
      Max amount of wallets to fetch per page
    </ParamField>

    <ParamField path="chainType" type="'ethereum' | 'solana'">
      Chain type to filter by.
    </ParamField>

    ### Returns

    <ResponseField name="data" type="WalletApiWalletResponseType[]">
      List of wallets in the current page
    </ResponseField>

    <ResponseField name="nextCursor" type="string">
      Cursor to use for fetching the next page of results, if any
    </ResponseField>
  </Tab>

  <Tab title="Java">
    To fetch all of your application's wallets, use the `list` method.

    ```java  theme={"system"}
    try {
        WalletListRequest request = WalletListRequest.builder()
            .chainType(WalletChainType.ETHEREUM)
            .build();

        WalletListResponse response = privyClient.wallets().list(request);

        if (response.wallets().isPresent()) {
            List<Wallet> wallets = response.wallets().get().data();
        }
    } catch (APIException e) {
        String errorBody = e.bodyAsString();
        System.err.println(errorBody);
    } catch (Exception e) {
        System.err.println(e.getMessage());
    }
    ```

    ### Parameters

    The `WalletListRequest` object accepts the following parameters, all of which are optional:

    <ParamField body="chainType" type="WalletChainType">
      The chain type to filter by.
    </ParamField>

    <ParamField body="userId" type="String">
      The user ID to filter by.
    </ParamField>

    <ParamField body="cursor" type="String">
      The cursor to use for fetching the next page of results, if any.
    </ParamField>

    <ParamField body="limit" type="Double">
      The maximum number of wallets to fetch per page.
      Defaults to `100`.
    </ParamField>

    ### Returns

    The `WalletListResponse` object contains an optional `object()` field, present if the
    wallets were retrieved successfully.

    <ResponseField name="object()" type="Optional<WalletListResponseBody>">
      The retrieved list of wallets. Each of the elements in the list under `.data()` is a `Wallet` object.

      <Expandable>
        <ResponseField type="String" name="id">
          Unique ID of the created wallet. This will be the primary identifier when using the wallet in the future.
        </ResponseField>

        <ResponseField type="String" name="address">
          Address of the created wallet.
        </ResponseField>

        <ResponseField type="WalletChainType" name="chainType">
          Chain type of the created wallet.
        </ResponseField>

        <ResponseField type="List<String>" name="policyIds">
          List of policy IDs for policies that are enforced on the wallet.
        </ResponseField>

        <ResponseField type="String" name="ownerId">
          The key quorum ID of the owner of the wallet.
        </ResponseField>

        <ResponseField type="List<WalletAdditionalSigner>" name="additionalSigners">
          The key quorum IDs of the additional signers for the wallet.
        </ResponseField>

        <ResponseField type="double" name="createdAt">
          The creation date of the wallet, as Unix time.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="REST API">
    To fetch your wallets by pages, make a `GET` request to:

    ```
    https://api.privy.io/v1/wallets
    ```

    ### Query

    In the request query parameters, include any of the following:

    <ParamField path="cursor" type="string">
      ID of the wallet from which start the search
    </ParamField>

    <ParamField path="limit" type="number">
      Max amount of wallets per page
    </ParamField>

    <ParamField path="chain_type" type="'ethereum' | 'solana'">
      Chain type to filter by.
    </ParamField>

    ### Response

    In the response, Privy will send back the following if successful:

    <ResponseField name="data" type="Array<WalletApiWalletResponseType>">
      List of wallets in the current page

      <Expandable defaultOpen="true">
        <ResponseField name="id" type="string">
          Unique ID of the wallet
        </ResponseField>

        <ResponseField name="address" type="string">
          Address of the wallet
        </ResponseField>

        <ResponseField name="chain_type" type="'ethereum' | 'solana'">
          Chain type of the wallet
        </ResponseField>

        <ResponseField name="policy_ids" type="string[]">
          List of policy IDs associated with the wallet
        </ResponseField>

        <ResponseField type="string | null" name="owner_id">
          The key quorum ID of the owner of the wallet.
        </ResponseField>

        <ResponseField type="{signer_id: string}[]" name="additional_signers">
          The key quorum IDs of the additional signers for the wallet.
        </ResponseField>

        <ResponseField name="created_at" type="number">
          The creation date of the wallet, in milliseconds since midnight, January 1, 1970 UTC.
        </ResponseField>
      </Expandable>
    </ResponseField>

    <ResponseField name="next_cursor" type="string">
      ID of the wallet from which start the next page
    </ResponseField>

    ### Example

    As an example, a sample request to fetch EVM wallets might look like the following:

    ```bash  theme={"system"}
    $ curl --request GET https://api.privy.io/v1/wallets?chain_type=ethereum&limit=1 \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H 'Content-Type: application/json' \
    ```

    A successful response will look like the following:

    ```json  theme={"system"}
    {
      "data": [
        {
          "id": "yepf6384cu2nkup42gvrwdqh",
          "address": "0x2F3eb40872143b77D54a6f6e7Cc120464C764c09",
          "chain_type": "ethereum",
          "authorization_threshold": 2,
          "owner_id": null,
          "additional_signers": [],
          "created_at": 1733923425155
        }
      ],
      "next_cursor": "u67nttpkeeti2hm9w7aoxdcc"
    }
    ```
  </Tab>

  <Tab title="Rust">
    To fetch all your application's wallets, use the `list` method on the `wallets()` interface of the Privy client. This is a paginated query that requires manual pagination.

    ### Usage

    ```rust  theme={"system"}
    use privy_rs::{PrivyClient, generated::types::*};

    let client = PrivyClient::new(app_id, app_secret)?;

    // Manual pagination through all wallets
    let mut all_wallets = Vec::new();
    let mut cursor = None;

    loop {
        let response = client.wallets().list(&WalletListQuery {
            chain_type: Some(WalletChainType::Ethereum),
            user_id: None,
            limit: Some(50), // Fetch 50 at a time
            cursor: cursor.clone(),
        }).await?;

        all_wallets.extend(response.data);

        if let Some(next_cursor) = response.next_cursor {
            cursor = Some(next_cursor);
        } else {
            break; // No more pages
        }
    }

    for wallet in all_wallets {
        println!("Wallet {}: {}", wallet.id, wallet.address);
    }
    ```

    ### Parameters and Returns

    See the Rust SDK documentation for detailed parameter and return types, including embedded examples:

    * [WalletsClient::list](https://docs.rs/privy-rs/latest/privy_rs/subclients/struct.WalletsClient.html#method.list)
    * [WalletListQuery](https://docs.rs/privy-rs/latest/privy_rs/generated/types/struct.WalletListQuery.html)
    * [Wallet](https://docs.rs/privy-rs/latest/privy_rs/generated/types/struct.Wallet.html)

    For REST API details, see the [API reference](/api-reference/wallets/get-all).

    ### Helper Function Example

    ```rust  theme={"system"}
    use privy_rs::{PrivyClient, generated::types::*};

    async fn fetch_all_wallets_by_chain(
        client: &PrivyClient,
        chain_type: WalletChainType,
    ) -> Result<Vec<Wallet>, Box<dyn std::error::Error>> {
        let mut all_wallets = Vec::new();
        let mut cursor = None;

        loop {
            let response = client
                .wallets()
                .list(&WalletListQuery {
                    chain_type: Some(chain_type.clone()),
                    user_id: None,
                    limit: Some(50), // Fetch 50 at a time
                    cursor: cursor.clone(),
                })
                .await?;

            all_wallets.extend(response.data);

            if let Some(next_cursor) = response.next_cursor {
                cursor = Some(next_cursor);
            } else {
                break; // No more pages
            }
        }

        Ok(all_wallets)
    }
    ```
  </Tab>
</Tabs>


# Get user connected wallets
Source: https://docs.privy.io/wallets/wallets/get-a-wallet/get-connected-wallet



A user may come in with both embedded and external wallets. Privy makes it easy to find all of a user's connected wallets so you can help them take an onchain action with the appropriate wallet.

It's worth distinguishing connected vs. linked wallets:

* **Linked wallets** are embedded or external wallets tied to a user object. They may or may not be connected.
* **Connected wallets** are embedded or external wallets currently available for the web client. They may or may not be linked to a user's account.

<Tip>
  Not seeing all of the external wallets connected to the application? Make sure you have [completed
  the steps to connect](/wallets/connectors/setup/configuring-external-connector-chains) any wallets
  to your application.
</Tip>

Both **external wallets** (that users *connect* to your site) and **embedded wallets** (that users *create* within your app) result in a unified object representing the wallet.

<Tabs>
  <Tab title="React">
    <Tabs>
      <Tab title="Ethereum">
        To access connected wallets with the React SDK, use the `wallets` array from the `useWallets` hook:

        ```tsx  theme={"system"}
        const wallets: ConnectedWallet[]
        ```

        ### Usage

        ```tsx  theme={"system"}
        import {useWallets} from '@privy-io/react-auth';
        const { wallets } = useWallets();
        const desiredWallet = wallets.find((wallet) => wallet.address === desiredAddress);
        ```

        The **`wallets`** array includes an object for all wallets a user has connected to your site.
      </Tab>

      <Tab title="Solana">
        To access connected wallets with the React SDK, use the `wallets` array from the `useWallets` hook:

        ```tsx  theme={"system"}
        const wallets: ConnectedStandardSolanaWallet[]
        ```

        ### Usage

        ```tsx  theme={"system"}
        import {useWallets} from '@privy-io/react-auth/solana';
        const { wallets } = useWallets();
        const desiredWallet = wallets.find((wallet) => wallet.address === desiredAddress);
        ```

        The **`wallets`** array includes an object for all wallets a user has connected to your site. The array is ordered from most recently connected to least recently connected.
      </Tab>
    </Tabs>

    ## Waiting for wallets to be `ready`

    When your page loads in the user's browser, the Privy SDK determines what wallets the user has connected to your app in two ways:

    * For **external wallets**, Privy determines what wallets are connected via EIP-6963 for injected wallets (e.g. browser extension wallets) and via WalletConnect for mobile wallets.
    * For **embedded wallets**, Privy determines if the user has an embedded wallet by loading the Privy iframe which stores the private key material used for the wallet.

    To determine if Privy has fully processed all external and embedded wallet connections, use the **`ready`** boolean returned by the **`useWallets`** hooks.

    Concretely, **`ready`** will be `false` while Privy is determining what wallets are available for the user, and will be `true` once Privy has settled on the current set of connected wallets.

    ***

    ## `useWallets` vs. `usePrivy`

    The **`useWallets`** and **`usePrivy`** hooks all return information about a user's wallets. The key difference between the them is:

    * **`useWallets`** will return all *connected* wallets (EVM and Solana), which you can use to request signatures or take onchain actions (via transactions).
    * **`usePrivy`** will return all *linked* wallets, which you can use to verify that a user owns a given wallet address.

    Linked wallets are not necessarily actively connected to your site, so you may not always be able to request a signature or transaction from them. Similarly, connected wallets are not necessarily linked, as a user may have connected their wallet without signing a message to verify that they own the wallet address.

    Concretely, if your use case only requires you to verify that a user owns a given wallet address, you should use the wallets information returned by the **`usePrivy`** hook.

    ### Accessing linked wallets

    To access linked wallets (both embedded and external wallets tied to the user account), use `user.linkedAccounts` from the **`usePrivy`** hook:

    ```tsx  theme={"system"}
    import {usePrivy} from '@privy-io/react-auth';

    const { user } = usePrivy();

    // Filter for wallet accounts from all linked accounts
    const linkedWallets = user?.linkedAccounts.filter(
      (account) => account.type === 'wallet' ||
                   account.type === 'smart_wallet'
    );

    // Access wallet addresses
    linkedWallets?.forEach((wallet) => {
      console.log(wallet.address);
    });
    ```

    Otherwise, if your use case requires you to take actions on a *connected* wallet, such as getting its network or requesting a signature or transaction, you should use the wallets information returned by the **`useWallets`** hooks instead.
  </Tab>

  <Tab title="React Native">
    <Tabs>
      <Tab title="Ethereum">
        To access connected wallets with the React Native SDK, use the `wallets` array from the `useEmbeddedEthereumWallet` hook:

        ```tsx  theme={"system"}
        const wallets: ConnectedEthereumWallet[]
        ```

        ### Usage

        ```tsx  theme={"system"}
        import {useEmbeddedEthereumWallet} from '@privy-io/expo';
        const {wallets} = useEmbeddedEthereumWallet();
        const desiredWallet = wallets.find((wallet) => wallet.address === desiredAddress);
        ```
      </Tab>

      <Tab title="Solana">
        To access connected wallets with the React Native SDK, use the `wallets` array from the `useEmbeddedSolanaWallet` hook:

        ```tsx  theme={"system"}
        const wallets: ConnectedSolanaWallet[]
        ```

        ### Usage

        ```tsx  theme={"system"}
        import {useEmbeddedSolanaWallet} from '@privy-io/expo';
        const {wallets} = useEmbeddedSolanaWallet();
        const desiredWallet = wallets.find((wallet) => wallet.address === desiredAddress);
        ```
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Swift">
    <Tabs>
      <Tab title="Ethereum">
        To access connected Ethereum wallets using the Swift SDK, use the `embeddedEthereumWallets` property from the `PrivyUser` object:

        ```swift  theme={"system"}
        var embeddedEthereumWallets: [EmbeddedEthereumWallet] { get }
        ```

        ### Usage

        ```swift  theme={"system"}
        guard let user = privy.user else {
            // If user is null, user is not authenticated
            return
        }

        // Retrieve list of user's embedded Ethereum wallets
        let ethereumWallets = user.embeddedEthereumWallets

        // Grab the desired wallet. Here, we retrieve the first wallet
        guard let ethereumWallet = ethereumWallets.first else {
            // No ETH wallets
            return
        }
        ```
      </Tab>

      <Tab title="Solana">
        To access connected Solana wallets using the Swift SDK, use the `embeddedSolanaWallets` property from the `PrivyUser` object:

        ```swift  theme={"system"}
        var embeddedSolanaWallets: [EmbeddedSolanaWallet] { get }
        ```

        ### Usage

        ```swift  theme={"system"}
        guard let user = privy.user else {
            // User is not authenticated
            return
        }

        // Retrieve list of user's embedded Solana wallets
        let solanaWallets = user.embeddedSolanaWallets

        // Grab the desired wallet. Here, we retrieve the first wallet
        guard let solanaWallet = solanaWallets.first else {
            // No SOL wallets
            return
        }
        ```
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Android">
    <Tabs>
      <Tab title="Ethereum">
        To access connected Ethereum wallets using the Android SDK, use the `embeddedEthereumWallets` property from the `PrivyUser` object:

        ```kotlin  theme={"system"}
        val embeddedEthereumWallets: List<EmbeddedEthereumWallet>
        ```

        ### Usage

        ```kotlin  theme={"system"}
        val user = privy.user
        if (user != null) {
            val ethereumWallets = user.embeddedEthereumWallets
            if (ethereumWallets.isNotEmpty()) {
                val ethereumWallet = ethereumWallets.first()
            }
        }
        ```

        The **`embeddedEthereumWallets`** property includes an array of objects for all Ethereum wallets a user has connected to your app. The array is ordered from most recently connected to least recently connected.
      </Tab>

      <Tab title="Solana">
        To access connected Solana wallets using the Android SDK, use the `embeddedSolanaWallets` property from the `PrivyUser` object:

        ```kotlin  theme={"system"}
        val embeddedSolanaWallets: List<EmbeddedSolanaWallet>
        ```

        ### Usage

        ```kotlin  theme={"system"}
        val user = privy.user
        if (user != null) {
            val solanaWallets = user.embeddedSolanaWallets
            if (solanaWallets.isNotEmpty()) {
                val solanaWallet = solanaWallets.first()
            }
        }
        ```

        The **`embeddedSolanaWallets`** property includes an array of objects for all Solana wallets a user has connected to your app. The array is ordered from most recently connected to least recently connected.
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Flutter">
    <Tabs>
      <Tab title="Ethereum">
        To retrieve a user's Ethereum wallet using the Flutter SDK, follow these steps:

        ```dart  theme={"system"}
        final user = privy.user;
        final EmbeddedEthereumWallet ethereumWallet = user.embeddedEthereumWallets.first;
        ```

        ### Usage

        ```dart  theme={"system"}
        import 'package:privy_flutter/privy_flutter.dart';

        // Get the user's first Ethereum wallet
        final user = privy.user;
        if (user != null && user.embeddedEthereumWallets.isNotEmpty) {
          final wallet = user.embeddedEthereumWallets.first;

          // Access wallet properties
          final address = wallet.address;
        }
        ```

        The **`embeddedEthereumWallets`** property includes an array of objects for all Ethereum wallets a user has connected to your app. The array is ordered from most recently connected to least recently connected.
      </Tab>

      <Tab title="Solana">
        To retrieve a user's Solana wallet using the Flutter SDK, follow these steps:

        ```dart  theme={"system"}
        final user = privy.user;
        final EmbeddedSolanaWallet solanaWallet = user.embeddedSolanaWallets.first;
        ```

        ### Usage

        ```dart  theme={"system"}
        import 'package:privy_flutter/privy_flutter.dart';

        // Get the user's first Solana wallet
        final user = privy.user;
        if (user != null && user.embeddedSolanaWallets.isNotEmpty) {
          final wallet = user.embeddedSolanaWallets.first;

          // Access wallet properties
          final address = wallet.address;
        }
        ```

        The **`embeddedSolanaWallets`** property includes an array of objects for all Solana wallets a user has connected to your app. The array is ordered from most recently connected to least recently connected.
      </Tab>
    </Tabs>
  </Tab>
</Tabs>


# Get wallet by ID
Source: https://docs.privy.io/wallets/wallets/get-a-wallet/get-wallet-by-id



You can get a specific wallet by its ID from the Privy API.

Note this is a wallet-centric abstraction. You may be looking for a way to [find a given user's wallets](/user-management/users/managing-users/querying-users).

<Tabs>
  <Tab title="NodeJS">
    To get a wallet by ID, use the `get` method on the `wallets()` interface of the Privy client.

    ### Usage

    ```tsx  theme={"system"}
    const wallet = await privy.wallets().get(walletId);
    ```

    ### Parameters and Returns

    Check out the [API reference](/api-reference/wallets/get) for more details.
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    To get a wallet by ID, use the `getWallet` method.

    ```tsx  theme={"system"}
    getWallet: ({id}: {id: string}) => Promise<WalletApiWalletResponseType>
    ```

    ### Usage

    ```tsx  theme={"system"}
    const wallet = await client.walletApi.getWallet({id: walletId});
    ```

    ### Parameters

    <ParamField path="id" type="string">
      The ID of the wallet to get
    </ParamField>

    ### Returns

    <ResponseField name="wallet" type="WalletApiWalletResponseType">
      <Expandable defaultOpen="true">
        <ResponseField name="id" type="string">
          Unique ID of the wallet
        </ResponseField>

        <ResponseField name="address" type="string">
          Address of the wallet
        </ResponseField>

        <ResponseField name="chainType" type="'ethereum' | 'solana'">
          Chain type of the wallet
        </ResponseField>

        <ResponseField name="policyIds" type="string[]">
          List of policy IDs associated with the wallet
        </ResponseField>

        <ResponseField type="string | null" name="ownerId">
          The key quorum ID of the owner of the wallet.
        </ResponseField>

        <ResponseField type="{signerId: string}[]" name="additionalSigners">
          The key quorum IDs of the additional signers for the wallet.
        </ResponseField>

        <ResponseField name="createdAt" type="Date">
          The creation date of the wallet
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="Java">
    To get a wallet by ID, use the `retrieve` method.

    ```java  theme={"system"}
    try {
        WalletRetrieveResponse response = privyClient.wallets().retrieve(walletId);
        if (response.wallet().isPresent()) {
            Wallet wallet = response.wallet().get();
        }
    } catch (APIException e) {
        String errorBody = e.bodyAsString();
        System.err.println(errorBody);
    } catch (Exception e) {
        System.err.println(e.getMessage());
    }
    ```

    ### Parameters

    <ParamField body="walletId" type="String" required>
      The ID of the wallet to retrieve
    </ParamField>

    ### Returns

    The `WalletRetrieveResponse` object contains an optional `wallet()` field, present if the
    wallet was retrieved successfully.

    <ResponseField name="wallet()" type="Optional<Wallet>">
      The retrieved `Wallet` object.

      <Expandable defaultOpen="true">
        <ResponseField type="String" name="id">
          Unique ID of the created wallet. This will be the primary identifier when using the wallet in the future.
        </ResponseField>

        <ResponseField type="String" name="address">
          Address of the created wallet.
        </ResponseField>

        <ResponseField type="WalletChainType" name="chainType">
          Chain type of the created wallet.
        </ResponseField>

        <ResponseField type="List<String>" name="policyIds">
          List of policy IDs for policies that are enforced on the wallet.
        </ResponseField>

        <ResponseField type="String" name="ownerId">
          The key quorum ID of the owner of the wallet.
        </ResponseField>

        <ResponseField type="List<WalletAdditionalSigner>" name="additionalSigners">
          The key quorum IDs of the additional signers for the wallet.
        </ResponseField>

        <ResponseField type="double" name="createdAt">
          The creation date of the wallet, in milliseconds since midnight, January 1, 1970 UTC.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="REST API">
    To get a wallet by ID, make a `GET` request to:

    ```
    https://api.privy.io/v1/wallets/[wallet-id]
    ```

    ### Response

    <ResponseField name="data" type="WalletApiWalletResponseType">
      The wallet object

      <Expandable defaultOpen="true">
        <ResponseField name="id" type="string">
          Unique ID of the wallet
        </ResponseField>

        <ResponseField name="address" type="string">
          Address of the wallet
        </ResponseField>

        <ResponseField name="chain_type" type="'ethereum' | 'solana'">
          Chain type of the wallet
        </ResponseField>

        <ResponseField name="policy_ids" type="string[]">
          List of policy IDs associated with the wallet
        </ResponseField>

        <ResponseField type="string | null" name="owner_id">
          The key quorum ID of the owner of the wallet.
        </ResponseField>

        <ResponseField type="{signer_id: string}[]" name="additional_signers">
          The key quorum IDs of the additional signers for the wallet.
        </ResponseField>

        <ResponseField name="created_at" type="number">
          The creation date of the wallet, in milliseconds since midnight, January 1, 1970 UTC.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="Rust">
    To get a wallet by ID, use the `get` method on the `wallets()` interface of the Privy client.

    ### Usage

    ```rust  theme={"system"}
    use privy_rs::PrivyClient;

    let client = PrivyClient::new(app_id, app_secret)?;
    let wallet = client.wallets().get("wallet-id").await?;
    println!("Retrieved wallet {} with address {}", wallet.id, wallet.address);
    ```

    ### Parameters and Returns

    See the Rust SDK documentation for detailed parameter and return types, including embedded examples:

    * [WalletsClient::get](https://docs.rs/privy-rs/latest/privy_rs/subclients/struct.WalletsClient.html#method.get)
    * [Wallet](https://docs.rs/privy-rs/latest/privy_rs/generated/types/struct.Wallet.html)

    For REST API details, see the [API reference](/api-reference/wallets/get).
  </Tab>
</Tabs>


# Architecture
Source: https://docs.privy.io/wallets/wallets/import-a-wallet/architecture



**Privy uses end-to-end encryption to securely transmit your wallet entropy into Privy's TEE infrastructure.**

This enables you to import a wallet from your client, server, or TEE without exposing your wallet entropy to any intermediary services.

The wallet import process takes place over three steps:

### Step 1. Initializing key import

In order to end-to-end encrypt an imported wallet directly to the TEE, an asymmetric encryption key is required. Send an initialization request to the Privy API to retrieve a temporary public key used for encrypting private key material before transmission.

### Step 2: Encrypting your private key

Encrypt the wallet’s private key using Hybrid Public Key Encryption (HPKE) with the retrieved public key. This ensures the private key remains encrypted during transit and can only be decrypted within the TEE.

### Step 3: Submitting the encrypted key

Send the encrypted payload to the Privy API. Within the TEE, the encrypted payload is decrypted and the private key is used to initialize a new wallet. The temporary keypair used for the import process is destroyed to maintain forward secrecy.


# HD wallets
Source: https://docs.privy.io/wallets/wallets/import-a-wallet/hd-wallets



**Privy enables you to import HD wallets for use via the Privy API.**

This allows you to migrate wallets from external sources to Privy, including from a different wallet provider. Or, your app can enable users to bring an existing external wallet into your application in order to access and manage their assets within your app seamlessly.

## Importing a wallet

To import an HD wallet, you'll provide your 12 or 24 word BIP39 mnemonic and the specific address and index you'd like to import.

<Info>
  If you'd like to import multiple addresses for the same HD wallet, you can make multiple import calls with the same mnemonic and each index/address pair you'd like to import.
</Info>

<Tabs>
  <Tab title="NodeJS">
    To import an HD wallet with the NodeJS SDK, use the `import` method from the Privy client’s `wallets()` interface. The Privy client will encrypt your mnemonic for secure transmission to the TEE. See [architecture](/wallets/wallets/import-a-wallet/architecture) for more details.

    <Tabs>
      <Tab title="EVM">
        ```ts  theme={"system"}
        import {PrivyClient} from '@privy-io/node';

        const privy = new PrivyClient({
          appId: 'your-app-id',
          appSecret: 'your-app-secret'
        });

        try {
          const wallet = await privy.wallets().import({
            wallet: {
              entropy_type: 'hd',
              address: '<your-wallet-address>',
              chain_type: 'ethereum',
              private_key: '<your-bip39-mnemonic>',
              index: 0 // your wallet index, typically 0 for the first address
            }
          });
        } catch (error) {
          console.error('Failed to import wallet:', error);
        }
        ```
      </Tab>

      <Tab title="Solana">
        ```ts  theme={"system"}
        import {PrivyClient} from '@privy-io/node';

        const privy = new PrivyClient({
          appId: 'your-app-id',
          appSecret: 'your-app-secret'
        });

        try {
          const wallet = await privy.wallets().import({
            wallet: {
              entropy_type: 'hd',
              address: '<your-wallet-address>',
              chain_type: 'solana',
              private_key: '<your-bip39-mnemonic>',
              index: 0 // your wallet index, typically 0 for the first address
            }
          });
        } catch (error) {
          console.error('Failed to import wallet:', error);
        }
        ```
      </Tab>
    </Tabs>

    The returned wallet is type `Wallet`. See [get wallet by ID](/api-reference/wallets/get) for type definition.

    When importing a wallet, it is also possible to provide an owner, policies, or signers.

    ```ts  theme={"system"}
    import {PrivyClient} from '@privy-io/node';

    const privy = new PrivyClient({
      appId: 'your-app-id',
      appSecret: 'your-app-secret'
    });

    const wallet = await privy.wallets().import({
      wallet: {
        entropy_type: 'hd',
        address: '<your-wallet-address>',
        chain_type: 'solana', // or "ethereum"
        private_key: '<your-bip39-mnemonic>',
        index: 0 // your wallet index, typically 0 for the first address
      },
      owner_id: '<your-owner-id>',
      additional_signers: [{signer_id: '<your-signer-id>'}],
      policy_ids: ['<your-policy-id>']
    });
    ```
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    To import an HD wallet with the NodeJS SDK, use the `importWallet` method from the Privy client’s `walletApi` class. The Privy client will encrypt your mnemonic for secure transmission to the TEE. See [architecture](/wallets/wallets/import-a-wallet/architecture) for more details.

    <Tabs>
      <Tab title="EVM">
        ```ts  theme={"system"}
        import {PrivyClient, WalletApiWalletResponseType} from '@privy-io/server-auth';

        const privy = new PrivyClient('your-app-id', 'your-app-secret');

        const wallet: WalletApiWalletResponseType = await privy.walletApi.importWallet({
          address: '<your-wallet-address>',
          chainType: 'ethereum',
          entropy: '<your-bip39-mnemonic>',
          entropyType: 'hd',
          index: 0 // your wallet index, typically 0 for the first address
        });
        ```
      </Tab>

      <Tab title="Solana">
        ```ts  theme={"system"}
        import {PrivyClient, WalletApiWalletResponseType} from '@privy-io/server-auth';

        const privy = new PrivyClient('your-app-id', 'your-app-secret');

        const wallet: WalletApiWalletResponseType = await privy.walletApi.importWallet({
          address: '<your-wallet-address>',
          chainType: 'solana',
          entropy: '<your-bip39-mnemonic>',
          entropyType: 'hd',
          index: 0 // your wallet index, typically 0 for the first address
        });
        ```
      </Tab>
    </Tabs>

    The returned wallet is type `WalletApiWalletResponseType`. See [get wallet by ID](/wallets/wallets/get-a-wallet/get-wallet-by-id#returns) for type definition.
  </Tab>

  <Tab title="REST API">
    ### 1. Initialization

    Initialize a key import flow by calling the `/v1/wallets/import/init` endpoint with your wallet address, index, and chain type. See [authentication](/api-reference/introduction#authentication) for how to encode your app credentials.

    <Tabs>
      <Tab title="EVM">
        ```bash  theme={"system"}
        curl --request POST \
          --url https://api.privy.io/v1/wallets/import/init \
          --header 'Authorization: Basic <encoded-app-credentials>' \
          --header 'Content-Type: application/json' \
          --header 'privy-app-id: <privy-app-id>' \
          --data '{
            "address": "<your-wallet-address>",
            "chain_type": "ethereum",
            "entropy_type": "hd",
            "index": <your-wallet-index>,
            "encryption_type": "HPKE"
          }'
        ```
      </Tab>

      <Tab title="Solana">
        ```bash  theme={"system"}
        curl --request POST \
          --url https://api.privy.io/v1/wallets/import/init \
          --header 'Authorization: Basic <encoded-app-credentials>' \
          --header 'Content-Type: application/json' \
          --header 'privy-app-id: <privy-app-id>' \
          --data '{
            "address": "<your-wallet-address>",
            "chain_type": "solana",
            "entropy_type": "hd",
            "index": <your-wallet-index>,
            "encryption_type": "HPKE"
          }'
        ```
      </Tab>
    </Tabs>

    The endpoint will return a public key to encrypt your private key with:

    ```json  theme={"system"}
    {
      "encryption_public_key": "<base64-encoded-encryption-public-key>",
      "encryption_type": "HPKE"
    }
    ```

    ### 2. Encryption

    Encrypt your private key using Hybrid Public Key Encryption (HPKE) with the following configuration:

    * KEM: DHKEM\_P256\_HKDF\_SHA256
    * KDF: HKDF\_SHA256
    * AEAD: CHACHA20\_POLY1305
    * Mode: BASE

    There are two outputs from the encryption step that you'll provide to Privy during submission:

    * `ciphertext`: The encrypted private key
    * `encapsulated_key`: The encapsulated key

    Here's an example of how to encrypt a private key in TypeScript:

    <Tabs>
      <Tab title="EVM">
        ```ts  theme={"system"}
        import {Chacha20Poly1305} from '@hpke/chacha20poly1305';
        import {CipherSuite, DhkemP256HkdfSha256, HkdfSha256} from '@hpke/core';
        import {base64} from '@scure/base';

        const encryptWithHpke = async ({
          encryptionPublicKey,
          plaintextMnemonic
        }: {
          encryptionPublicKey: Uint8Array;
          plaintextMnemonic: Uint8Array;
        }) => {
          // Deserialize the raw key returned by the `init` request to the Privy API to a public key object
          const suite = new CipherSuite({
            kem: new DhkemP256HkdfSha256(),
            kdf: new HkdfSha256(),
            aead: new Chacha20Poly1305()
          });
          const publicKeyObject = await suite.kem.deserializePublicKey(
            Buffer.from(encryptionPublicKey).buffer
          );

          // Encrypt the plaintext wallet mnemonic
          const sender = await suite.createSenderContext({
            recipientPublicKey: publicKeyObject
          });
          const ciphertext = await sender.seal(Buffer.from(plaintextMnemonic).buffer);

          // Return the encapsulated key and ciphertext, converting ArrayBuffer to Uint8Array
          return {
            encapsulatedKey: new Uint8Array(sender.enc),
            ciphertext: new Uint8Array(ciphertext)
          };
        };

        // The encryption public key is returned by the `init` request to the Privy API
        // For example: BPoOQ5k9nRk37v+XQWkmFEjpvW6RS0HQsPF3+IbhgMlc2Qwp/vz7lln1h0MJj/l0crLUhyyjdmC9RnAcpAkUNVQ=
        const base64EncodedEncryptionPublicKey = '<encryption-public-key>';
        // The wallet's BIP39 mnemonic.
        // For example: "solution tree shed picnic exile caught pluck hammer flag strategy surprise fiber"
        const plaintextMnemonic = '<your-wallet-mnemonic>';

        const {encapsulatedKey, ciphertext} = await encryptWithHpke({
          encryptionPublicKey: base64.decode(base64EncodedEncryptionPublicKey),
          plaintextMnemonic: new Uint8Array(Buffer.from(plaintextMnemonic, 'utf-8'))
        });
        ```
      </Tab>

      <Tab title="Solana">
        ```ts  theme={"system"}
        import {Chacha20Poly1305} from '@hpke/chacha20poly1305';
        import {CipherSuite, DhkemP256HkdfSha256, HkdfSha256} from '@hpke/core';
        import {base64} from '@scure/base';

        const encryptWithHpke = async ({
          encryptionPublicKey,
          plaintextMnemonic
        }: {
          encryptionPublicKey: Uint8Array;
          plaintextMnemonic: Uint8Array;
        }) => {
          // Deserialize the raw key returned by the `init` request to the Privy API to a public key object
          const suite = new CipherSuite({
            kem: new DhkemP256HkdfSha256(),
            kdf: new HkdfSha256(),
            aead: new Chacha20Poly1305()
          });
          const publicKeyObject = await suite.kem.deserializePublicKey(
            Buffer.from(encryptionPublicKey).buffer
          );

          // Encrypt the plaintext wallet mnemonic
          const sender = await suite.createSenderContext({
            recipientPublicKey: publicKeyObject
          });
          const ciphertext = await sender.seal(Buffer.from(plaintextMnemonic).buffer);

          // Return the encapsulated key and ciphertext, converting ArrayBuffer to Uint8Array
          return {
            encapsulatedKey: new Uint8Array(sender.enc),
            ciphertext: new Uint8Array(ciphertext)
          };
        };

        // The encryption public key is returned by the `init` request to the Privy API
        // For example: BPoOQ5k9nRk37v+XQWkmFEjpvW6RS0HQsPF3+IbhgMlc2Qwp/vz7lln1h0MJj/l0crLUhyyjdmC9RnAcpAkUNVQ=
        const base64EncodedEncryptionPublicKey = '<encryption-public-key>';
        // The wallet's BIP39 mnemonic.
        // For example: "solution tree shed picnic exile caught pluck hammer flag strategy surprise fiber"
        const plaintextMnemonic = '<your-wallet-mnemonic>';

        const {encapsulatedKey, ciphertext} = await encryptWithHpke({
          encryptionPublicKey: base64.decode(base64EncodedEncryptionPublicKey),
          plaintextMnemonic: new Uint8Array(Buffer.from(plaintextMnemonic, 'utf-8'))
        });
        ```
      </Tab>
    </Tabs>

    ### 3. Submission

    Submit your encrypted mnemonic to the Privy API by calling the `/v1/wallets/import/submit` endpoint with the rest of your wallet configuration (e.g. an owner, policies, or signers). See [creating a wallet](/api-reference/wallets/create) for more information on configuration options.

    <Tabs>
      <Tab title="EVM">
        ```bash  theme={"system"}
        curl --request POST \
          --url https://api.privy.io/v1/wallets/import/submit \
          --header 'Authorization: Basic <encoded-app-credentials>' \
          --header 'Content-Type: application/json' \
          --header 'privy-app-id: <privy-app-id>' \
          --data '{
            "wallet": {
              "address": "<your-wallet-address>",
              "chain_type": "ethereum",
              "entropy_type": "hd",
              "index": <your-wallet-index>,
              "encryption_type": "HPKE",
              "ciphertext": "<base64-encoded-encrypted-mnemonic>",
              "encapsulated_key": "<base64-encoded-encapsulated-key>"
            },
            // Optional additional configuration
            "owner": {...},
            "policy_ids": [...],
            "additional_singers": [...]
          }'
        ```
      </Tab>

      <Tab title="Solana">
        ```bash  theme={"system"}
        curl --request POST \
          --url https://api.privy.io/v1/wallets/import/submit \
          --header 'Authorization: Basic <encoded-app-credentials>' \
          --header 'Content-Type: application/json' \
          --header 'privy-app-id: <privy-app-id>' \
          --data '{
            "wallet": {
              "address": "<your-wallet-address>",
              "chain_type": "solana",
              "entropy_type": "hd",
              "index": <your-wallet-index>,
              "encryption_type": "HPKE",
              "ciphertext": "<base64-encoded-encrypted-mnemonic>",
              "encapsulated_key": "<base64-encoded-encapsulated-key>"
            },
            // Optional additional configuration
            "owner": {...},
            "policy_ids": [...],
            "additional_singers": [...]
          }'
        ```
      </Tab>
    </Tabs>

    The endpoint will return the wallet object of your imported wallet:

    <Tabs>
      <Tab title="EVM">
        ```json  theme={"system"}
        {
          "id": "<privy-wallet-id>",
          "address": "<your-wallet-address>",
          "chain_type": "ethereum",
          "policy_ids": [],
          "additional_signers": [],
          "exported_at": null,
          "imported_at": 1753300563195,
          "created_at": 1753300563197,
          "owner_id": null
        }
        ```
      </Tab>

      <Tab title="Solana">
        ```json  theme={"system"}
        {
          "id": "<privy-wallet-id>",
          "address": "<your-wallet-address>",
          "chain_type": "solana",
          "policy_ids": [],
          "additional_signers": [],
          "exported_at": null,
          "imported_at": 1753300563195,
          "created_at": 1753300563197,
          "owner_id": null
        }
        ```
      </Tab>
    </Tabs>
  </Tab>
</Tabs>

## Using imported wallets

Imported wallets function the same way as Privy-generated wallets. See the API reference for [Ethereum](/api-reference/wallets/ethereum/eth-send-transaction) or [Solana](/api-reference/wallets/solana/sign-and-send-transaction) for information about how to send transactions and execute other wallet operations.


# Private keys
Source: https://docs.privy.io/wallets/wallets/import-a-wallet/private-key



**Privy enables you to import wallet private keys for use via the Privy API.**

This allows you to migrate wallets from external sources to Privy, including from a different wallet provider. Or, your app can enable users to bring an existing external wallet into your application in order to access and manage their assets within your app seamlessly.

## Importing a wallet

<Tabs>
  <Tab title="React">
    To import a private key wallet with the React SDK, use the `importWallet` method from the `useImportWallet` hook:

    ```tsx  theme={"system"}
    importWallet: (input: {privateKey: string}) => Promise<Wallet>;
    ```

    <Tabs>
      <Tab title="EVM">
        ### Usage

        ```tsx  theme={"system"}
        import {useImportWallet} from '@privy-io/react-auth';

        const {importWallet} = useImportWallet();

        const wallet = await importWallet({
          privateKey: 'your-wallet-private-key'
        });
        ```

        ### Parameters

        <ParamField header="privateKey" type="string">
          The hex-encoded private key of the ethereum wallet to import, with or without a `0x` prefix.
        </ParamField>

        ### Returns

        <ResponseField name="wallet" type="Promise<Wallet>">
          A `Promise` for the imported wallet object.
        </ResponseField>
      </Tab>

      <Tab title="Solana">
        ### Usage

        ```tsx  theme={"system"}
        import {useImportWallet} from '@privy-io/react-auth/solana';

        const {importWallet} = useImportWallet();

        const wallet = await importWallet({
          privateKey: 'your-wallet-private-key'
        });
        ```

        ### Parameters

        <ParamField header="privateKey" type="string">
          The base58-encoded private key of the solana wallet to import.
        </ParamField>

        ### Returns

        <ResponseField name="wallet" type="Promise<Wallet>">
          A `Promise` for the imported wallet object.
        </ResponseField>
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="NodeJS">
    To import a private key wallet with the NodeJS SDK, use the `import` method from the Privy client’s `wallets()` interface. The Privy client will encrypt your private key for secure transmission to the TEE. See [architecture](/wallets/wallets/import-a-wallet/architecture) for more details.

    <Tabs>
      <Tab title="EVM">
        For EVM wallets, the Privy client accepts a hex-encoded private key, with or without a `0x` prefix.

        ```ts  theme={"system"}
        import {PrivyClient} from '@privy-io/node';

        const privy = new PrivyClient({
          appId: 'your-app-id',
          appSecret: 'your-app-secret'
        });

        try {
          const wallet = await privy.wallets().import({
            wallet: {
              entropy_type: 'private-key',
              chain_type: 'ethereum',
              address: '<your-wallet-address>',
              private_key: '<your-hex-encoded-wallet-private-key>'
            }
          });
        } catch (error) {
          console.error('Failed to import wallet:', error);
        }
        ```

        Alternatively, you can also pass the private key directly as binary (`Uint8Array`).

        ```ts  theme={"system"}
        import {PrivyClient} from '@privy-io/node';

        const privy = new PrivyClient({
          appId: 'your-app-id',
          appSecret: 'your-app-secret'
        });

        const wallet = await privy.wallets().import({
          wallet: {
            entropy_type: 'private-key',
            chain_type: 'ethereum',
            address: '<your-wallet-address>',
            private_key: '<your-uint8array-wallet-private-key>'
          }
        });
        ```
      </Tab>

      <Tab title="Solana">
        For Solana wallets, the Privy client accepts a base58-encoded private key.

        ```ts  theme={"system"}
        import {PrivyClient} from '@privy-io/node';

        const privy = new PrivyClient({
          appId: 'your-app-id',
          appSecret: 'your-app-secret'
        });

        try {
          const wallet = await privy.wallets().import({
            wallet: {
              entropy_type: 'private-key',
              chain_type: 'solana',
              address: '<your-wallet-address>',
              private_key: '<your-base58-encoded-wallet-private-key>'
            }
          });
        } catch (error) {
          console.error('Failed to import wallet:', error);
        }
        ```

        Alternatively, you can also pass the private key directly as binary (`Uint8Array`).

        ```ts  theme={"system"}
        import {PrivyClient} from '@privy-io/node';

        const privy = new PrivyClient({
          appId: 'your-app-id',
          appSecret: 'your-app-secret'
        });

        const wallet = await privy.wallets().import({
          wallet: {
            entropy_type: 'private-key',
            chain_type: 'solana',
            address: '<your-wallet-address>',
            private_key: '<your-uint8array-wallet-private-key>'
          }
        });
        ```
      </Tab>
    </Tabs>

    The returned wallet is type `Wallet`. See [get wallet by ID](/api-reference/wallets/get) for type definition.
  </Tab>

  <Tab title="NodeJS (server-auth)">
    <Warning>
      The `@privy-io/server-auth` library is deprecated. We recommend integrating `@privy-io/node` for
      the latest features and support.
    </Warning>

    To import a private key wallet with the NodeJS SDK, use the `importWallet` method from the Privy client’s `walletApi` class. The Privy client will encrypt your private key for secure transmission to the TEE. See [architecture](/wallets/wallets/import-a-wallet/architecture) for more details.

    <Tabs>
      <Tab title="EVM">
        For EVM wallets, the Privy client accepts a hex-encoded private key, with or without a `0x` prefix.

        ```ts  theme={"system"}
        import {PrivyClient, WalletApiWalletResponseType} from '@privy-io/server-auth';

        const privy = new PrivyClient('your-app-id', 'your-app-secret');

        const wallet: WalletApiWalletResponseType = await privy.walletApi.importWallet({
          address: '<your-wallet-address>',
          chainType: 'ethereum',
          entropy: '<your-hex-encoded-wallet-private-key>',
          entropyType: 'private-key'
        });
        ```
      </Tab>

      <Tab title="Solana">
        For Solana wallets, the Privy client accepts a base58-encoded private key.

        ```ts  theme={"system"}
        import {PrivyClient, WalletApiWalletResponseType} from '@privy-io/server-auth';

        const privy = new PrivyClient('your-app-id', 'your-app-secret');

        const wallet: WalletApiWalletResponseType = await privy.walletApi.importWallet({
          address: '<your-wallet-address>',
          chainType: 'solana',
          entropy: '<your-base58-encoded-wallet-private-key>',
          entropyType: 'private-key'
        });
        ```
      </Tab>
    </Tabs>

    The returned wallet is type `WalletApiWalletResponseType`. See [get wallet by ID](/wallets/wallets/get-a-wallet/get-wallet-by-id#returns) for type definition.
  </Tab>

  <Tab title="REST API">
    ### 1. Initialization

    Initialize a key import flow by calling the `/v1/wallets/import/init` endpoint with your wallet address and chain type. See [authentication](/api-reference/introduction#authentication) for how to encode your app credentials.

    <Tabs>
      <Tab title="EVM">
        ```bash  theme={"system"}
        curl --request POST \
          --url https://api.privy.io/v1/wallets/import/init \
          --header 'Authorization: Basic <encoded-app-credentials>' \
          --header 'Content-Type: application/json' \
          --header 'privy-app-id: <privy-app-id>' \
          --data '{
            "address": "<your-wallet-address>",
            "chain_type": "ethereum",
            "entropy_type": "private-key",
            "encryption_type": "HPKE"
          }'
        ```
      </Tab>

      <Tab title="Solana">
        ```bash  theme={"system"}
        curl --request POST \
          --url https://api.privy.io/v1/wallets/import/init \
          --header 'Authorization: Basic <encoded-app-credentials>' \
          --header 'Content-Type: application/json' \
          --header 'privy-app-id: <privy-app-id>' \
          --data '{
            "address": "<your-wallet-address>",
            "chain_type": "solana",
            "entropy_type": "private-key",
            "encryption_type": "HPKE"
          }'
        ```
      </Tab>
    </Tabs>

    The endpoint will return a public key to encrypt your private key with:

    ```json  theme={"system"}
    {
      "encryption_public_key": "<base64-encoded-encryption-public-key>",
      "encryption_type": "HPKE"
    }
    ```

    ### 2. Encryption

    Encrypt your private key using Hybrid Public Key Encryption (HPKE) with the following configuration:

    * KEM: DHKEM\_P256\_HKDF\_SHA256
    * KDF: HKDF\_SHA256
    * AEAD: CHACHA20\_POLY1305
    * Mode: BASE

    There are two outputs from the encryption step that you'll provide to Privy during submission:

    * `ciphertext`: The encrypted private key
    * `encapsulated_key`: The encapsulated key

    Here's an example of how to encrypt a private key in TypeScript:

    <Tabs>
      <Tab title="EVM">
        ```ts  theme={"system"}
        import {Chacha20Poly1305} from '@hpke/chacha20poly1305';
        import {CipherSuite, DhkemP256HkdfSha256, HkdfSha256} from '@hpke/core';
        import {base64} from '@scure/base';

        const encryptWithHpke = async ({
          encryptionPublicKey,
          plaintextPrivateKey
        }: {
          encryptionPublicKey: Uint8Array;
          plaintextPrivateKey: Uint8Array;
        }) => {
          // Deserialize the raw key returned by the `init` request to the Privy API to a public key object
          const suite = new CipherSuite({
            kem: new DhkemP256HkdfSha256(),
            kdf: new HkdfSha256(),
            aead: new Chacha20Poly1305()
          });
          const publicKeyObject = await suite.kem.deserializePublicKey(
            Buffer.from(encryptionPublicKey).buffer
          );

          // Encrypt the plaintext wallet private key
          const sender = await suite.createSenderContext({
            recipientPublicKey: publicKeyObject
          });
          const ciphertext = await sender.seal(Buffer.from(plaintextPrivateKey).buffer);

          // Return the encapsulated key and ciphertext, converting ArrayBuffer to Uint8Array
          return {
            encapsulatedKey: new Uint8Array(sender.enc),
            ciphertext: new Uint8Array(ciphertext)
          };
        };

        // The encryption public key is returned by the `init` request to the Privy API
        // For example: BPoOQ5k9nRk37v+XQWkmFEjpvW6RS0HQsPF3+IbhgMlc2Qwp/vz7lln1h0MJj/l0crLUhyyjdmC9RnAcpAkUNVQ=
        const base64EncodedEncryptionPublicKey = '<encryption-public-key>';
        // The wallet private key in hex format. This may have a '0x' prefix or may not depending on the
        // provider you're importing from, so make sure to remove it before encrypting if present as shown below.
        // For example: 0xe42f4dc0c8396e93891f05c3a34228c395f9b02505ffd0e79d7d2098af8b20a3
        const hexEncodedPlaintextPrivateKey = '<your-wallet-private-key>';

        const {encapsulatedKey, ciphertext} = await encryptWithHpke({
          encryptionPublicKey: base64.decode(base64EncodedEncryptionPublicKey),
          plaintextPrivateKey: new Uint8Array(
            Buffer.from(
              // Be sure to remove the `0x` prefix if present
              hexEncodedPlaintextPrivateKey.replace(/^0x/, ''),
              'hex'
            )
          )
        });
        ```
      </Tab>

      <Tab title="Solana">
        ```ts  theme={"system"}
        import {Chacha20Poly1305} from '@hpke/chacha20poly1305';
        import {CipherSuite, DhkemP256HkdfSha256, HkdfSha256} from '@hpke/core';
        import {base58, base64} from '@scure/base';

        const encryptWithHpke = async ({
          encryptionPublicKey,
          plaintextPrivateKey
        }: {
          encryptionPublicKey: Uint8Array;
          plaintextPrivateKey: Uint8Array;
        }) => {
          // Deserialize the raw key returned by the `init` request to the Privy API to a public key object
          const suite = new CipherSuite({
            kem: new DhkemP256HkdfSha256(),
            kdf: new HkdfSha256(),
            aead: new Chacha20Poly1305()
          });
          const publicKeyObject = await suite.kem.deserializePublicKey(
            Buffer.from(encryptionPublicKey).buffer
          );

          // Encrypt the plaintext wallet private key
          const sender = await suite.createSenderContext({
            recipientPublicKey: publicKeyObject
          });
          const ciphertext = await sender.seal(Buffer.from(plaintextPrivateKey).buffer);

          // Return the encapsulated key and ciphertext, converting ArrayBuffer to Uint8Array
          return {
            encapsulatedKey: new Uint8Array(sender.enc),
            ciphertext: new Uint8Array(ciphertext)
          };
        };

        // The encryption public key is returned by the `init` request to the Privy API
        // For example: BPoOQ5k9nRk37v+XQWkmFEjpvW6RS0HQsPF3+IbhgMlc2Qwp/vz7lln1h0MJj/l0crLUhyyjdmC9RnAcpAkUNVQ=
        const base64EncodedEncryptionPublicKey = '<encryption-public-key>';
        // The wallet private key in base58 format. This is commonly the format used when exporting a Solana wallet from another provider.
        // For example: 4ANrq8ysACrNqmjWnekSPpud8GEdPN9YB7isMBbCxKWYrzcyAWnttYe8dPxfkhkR9mwLh4SfyZx4cUXnJAmZvbQ2
        const base58EncodedPlaintextPrivateKey = '<your-wallet-private-key>';

        const {encapsulatedKey, ciphertext} = await encryptWithHpke({
          encryptionPublicKey: base64.decode(base64EncodedEncryptionPublicKey),
          plaintextPrivateKey: base58.decode(base58EncodedPlaintextPrivateKey)
        });
        ```
      </Tab>
    </Tabs>

    ### 3. Submission

    Submit your encrypted private key to the Privy API by calling the `/v1/wallets/import/submit` endpoint with the rest of your wallet configuration (e.g. an owner, policies, or signers). See [creating a wallet](/api-reference/wallets/create) for more information on configuration options.

    <Tabs>
      <Tab title="EVM">
        ```bash  theme={"system"}
        curl --request POST \
          --url https://api.privy.io/v1/wallets/import/submit \
          --header 'Authorization: Basic <encoded-app-credentials>' \
          --header 'Content-Type: application/json' \
          --header 'privy-app-id: <privy-app-id>' \
          --data '{
            "wallet": {
              "address": "<your-wallet-address>",
              "chain_type": "ethereum",
              "entropy_type": "private-key",
              "encryption_type": "HPKE",
              "ciphertext": "<base64-encoded-encrypted-private-key>",
              "encapsulated_key": "<base64-encoded-encapsulated-key>"
            },
            // Optional additional configuration
            "owner": {...},
            "policy_ids": [...],
            "additional_singers": [...]
          }'
        ```
      </Tab>

      <Tab title="Solana">
        ```bash  theme={"system"}
        curl --request POST \
          --url https://api.privy.io/v1/wallets/import/submit \
          --header 'Authorization: Basic <encoded-app-credentials>' \
          --header 'Content-Type: application/json' \
          --header 'privy-app-id: <privy-app-id>' \
          --data '{
            "wallet": {
              "address": "<your-wallet-address>",
              "chain_type": "solana",
              "entropy_type": "private-key",
              "encryption_type": "HPKE",
              "ciphertext": "<base64-encoded-encrypted-private-key>",
              "encapsulated_key": "<base64-encoded-encapsulated-key>"
            },
            // Optional additional configuration
            "owner": {...},
            "policy_ids": [...],
            "additional_singers": [...]
          }'
        ```
      </Tab>
    </Tabs>

    The endpoint will return the wallet object of your imported wallet:

    <Tabs>
      <Tab title="EVM">
        ```json  theme={"system"}
        {
          "id": "<privy-wallet-id>",
          "address": "<your-wallet-address>",
          "chain_type": "ethereum",
          "policy_ids": [],
          "additional_signers": [],
          "exported_at": null,
          "imported_at": 1753300563195,
          "created_at": 1753300563197,
          "owner_id": null
        }
        ```
      </Tab>

      <Tab title="Solana">
        ```json  theme={"system"}
        {
          "id": "<privy-wallet-id>",
          "address": "<your-wallet-address>",
          "chain_type": "solana",
          "policy_ids": [],
          "additional_signers": [],
          "exported_at": null,
          "imported_at": 1753300563195,
          "created_at": 1753300563197,
          "owner_id": null
        }
        ```
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Rust">
    To import a private key wallet with the Rust SDK, use the `import()` method. The Rust SDK automatically handles the HPKE encryption for secure transmission to the TEE. See [architecture](/wallets/wallets/import-a-wallet/architecture) for more details.

    ### Usage

    ```rust  theme={"system"}
    use privy_rs::{PrivyClient, generated::types::*};

    let client = PrivyClient::new(app_id, app_secret)?;

    // Import an Ethereum wallet from private key
    let imported_wallet = client
        .wallets()
        .import(
            "0x742d35Cc6635C0532925a3b8D2dB4C5e64b1C0dB", // wallet address
            "your-hex-encoded-private-key", // private key (with or without 0x prefix)
            WalletImportSupportedChains::Ethereum,
            None,   // owner
            vec![], // policy_ids
            vec![], // additional_signers
        )
        .await?
        .into_inner();

    println!("Imported wallet {} with address {}", imported_wallet.id, imported_wallet.address);
    ```

    ### Parameters and Returns

    See the Rust SDK documentation for detailed parameter and return types, including embedded examples:

    * [WalletsClient::import](https://docs.rs/privy-rs/latest/privy_rs/subclients/struct.WalletsClient.html#method.import)
    * [WalletImportBody](https://docs.rs/privy-rs/latest/privy_rs/generated/types/struct.WalletImportBody.html)
    * [WalletImportData](https://docs.rs/privy-rs/latest/privy_rs/generated/types/struct.WalletImportData.html)
    * [Wallet](https://docs.rs/privy-rs/latest/privy_rs/generated/types/struct.Wallet.html)

    For REST API details, see the [API reference](/api-reference/wallets/import).

    <Info>
      The Rust SDK automatically handles the HPKE encryption process internally when importing wallets. You don't need to manually encrypt the private key - simply provide the raw private key string and the SDK will handle secure transmission to Privy's infrastructure.
    </Info>
  </Tab>
</Tabs>

## Using imported wallets

Imported wallets function the same way as Privy-generated wallets. See the API reference for [Ethereum](/api-reference/wallets/ethereum/eth-send-transaction) or [Solana](/api-reference/wallets/solana/sign-and-send-transaction) for information about how to send transactions and execute other wallet operations.


# Enabling offline actions with user wallets
Source: https://docs.privy.io/wallets/wallets/offline-actions



Privy's [control abstractions](/controls/overview) allow you to enable offline actions with user wallets with a specific scope of permissions.

This supports several use cases, such as executing **limit orders**, enabling **agentic trading**, or implementing **subscriptions** and other recurring transactions.

Learn more about how to configure wallets for offline access in the **Policies & controls** section of the docs.

<Card title="Enabling offline actions" href="/wallets/using-wallets/session-signers/overview" icon="server">
  Enable server-side access to user wallets to support offline transactions, offline updates, custom
  approval configurations, and more.
</Card>


# Enabling server-side access to user wallets
Source: https://docs.privy.io/wallets/wallets/server-side-access



Privy's [control abstractions](/controls/overview) allow you to interact with wallets from your app's server, even without the user in the loop. These interactions can be restricted by policies that configure the scope of actions that can be taken without user authorization.

This supports several use cases, such as:

* executing transactions when a user is offline, e.g for limit orders, agentic trading, portfolio rebalancing, etc.
* updating wallets when a user is offline, such as updating policies or assigning specific permissions to third-parties
* requiring both users and servers to approve user transactions

and more.

Learn more about how to configure wallets for server-side access in the **Policies & controls** section of the docs.

<Card title="Enabling server-side access" href="/wallets/using-wallets/session-signers/overview" icon="server">
  Enable server-side access to user wallets to support offline transactions, offline updates, custom
  approval configurations, and more.
</Card>


# Update a wallet
Source: https://docs.privy.io/wallets/wallets/update-a-wallet



Privy enables you to update the policies, owners, and signers for a wallet.

<Tabs>
  <Tab title="REST API">
    To update an existing wallet, make a `PATCH` request to:

    ```
    https://api.privy.io/v1/wallets/<wallet_id>
    ```

    <Info>
      Wallets with `owner_id` present must provide an [authorization signature](/api-reference/authorization-signatures) as a request header. Privy SDKs offer utility functions such as `generateAuthorizationSignature` to generate the authorization signature.
    </Info>

    ### Body

    In the request body, include the following fields:

    <ParamField path="policy_ids" type="string[]">
      New policy IDs to enforce on the wallet. Currently, only one policy is supported per wallet.
    </ParamField>

    <ParamField type="{user_id: string} | {public_key: string} | null" path="owner">
      The user ID or P-256 public key of the owner of the wallet. If you provide this, do not specify an owner\_id as it will be generated automatically.

      View [this guide](/controls/authorization-keys/owners/overview) to learn more about owners.
    </ParamField>

    <ParamField type="string | null" path="owner_id">
      The key quorum ID of the owner of the wallet. If you provide this, do not specify an owner.

      View [this guide](/controls/authorization-keys/owners/overview) to learn more about owners.
    </ParamField>

    <ParamField type="{signer_id: string}[]" path="additional_signers">
      The key quorum IDs to add as additional signers for the wallet.

      View [this guide](/controls/key-quorum/overview) to learn more about key quorums.
    </ParamField>

    Any fields not included in the `PATCH` request body will remain unchanged from the original wallet.

    ### Response

    If the wallet is updated successfully, the response will include the updated wallet.

    <ResponseField name="id" type="string">
      Unique ID for the wallet.
    </ResponseField>

    <ResponseField name="address" type="string">
      Address of the wallet.
    </ResponseField>

    <ResponseField name="chain_type" type="'ethereum'">
      Chain type for the wallet.
    </ResponseField>

    <ResponseField name="policy_ids" type="MethodRule">
      Updated policy IDs to enforce on the wallet.
    </ResponseField>

    <ResponseField type="string | null" name="owner_id">
      The key quorum ID of the owner of the wallet.
    </ResponseField>

    <ResponseField type="{signer_id: string}[]" name="additional_signers">
      The key quorum IDs of the additional signers for the wallet.
    </ResponseField>

    ### Example

    A sample request might look like the following:

    ```tsx  theme={"system"}
    $ curl --request PATCH https://api.privy.io/v1/wallets/rbokq6mmq5f8j1cgyr6a5g4n \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H "privy-authorization-signature: <authorization-signature-for-request>" \
    -H 'Content-Type: application/json' \
    --data '{
        "policy_ids": ["fmfdj6yqly31huorjqzq38zc"],
        "owner_id": "yhu8t1fjns9rtc2o702ub3vt",
        "additional_signers": [{"signer_id": "trt9syg5k19jvxwbnt6t8rd0"}]
    }'
    ```

    A successful response will look like the following:

    ```tsx  theme={"system"}
    {
      "id": "rbokq6mmq5f8j1cgyr6a5g4n",
      "address": "0xE315ce0854CcbdB0E33e71af1190F48Eb5d4f5a4",
      "chain_type": "ethereum",
      "policy_ids": ["fmfdj6yqly31huorjqzq38zc"],
      "owner_id": "yhu8t1fjns9rtc2o702ub3vt",
      "additional_signers": [
        {
          "signer_id": "trt9syg5k19jvxwbnt6t8rd0"
        }
      ],
      "created_at": 1737492220389
    }
    ```
  </Tab>

  <Tab title="Java">
    To update an existing wallet, use the `update` method, passing in a `walletId` along with a
    `WalletUpdateRequestBody`.

    ### Usage

    ```java  theme={"system"}
    try {
        WalletUpdateRequestBody request = WalletUpdateRequestBody.builder()
            .policyIds(List.of("new-policy-id"))
            .build();

        // Use the AuthorizationContext to sign the request with the wallet's owner.
        // Example if the wallet's owner is an authorization private key
        AuthorizationContext authorizationContext = AuthorizationContext.builder()
            .addAuthorizationPrivateKey("authorization-key")
            .build();

        WalletUpdateResponse response = privyClient.wallets().update(
            "wallet-id",
            request,
            authorizationContext
        );

        if (response.wallet().isPresent()) {
            Wallet updatedWallet = response.wallet().get();
        }
    } catch (APIException e) {
        String errorBody = e.bodyAsString();
        System.err.println(errorBody);
    } catch (Exception e) {
        System.err.println(e.getMessage());
    }
    ```

    ### Parameters

    When updating a wallet, you may specify the following values on the `WalletUpdateRequestBody`:

    <ParamField body="policyIds" type="List<String>">
      List of policy IDs for policies that should be enforced on the wallet. Currently, only one policy
      is supported per wallet.
    </ParamField>

    <ParamField body="owner" type="OwnerInput">
      The owner of the resource, which can either be a public key from a p256 keypair, or a user ID. If
      you provide this, do not specify an `ownerId` as it will be generated automatically.
    </ParamField>

    <ParamField body="ownerId" type="String">
      The key quorum ID to set as the owner of the resource. If you provide this, do not specify
      an`owner`.
    </ParamField>

    <ParamField body="additionalSigners" type="WalletAdditionalSigner">
      Additional signers for the wallet.
    </ParamField>

    ### Returns

    The `WalletUpdateResponse` object contains an optional `wallet()` field, present if the
    wallet was updated successfully.

    <ResponseField name="wallet()" type="Optional<Wallet>">
      The updated `Wallet` object.

      <Expandable>
        <ResponseField type="String" name="id">
          Unique ID of the created wallet. This will be the primary identifier when using the wallet in the future.
        </ResponseField>

        <ResponseField type="String" name="address">
          Address of the created wallet.
        </ResponseField>

        <ResponseField type="WalletChainType" name="chainType">
          Chain type of the created wallet.
        </ResponseField>

        <ResponseField type="List<String>" name="policyIds">
          List of policy IDs for policies that are enforced on the wallet.
        </ResponseField>

        <ResponseField type="String" name="ownerId">
          The key quorum ID of the owner of the wallet. If an `ownerId` was passed in, this response is the input `ownerId`. If a user ID or authorization key was passed in as the `owner`, this response is a newly created key quorum containing the input user ID or authorization key.
        </ResponseField>

        <ResponseField type="List<WalletAdditionalSigner>" name="additionalSigners">
          The key quorum IDs of the additional signers for the wallet.
        </ResponseField>

        <ResponseField type="double" name="createdAt">
          The creation date of the wallet, in milliseconds since midnight, January 1, 1970 UTC.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="Rust">
    To update an existing wallet, use the `update` method on the `wallets()` interface, along with an `AuthorizationContext` for signing the request.

    <Info>
      Wallets with an `owner_id` must provide authorization from the owner to perform updates. Use the `AuthorizationContext` to include the necessary credentials for request signing.
    </Info>

    ### Usage

    ```rust  theme={"system"}
    use privy_rs::{PrivyClient, generated::types::*, AuthorizationContext};

    let client = PrivyClient::new(app_id, app_secret)?;

    // Create authorization context with the wallet owner's key
    let ctx = AuthorizationContext::new()
        .push(PrivateKey("authorization-private-key".to_string()));

    let updated_wallet = client
        .wallets()
        .update(
            "wallet-id",
            &ctx,
            &WalletUpdateBody {
                policy_ids: Some(vec!["new-policy-id".to_string()]),
                owner: None,
                owner_id: Some("new-owner-quorum-id".to_string()),
                additional_signers: Some(vec![
                    WalletAdditionalSigner {
                        signer_id: "additional-signer-id".to_string(),
                    },
                ]),
            },
        )
        .await?;

    println!("Updated wallet: {}", updated_wallet.id);
    ```

    ### Parameters and Returns

    See the Rust SDK documentation for detailed parameter and return types, including embedded examples:

    * [WalletsClient::update](https://docs.rs/privy-rs/latest/privy_rs/subclients/struct.WalletsClient.html#method.update)
    * [WalletUpdateBody](https://docs.rs/privy-rs/latest/privy_rs/generated/types/struct.WalletUpdateBody.html)
    * [AuthorizationContext](https://docs.rs/privy-rs/latest/privy_rs/struct.AuthorizationContext.html)
    * [Wallet](https://docs.rs/privy-rs/latest/privy_rs/generated/types/struct.Wallet.html)

    For REST API details, see the [API reference](/api-reference/wallets/update).
  </Tab>
</Tabs>


# Welcome
Source: https://docs.privy.io/welcome



export const Logo = ({img, name, href, className}) => {
  return <a href={href} className={'block not-prose font-normal rounded-md cursor-pointer ' + (className || '')} onClick={e => {
    if (href) {
      e.preventDefault();
      window.location.href = href;
    }
  }}>
      <div className="card h-20 w-20 p-2 object-cover overflow-hidden flex items-center justify-center">
        <img src={img} alt={name} noZoom />
      </div>
      <p className="text-nowrap text-center text-xs mt-2">{name}</p>
    </a>;
};

<div className="hero">
  <div className="text-center">
    <h1 className="justify-center">Build with Privy.</h1>
  </div>

  <p className="text-center font-medium details-text">
    Privy builds user onboarding and wallet infrastructure to enable better products built on crypto
    rails by embedding asset control directly into your product.
  </p>

  <div id="hero-search" className="search" onClick={() => clickOnSearch()}>
    <span>Help me learn how to...</span>

    <Icon icon="magnifying-glass" iconType="solid" size={14} />
  </div>

  <div className="text-sm flex items-center justify-center gap-1 font-medium">
    <a href="basics/get-started/account" className="no-underline">
      Get started
    </a>

    <Icon icon="arrow-right" iconType="solid" size={12} />
  </div>
</div>

<div className="max-w-3xl px-4 mx-auto lg:px-8 pb-10">
  <div className="text-center text-sm mb-6">
    <h2 className="subtitle">Quickstarts & recipes</h2>
  </div>

  <CardGroup cols={3}>
    <Card title="Create your first wallet" icon="wallet" href="/basics/react/quickstart">
      Use the React SDK to authenticate a user and create an embedded wallet.
    </Card>

    <Card title="Build a mobile app" icon="mobile" href="/basics/react-native/quickstart">
      Use the React Native SDK to build a mobile app on Solana.
    </Card>

    <Card title="Whitelabel" icon="palette" href="/recipes/react/whitelabel">
      Whitelabel login, wallets, and user management with your own UI and branding.
    </Card>
  </CardGroup>

  <div className="text-center text-sm mt-12 mb-6">
    <h2 className="subtitle">Explore client SDKs</h2>
  </div>

  <div className="flex flex-wrap gap-3 justify-between">
    <Logo name="React" img="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/react-logo.png?fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=0f8dcc42c005ec4a2ed9d40cbcec2f74" href="basics/react/setup" data-og-width="512" width="512" data-og-height="456" height="456" data-path="images/react-logo.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/react-logo.png?w=280&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=993dbaf14151ecb2205ea43d063aba22 280w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/react-logo.png?w=560&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=eb7952e94d645a92fa71db15025ac7ce 560w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/react-logo.png?w=840&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=3b00b2ecc2745f3a18dc90d8739c7d20 840w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/react-logo.png?w=1100&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=d0a8508490716ef09571f0f858f25f6f 1100w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/react-logo.png?w=1650&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=0e072af57e503500fc4fa466d490f526 1650w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/react-logo.png?w=2500&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=a2310192bd5eda544038d6b427287c10 2500w" />

    <Logo name="React Native" img="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/expo-logo.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=2eed3f18ded0223ce8e9b135290dcb6b" className="dark:hidden" href="basics/react-native/setup" data-og-width="1024" width="1024" data-og-height="914" height="914" data-path="images/expo-logo.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/expo-logo.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=0f7955cb01ed32b0e031d2b7200998b9 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/expo-logo.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=4451bb779717fb3d772efd0b38bc7987 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/expo-logo.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=34771ad7f2e1fb0ced48e67bb23c853b 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/expo-logo.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=bff7c27ecda7c6c5a4823ae0a5379210 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/expo-logo.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=c6b094a7ce38cbf904fd888416177ba8 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/expo-logo.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=c90df03a98efe89c9d6986f48952301e 2500w" />

    <Logo name="React Native" img="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/expo-logo-dark.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=5b973668fbf1a9151dedcf4e12f642d0" className="hidden dark:block" href="basics/react-native/setup" data-og-width="1024" width="1024" data-og-height="914" height="914" data-path="images/expo-logo-dark.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/expo-logo-dark.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=a93f1453b96113df3c39694bf4a0ee64 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/expo-logo-dark.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=d1bf5ccec53637d0e46335c27a5fd6d1 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/expo-logo-dark.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=9998ef7290dfe5e2f588172eda51ed4f 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/expo-logo-dark.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=0544331624ee5cac4e3bdaacf4bbb0cd 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/expo-logo-dark.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=0856eb1cf558a26cd25c5d3bd0902097 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/expo-logo-dark.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=12ac9dc99cd7e18ff2a6eb3520884f55 2500w" />

    <Logo name="iOS (Swift)" img="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/swift-logo.png?fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=11df6cff81cb22e668df48d5d9c9d300" href="basics/swift/setup" data-og-width="848" width="848" data-og-height="790" height="790" data-path="images/swift-logo.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/swift-logo.png?w=280&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=4b824489f9c91d2e7b68459f1cffa942 280w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/swift-logo.png?w=560&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=93b7ad188ce5548c92a196fff4219a74 560w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/swift-logo.png?w=840&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=4666e5abeedb3bd4f1472f3d53929ec3 840w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/swift-logo.png?w=1100&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=81ec2d4dcfb0cef29cd0932f37e0f9ab 1100w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/swift-logo.png?w=1650&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=7a7f6b0cf81fde621acf52f9c224c6aa 1650w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/swift-logo.png?w=2500&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=b9961f72a20067687134a45398791273 2500w" />

    <Logo name="Android (Kotlin)" img="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/android-logo.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=fcb54544ea626a4e61aa0a275b864c8d" href="/basics/android/setup" data-og-width="512" width="512" data-og-height="601" height="601" data-path="images/android-logo.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/android-logo.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=e2e8bcf6ae87173ee1acbadec634c9e2 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/android-logo.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=704ee3eaa148580c7774ad1ab9f3625e 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/android-logo.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=eb233cbecb56f7ad77bb13a2917c111a 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/android-logo.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=f534a7bf7027612d855fb466d0467792 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/android-logo.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=55f102eed0449705cfdde7459444df8d 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/android-logo.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=7acb8821a1a739d09e468889514afc48 2500w" />

    <Logo name="Unity" img="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/unity-logo.png?fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=d01a6cd23e2f00e11151e002b5ec63fb" className="dark:hidden" href="basics/unity/setup" data-og-width="280" width="280" data-og-height="280" height="280" data-path="images/unity-logo.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/unity-logo.png?w=280&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=67a5cc3ec2f79c2cbe4a38d09bd91a2e 280w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/unity-logo.png?w=560&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=08d3150e31cb5e560b33b131fc2ad1a3 560w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/unity-logo.png?w=840&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=0da9f8e026f70b6646054cd0dc948c00 840w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/unity-logo.png?w=1100&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=ec3e2e6cefd59bebb981b0442e68c0fe 1100w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/unity-logo.png?w=1650&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=dcd4b81a83d541fa227b3812f55840ee 1650w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/unity-logo.png?w=2500&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=6e6bf5988c4f180f28e908469cd17b01 2500w" />

    <Logo name="Unity" img="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/unity-logo-dark.png?fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=6d5d45f7d40721e72ee482885fe1e48d" className="hidden dark:block" href="basics/unity/setup" data-og-width="280" width="280" data-og-height="280" height="280" data-path="images/unity-logo-dark.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/unity-logo-dark.png?w=280&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=667b3bddd6314b03f51b1f1cd86781f2 280w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/unity-logo-dark.png?w=560&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=913e52733d0b8771fd8ebf64e23a0210 560w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/unity-logo-dark.png?w=840&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=57a60f28fe8a973a9294a1646237d097 840w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/unity-logo-dark.png?w=1100&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=64c151b52fc9b60b8054d304a1d70011 1100w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/unity-logo-dark.png?w=1650&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=70780c956c1368e2b213e94e1949f3b6 1650w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/unity-logo-dark.png?w=2500&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=91f0e85513063ad6b51f9034e4fd0a91 2500w" />

    <Logo name="Flutter" img="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/flutter-logo.png?fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=c058785999aa3fdbab87ef382fb080ab" href="basics/flutter/setup" data-og-width="3000" width="3000" data-og-height="3000" height="3000" data-path="images/flutter-logo.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/flutter-logo.png?w=280&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=67dbdf11a12567135884567b8884c904 280w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/flutter-logo.png?w=560&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=910a95b14c53792ad5231d81cdfce4d8 560w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/flutter-logo.png?w=840&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=2d22e9eb36b5df2a59012e98a4c80b32 840w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/flutter-logo.png?w=1100&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=2fed5bd1a6422160e3d27c8607fc2209 1100w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/flutter-logo.png?w=1650&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=92963fe76568e8b0a53ae2643017e7c1 1650w, https://mintcdn.com/privy-c2af3412/YvGXGsI-T4KAqoan/images/flutter-logo.png?w=2500&fit=max&auto=format&n=YvGXGsI-T4KAqoan&q=85&s=7a9ef1a80f34ac9fb97e3fce27afbd1b 2500w" />
  </div>

  <div className="text-center text-sm mt-12 mb-6">
    <h2 className="subtitle">Explore server SDKs</h2>
  </div>

  <div className="flex flex-wrap gap-12 space-around justify-center">
    <Logo name="NodeJS" img="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/node-logo.png?fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=d894369bda27812eb446b3f07fa678b5" href="basics/nodeJS/setup" data-og-width="256" width="256" data-og-height="256" height="256" data-path="images/node-logo.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/node-logo.png?w=280&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=4ed6dca5ba3d62011d9e6d25b79da9fb 280w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/node-logo.png?w=560&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=13d0797e547191c93dbe823e7750969f 560w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/node-logo.png?w=840&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=33432def0e3fe942dbb2076f4eacd089 840w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/node-logo.png?w=1100&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=bb43e171620685cf26b34c60fc532c48 1100w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/node-logo.png?w=1650&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=d6ea3aa98f1cb0ee3404626323116c64 1650w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/node-logo.png?w=2500&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=e7e9e67e6f77c8d946af32e0bfadd105 2500w" />

    <Logo name="Python" img="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/python-logo.png?fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=564a6aac342d4e2f450cbf4289bc537a" href="basics/python/setup" data-og-width="512" width="512" data-og-height="512" height="512" data-path="images/python-logo.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/python-logo.png?w=280&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=a5838d08a6115718583dc9cd6bb63384 280w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/python-logo.png?w=560&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=3cd0951d6a6b55e83c432d7f6ef949d4 560w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/python-logo.png?w=840&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=76428a15ec93abe9dd22c42d5e08ffa8 840w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/python-logo.png?w=1100&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=c4b85f936a222df6d74f8a954608d1d6 1100w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/python-logo.png?w=1650&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=37f72f4bef9143a64841f1dbf0fcda0d 1650w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/python-logo.png?w=2500&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=2e6b0954fddbafcdda1edd72acc25323 2500w" />

    <Logo name="Java" img="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/java-logo.png?fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=dee8f122bd829f47fe6f74f3fe611fc1" href="basics/java/setup" data-og-width="512" width="512" data-og-height="512" height="512" data-path="images/java-logo.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/java-logo.png?w=280&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=c653a3f151cf57e558941fcafc83da54 280w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/java-logo.png?w=560&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=8402be50a6725e12d5bf4151cba1f8b1 560w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/java-logo.png?w=840&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=3525ffb0bb74d86b153a0316729ecdc6 840w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/java-logo.png?w=1100&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=9bbfacc30ba23af5524a6ab69f36e1cb 1100w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/java-logo.png?w=1650&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=75e57dbee62e0db293ec9870edd065c9 1650w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/java-logo.png?w=2500&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=f000ac1fda3823e9efa7e5414544e196 2500w" />

    <Logo name="REST API" img="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/rest-api-logo.png?fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=02af129966bcfc90ded9ea9f94d5ced5" href="basics/rest-api/setup" className="dark:hidden" data-og-width="121" width="121" data-og-height="84" height="84" data-path="images/rest-api-logo.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/rest-api-logo.png?w=280&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=64a9c4d8147104925461be3734fc9051 280w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/rest-api-logo.png?w=560&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=dba3163f960b24baa91f8c9dabcfdc24 560w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/rest-api-logo.png?w=840&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=3afd097bccb104836401c68e297cd56c 840w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/rest-api-logo.png?w=1100&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=bf7fe9139f68f91cf0c8ffcde6ff25b1 1100w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/rest-api-logo.png?w=1650&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=d37cf6b68a918f2c0adc6e6b3f560ecf 1650w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/rest-api-logo.png?w=2500&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=04452ef627b5020d083e75a77843a066 2500w" />

    <Logo name="REST API" img="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/rest-api-logo-dark.png?fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=ec0310cf9562416fcbea388fbe464de4" href="basics/rest-api/setup" className="hidden dark:block" data-og-width="121" width="121" data-og-height="84" height="84" data-path="images/rest-api-logo-dark.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/rest-api-logo-dark.png?w=280&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=893bd883ea1970094639f97db4977e22 280w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/rest-api-logo-dark.png?w=560&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=893cf699304d318acf2f2656adf2bf4e 560w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/rest-api-logo-dark.png?w=840&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=8df3e03f8df2e5efd5e1643f7c5328c8 840w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/rest-api-logo-dark.png?w=1100&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=da19c7c844798e7c006452635bea4624 1100w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/rest-api-logo-dark.png?w=1650&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=acfcde7e073cf9ac0beb7bf0ac42eb79 1650w, https://mintcdn.com/privy-c2af3412/zlmLhiIqRR7ViKN0/images/rest-api-logo-dark.png?w=2500&fit=max&auto=format&n=zlmLhiIqRR7ViKN0&q=85&s=a84b372ac10b5021a50ffb8195c1223c 2500w" />
  </div>

  <div className="text-center text-sm mt-12 mb-6">
    <h2 className="subtitle">Resources</h2>
  </div>

  <CardGroup cols={3}>
    <Card title="Support" icon="slack" href="https://privy.io/slack">
      Join our Slack community to get support.
    </Card>

    <Card title="Recipes" icon="file-lines" href="/recipes/overview">
      Implement common Privy features and integrations.
    </Card>

    <Card title="Demo" icon="circle-play" href="https://demo.privy.io">
      Sign in to demo.privy.io to view Privy in action.
    </Card>
  </CardGroup>
</div>

